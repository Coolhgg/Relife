Master 7-Phase Launch-Ready Roadmap (detailed & actionable)
Phase 0 — Prep & Dev Setup (pre-work)
Goal: Standardize repo, onboarding, CI and dev tooling so work is reliable.

Tasks

Normalize repo structure: /apps/web, /packages/ui, /services/backend, /scripts.

Add .env.example, .editorconfig, .prettierrc, .eslintrc.

Add README/CONTRIBUTING with dev steps.

Create GitHub repo + branch policy (main = protected, PR required).

Add CI (GitHub Actions) with lint, typecheck, build, test steps.

Acceptance Criteria

npm ci && npm run build passes in CI.

npm run lint passes.

New developers can run npm run dev locally within 5 minutes.

Suggested tools

Node 20+, pnpm or npm, TypeScript, Vite (web).

GitHub Actions.

Phase 1 — Comprehensive Testing, Bug Fixes & Reliability Stress Tests
Goal: Root out all runtime bugs and make alarm behavior provably reliable.

Tasks

Static cleanup

Remove all console.log/console.error from src/*. Replace with logger.debug/info/warn/error where logger respects NODE_ENV.

Compile & type fixes

Fix TS errors/warnings, ensure strict mode.

Functional test suite

Add Unit tests (Jest) for scheduler, hooks (useAudioDetection, alarm logic).

Add Playwright E2E tests for key flows: set alarm, edit alarm, trigger alarm, dismiss, snooze, fail-case.

Full run tests

npm run build && npm run preview and run manual QA checklist.

Pre-launch stress test (critical)

Scripted simulation: create 100+ alarms over simulated 7 days (accelerated) to detect timing drift. Use a Node script that schedules alarms and validates triggers.

Device/OS scenarios: background tab, locked screen, low battery, flaky network.

Alarm reliability tests

Verify alarms persist across reloads/close/open.

Verify fallback sound plays if TTS fails.

Acceptance Criteria / Tests

0 critical runtime errors in production build.

Scheduler drift <100ms after 7-day sim.

All Playwright tests green in CI.

Deliverables

Test suite in CI.

Stress test report (CSV of failures/times).

Fixed bug list and PRs.

Phase 2 — UI/UX Redesign & Onboarding
Goal: Replace single messy page with clear, responsive UI and onboarding that drives permission acceptance.

Tasks

New navigation

Sidebar or bottom-tab nav: Dashboard, Alarms, Voice, Challenges, Profile, Settings.

Responsive layout

Mobile-first CSS/Tailwind (or chosen design system).

Onboarding wizard

Steps: Welcome → Request Notification → Request Microphone → Set test alarm → Test alarm sound.

Include inline permission explanations (Why we ask mic/notification).

Visual polish

Animations, micro-interactions, theme (dark/light), iconography.

Accessibility

Run axe audit, fix keyboard nav and aria labels.

Acceptance Criteria

Onboarding conversion metric ≥ X% in test group (set a target).

axe report shows no serious violations.

Deliverables

New UI components, design tokens, mock screenshots for store.

Phase 3 — Cloud Backend & Persistent Storage
Goal: Replace mock api.ts with a secure, persistent backend + real-time sync.

Recommended stack

Supabase for quick setup (Auth, Postgres, Realtime) OR Firebase + Firestore.

Serverless API routes (Cloudflare Workers or Vercel Serverless) for Cron/validation.

Key tasks

DB Schema (minimum)

users (id, email, created_at, prefs)

alarms (id, user_id, time, tz, repeat_rule, label, enabled, voice_mood, snooze_count, created_at, updated_at)

alarm_events (id, alarm_id, fired_at, dismissed, user_action)

voices (id, name, provider, config)

stats/achievements

Endpoints

POST /api/auth (via Supabase)

GET/POST /api/alarms

POST /api/alarms/:id/fire (server validation / event logging)

Secrets

Move keys to environment (VITE_API_URL, SUPABASE_URL, SUPABASE_KEY, TTS_API_KEY).

Real-time sync

Use Supabase Realtime or web sockets to sync alarm changes.

Acceptance Criteria

Alarms saved in DB persist across devices.

Real-time updates <5s.

Deliverables

Production DB deployed.

Backend CI/Deployment.

Phase 4 — Advanced Voice & Audio System
Goal: Make voice mood selection actually control alarm audio; ensure offline fallback and instant play.

Tasks

TTS engine

Integrate ElevenLabs / Google TTS / local wasm voices (choose provider).

Use SSML for expressive speech.

Voice moods

Map mood presets (Drill Sergeant, Sweet Angel, Anime Hero, Savage Roast) to voice + SSML templates.

Local caching

On alarm creation: pre-generate and cache audio blob in IndexedDB/localForage.

On alarm trigger: play cached file immediately; if missing, fallback sound.

Mic-based dismiss

Use getUserMedia to stream audio, run energy threshold / voice recognition to detect expected response.

Add sensitivity slider in UI (persist setting).

Edge cases

If mic denied: fallback to button-dismiss or proof-of-life camera.

Acceptance Criteria

Voice mood selection plays the expected voice in <200ms latency.

Offline test: cached voice plays when network is off.

Deliverables

Voice mood library, caching layer, UI.

Phase 5 — Cross-Platform Packaging & Background Handling
Goal: Ensure alarm works on web, PWA, and packaged mobile apps with best-effort background behavior.

Tasks

PWA

Add manifest, service worker, pre-cache critical assets and alarm audio.

Implement beforeunload warning if alarms active.

Mobile packaging

Build Capacitor wrapper for Android/iOS with native notifications and vibration.

Implement background task for Android using Headless JS or native broadcast receiver if packaging as native.

Native notification handling

Use Firebase Cloud Messaging (FCM) or local notifications when scheduling via backend.

Acceptance Criteria

On Android packaging: local notification triggers at alarm time when app in background/closed (where OS allows).

Document platform limitations (iOS restrictions) and provide fallback instructions.

Deliverables

PWA + Capacitor project build, store-ready assets.

Phase 6 — Advanced Features, Reliability & Optics
Goal: Add smart scheduling, gamification, monetization hooks and harden reliability.

Tasks

Smart alarms

Implement sleep pattern input + optional integration (fitbit / google fit).

Proof-of-life flows

Camera capture (permission) or photo upload verification.

Gamification

Leaderboards, XP, streaks, PvP battle mode (opt-in).

Premium

Add feature flags + paywall (stripe integration).

Pre-launch reliability

Battery/cpu profiling, optimize audio pipeline, lazy load large assets.

Security

Validate schedule changes server-side.

Detect conflicting edits (vector clocks) and resolve.

Acceptance Criteria

Conflict resolution tested.

Premium purchase flow works end-to-end.

Deliverables

Feature toggles, premium config, analytics funnel.

Phase 7 — Final Polish, Compliance & Launch Prep
Goal: Make the app store-ready and legally compliant.

Tasks

Accessibility audit

Fix critical issues found by axe.

Privacy & Legal

Add Privacy Policy, Terms, support contact inside Settings.

Implement analytics opt-in.

Crash reporting & analytics

Integrate Sentry + PostHog/Plausible.

Store prep

App icons, screenshots, promo text, privacy policy hosted URL.

PWA meta + cross-platform test reports.

Automated QA

Run nightly E2E and smoke tests; fail builds on critical regressions.

Acceptance Criteria

App passes Play Store basic checks and has privacy policy linked.

All critical E2E tests passing in CI.

Deliverables

Release candidate builds, store listing assets, compliance docs.

Implementation specifics & sample snippets (practical)
Recommended tech stack (concise)
Frontend: React + TypeScript + Vite + Tailwind (or existing ShadCN UI components).

Backend: Supabase (Auth + Postgres + Realtime) — fastest for MVP.

TTS: ElevenLabs or Google Cloud TTS (SSML); cache audio in IndexedDB with localForage.

Packaging: PWA + Capacitor for mobile.

Tests: Jest (unit), Playwright (E2E).

Observability: Sentry (errors), PostHog (analytics).

CI/CD: GitHub Actions → Vercel/Netlify for web; GitHub Actions → PlayStore/Apple (manual signing).

DB: alarm object (example)
sql
Copy
Edit
alarms (
  id uuid primary key,
  user_id uuid references users(id),
  time timestamptz,          -- scheduled time in user's timezone
  timezone text,
  repeat jsonb,              -- rules (daily, weekdays ...)
  label text,
  voice_mood text,
  cached_audio_url text,
  enabled boolean default true,
  snooze_count int default 0,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
)
Env vars example (.env.example)
makefile
Copy
Edit
VITE_SUPABASE_URL=
VITE_SUPABASE_ANON_KEY=
SUPABASE_SERVICE_ROLE_KEY=
TTS_API_KEY=
SENTRY_DSN=
VITE_API_URL=
Logger snippet
ts
Copy
Edit
export const isProd = process.env.NODE_ENV === 'production';
export const logger = {
  debug: (...a:any[]) => !isProd && console.debug(...a),
  info: (...a:any[]) => !isProd && console.info(...a),
  warn: (...a:any[]) => console.warn(...a),
  error: (...a:any[]) => {
    // send to Sentry if in prod
    if (isProd) { /* Sentry.captureException */ }
    console.error(...a);
  }
}
Stress test script idea (node pseudocode)
Create scripts/stress-alarms.js that programmatically calls backend POST /api/alarms for n=100, sets times across next 7 days in accelerated clock, and subscribes to webhook events to validate triggers. Run in CI container to detect drift.

Test & QA matrix (must-have tests)
Unit: scheduler correctness, alarm toggle, snooze logic, persistence.

Integration: TTS generation → cache → playback.

E2E: Create alarm → trigger → dismiss → analytics event present.

Stress: 100 alarms over 7 days simulation — produce report.

Manual cross-browser: Chrome/Firefox/Desktop, Chrome Android, Safari iOS.

Pre-launch checklist (copyable)
 All console.* removed (or behind logger).

 No secret keys in code.

 DB configured & migrations applied.

 Alarms persist on reload & sync across devices.

 TTS voice moods working & cached for offline use.

 Fallback sound plays when TTS fails or mic denied.

 Onboarding prompts guide permissions in correct order.

 E2E & unit tests pass in CI.

 Stress test report attached.

 Privacy Policy & Terms published and linked.

 App icons, screenshots and store copy ready.

 Crash reporting integrated.

 Accessibility audit cleared critical issues.

Timeline & Sprints (suggested quick plan)
Sprint 0 (3 days): Prep + CI + dev environment + repo cleanup.

Sprint 1 (1.5 weeks): Phase 1 — Tests & core bug fixes + stress test.

Sprint 2 (1.5 weeks): Phase 2 — UI/UX & onboarding.

Sprint 3 (2 weeks): Phase 3 — Backend & persistence.

Sprint 4 (2 weeks): Phase 4 — Voice integration + caching.

Sprint 5 (2 weeks): Phase 5 — PWA & mobile packaging.

Sprint 6 (2 weeks): Phase 6 — Smart features, premium.

Sprint 7 (1 week): Final polish & compliance.

(Adjust — this is a high-level estimate depending on team size. If you want I can break into day-by-day tasks.)

“Paste this to Scout” — Approval text (ready to paste)
Approve and proceed — but include these exact additions and acceptance criteria.

Deliver the work in the 7 phases I pasted (Comprehensive Testing → UI/UX → Backend → Voice → Cross-Platform → Advanced Features → Final Polish).
For each phase deliver a checklist, automated tests, and CI that fails on regressions.
Critical requirements before merging to main:

Replace mock backend with Supabase (or equivalent) and move ALL keys to env vars — no API_KEY in repo.

Remove/replace all console logs with a production-aware logger; integrate Sentry.

Implement local caching of pre-generated voice audio (IndexedDB/localForage) and a fail-safe fallback sound that is pre-cached at alarm setup.

Add onboarding flow for permissions (mic/notifications) that includes clear explanations and retry flow.

Add automated test suite (Jest unit tests + Playwright E2E) that runs in CI.

Run the pre-launch stress test (simulate 100+ alarms over 7 days accelerated) and attach the report. Fix any timing drift or failure.

Deliver PWA and Android build (Capacitor) with documentation of platform limitations (especially iOS).

Provide release checklist: privacy policy, store assets, screenshots, and an accessibility/audit report.

Please produce PRs per-phase with clear changelogs, tests, and a demo video showing: set alarm → pre-cache voice → alarm fires (background and foreground) → dismiss flows.

I approve Scout’s work conditional on the above. Start with Phase 0 and deliver Sprint 1 results (tests, logger cleanup, stress test report) within the first PR.

