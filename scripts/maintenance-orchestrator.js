#!/usr/bin/env node
/**
 * Maintenance Orchestrator
 * Runs all automated maintenance scripts in sequence
 */

const AutoESLintFixer = require('./auto-eslint-fixer');
const AutoTypeImprover = require('./auto-type-improver');
const AutoSecurityUpdater = require('./auto-security-updater');
const { execSync } = require('child_process');
const fs = require('fs');

class MaintenanceOrchestrator {
  constructor() {
    this.config = {
      logFile: 'logs/maintenance.log',
      schedule: {
        eslint: 'daily',
        types: 'weekly',
        security: 'daily',
      },
      maxRunTime: 30 * 60 * 1000, // 30 minutes
      createPR: false,
    };
  }

  log(message) {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] ${message}`;
    console.log(logMessage);

    if (!fs.existsSync('logs')) {
      fs.mkdirSync('logs', { recursive: true });
    }

    fs.appendFileSync(this.config.logFile, logMessage + '\n');
  }

  async runMaintenance() {
    this.log('ðŸš€ Starting complete automated maintenance...');

    const results = {
      eslint: false,
      types: false,
      security: false,
      startTime: Date.now(),
    };

    try {
      // 1. Security updates first (foundation)
      this.log('ðŸ›¡ï¸ Phase 1: Security Updates');
      const securityUpdater = new AutoSecurityUpdater();
      results.security = await securityUpdater.run();

      // 2. ESLint fixes (code quality)
      this.log('ðŸ”§ Phase 2: ESLint Fixes');
      const eslintFixer = new AutoESLintFixer();
      results.eslint = await eslintFixer.run();

      // 3. Type improvements (final polish)
      this.log('ðŸŽ¯ Phase 3: Type Improvements');
      const typeImprover = new AutoTypeImprover();
      results.types = await typeImprover.run();

      // 4. Final validation
      this.log('âœ… Phase 4: Validation');
      await this.runValidation();

      const duration = Date.now() - results.startTime;
      this.log(`ðŸŽ‰ Maintenance completed in ${Math.round(duration / 1000)}s`);

      // Generate summary
      await this.generateSummaryReport(results, duration);

      // Create PR if configured
      if (this.config.createPR) {
        await this.createMaintenancePR(results);
      }

      return true;
    } catch (error) {
      this.log(`âŒ Maintenance failed: ${error.message}`);
      return false;
    }
  }

  async runValidation() {
    try {
      this.log('ðŸ” Running TypeScript validation...');
      execSync('npx tsc --noEmit', { stdio: 'inherit' });

      this.log('ðŸ” Running ESLint validation...');
      execSync('npx eslint src --ext .ts,.tsx --max-warnings 999999', {
        stdio: 'inherit',
      });

      this.log('âœ… Validation passed');
    } catch (_error) {
      this.log('âš ï¸ Validation had issues but continuing...');
    }
  }

  async generateSummaryReport(results, duration) {
    const report = `# Automated Maintenance Report

**Date:** ${new Date().toISOString()}
**Duration:** ${Math.round(duration / 1000)} seconds

## Results Summary
- ðŸ›¡ï¸ Security Updates: ${results.security ? 'âœ… Success' : 'âŒ Failed'}
- ðŸ”§ ESLint Fixes: ${results.eslint ? 'âœ… Success' : 'âŒ Failed'}  
- ðŸŽ¯ Type Improvements: ${results.types ? 'âœ… Success' : 'âŒ Failed'}

## Next Scheduled Run
This maintenance will run automatically on schedule.

Check individual logs for detailed information:
- \`logs/security-updates.log\`
- \`logs/eslint-auto-fixes.log\`
- \`logs/type-improvements.log\`

---
*Generated by Automated Maintenance System*
`;

    if (!fs.existsSync('reports')) {
      fs.mkdirSync('reports', { recursive: true });
    }

    fs.writeFileSync('reports/maintenance-summary.md', report);
    this.log('ðŸ“Š Generated maintenance summary report');
  }

  async createMaintenancePR(_results) {
    this.log('ðŸ“ Creating maintenance PR...');

    try {
      // Check if there are changes to commit
      const status = execSync('git status --porcelain', { encoding: 'utf8' });

      if (!status.trim()) {
        this.log('â„¹ï¸ No changes to commit');
        return;
      }

      const timestamp = new Date().toISOString().slice(0, 10);
      const branchName = `auto/maintenance-${timestamp}`;

      // Create branch and commit changes
      execSync(`git checkout -b ${branchName}`, { stdio: 'inherit' });
      execSync('git add .', { stdio: 'inherit' });
      execSync('git commit -m "chore: automated maintenance updates"', {
        stdio: 'inherit',
      });
      execSync(`git push origin ${branchName}`, { stdio: 'inherit' });

      this.log(`âœ… Created maintenance branch: ${branchName}`);
    } catch (error) {
      this.log(`âš ï¸ Could not create PR: ${error.message}`);
    }
  }
}

// Run if called directly
if (require.main === module) {
  const orchestrator = new MaintenanceOrchestrator();

  // Parse command line arguments
  if (process.argv.includes('--create-pr')) {
    orchestrator.config.createPR = true;
  }

  orchestrator
    .runMaintenance()
    .then(success => {
      process.exit(success ? 0 : 1);
    })
    .catch(error => {
      console.error('Fatal error:', error);
      process.exit(1);
    });
}

module.exports = MaintenanceOrchestrator;
