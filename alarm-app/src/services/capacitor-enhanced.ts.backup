import { Capacitor } from '@capacitor/core';
import { StatusBar, Style } from '@capacitor/status-bar';
import { SplashScreen } from '@capacitor/splash-screen';
import { LocalNotifications } from '@capacitor/local-notifications';
import { PushNotifications } from '@capacitor/push-notifications';

// Extend PermissionName type for TypeScript
declare global {
  interface PermissionDescriptor {
    name: 'microphone' | 'camera' | 'geolocation' | 'notifications' | 'persistent-storage' | 'push' | 'midi' | 'background-sync';
  }
}

export interface CapacitorInitResult {
  platform: string;
  isNative: boolean;
  notificationPermission: boolean;
  pushPermission: boolean;
  microphonePermission: boolean;
}

export const initializeCapacitor = async (): Promise<CapacitorInitResult> => {
  const platform = Capacitor.getPlatform();
  const isNative = Capacitor.isNativePlatform();
  
  console.log(`Initializing on platform: ${platform}`);
  
  try {
    // Configure status bar for mobile
    if (isNative) {
      await StatusBar.setStyle({ style: Style.Dark });
      await StatusBar.setBackgroundColor({ color: '#1e3a8a' });
    }
    
    // Hide splash screen
    if (isNative) {
      await SplashScreen.hide();
    }
    
    // Request permissions
    const notificationPermission = await requestNotificationPermissions();
    const pushPermission = await requestPushPermissions();
    const microphonePermission = await requestMicrophonePermissions();
    
    return {
      platform,
      isNative,
      notificationPermission,
      pushPermission,
      microphonePermission
    };
  } catch (error) {
    console.error('Error initializing Capacitor:', error);
    return {
      platform,
      isNative,
      notificationPermission: false,
      pushPermission: false,
      microphonePermission: false
    };
  }
};

export const requestNotificationPermissions = async (): Promise<boolean> => {
  try {
    const { receive } = await LocalNotifications.requestPermissions();
    return receive === 'granted';
  } catch (error) {
    console.error('Error requesting notification permissions:', error);
    return false;
  }
};

export const requestPushPermissions = async (): Promise<boolean> => {
  try {
    const { receive } = await PushNotifications.requestPermissions();
    return receive === 'granted';
  } catch (error) {
    console.error('Error requesting push permissions:', error);
    return false;
  }
};

export const requestMicrophonePermissions = async (): Promise<boolean> => {
  try {
    // For web and native, use MediaDevices API
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      // Stop the stream immediately as we just need permission
      stream.getTracks().forEach(track => track.stop());
      console.log('Microphone permission granted');
      return true;
    }
    
    console.warn('MediaDevices API not available');
    return false;
  } catch (error) {
    console.error('Error requesting microphone permissions:', error);
    return false;
  }
};

export const checkMicrophonePermission = async (): Promise<boolean> => {
  try {
    if ('permissions' in navigator) {
      const permission = await navigator.permissions.query({ name: 'microphone' as PermissionName });
      return permission.state === 'granted';
    }
    
    // Fallback: try to access microphone
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      stream.getTracks().forEach(track => track.stop());
      return true;
    }
    
    return false;
  } catch (error) {
    return false;
  }
};

export const scheduleLocalNotification = async ({
  id,
  title,
  body,
  schedule
}: {
  id: number;
  title: string;
  body: string;
  schedule: Date;
}): Promise<void> => {
  try {
    await LocalNotifications.schedule({
      notifications: [
        {
          id,
          title,
          body,
          schedule: {
            at: schedule
          },
          sound: 'beep.wav',
          attachments: [],
          actionTypeId: 'ALARM_ACTION',
          extra: {
            alarmId: id.toString()
          }
        }
      ]
    });
    
    console.log(`Scheduled notification for ${schedule}`);
  } catch (error) {
    console.error('Error scheduling notification:', error);
    throw error;
  }
};

export const cancelLocalNotification = async (id: number): Promise<void> => {
  try {
    await LocalNotifications.cancel({
      notifications: [{ id: id.toString() }]
    });
    
    console.log(`Cancelled notification ${id}`);
  } catch (error) {
    console.error('Error cancelling notification:', error);
    throw error;
  }
};

export const setupNotificationListeners = (): void => {
  // Listen for notification tap
  LocalNotifications.addListener('localNotificationActionPerformed', (notification) => {
    console.log('Notification action performed:', notification);
    
    // Handle alarm notification tap
    if (notification.actionId === 'tap') {
      const alarmId = notification.notification.extra?.alarmId;
      if (alarmId) {
        // Trigger alarm UI
        window.dispatchEvent(new CustomEvent('alarm-triggered', {
          detail: { alarmId }
        }));
      }
    }
  });
  
  // Listen for notification received (when app is in foreground)
  LocalNotifications.addListener('localNotificationReceived', (notification) => {
    console.log('Notification received:', notification);
  });
  
  // Push notification listeners
  PushNotifications.addListener('registration', (token) => {
    console.log('Push registration success, token: ' + token.value);
  });
  
  PushNotifications.addListener('registrationError', (error) => {
    console.error('Push registration error:', error);
  });
  
  PushNotifications.addListener('pushNotificationReceived', (notification) => {
    console.log('Push notification received:', notification);
  });
  
  PushNotifications.addListener('pushNotificationActionPerformed', (notification) => {
    console.log('Push notification action performed:', notification);
  });
};

export const vibrate = async (duration: number = 500): Promise<void> => {
  try {
    const { Haptics, ImpactStyle } = await import('@capacitor/haptics');
    await Haptics.impact({ style: ImpactStyle.Heavy });
  } catch (error) {
    console.warn('Haptics not available:', error);
    
    // Fallback for web
    if ('vibrate' in navigator) {
      navigator.vibrate(duration);
    }
  }
};

export const vibratePattern = async (pattern: number[]): Promise<void> => {
  try {
    const { Haptics, ImpactStyle } = await import('@capacitor/haptics');
    
    // For native platforms, create a vibration pattern
    for (let i = 0; i < pattern.length; i++) {
      if (i % 2 === 0) {
        // Vibrate
        await Haptics.impact({ style: ImpactStyle.Heavy });
        await new Promise(resolve => setTimeout(resolve, pattern[i]));
      } else {
        // Pause
        await new Promise(resolve => setTimeout(resolve, pattern[i]));
      }
    }
  } catch (error) {
    console.warn('Haptics not available:', error);
    
    // Fallback for web
    if ('vibrate' in navigator) {
      navigator.vibrate(pattern);
    }
  }
};

export const setupAccelerometerShakeDetection = (onShake: () => void): (() => void) => {
  let lastUpdate = 0;
  let lastX = 0, lastY = 0, lastZ = 0;
  const SHAKE_THRESHOLD = 600;
  
  const handleDeviceMotion = (event: DeviceMotionEvent) => {
    const currentTime = Date.now();
    if ((currentTime - lastUpdate) > 100) {
      const timeDifference = currentTime - lastUpdate;
      lastUpdate = currentTime;
      
      const acceleration = event.accelerationIncludingGravity;
      if (acceleration) {
        const x = acceleration.x || 0;
        const y = acceleration.y || 0;
        const z = acceleration.z || 0;
        
        const speed = Math.abs(x + y + z - lastX - lastY - lastZ) / timeDifference * 10000;
        
        if (speed > SHAKE_THRESHOLD) {
          console.log('Shake detected!');
          onShake();
        }
        
        lastX = x;
        lastY = y;
        lastZ = z;
      }
    }
  };
  
  // Request motion permissions for iOS 13+
  if (typeof (DeviceMotionEvent as any).requestPermission === 'function') {
    (DeviceMotionEvent as any).requestPermission()
      .then((response: string) => {
        if (response === 'granted') {
          window.addEventListener('devicemotion', handleDeviceMotion);
        }
      })
      .catch(console.error);
  } else {
    // Non-iOS or older iOS
    window.addEventListener('devicemotion', handleDeviceMotion);
  }
  
  // Return cleanup function
  return () => {
    window.removeEventListener('devicemotion', handleDeviceMotion);
  };
};

// Enhanced device detection
export const getDeviceInfo = () => {
  const platform = Capacitor.getPlatform();
  const isNative = Capacitor.isNativePlatform();
  const userAgent = navigator.userAgent;
  
  return {
    platform,
    isNative,
    isAndroid: platform === 'android',
    isIOS: platform === 'ios',
    isWeb: platform === 'web',
    isMobile: isNative || /Mobi|Android/i.test(userAgent),
    supportsHaptics: isNative,
    supportsNotifications: 'Notification' in window,
    supportsSpeechSynthesis: 'speechSynthesis' in window,
    supportsSpeechRecognition: 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window,
    supportsMediaDevices: 'mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices,
    supportsDeviceMotion: 'DeviceMotionEvent' in window
  };
};