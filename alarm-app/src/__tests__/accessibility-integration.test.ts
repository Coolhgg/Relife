/**
 * Comprehensive Accessibility Integration Tests
 * Verifies that all accessibility features work together harmoniously
 */

import AccessibilityPreferencesService from '../services/accessibility-preferences';
import { KeyboardNavigationService } from '../utils/keyboard-navigation';
import ScreenReaderService from '../utils/screen-reader';

// Mock DOM environment
const mockDocument = {
  documentElement: {
    style: {
      setProperty: jest.fn(),
      getPropertyValue: jest.fn(() => '16px'),
    },
  },
  body: {
    classList: {
      toggle: jest.fn(),
      add: jest.fn(),
      remove: jest.fn(),
      contains: jest.fn(() => false),
    },
  },
  createElement: jest.fn(() => ({
    id: '',
    className: '',
    style: {},
    textContent: '',
    appendChild: jest.fn(),
    addEventListener: jest.fn(),
    removeEventListener: jest.fn(),
  })),
  head: {
    appendChild: jest.fn(),
  },
  getElementById: jest.fn(() => null),
  querySelector: jest.fn(() => null),
  querySelectorAll: jest.fn(() => []),
  addEventListener: jest.fn(),
  removeEventListener: jest.fn(),
  dispatchEvent: jest.fn(),
  contains: jest.fn(() => true),
};\n\n// Mock window environment\nconst mockWindow = {\n  matchMedia: jest.fn((query) => ({\n    matches: false,\n    media: query,\n    addEventListener: jest.fn(),\n    removeEventListener: jest.fn(),\n  })),\n  localStorage: {\n    getItem: jest.fn(() => null),\n    setItem: jest.fn(),\n    removeItem: jest.fn(),\n  },\n  navigator: {\n    userAgent: 'Test Browser',\n    vibrate: jest.fn(),\n  },\n  speechSynthesis: {\n    getVoices: jest.fn(() => []),\n  },\n};\n\n// Setup global mocks\nglobal.document = mockDocument as any;\nglobal.window = mockWindow as any;\nglobal.localStorage = mockWindow.localStorage as any;\nglobal.navigator = mockWindow.navigator as any;\n\ndescribe('Accessibility Integration Tests', () => {\n  let accessibilityService: AccessibilityPreferencesService;\n  let keyboardService: KeyboardNavigationService;\n  let screenReaderService: ScreenReaderService;\n\n  beforeEach(() => {\n    // Reset all mocks\n    jest.clearAllMocks();\n    \n    // Get fresh instances\n    accessibilityService = AccessibilityPreferencesService.getInstance();\n    keyboardService = KeyboardNavigationService.getInstance();\n    screenReaderService = ScreenReaderService.getInstance();\n  });\n\n  afterEach(() => {\n    // Clean up services\n    try {\n      accessibilityService.cleanup();\n      keyboardService.cleanup();\n      screenReaderService.cleanup();\n    } catch (error) {\n      // Ignore cleanup errors in tests\n    }\n  });\n\n  describe('Service Integration', () => {\n    test('accessibility preferences service should initialize properly', () => {\n      expect(accessibilityService).toBeDefined();\n      const preferences = accessibilityService.getPreferences();\n      expect(preferences).toBeDefined();\n      expect(typeof preferences.highContrastMode).toBe('boolean');\n      expect(typeof preferences.reducedMotion).toBe('boolean');\n      expect(typeof preferences.keyboardNavigation).toBe('boolean');\n    });\n\n    test('keyboard navigation should integrate with accessibility preferences', () => {\n      expect(keyboardService).toBeDefined();\n      \n      // Test initial state\n      const initialStatus = keyboardService.getAccessibilityStatus();\n      expect(initialStatus).toBeDefined();\n      expect(typeof initialStatus.keyboardNavigationEnabled).toBe('boolean');\n      \n      // Test preference updates\n      accessibilityService.updatePreferences({ keyboardNavigation: false });\n      keyboardService.refreshAccessibilityIntegration();\n      \n      const updatedStatus = keyboardService.getAccessibilityStatus();\n      expect(updatedStatus.keyboardNavigationEnabled).toBe(false);\n    });\n\n    test('screen reader service should respond to accessibility preferences', () => {\n      expect(screenReaderService).toBeDefined();\n      \n      // Test screen reader optimization\n      accessibilityService.updatePreferences({ \n        screenReaderOptimized: true,\n        announceTransitions: true \n      });\n      \n      const state = screenReaderService.getState();\n      expect(state).toBeDefined();\n    });\n  });\n\n  describe('Preference Synchronization', () => {\n    test('updating accessibility preferences should trigger service updates', () => {\n      const initialPrefs = accessibilityService.getPreferences();\n      \n      // Update multiple preferences\n      const updates = {\n        highContrastMode: !initialPrefs.highContrastMode,\n        reducedMotion: !initialPrefs.reducedMotion,\n        enhancedFocusRings: !initialPrefs.enhancedFocusRings,\n        keyboardNavigation: !initialPrefs.keyboardNavigation,\n      };\n      \n      accessibilityService.updatePreferences(updates);\n      \n      const updatedPrefs = accessibilityService.getPreferences();\n      expect(updatedPrefs.highContrastMode).toBe(updates.highContrastMode);\n      expect(updatedPrefs.reducedMotion).toBe(updates.reducedMotion);\n      expect(updatedPrefs.enhancedFocusRings).toBe(updates.enhancedFocusRings);\n      expect(updatedPrefs.keyboardNavigation).toBe(updates.keyboardNavigation);\n    });\n\n    test('preference changes should apply CSS styles correctly', () => {\n      // Test high contrast mode\n      accessibilityService.updatePreferences({ highContrastMode: true });\n      expect(mockDocument.body.classList.toggle).toHaveBeenCalledWith('a11y-high-contrast', true);\n      \n      // Test reduced motion\n      accessibilityService.updatePreferences({ reducedMotion: true });\n      expect(mockDocument.body.classList.toggle).toHaveBeenCalledWith('a11y-reduced-motion', true);\n      \n      // Test enhanced focus rings\n      accessibilityService.updatePreferences({ enhancedFocusRings: true });\n      expect(mockDocument.body.classList.toggle).toHaveBeenCalledWith('a11y-enhanced-focus', true);\n    });\n\n    test('font scaling should update CSS custom properties', () => {\n      accessibilityService.updatePreferences({ fontSize: 'large' });\n      expect(mockDocument.documentElement.style.setProperty).toHaveBeenCalledWith(\n        '--a11y-font-scale', \n        '1.125'\n      );\n      \n      accessibilityService.updatePreferences({ fontSize: 'extra-large' });\n      expect(mockDocument.documentElement.style.setProperty).toHaveBeenCalledWith(\n        '--a11y-font-scale', \n        '1.25'\n      );\n    });\n\n    test('focus ring color should update CSS custom properties', () => {\n      const customColor = '#FF0000';\n      accessibilityService.updatePreferences({ focusRingColor: customColor });\n      expect(mockDocument.documentElement.style.setProperty).toHaveBeenCalledWith(\n        '--a11y-focus-ring-color', \n        customColor\n      );\n    });\n  });\n\n  describe('System Integration', () => {\n    test('should detect system preferences correctly', () => {\n      // Mock system dark mode\n      const darkModeQuery = { matches: true };\n      mockWindow.matchMedia.mockImplementation((query) => {\n        if (query === '(prefers-color-scheme: dark)') {\n          return {\n            ...darkModeQuery,\n            media: query,\n            addEventListener: jest.fn(),\n            removeEventListener: jest.fn(),\n          };\n        }\n        return {\n          matches: false,\n          media: query,\n          addEventListener: jest.fn(),\n          removeEventListener: jest.fn(),\n        };\n      });\n      \n      const state = accessibilityService.getState();\n      expect(state.isSystemDarkMode).toBe(true);\n    });\n\n    test('should handle localStorage gracefully', () => {\n      // Test localStorage failure\n      mockWindow.localStorage.getItem.mockImplementation(() => {\n        throw new Error('Storage quota exceeded');\n      });\n      \n      // Should not crash when localStorage fails\n      expect(() => {\n        AccessibilityPreferencesService.getInstance();\n      }).not.toThrow();\n    });\n  });\n\n  describe('Keyboard Navigation Integration', () => {\n    test('keyboard shortcuts should respect accessibility preferences', () => {\n      // Disable keyboard navigation\n      accessibilityService.updatePreferences({ keyboardNavigation: false });\n      keyboardService.refreshAccessibilityIntegration();\n      \n      const shortcuts = keyboardService.getShortcuts();\n      const nonGeneralShortcuts = shortcuts.filter(s => s.category !== 'general');\n      \n      // Non-general shortcuts should be disabled\n      nonGeneralShortcuts.forEach(shortcut => {\n        expect(shortcut.enabled).toBe(false);\n      });\n    });\n\n    test('skip links should update based on visibility preferences', () => {\n      const mockSkipContainer = {\n        style: { display: '' },\n      };\n      mockDocument.getElementById.mockReturnValue(mockSkipContainer as any);\n      \n      // Test skip links visibility\n      accessibilityService.updatePreferences({ skipLinksVisible: true });\n      keyboardService.refreshAccessibilityIntegration();\n      \n      expect(mockSkipContainer.style.display).toBe('block');\n    });\n  });\n\n  describe('Error Handling', () => {\n    test('should handle service initialization failures gracefully', () => {\n      // Mock a service that throws during initialization\n      const originalConsoleWarn = console.warn;\n      console.warn = jest.fn();\n      \n      try {\n        // Should not crash even if individual services fail\n        expect(() => {\n          AccessibilityPreferencesService.getInstance();\n        }).not.toThrow();\n      } finally {\n        console.warn = originalConsoleWarn;\n      }\n    });\n\n    test('should handle DOM manipulation failures', () => {\n      // Mock document.body as null\n      const originalBody = mockDocument.body;\n      (mockDocument as any).body = null;\n      \n      try {\n        // Should not crash when DOM elements are missing\n        expect(() => {\n          accessibilityService.updatePreferences({ highContrastMode: true });\n        }).not.toThrow();\n      } finally {\n        (mockDocument as any).body = originalBody;\n      }\n    });\n  });\n\n  describe('Performance', () => {\n    test('preference updates should be debounced to avoid excessive DOM manipulation', () => {\n      const startTime = performance.now();\n      \n      // Rapid preference updates\n      for (let i = 0; i < 10; i++) {\n        accessibilityService.updatePreferences({ \n          fontSize: i % 2 === 0 ? 'large' : 'medium' \n        });\n      }\n      \n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      // Should complete quickly (less than 100ms for 10 updates)\n      expect(duration).toBeLessThan(100);\n    });\n\n    test('CSS style generation should be efficient', () => {\n      const startTime = performance.now();\n      \n      // Generate CSS styles multiple times\n      for (let i = 0; i < 5; i++) {\n        accessibilityService.updatePreferences({ highContrastMode: i % 2 === 0 });\n      }\n      \n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      // Should complete quickly\n      expect(duration).toBeLessThan(50);\n    });\n  });\n\n  describe('WCAG Compliance', () => {\n    test('should provide proper contrast ratios', () => {\n      const contrastResult = accessibilityService.testColorContrast('#000000', '#ffffff');\n      expect(contrastResult).toBeDefined();\n      expect(typeof contrastResult.ratio).toBe('number');\n      expect(typeof contrastResult.wcagAA).toBe('boolean');\n      expect(typeof contrastResult.wcagAAA).toBe('boolean');\n    });\n\n    test('focus management should follow WCAG guidelines', () => {\n      const status = keyboardService.getAccessibilityStatus();\n      expect(status.enhancedFocusRings).toBeDefined();\n      expect(status.focusRingColor).toBeDefined();\n      expect(typeof status.focusRingColor).toBe('string');\n    });\n\n    test('should support proper ARIA announcements', () => {\n      accessibilityService.updatePreferences({ \n        screenReaderOptimized: true,\n        announceTransitions: true,\n        announceErrors: true,\n        announceSuccess: true,\n      });\n      \n      const preferences = accessibilityService.getPreferences();\n      expect(preferences.announceTransitions).toBe(true);\n      expect(preferences.announceErrors).toBe(true);\n      expect(preferences.announceSuccess).toBe(true);\n    });\n  });\n\n  describe('Mobile Accessibility', () => {\n    test('should handle touch target sizing', () => {\n      accessibilityService.updatePreferences({ largerTouchTargets: true });\n      expect(mockDocument.body.classList.toggle).toHaveBeenCalledWith('a11y-large-touch-targets', true);\n    });\n\n    test('should handle haptic feedback preferences', () => {\n      accessibilityService.updatePreferences({ hapticFeedback: true });\n      const preferences = accessibilityService.getPreferences();\n      expect(preferences.hapticFeedback).toBe(true);\n    });\n\n    test('should adjust long press delay', () => {\n      const customDelay = 750;\n      accessibilityService.updatePreferences({ longPressDelay: customDelay });\n      expect(mockDocument.documentElement.style.setProperty).toHaveBeenCalledWith(\n        '--a11y-long-press-delay', \n        `${customDelay}ms`\n      );\n    });\n  });\n\n  describe('Integration Scenarios', () => {\n    test('high contrast + reduced motion should work together', () => {\n      accessibilityService.updatePreferences({ \n        highContrastMode: true, \n        reducedMotion: true \n      });\n      \n      expect(mockDocument.body.classList.toggle).toHaveBeenCalledWith('a11y-high-contrast', true);\n      expect(mockDocument.body.classList.toggle).toHaveBeenCalledWith('a11y-reduced-motion', true);\n    });\n\n    test('screen reader + keyboard navigation should work together', () => {\n      accessibilityService.updatePreferences({ \n        screenReaderOptimized: true, \n        keyboardNavigation: true,\n        enhancedFocusRings: true,\n      });\n      \n      keyboardService.refreshAccessibilityIntegration();\n      const status = keyboardService.getAccessibilityStatus();\n      \n      expect(status.keyboardNavigationEnabled).toBe(true);\n      expect(status.enhancedFocusRings).toBe(true);\n      expect(status.screenReaderOptimized).toBe(true);\n    });\n\n    test('all accessibility features enabled should not conflict', () => {\n      const allFeaturesEnabled = {\n        highContrastMode: true,\n        reducedMotion: true,\n        fontSize: 'large' as const,\n        colorBlindFriendly: true,\n        enhancedFocusRings: true,\n        skipLinksVisible: true,\n        keyboardNavigation: true,\n        screenReaderOptimized: true,\n        announceTransitions: true,\n        announceErrors: true,\n        announceSuccess: true,\n        largerTouchTargets: true,\n        hapticFeedback: true,\n        voiceCommands: true,\n        gestureNavigation: true,\n      };\n      \n      expect(() => {\n        accessibilityService.updatePreferences(allFeaturesEnabled);\n        keyboardService.refreshAccessibilityIntegration();\n      }).not.toThrow();\n      \n      const finalPreferences = accessibilityService.getPreferences();\n      Object.keys(allFeaturesEnabled).forEach(key => {\n        expect(finalPreferences[key as keyof typeof allFeaturesEnabled]).toBe(\n          allFeaturesEnabled[key as keyof typeof allFeaturesEnabled]\n        );\n      });\n    });\n  });\n});\n\n// Additional integration tests for React hooks would go here\n// These would require a React testing environment setup