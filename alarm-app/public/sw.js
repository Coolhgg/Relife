// Smart Alarm Service Worker\n// Handles background alarm processing and notifications\n\nconst CACHE_NAME = 'smart-alarm-v1';\nconst ALARM_CHECK_INTERVAL = 30000; // 30 seconds\nconst urlsToCache = [\n  '/',\n  '/static/js/bundle.js',\n  '/static/css/main.css',\n  '/manifest.json'\n];\n\nlet alarmCheckInterval = null;\nlet cachedAlarms = [];\n\n// Install event - cache essential files\nself.addEventListener('install', (event) => {\n  console.log('[SW] Installing service worker');\n  \n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then((cache) => {\n        console.log('[SW] Caching app shell');\n        return cache.addAll(urlsToCache);\n      })\n      .then(() => {\n        console.log('[SW] Service worker installed successfully');\n        return self.skipWaiting();\n      })\n      .catch((error) => {\n        console.error('[SW] Error during install:', error);\n      })\n  );\n});\n\n// Activate event - clean up old caches\nself.addEventListener('activate', (event) => {\n  console.log('[SW] Activating service worker');\n  \n  event.waitUntil(\n    caches.keys().then((cacheNames) => {\n      return Promise.all(\n        cacheNames.map((cacheName) => {\n          if (cacheName !== CACHE_NAME) {\n            console.log('[SW] Deleting old cache:', cacheName);\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    }).then(() => {\n      console.log('[SW] Service worker activated');\n      startAlarmChecker();\n      return self.clients.claim();\n    })\n  );\n});\n\n// Fetch event - serve from cache when offline\nself.addEventListener('fetch', (event) => {\n  event.respondWith(\n    caches.match(event.request)\n      .then((response) => {\n        // Return cached version or fetch from network\n        return response || fetch(event.request);\n      })\n      .catch(() => {\n        // Return offline page for navigation requests\n        if (event.request.mode === 'navigate') {\n          return caches.match('/');\n        }\n      })\n  );\n});\n\n// Message event - handle communication with main app\nself.addEventListener('message', (event) => {\n  const { type, data } = event.data;\n  \n  console.log('[SW] Received message:', type, data);\n  \n  switch (type) {\n    case 'UPDATE_ALARMS':\n      updateCachedAlarms(data.alarms);\n      break;\n    case 'TRIGGER_ALARM':\n      triggerAlarm(data.alarm);\n      break;\n    case 'PING':\n      event.ports[0].postMessage({ type: 'PONG', timestamp: Date.now() });\n      break;\n    default:\n      console.log('[SW] Unknown message type:', type);\n  }\n});\n\n// Notification click event\nself.addEventListener('notificationclick', (event) => {\n  console.log('[SW] Notification clicked:', event.notification.tag);\n  \n  event.notification.close();\n  \n  // Open the app\n  event.waitUntil(\n    clients.openWindow('/')\n      .then((client) => {\n        if (client) {\n          client.focus();\n          // Send alarm trigger event to the client\n          client.postMessage({\n            type: 'ALARM_TRIGGERED',\n            alarmId: event.notification.tag\n          });\n        }\n      })\n  );\n});\n\n// Push event - handle push notifications\nself.addEventListener('push', (event) => {\n  console.log('[SW] Push event received');\n  \n  let notificationData = {\n    title: 'Smart Alarm',\n    body: 'Time to wake up!',\n    icon: '/icon-192x192.png',\n    badge: '/badge-72x72.png',\n    vibrate: [200, 100, 200],\n    requireInteraction: true,\n    actions: [\n      {\n        action: 'dismiss',\n        title: 'Dismiss',\n        icon: '/dismiss-icon.png'\n      },\n      {\n        action: 'snooze',\n        title: 'Snooze 5min',\n        icon: '/snooze-icon.png'\n      }\n    ]\n  };\n  \n  if (event.data) {\n    try {\n      const data = event.data.json();\n      notificationData = { ...notificationData, ...data };\n    } catch (error) {\n      console.error('[SW] Error parsing push data:', error);\n    }\n  }\n  \n  event.waitUntil(\n    self.registration.showNotification(notificationData.title, notificationData)\n  );\n});\n\n// Background sync event\nself.addEventListener('sync', (event) => {\n  console.log('[SW] Background sync:', event.tag);\n  \n  if (event.tag === 'alarm-sync') {\n    event.waitUntil(syncAlarms());\n  }\n});\n\n// Notification action event\nself.addEventListener('notificationaction', (event) => {\n  console.log('[SW] Notification action:', event.action);\n  \n  event.notification.close();\n  \n  switch (event.action) {\n    case 'dismiss':\n      handleAlarmDismiss(event.notification.tag);\n      break;\n    case 'snooze':\n      handleAlarmSnooze(event.notification.tag);\n      break;\n  }\n});\n\n// Alarm checking functions\nfunction startAlarmChecker() {\n  if (alarmCheckInterval) {\n    clearInterval(alarmCheckInterval);\n  }\n  \n  console.log('[SW] Starting alarm checker');\n  \n  alarmCheckInterval = setInterval(() => {\n    checkForTriggeredAlarms();\n  }, ALARM_CHECK_INTERVAL);\n  \n  // Check immediately\n  checkForTriggeredAlarms();\n}\n\nfunction stopAlarmChecker() {\n  if (alarmCheckInterval) {\n    clearInterval(alarmCheckInterval);\n    alarmCheckInterval = null;\n    console.log('[SW] Stopped alarm checker');\n  }\n}\n\nfunction updateCachedAlarms(alarms) {\n  cachedAlarms = alarms || [];\n  console.log('[SW] Updated cached alarms:', cachedAlarms.length);\n}\n\nfunction checkForTriggeredAlarms() {\n  if (!cachedAlarms.length) return;\n  \n  const now = new Date();\n  const currentHour = now.getHours();\n  const currentMinute = now.getMinutes();\n  const currentDay = now.getDay();\n  \n  cachedAlarms.forEach(alarm => {\n    if (!alarm.enabled || !alarm.days.includes(currentDay)) return;\n    \n    const [alarmHour, alarmMinute] = alarm.time.split(':').map(Number);\n    \n    // Check if this is the exact alarm time\n    if (alarmHour === currentHour && alarmMinute === currentMinute) {\n      // Check if we haven't triggered this alarm recently\n      const lastTriggered = alarm.lastTriggered ? new Date(alarm.lastTriggered) : null;\n      const shouldTrigger = !lastTriggered || \n        (now.getTime() - lastTriggered.getTime()) > (22 * 60 * 60 * 1000); // 22 hours\n      \n      if (shouldTrigger) {\n        triggerAlarm(alarm);\n      }\n    }\n  });\n}\n\nfunction triggerAlarm(alarm) {\n  console.log('[SW] Triggering alarm:', alarm.label);\n  \n  // Show notification\n  const notificationOptions = {\n    body: `Time for ${alarm.label}!`,\n    icon: '/icon-192x192.png',\n    badge: '/badge-72x72.png',\n    tag: alarm.id,\n    requireInteraction: true,\n    vibrate: [500, 200, 500, 200, 500],\n    actions: [\n      {\n        action: 'dismiss',\n        title: 'Dismiss',\n        icon: '/dismiss-icon.png'\n      },\n      {\n        action: 'snooze',\n        title: 'Snooze 5min',\n        icon: '/snooze-icon.png'\n      }\n    ],\n    data: {\n      alarmId: alarm.id,\n      voiceMood: alarm.voiceMood,\n      timestamp: Date.now()\n    }\n  };\n  \n  self.registration.showNotification('ðŸ”” Smart Alarm', notificationOptions);\n  \n  // Notify all clients\n  self.clients.matchAll().then(clients => {\n    clients.forEach(client => {\n      client.postMessage({\n        type: 'ALARM_TRIGGERED',\n        alarm: alarm\n      });\n    });\n  });\n  \n  // Update last triggered time\n  updateAlarmLastTriggered(alarm.id);\n}\n\nfunction handleAlarmDismiss(alarmId) {\n  console.log('[SW] Alarm dismissed:', alarmId);\n  \n  // Notify clients\n  self.clients.matchAll().then(clients => {\n    clients.forEach(client => {\n      client.postMessage({\n        type: 'ALARM_DISMISSED',\n        alarmId: alarmId,\n        method: 'notification'\n      });\n    });\n  });\n}\n\nfunction handleAlarmSnooze(alarmId) {\n  console.log('[SW] Alarm snoozed:', alarmId);\n  \n  // Schedule snooze notification\n  const snoozeTime = 5 * 60 * 1000; // 5 minutes\n  \n  setTimeout(() => {\n    const alarm = cachedAlarms.find(a => a.id === alarmId);\n    if (alarm) {\n      triggerAlarm(alarm);\n    }\n  }, snoozeTime);\n  \n  // Notify clients\n  self.clients.matchAll().then(clients => {\n    clients.forEach(client => {\n      client.postMessage({\n        type: 'ALARM_SNOOZED',\n        alarmId: alarmId,\n        snoozeMinutes: 5\n      });\n    });\n  });\n}\n\nfunction updateAlarmLastTriggered(alarmId) {\n  const alarm = cachedAlarms.find(a => a.id === alarmId);\n  if (alarm) {\n    alarm.lastTriggered = new Date().toISOString();\n  }\n}\n\nasync function syncAlarms() {\n  try {\n    console.log('[SW] Syncing alarms...');\n    \n    // This would sync with the server when connectivity is restored\n    // For now, we'll just log the attempt\n    \n    // In a real implementation, you would:\n    // 1. Get stored offline changes\n    // 2. Send them to the server\n    // 3. Fetch latest alarm data\n    // 4. Update local cache\n    \n    console.log('[SW] Alarm sync completed');\n  } catch (error) {\n    console.error('[SW] Error syncing alarms:', error);\n  }\n}\n\n// Periodic background sync (if supported)\nif ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {\n  console.log('[SW] Background sync supported');\n} else {\n  console.log('[SW] Background sync not supported');\n}\n\n// Handle service worker updates\nself.addEventListener('message', (event) => {\n  if (event.data && event.data.type === 'SKIP_WAITING') {\n    self.skipWaiting();\n  }\n});\n\n// Cleanup on termination\nself.addEventListener('beforeunload', () => {\n  stopAlarmChecker();\n});