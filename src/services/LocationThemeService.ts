import { Geolocation } from '@capacitor/geolocation';\nimport { Preferences } from '@capacitor/preferences';\nimport type { ThemeVariant } from '../types';\n\ninterface LocationThemeConfig {\n  enabled: boolean;\n  rules: LocationThemeRule[];\n  lastLocation?: {\n    lat: number;\n    lng: number;\n    timestamp: number;\n  };\n}\n\ninterface LocationThemeRule {\n  id: string;\n  name: string;\n  enabled: boolean;\n  location: {\n    lat: number;\n    lng: number;\n    radius: number; // in kilometers\n  };\n  theme: {\n    mode?: 'light' | 'dark' | 'system';\n    variant?: ThemeVariant;\n  };\n  timeRestriction?: {\n    startTime: string; // HH:MM\n    endTime: string; // HH:MM\n  };\n}\n\n// Weather-based theme adaptation\ninterface WeatherThemeConfig {\n  enabled: boolean;\n  apiKey?: string;\n  rules: {\n    sunny: { variant: ThemeVariant; mode?: 'light' | 'dark' };\n    cloudy: { variant: ThemeVariant; mode?: 'light' | 'dark' };\n    rainy: { variant: ThemeVariant; mode?: 'light' | 'dark' };\n    snowy: { variant: ThemeVariant; mode?: 'light' | 'dark' };\n    stormy: { variant: ThemeVariant; mode?: 'light' | 'dark' };\n  };\n}\n\nclass LocationThemeService {\n  private static instance: LocationThemeService;\n  private config: LocationThemeConfig = {\n    enabled: false,\n    rules: []\n  };\n  private weatherConfig: WeatherThemeConfig = {\n    enabled: false,\n    rules: {\n      sunny: { variant: 'orange', mode: 'light' },\n      cloudy: { variant: 'blue', mode: 'dark' },\n      rainy: { variant: 'blue', mode: 'dark' },\n      snowy: { variant: 'default', mode: 'light' },\n      stormy: { variant: 'red', mode: 'dark' }\n    }\n  };\n  \n  private locationWatchId: string | null = null;\n  private readonly CONFIG_KEY = 'location-theme-config';\n  private readonly WEATHER_CONFIG_KEY = 'weather-theme-config';\n\n  static getInstance(): LocationThemeService {\n    if (!LocationThemeService.instance) {\n      LocationThemeService.instance = new LocationThemeService();\n    }\n    return LocationThemeService.instance;\n  }\n\n  async initialize() {\n    try {\n      // Load saved configuration\n      await this.loadConfig();\n      \n      if (this.config.enabled) {\n        await this.startLocationTracking();\n      }\n    } catch (error) {\n      console.warn('Failed to initialize location theme service:', error);\n    }\n  }\n\n  private async loadConfig() {\n    try {\n      const saved = await Preferences.get({ key: this.CONFIG_KEY });\n      if (saved.value) {\n        this.config = { ...this.config, ...JSON.parse(saved.value) };\n      }\n      \n      const weatherSaved = await Preferences.get({ key: this.WEATHER_CONFIG_KEY });\n      if (weatherSaved.value) {\n        this.weatherConfig = { ...this.weatherConfig, ...JSON.parse(weatherSaved.value) };\n      }\n    } catch (error) {\n      console.warn('Failed to load location theme config:', error);\n    }\n  }\n\n  private async saveConfig() {\n    try {\n      await Preferences.set({\n        key: this.CONFIG_KEY,\n        value: JSON.stringify(this.config)\n      });\n      \n      await Preferences.set({\n        key: this.WEATHER_CONFIG_KEY,\n        value: JSON.stringify(this.weatherConfig)\n      });\n    } catch (error) {\n      console.warn('Failed to save location theme config:', error);\n    }\n  }\n\n  async requestLocationPermission(): Promise<boolean> {\n    try {\n      const permission = await Geolocation.requestPermissions();\n      return permission.location === 'granted';\n    } catch (error) {\n      console.error('Location permission request failed:', error);\n      return false;\n    }\n  }\n\n  async startLocationTracking() {\n    try {\n      const hasPermission = await this.requestLocationPermission();\n      if (!hasPermission) {\n        throw new Error('Location permission denied');\n      }\n\n      this.locationWatchId = await Geolocation.watchPosition(\n        {\n          enableHighAccuracy: false,\n          timeout: 10000,\n          maximumAge: 300000 // 5 minutes\n        },\n        (position) => {\n          this.handleLocationUpdate(position.coords.latitude, position.coords.longitude);\n        },\n        (error) => {\n          console.warn('Location tracking error:', error);\n        }\n      );\n    } catch (error) {\n      console.error('Failed to start location tracking:', error);\n      throw error;\n    }\n  }\n\n  async stopLocationTracking() {\n    if (this.locationWatchId) {\n      await Geolocation.clearWatch({ id: this.locationWatchId });\n      this.locationWatchId = null;\n    }\n  }\n\n  private handleLocationUpdate(lat: number, lng: number) {\n    this.config.lastLocation = {\n      lat,\n      lng,\n      timestamp: Date.now()\n    };\n    \n    // Check for location-based theme rules\n    const matchingRule = this.findMatchingLocationRule(lat, lng);\n    if (matchingRule) {\n      this.applyLocationTheme(matchingRule);\n    }\n    \n    // Check weather if enabled\n    if (this.weatherConfig.enabled && this.weatherConfig.apiKey) {\n      this.checkWeatherAndApplyTheme(lat, lng);\n    }\n    \n    this.saveConfig();\n  }\n\n  private findMatchingLocationRule(lat: number, lng: number): LocationThemeRule | null {\n    const now = new Date();\n    const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;\n    \n    return this.config.rules.find(rule => {\n      if (!rule.enabled) return false;\n      \n      // Check time restriction\n      if (rule.timeRestriction) {\n        const { startTime, endTime } = rule.timeRestriction;\n        if (startTime <= endTime) {\n          // Same day range\n          if (currentTime < startTime || currentTime > endTime) return false;\n        } else {\n          // Crosses midnight\n          if (currentTime < startTime && currentTime > endTime) return false;\n        }\n      }\n      \n      // Check distance\n      const distance = this.calculateDistance(lat, lng, rule.location.lat, rule.location.lng);\n      return distance <= rule.location.radius;\n    }) || null;\n  }\n\n  private calculateDistance(lat1: number, lng1: number, lat2: number, lng2: number): number {\n    const R = 6371; // Earth's radius in km\n    const dLat = this.degToRad(lat2 - lat1);\n    const dLng = this.degToRad(lng2 - lng1);\n    const a = \n      Math.sin(dLat/2) * Math.sin(dLat/2) +\n      Math.cos(this.degToRad(lat1)) * Math.cos(this.degToRad(lat2)) *\n      Math.sin(dLng/2) * Math.sin(dLng/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n    return R * c;\n  }\n\n  private degToRad(deg: number): number {\n    return deg * (Math.PI/180);\n  }\n\n  private applyLocationTheme(rule: LocationThemeRule) {\n    // Dispatch custom event for theme change\n    const event = new CustomEvent('location-theme-change', {\n      detail: {\n        rule,\n        location: this.config.lastLocation\n      }\n    });\n    window.dispatchEvent(event);\n  }\n\n  private async checkWeatherAndApplyTheme(lat: number, lng: number) {\n    try {\n      const weather = await this.fetchWeather(lat, lng);\n      const weatherType = this.mapWeatherToType(weather.condition);\n      const themeRule = this.weatherConfig.rules[weatherType];\n      \n      if (themeRule) {\n        const event = new CustomEvent('weather-theme-change', {\n          detail: {\n            weather,\n            theme: themeRule,\n            location: { lat, lng }\n          }\n        });\n        window.dispatchEvent(event);\n      }\n    } catch (error) {\n      console.warn('Weather check failed:', error);\n    }\n  }\n\n  private async fetchWeather(lat: number, lng: number) {\n    if (!this.weatherConfig.apiKey) {\n      throw new Error('Weather API key not configured');\n    }\n    \n    const response = await fetch(\n      `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lng}&appid=${this.weatherConfig.apiKey}`\n    );\n    \n    if (!response.ok) {\n      throw new Error('Weather API request failed');\n    }\n    \n    return await response.json();\n  }\n\n  private mapWeatherToType(condition: string): keyof WeatherThemeConfig['rules'] {\n    const lowerCondition = condition.toLowerCase();\n    \n    if (lowerCondition.includes('sun') || lowerCondition.includes('clear')) return 'sunny';\n    if (lowerCondition.includes('cloud')) return 'cloudy';\n    if (lowerCondition.includes('rain') || lowerCondition.includes('drizzle')) return 'rainy';\n    if (lowerCondition.includes('snow')) return 'snowy';\n    if (lowerCondition.includes('storm') || lowerCondition.includes('thunder')) return 'stormy';\n    \n    return 'cloudy'; // default\n  }\n\n  // Public API methods\n  async enableLocationThemes(enabled: boolean) {\n    this.config.enabled = enabled;\n    \n    if (enabled) {\n      await this.startLocationTracking();\n    } else {\n      await this.stopLocationTracking();\n    }\n    \n    await this.saveConfig();\n  }\n\n  async addLocationRule(rule: Omit<LocationThemeRule, 'id'>) {\n    const newRule: LocationThemeRule = {\n      ...rule,\n      id: `rule-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n    };\n    \n    this.config.rules.push(newRule);\n    await this.saveConfig();\n    return newRule;\n  }\n\n  async removeLocationRule(ruleId: string) {\n    this.config.rules = this.config.rules.filter(rule => rule.id !== ruleId);\n    await this.saveConfig();\n  }\n\n  async setWeatherApiKey(apiKey: string) {\n    this.weatherConfig.apiKey = apiKey;\n    await this.saveConfig();\n  }\n\n  async enableWeatherThemes(enabled: boolean) {\n    this.weatherConfig.enabled = enabled;\n    await this.saveConfig();\n  }\n\n  getConfig() {\n    return { ...this.config };\n  }\n\n  getWeatherConfig() {\n    return { ...this.weatherConfig };\n  }\n}\n\nexport { LocationThemeService, type LocationThemeRule, type WeatherThemeConfig };\nexport default LocationThemeService;