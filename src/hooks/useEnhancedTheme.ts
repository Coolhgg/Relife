import { useTheme as useNextTheme } from 'next-themes';\nimport { useEffect, useState, useCallback } from 'react';\nimport { Preferences } from '@capacitor/preferences';\nimport { Haptics, ImpactStyle } from '@capacitor/haptics';\nimport type { ThemeConfig, ThemeMode, ThemeVariant, ThemeStyle } from '../types';\nimport { themeVariants, themeStyles, defaultThemeConfig } from '../config/themes';\n\nconst THEME_CONFIG_KEY = 'theme-config';\n\nexport interface UseEnhancedThemeReturn {\n  // Basic theme functionality\n  mode: string | undefined;\n  resolvedTheme: string | undefined;\n  setMode: (theme: string) => void;\n  systemTheme: string | undefined;\n  themes: string[];\n  isSystemMode: boolean;\n  isDark: boolean;\n  isLight: boolean;\n  toggleMode: () => void;\n  \n  // Enhanced theme functionality\n  config: ThemeConfig;\n  variant: ThemeVariant;\n  style: ThemeStyle;\n  setVariant: (variant: ThemeVariant) => void;\n  setStyle: (style: ThemeStyle) => void;\n  setConfig: (config: Partial<ThemeConfig>) => void;\n  \n  // Utility functions\n  getCurrentColors: () => { primary: string; secondary: string; accent: string };\n  getCurrentGradient: () => string;\n  applyThemeToDOM: () => void;\n  \n  // Mobile features\n  triggerHapticFeedback: () => void;\n  \n  // Scheduled themes\n  isScheduledModeActive: boolean;\n  enableScheduledMode: (lightStart: string, darkStart: string) => void;\n  disableScheduledMode: () => void;\n}\n\n/**\n * Enhanced theme hook with multiple variants, mobile optimizations, and advanced features\n */\nexport function useEnhancedTheme(): UseEnhancedThemeReturn {\n  const {\n    theme: mode,\n    resolvedTheme,\n    setTheme: setMode,\n    systemTheme,\n    themes\n  } = useNextTheme();\n\n  const [mounted, setMounted] = useState(false);\n  const [config, setConfigState] = useState<ThemeConfig>(defaultThemeConfig);\n  const [isScheduledModeActive, setIsScheduledModeActive] = useState(false);\n\n  // Load saved theme configuration\n  useEffect(() => {\n    setMounted(true);\n    loadThemeConfig();\n  }, []);\n\n  // Check for scheduled theme switching\n  useEffect(() => {\n    if (!mounted || !config.autoSchedule?.enabled) return;\n\n    const checkScheduledTheme = () => {\n      const now = new Date();\n      const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;\n      \n      const lightStart = config.autoSchedule!.lightModeStart;\n      const darkStart = config.autoSchedule!.darkModeStart;\n      \n      let shouldBeDark = false;\n      \n      if (darkStart < lightStart) {\n        // Dark mode spans midnight (e.g., 19:00 to 07:00)\n        shouldBeDark = currentTime >= darkStart || currentTime < lightStart;\n      } else {\n        // Dark mode within same day (e.g., 12:00 to 15:00)\n        shouldBeDark = currentTime >= darkStart && currentTime < lightStart;\n      }\n      \n      const targetMode = shouldBeDark ? 'dark' : 'light';\n      if (mode !== targetMode) {\n        setMode(targetMode);\n        setIsScheduledModeActive(true);\n        triggerHapticFeedback();\n      }\n    };\n\n    checkScheduledTheme();\n    const interval = setInterval(checkScheduledTheme, 60000); // Check every minute\n    \n    return () => clearInterval(interval);\n  }, [mounted, config.autoSchedule, mode, setMode]);\n\n  const loadThemeConfig = async () => {\n    try {\n      const saved = await Preferences.get({ key: THEME_CONFIG_KEY });\n      if (saved.value) {\n        const parsed = JSON.parse(saved.value) as ThemeConfig;\n        setConfigState({ ...defaultThemeConfig, ...parsed });\n      }\n    } catch (error) {\n      console.warn('Failed to load theme config:', error);\n    }\n  };\n\n  const saveThemeConfig = async (newConfig: ThemeConfig) => {\n    try {\n      await Preferences.set({\n        key: THEME_CONFIG_KEY,\n        value: JSON.stringify(newConfig)\n      });\n    } catch (error) {\n      console.warn('Failed to save theme config:', error);\n    }\n  };\n\n  const setConfig = useCallback(async (updates: Partial<ThemeConfig>) => {\n    const newConfig = { ...config, ...updates };\n    setConfigState(newConfig);\n    await saveThemeConfig(newConfig);\n    applyThemeToDOM();\n  }, [config]);\n\n  const setVariant = useCallback((variant: ThemeVariant) => {\n    setConfig({ variant });\n    triggerHapticFeedback();\n  }, [setConfig]);\n\n  const setStyle = useCallback((style: ThemeStyle) => {\n    setConfig({ style });\n    triggerHapticFeedback();\n  }, [setConfig]);\n\n  const toggleMode = useCallback(() => {\n    if (!mounted) return;\n    \n    const newMode = mode === 'system' \n      ? (resolvedTheme === 'dark' ? 'light' : 'dark')\n      : (mode === 'dark' ? 'light' : 'dark');\n    \n    setMode(newMode);\n    setIsScheduledModeActive(false);\n    triggerHapticFeedback();\n  }, [mounted, mode, resolvedTheme, setMode]);\n\n  const getCurrentColors = useCallback(() => {\n    const variant = themeVariants[config.variant] || themeVariants.default;\n    return variant.colors;\n  }, [config.variant]);\n\n  const getCurrentGradient = useCallback(() => {\n    const variant = themeVariants[config.variant] || themeVariants.default;\n    return variant.gradient;\n  }, [config.variant]);\n\n  const applyThemeToDOM = useCallback(() => {\n    if (!mounted) return;\n    \n    const root = document.documentElement;\n    const colors = getCurrentColors();\n    const gradient = getCurrentGradient();\n    const styleConfig = themeStyles[config.style] || themeStyles.modern;\n    \n    // Apply CSS custom properties\n    root.style.setProperty('--theme-primary', colors.primary);\n    root.style.setProperty('--theme-secondary', colors.secondary);\n    root.style.setProperty('--theme-accent', colors.accent);\n    root.style.setProperty('--theme-gradient', gradient);\n    root.style.setProperty('--theme-border-radius', styleConfig.borderRadius);\n    \n    // Apply theme variant class\n    root.classList.remove('theme-default', 'theme-purple', 'theme-blue', 'theme-green', 'theme-orange', 'theme-pink', 'theme-red');\n    root.classList.add(`theme-${config.variant}`);\n    \n    // Apply theme style class\n    root.classList.remove('style-modern', 'style-classic', 'style-minimal', 'style-vibrant');\n    root.classList.add(`style-${config.style}`);\n  }, [mounted, config, getCurrentColors, getCurrentGradient]);\n\n  const triggerHapticFeedback = useCallback(async () => {\n    try {\n      await Haptics.impact({ style: ImpactStyle.Light });\n    } catch (error) {\n      // Haptics not available on this platform\n      console.debug('Haptic feedback not available:', error);\n    }\n  }, []);\n\n  const enableScheduledMode = useCallback((lightStart: string, darkStart: string) => {\n    setConfig({\n      autoSchedule: {\n        enabled: true,\n        lightModeStart: lightStart,\n        darkModeStart: darkStart\n      }\n    });\n  }, [setConfig]);\n\n  const disableScheduledMode = useCallback(() => {\n    setConfig({\n      autoSchedule: {\n        ...config.autoSchedule,\n        enabled: false\n      }\n    });\n    setIsScheduledModeActive(false);\n  }, [setConfig, config.autoSchedule]);\n\n  // Apply theme changes when mounted or config changes\n  useEffect(() => {\n    if (mounted) {\n      applyThemeToDOM();\n    }\n  }, [mounted, config, applyThemeToDOM]);\n\n  return {\n    // Basic theme functionality\n    mode,\n    resolvedTheme,\n    setMode,\n    systemTheme,\n    themes,\n    isSystemMode: mode === 'system',\n    isDark: mounted ? resolvedTheme === 'dark' : false,\n    isLight: mounted ? resolvedTheme === 'light' : false,\n    toggleMode,\n    \n    // Enhanced theme functionality\n    config,\n    variant: config.variant,\n    style: config.style,\n    setVariant,\n    setStyle,\n    setConfig,\n    \n    // Utility functions\n    getCurrentColors,\n    getCurrentGradient,\n    applyThemeToDOM,\n    \n    // Mobile features\n    triggerHapticFeedback,\n    \n    // Scheduled themes\n    isScheduledModeActive,\n    enableScheduledMode,\n    disableScheduledMode\n  };\n}\n\nexport default useEnhancedTheme;