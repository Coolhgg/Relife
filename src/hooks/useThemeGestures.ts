import { useEffect, useRef, useCallback } from 'react';\nimport { useEnhancedTheme } from './useEnhancedTheme';\n\ninterface SwipeGesture {\n  startX: number;\n  startY: number;\n  currentX: number;\n  currentY: number;\n  startTime: number;\n}\n\ninterface UseThemeGesturesOptions {\n  enabled?: boolean;\n  sensitivity?: number; // Minimum swipe distance\n  maxDuration?: number; // Maximum swipe duration in ms\n  excludeSelectors?: string[]; // CSS selectors to exclude from gestures\n}\n\nconst defaultOptions: UseThemeGesturesOptions = {\n  enabled: true,\n  sensitivity: 50,\n  maxDuration: 500,\n  excludeSelectors: ['input', 'textarea', 'select', '[data-no-swipe]']\n};\n\n/**\n * Hook for mobile gesture-based theme switching\n * Supports:\n * - Horizontal swipe (left/right) for theme mode toggle\n * - Vertical swipe (up/down) for theme variant cycle\n * - Long press for theme customizer\n */\nexport function useThemeGestures(options: UseThemeGesturesOptions = {}) {\n  const config = { ...defaultOptions, ...options };\n  const { toggleMode, setVariant, variant, triggerHapticFeedback } = useEnhancedTheme();\n  const gestureRef = useRef<SwipeGesture | null>(null);\n  const longPressTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const isGestureActiveRef = useRef(false);\n\n  const isElementExcluded = useCallback((element: Element): boolean => {\n    if (!config.excludeSelectors) return false;\n    \n    return config.excludeSelectors.some(selector => {\n      try {\n        return element.matches(selector) || element.closest(selector);\n      } catch {\n        return false;\n      }\n    });\n  }, [config.excludeSelectors]);\n\n  const getNextVariant = useCallback(() => {\n    const variants = ['default', 'purple', 'blue', 'green', 'orange', 'pink', 'red'];\n    const currentIndex = variants.indexOf(variant);\n    const nextIndex = (currentIndex + 1) % variants.length;\n    return variants[nextIndex] as any;\n  }, [variant]);\n\n  const getPrevVariant = useCallback(() => {\n    const variants = ['default', 'purple', 'blue', 'green', 'orange', 'pink', 'red'];\n    const currentIndex = variants.indexOf(variant);\n    const prevIndex = (currentIndex - 1 + variants.length) % variants.length;\n    return variants[prevIndex] as any;\n  }, [variant]);\n\n  const handleTouchStart = useCallback((e: TouchEvent) => {\n    if (!config.enabled) return;\n    \n    const target = e.target as Element;\n    if (isElementExcluded(target)) return;\n\n    const touch = e.touches[0];\n    if (!touch) return;\n\n    gestureRef.current = {\n      startX: touch.clientX,\n      startY: touch.clientY,\n      currentX: touch.clientX,\n      currentY: touch.clientY,\n      startTime: Date.now()\n    };\n\n    isGestureActiveRef.current = true;\n\n    // Start long press detection\n    longPressTimeoutRef.current = setTimeout(() => {\n      if (isGestureActiveRef.current) {\n        triggerHapticFeedback();\n        // Dispatch custom event for long press (can be used to open theme customizer)\n        const event = new CustomEvent('theme-long-press', {\n          detail: { x: touch.clientX, y: touch.clientY }\n        });\n        window.dispatchEvent(event);\n      }\n    }, 500);\n  }, [config.enabled, isElementExcluded, triggerHapticFeedback]);\n\n  const handleTouchMove = useCallback((e: TouchEvent) => {\n    if (!config.enabled || !gestureRef.current) return;\n\n    const touch = e.touches[0];\n    if (!touch) return;\n\n    gestureRef.current.currentX = touch.clientX;\n    gestureRef.current.currentY = touch.clientY;\n\n    // Clear long press if user moves too much\n    const deltaX = Math.abs(touch.clientX - gestureRef.current.startX);\n    const deltaY = Math.abs(touch.clientY - gestureRef.current.startY);\n    \n    if ((deltaX > 20 || deltaY > 20) && longPressTimeoutRef.current) {\n      clearTimeout(longPressTimeoutRef.current);\n      longPressTimeoutRef.current = null;\n    }\n  }, [config.enabled]);\n\n  const handleTouchEnd = useCallback(() => {\n    if (!config.enabled || !gestureRef.current) return;\n\n    const gesture = gestureRef.current;\n    const deltaX = gesture.currentX - gesture.startX;\n    const deltaY = gesture.currentY - gesture.startY;\n    const deltaTime = Date.now() - gesture.startTime;\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n\n    isGestureActiveRef.current = false;\n    \n    // Clear long press timeout\n    if (longPressTimeoutRef.current) {\n      clearTimeout(longPressTimeoutRef.current);\n      longPressTimeoutRef.current = null;\n    }\n\n    // Check if it's a valid swipe\n    if (distance < (config.sensitivity || 50) || deltaTime > (config.maxDuration || 500)) {\n      gestureRef.current = null;\n      return;\n    }\n\n    const isHorizontal = Math.abs(deltaX) > Math.abs(deltaY);\n    const isVertical = Math.abs(deltaY) > Math.abs(deltaX);\n\n    if (isHorizontal) {\n      // Horizontal swipe: toggle theme mode\n      if (Math.abs(deltaX) > (config.sensitivity || 50)) {\n        toggleMode();\n        triggerHapticFeedback();\n        \n        // Dispatch custom event\n        const event = new CustomEvent('theme-horizontal-swipe', {\n          detail: { direction: deltaX > 0 ? 'right' : 'left' }\n        });\n        window.dispatchEvent(event);\n      }\n    } else if (isVertical) {\n      // Vertical swipe: cycle theme variants\n      if (Math.abs(deltaY) > (config.sensitivity || 50)) {\n        const newVariant = deltaY < 0 ? getNextVariant() : getPrevVariant();\n        setVariant(newVariant);\n        triggerHapticFeedback();\n        \n        // Dispatch custom event\n        const event = new CustomEvent('theme-vertical-swipe', {\n          detail: { \n            direction: deltaY < 0 ? 'up' : 'down',\n            variant: newVariant\n          }\n        });\n        window.dispatchEvent(event);\n      }\n    }\n\n    gestureRef.current = null;\n  }, [config.enabled, config.sensitivity, config.maxDuration, toggleMode, setVariant, getNextVariant, getPrevVariant, triggerHapticFeedback]);\n\n  // Add touch event listeners\n  useEffect(() => {\n    if (!config.enabled) return;\n\n    const options = { passive: false };\n    \n    document.addEventListener('touchstart', handleTouchStart, options);\n    document.addEventListener('touchmove', handleTouchMove, options);\n    document.addEventListener('touchend', handleTouchEnd, options);\n    document.addEventListener('touchcancel', handleTouchEnd, options);\n\n    return () => {\n      document.removeEventListener('touchstart', handleTouchStart);\n      document.removeEventListener('touchmove', handleTouchMove);\n      document.removeEventListener('touchend', handleTouchEnd);\n      document.removeEventListener('touchcancel', handleTouchEnd);\n      \n      // Clear timeout on cleanup\n      if (longPressTimeoutRef.current) {\n        clearTimeout(longPressTimeoutRef.current);\n      }\n    };\n  }, [config.enabled, handleTouchStart, handleTouchMove, handleTouchEnd]);\n\n  // Return utility functions for manual gesture handling\n  return {\n    isGestureActive: isGestureActiveRef.current,\n    triggerThemeToggle: () => {\n      toggleMode();\n      triggerHapticFeedback();\n    },\n    triggerVariantCycle: (direction: 'next' | 'prev' = 'next') => {\n      const newVariant = direction === 'next' ? getNextVariant() : getPrevVariant();\n      setVariant(newVariant);\n      triggerHapticFeedback();\n    }\n  };\n}\n\nexport default useThemeGestures;