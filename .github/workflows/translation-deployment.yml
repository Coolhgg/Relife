# Translation Deployment Pipeline
# Automated deployment of translation updates to staging and production environments

name: ğŸš€ Translation Deployment

on:
  push:
    branches: [main]
    paths:
      - "public/locales/**/*.json"
      - "src/locales/**/*.json"
      - "locales/**/*.json"
  pull_request:
    branches: [main]
    types: [closed]
    paths:
      - "public/locales/**/*.json"
      - "src/locales/**/*.json"
      - "locales/**/*.json"
  workflow_dispatch:
    inputs:
      environment:
        description: "Target environment"
        required: true
        default: "staging"
        type: choice
        options:
          - "staging"
          - "production"
          - "both"
      validation_level:
        description: "Translation validation level"
        required: false
        default: "standard"
        type: choice
        options:
          - "basic"
          - "standard"
          - "strict"
      skip_validation:
        description: "Skip translation validation (emergency deploys only)"
        required: false
        default: false
        type: boolean
      force_deploy:
        description: "Force deployment even if validation fails"
        required: false
        default: false
        type: boolean
      enable_rollback:
        description: "Enable automatic rollback on failure"
        required: false
        default: true
        type: boolean

permissions:
  contents: read
  pull-requests: write
  issues: write
  actions: read
  checks: write

env:
  NODE_VERSION: "20"
  MIN_QUALITY_SCORE: 75
  DEPLOYMENT_TIMEOUT: 300
  CACHE_VERSION: "1"

jobs:
  # Detect translation changes and determine deployment strategy
  detect-changes:
    name: ğŸ” Detect Translation Changes
    runs-on: ubuntu-latest

    outputs:
      should-deploy: ${{ steps.changes.outputs.should-deploy }}
      changed-languages: ${{ steps.changes.outputs.changed-languages }}
      deployment-strategy: ${{ steps.strategy.outputs.strategy }}
      target-environment: ${{ steps.strategy.outputs.target-environment }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 10

      - name: Detect translation changes
        id: changes
        run: |
          echo "ğŸ” Detecting translation changes..."

          # Get changed files
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            # Manual deployment - deploy all translations
            SHOULD_DEPLOY="true"
            CHANGED_LANGUAGES='["all"]'
            echo "Manual deployment triggered"
          elif [[ "${{ github.event_name }}" == "pull_request" && "${{ github.event.pull_request.merged }}" == "true" ]]; then
            # Merged PR - check for translation changes
            CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }}...${{ github.sha }} | grep -E '\.(json)$' | grep -E '(locales|translations)' || true)
            
            if [[ -n "$CHANGED_FILES" ]]; then
              SHOULD_DEPLOY="true"
              CHANGED_LANGUAGES=$(echo "$CHANGED_FILES" | grep -oE '/([a-z]{2}(-[A-Z]{2})?)/[^/]+\.json' | grep -oE '[a-z]{2}(-[A-Z]{2})?' | sort -u | jq -R -s -c 'split("\n") | map(select(length > 0))')
              echo "PR merged with translation changes"
            else
              SHOULD_DEPLOY="false"
              CHANGED_LANGUAGES='[]'
              echo "PR merged but no translation changes"
            fi
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            # Direct push to main - check for changes
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | grep -E '\.(json)$' | grep -E '(locales|translations)' || true)
            
            if [[ -n "$CHANGED_FILES" ]]; then
              SHOULD_DEPLOY="true"
              CHANGED_LANGUAGES=$(echo "$CHANGED_FILES" | grep -oE '/([a-z]{2}(-[A-Z]{2})?)/[^/]+\.json' | grep -oE '[a-z]{2}(-[A-Z]{2})?' | sort -u | jq -R -s -c 'split("\n") | map(select(length > 0))')
              echo "Direct push with translation changes"
            else
              SHOULD_DEPLOY="false"
              CHANGED_LANGUAGES='[]'
              echo "Push without translation changes"
            fi
          else
            SHOULD_DEPLOY="false"
            CHANGED_LANGUAGES='[]'
            echo "No deployment trigger conditions met"
          fi

          echo "should-deploy=$SHOULD_DEPLOY" >> $GITHUB_OUTPUT
          echo "changed-languages=$CHANGED_LANGUAGES" >> $GITHUB_OUTPUT

          echo "Should deploy: $SHOULD_DEPLOY"
          echo "Changed languages: $CHANGED_LANGUAGES"

      - name: Determine deployment strategy
        id: strategy
        run: |
          echo "ğŸ¯ Determining deployment strategy..."

          # Determine target environment
          if [[ "${{ github.event.inputs.environment }}" != "" ]]; then
            TARGET_ENV="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            TARGET_ENV="production"
          else
            TARGET_ENV="staging"
          fi

          # Determine deployment strategy
          CHANGED_LANGS='${{ steps.changes.outputs.changed-languages }}'
          LANG_COUNT=$(echo "$CHANGED_LANGS" | jq 'length')

          if [[ "$LANG_COUNT" -gt "10" || "$CHANGED_LANGS" == '["all"]' ]]; then
            STRATEGY="full-deployment"
          elif [[ "$LANG_COUNT" -gt "3" ]]; then
            STRATEGY="batch-deployment"
          else
            STRATEGY="incremental-deployment"
          fi

          echo "target-environment=$TARGET_ENV" >> $GITHUB_OUTPUT
          echo "strategy=$STRATEGY" >> $GITHUB_OUTPUT

          echo "Target environment: $TARGET_ENV"
          echo "Deployment strategy: $STRATEGY"

  # Pre-deployment validation
  pre-deployment-validation:
    name: âœ… Pre-deployment Validation
    runs-on: ubuntu-latest
    needs: detect-changes
    if: needs.detect-changes.outputs.should-deploy == 'true' && github.event.inputs.skip_validation != 'true'

    outputs:
      validation-passed: ${{ steps.validate.outputs.passed }}
      validation-score: ${{ steps.validate.outputs.score }}
      critical-issues: ${{ steps.validate.outputs.critical-issues }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          node-version: ${{ env.NODE_VERSION }}
          

      - name: Install dependencies
        run: bun install --production=false

      - name: Run comprehensive validation
        id: validate
        run: |
          echo "âœ… Running pre-deployment translation validation..."

          VALIDATION_LEVEL="${{ github.event.inputs.validation_level || 'standard' }}"
          CHANGED_LANGUAGES='${{ needs.detect-changes.outputs.changed-languages }}'
          MIN_SCORE="${{ env.MIN_QUALITY_SCORE }}"

          # Run validation with appropriate level
          case "$VALIDATION_LEVEL" in
            "strict")
              MIN_SCORE=85
              EXTRA_FLAGS="--cultural-strict --consistency-strict"
              ;;
            "basic")
              MIN_SCORE=60
              EXTRA_FLAGS="--quick-check"
              ;;
            *)
              MIN_SCORE=75
              EXTRA_FLAGS=""
              ;;
          esac

          echo "Validation level: $VALIDATION_LEVEL (min score: $MIN_SCORE)"

          # Run advanced validation
          if [[ "$CHANGED_LANGUAGES" == '["all"]' ]]; then
            node scripts/advanced-translation-manager.mjs analyze --format=json --output=validation-results.json $EXTRA_FLAGS
          else
            # Validate only changed languages
            LANG_LIST=$(echo "$CHANGED_LANGUAGES" | jq -r '.[]' | tr '\n' ',' | sed 's/,$//')
            node scripts/advanced-translation-manager.mjs analyze --languages="$LANG_LIST" --format=json --output=validation-results.json $EXTRA_FLAGS
          fi

          # Analyze validation results
          node -e "
            const fs = require('fs');
            
            try {
              const results = JSON.parse(fs.readFileSync('validation-results.json', 'utf8'));
              const languages = Object.entries(results.languages || {});
              const minScore = parseInt('$MIN_SCORE');
              
              let totalScore = 0;
              let criticalIssues = 0;
              let failedLanguages = [];
              
              console.log('ğŸ“Š Validation Results:');
              console.log('======================');
              
              languages.forEach(([lang, data]) => {
                const score = Math.round(data.qualityScore?.overall || 0);
                totalScore += score;
                
                console.log(\`\${lang}: \${score}% quality\`);
                
                if (score < minScore) {
                  failedLanguages.push({ lang, score });
                  console.log(\`âŒ \${lang} failed validation (\${score}% < \${minScore}%)\`);
                }
                
                // Count critical cultural issues
                const cultural = data.culturalIssues?.filter(issue => issue.severity === 'critical').length || 0;
                criticalIssues += cultural;
                
                if (cultural > 0) {
                  console.log(\`âš ï¸ \${lang} has \${cultural} critical cultural issues\`);
                }
              });
              
              const averageScore = languages.length > 0 ? Math.round(totalScore / languages.length) : 0;
              
              console.log('');
              console.log(\`Average Score: \${averageScore}%\`);
              console.log(\`Failed Languages: \${failedLanguages.length}\`);
              console.log(\`Critical Issues: \${criticalIssues}\`);
              
              // Determine if validation passed
              const validationPassed = failedLanguages.length === 0 && criticalIssues === 0;
              
              // Set outputs
              process.stdout.write('passed=' + validationPassed + '\n');
              process.stdout.write('score=' + averageScore + '\n');
              process.stdout.write('critical-issues=' + criticalIssues + '\n');
              
              if (validationPassed) {
                console.log('âœ… All validations passed - ready for deployment');
              } else {
                console.log('âŒ Validation failed - deployment blocked');
                if ('${{ github.event.inputs.force_deploy }}' !== 'true') {
                  process.exit(1);
                } else {
                  console.log('âš ï¸ Force deploy enabled - proceeding despite validation failures');
                }
              }
              
            } catch (error) {
              console.error('Validation error:', error.message);
              process.stdout.write('passed=false' + '\n');
              process.stdout.write('score=0' + '\n');
              process.stdout.write('critical-issues=999' + '\n');
              process.exit(1);
            }
          " >> $GITHUB_OUTPUT

      - name: Upload validation results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: deployment-validation-results
          path: validation-results.json
          retention-days: 30

  # Build and prepare translations
  build-translations:
    name: ğŸ”¨ Build Translations
    runs-on: ubuntu-latest
    needs: [detect-changes, pre-deployment-validation]
    if: always() && needs.detect-changes.outputs.should-deploy == 'true' && (needs.pre-deployment-validation.result == 'success' || needs.pre-deployment-validation.result == 'skipped' || github.event.inputs.force_deploy == 'true')

    outputs:
      build-version: ${{ steps.build.outputs.version }}
      translation-hash: ${{ steps.build.outputs.hash }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          node-version: ${{ env.NODE_VERSION }}
          

      - name: Install dependencies
        run: bun install --production=false

      - name: Build translations
        id: build
        run: |
          echo "ğŸ”¨ Building translations for deployment..."

          # Create build directory
          mkdir -p dist/translations
          mkdir -p dist/translations/optimized

          # Generate build version
          BUILD_VERSION=$(date +%Y%m%d_%H%M%S)
          TRANSLATION_HASH=$(find public/locales src/locales locales -name "*.json" -type f -exec sha256sum {} \; 2>/dev/null | sha256sum | cut -d' ' -f1 | head -c 8)

          echo "Build version: $BUILD_VERSION"
          echo "Translation hash: $TRANSLATION_HASH"

          # Copy translation files
          if [[ -d "public/locales" ]]; then
            cp -r public/locales/* dist/translations/ 2>/dev/null || true
          fi

          if [[ -d "src/locales" ]]; then
            cp -r src/locales/* dist/translations/ 2>/dev/null || true
          fi

          if [[ -d "locales" ]]; then
            cp -r locales/* dist/translations/ 2>/dev/null || true
          fi

          # Optimize translations (minify JSON)
          echo "ğŸ—œï¸ Optimizing translation files..."

          find dist/translations -name "*.json" -type f | while read -r file; do
            if [[ -s "$file" ]]; then
              # Minify JSON
              jq -c '.' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
              
              # Create optimized version with compression info
              cp "$file" "dist/translations/optimized/$(basename "$file")"
            fi
          done

          # Generate translation manifest
          node -e "
            const fs = require('fs');
            const path = require('path');
            const crypto = require('crypto');
            
            const manifest = {
              version: '$BUILD_VERSION',
              hash: '$TRANSLATION_HASH',
              buildTime: new Date().toISOString(),
              languages: {},
              totalSize: 0
            };
            
            // Scan translation files
            function scanDirectory(dir) {
              if (!fs.existsSync(dir)) return;
              
              const items = fs.readdirSync(dir);
              items.forEach(item => {
                const fullPath = path.join(dir, item);
                const stat = fs.statSync(fullPath);
                
                if (stat.isDirectory()) {
                  const langCode = item;
                  const langPath = fullPath;
                  
                  const langFiles = fs.readdirSync(langPath).filter(f => f.endsWith('.json'));
                  let langSize = 0;
                  let langKeys = 0;
                  
                  langFiles.forEach(file => {
                    const filePath = path.join(langPath, file);
                    const fileSize = fs.statSync(filePath).size;
                    langSize += fileSize;
                    
                    try {
                      const content = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                      langKeys += Object.keys(content).length;
                    } catch (e) {
                      console.warn('Could not parse:', filePath);
                    }
                  });
                  
                  manifest.languages[langCode] = {
                    files: langFiles.length,
                    size: langSize,
                    keys: langKeys,
                    hash: crypto.createHash('md5').update(fs.readFileSync(path.join(langPath, langFiles[0] || 'common.json'), 'utf8')).digest('hex').substring(0, 8)
                  };
                  
                  manifest.totalSize += langSize;
                }
              });
            }
            
            scanDirectory('dist/translations');
            
            fs.writeFileSync('dist/translations/manifest.json', JSON.stringify(manifest, null, 2));
            console.log('Generated translation manifest:', Object.keys(manifest.languages).length, 'languages');
          "

          # Set outputs
          echo "version=$BUILD_VERSION" >> $GITHUB_OUTPUT
          echo "hash=$TRANSLATION_HASH" >> $GITHUB_OUTPUT

          echo "âœ… Translation build complete"

          # Display build summary
          echo ""
          echo "ğŸ“Š Build Summary:"
          echo "================="
          cat dist/translations/manifest.json | jq -r '
            "Build Version: " + .version,
            "Hash: " + .hash,
            "Languages: " + (.languages | keys | length | tostring),
            "Total Size: " + (.totalSize | tostring) + " bytes",
            "Build Time: " + .buildTime
          '

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: translation-build-${{ steps.build.outputs.version }}
          path: dist/translations/
          retention-days: 30

  # Deploy to staging
  deploy-staging:
    name: ğŸš€ Deploy to Staging
    runs-on: ubuntu-latest
    needs: [detect-changes, pre-deployment-validation, build-translations]
    if: always() && needs.detect-changes.outputs.should-deploy == 'true' && needs.build-translations.result == 'success' && (needs.detect-changes.outputs.target-environment == 'staging' || needs.detect-changes.outputs.target-environment == 'both')

    environment:
      name: staging-translations
      url: ${{ steps.deploy.outputs.staging-url }}

    outputs:
      deployment-status: ${{ steps.deploy.outputs.status }}
      staging-url: ${{ steps.deploy.outputs.staging-url }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          name: translation-build-${{ needs.build-translations.outputs.build-version }}
          path: dist/translations/

      - name: Deploy to staging
        id: deploy
        run: |
          echo "ğŸš€ Deploying translations to staging environment..."

          BUILD_VERSION="${{ needs.build-translations.outputs.build-version }}"
          TRANSLATION_HASH="${{ needs.build-translations.outputs.translation-hash }}"

          # Simulate staging deployment (replace with actual deployment logic)
          echo "Deploying build version: $BUILD_VERSION"
          echo "Translation hash: $TRANSLATION_HASH"

          # In a real scenario, this would:
          # 1. Upload to staging server
          # 2. Update CDN with new translations
          # 3. Invalidate caches
          # 4. Run staging health checks

          # For demonstration, we'll simulate deployment steps
          sleep 5

          echo "âœ… Staging deployment completed successfully"

          # Set outputs
          STAGING_URL="https://staging.relife.example.com"
          echo "status=success" >> $GITHUB_OUTPUT
          echo "staging-url=$STAGING_URL" >> $GITHUB_OUTPUT

          echo "Staging URL: $STAGING_URL"

      - name: Run staging health checks
        run: |
          echo "ğŸ” Running staging health checks..."

          # Check if translations are accessible
          # In production, this would make actual HTTP requests
          echo "âœ… Translation files accessible"
          echo "âœ… Manifest file valid"
          echo "âœ… All language endpoints responding"

          echo "ğŸ‰ Staging health checks passed"

      - name: Notify staging deployment
        if: success()
        run: |
          echo "ğŸ“¢ Staging deployment notification sent"
          echo "Build: ${{ needs.build-translations.outputs.build-version }}"
          echo "URL: ${{ steps.deploy.outputs.staging-url }}"

  # Deploy to production
  deploy-production:
    name: ğŸŒ Deploy to Production
    runs-on: ubuntu-latest
    needs:
      [detect-changes, pre-deployment-validation, build-translations, deploy-staging]
    if: always() && needs.detect-changes.outputs.should-deploy == 'true' && needs.build-translations.result == 'success' && (needs.detect-changes.outputs.target-environment == 'production' || needs.detect-changes.outputs.target-environment == 'both') && (needs.deploy-staging.result == 'success' || needs.deploy-staging.result == 'skipped')

    environment:
      name: production-translations
      url: ${{ steps.deploy.outputs.production-url }}

    outputs:
      deployment-status: ${{ steps.deploy.outputs.status }}
      production-url: ${{ steps.deploy.outputs.production-url }}
      rollback-version: ${{ steps.prepare.outputs.rollback-version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          name: translation-build-${{ needs.build-translations.outputs.build-version }}
          path: dist/translations/

      - name: Prepare production deployment
        id: prepare
        run: |
          echo "ğŸ¯ Preparing production deployment..."

          # Backup current production translations for rollback
          ROLLBACK_VERSION=$(date +%Y%m%d_%H%M%S)_rollback

          # In production, this would backup current translations
          echo "Created rollback point: $ROLLBACK_VERSION"
          echo "rollback-version=$ROLLBACK_VERSION" >> $GITHUB_OUTPUT

          # Pre-deployment checks
          echo "âœ… Rollback prepared"
          echo "âœ… Production environment ready"
          echo "âœ… CDN invalidation prepared"

      - name: Deploy to production
        id: deploy
        run: |
          echo "ğŸŒ Deploying translations to production..."

          BUILD_VERSION="${{ needs.build-translations.outputs.build-version }}"
          TRANSLATION_HASH="${{ needs.build-translations.outputs.translation-hash }}"
          STRATEGY="${{ needs.detect-changes.outputs.deployment-strategy }}"

          echo "Deployment strategy: $STRATEGY"
          echo "Build version: $BUILD_VERSION"

          # Production deployment simulation
          case "$STRATEGY" in
            "incremental-deployment")
              echo "ğŸ”„ Performing incremental deployment..."
              sleep 10
              ;;
            "batch-deployment")
              echo "ğŸ“¦ Performing batch deployment..."
              sleep 15
              ;;
            "full-deployment")
              echo "ğŸš€ Performing full deployment..."
              sleep 20
              ;;
          esac

          # In production, this would:
          # 1. Upload to production servers
          # 2. Update CDN with new translations
          # 3. Invalidate caches globally
          # 4. Update load balancer configuration
          # 5. Run production health checks

          echo "âœ… Production deployment completed"

          PRODUCTION_URL="https://relife.example.com"
          echo "status=success" >> $GITHUB_OUTPUT
          echo "production-url=$PRODUCTION_URL" >> $GITHUB_OUTPUT

      - name: Run production health checks
        id: health-check
        run: |
          echo "ğŸ¥ Running production health checks..."

          # Production health checks
          echo "Checking translation availability..."
          sleep 5

          # Simulate health check results
          HEALTH_STATUS="healthy"

          echo "âœ… All translation endpoints healthy"
          echo "âœ… CDN serving updated translations"
          echo "âœ… Cache invalidation successful"
          echo "âœ… Load balancer configuration updated"

          echo "ğŸ‰ Production health checks passed"
          echo "health-status=$HEALTH_STATUS" >> $GITHUB_OUTPUT

      - name: Post-deployment verification
        run: |
          echo "ğŸ” Running post-deployment verification..."

          # Verify specific languages if changed
          CHANGED_LANGUAGES='${{ needs.detect-changes.outputs.changed-languages }}'

          echo "Verifying changed languages: $CHANGED_LANGUAGES"

          # In production, this would verify each changed language
          echo "âœ… Translation files verified"
          echo "âœ… Manifest integrity confirmed"
          echo "âœ… All endpoints responding correctly"

          echo "ğŸ‰ Post-deployment verification completed"

  # Handle rollback if needed
  handle-rollback:
    name: ğŸ”„ Handle Rollback
    runs-on: ubuntu-latest
    needs: [detect-changes, build-translations, deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure') && github.event.inputs.enable_rollback != 'false'

    steps:
      - name: Determine rollback necessity
        id: check
        run: |
          STAGING_FAILED="${{ needs.deploy-staging.result }}" 
          PRODUCTION_FAILED="${{ needs.deploy-production.result }}"

          if [[ "$PRODUCTION_FAILED" == "failure" ]]; then
            echo "ğŸš¨ Production deployment failed - initiating rollback"
            echo "rollback-needed=true" >> $GITHUB_OUTPUT
            echo "rollback-scope=production" >> $GITHUB_OUTPUT
          elif [[ "$STAGING_FAILED" == "failure" ]]; then
            echo "âš ï¸ Staging deployment failed - no production impact"
            echo "rollback-needed=false" >> $GITHUB_OUTPUT
            echo "rollback-scope=staging" >> $GITHUB_OUTPUT
          else
            echo "â„¹ï¸ No rollback needed"
            echo "rollback-needed=false" >> $GITHUB_OUTPUT
            echo "rollback-scope=none" >> $GITHUB_OUTPUT
          fi

      - name: Execute rollback
        if: steps.check.outputs.rollback-needed == 'true'
        run: |
          echo "ğŸ”„ Executing production rollback..."

          ROLLBACK_VERSION="${{ needs.deploy-production.outputs.rollback-version }}"

          echo "Rolling back to version: $ROLLBACK_VERSION"

          # In production, this would:
          # 1. Restore previous translation files
          # 2. Revert CDN configuration
          # 3. Invalidate caches
          # 4. Restore load balancer settings
          # 5. Verify rollback health

          sleep 10

          echo "âœ… Rollback completed successfully"
          echo "ğŸ¥ Running post-rollback health checks..."

          # Verify rollback
          echo "âœ… Previous translations restored"
          echo "âœ… All endpoints healthy after rollback"

          echo "ğŸ‰ Rollback verification completed"

      - name: Create rollback notification
        if: steps.check.outputs.rollback-needed == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            const rollbackVersion = '${{ needs.deploy-production.outputs.rollback-version }}';
            const buildVersion = '${{ needs.build-translations.outputs.build-version }}';

            const title = 'ğŸš¨ Translation Deployment Rollback Executed';
            const body = `# ğŸš¨ Translation Deployment Rollback

            **Rollback Executed**: ${new Date().toLocaleString()}
            **Failed Build**: ${buildVersion}
            **Restored Version**: ${rollbackVersion}

            ## ğŸ“Š Rollback Details
            - **Scope**: Production environment
            - **Trigger**: Production deployment failure
            - **Status**: âœ… Completed successfully
            - **Health Check**: âœ… All systems healthy

            ## ğŸ” Next Steps
            1. Investigate deployment failure cause
            2. Fix identified issues
            3. Re-run translation validation
            4. Attempt deployment again

            ## ğŸ”— Resources
            - [Deployment Logs](${context.payload.repository.html_url}/actions/runs/${context.runId})
            - [Translation Guidelines](./TRANSLATION_GUIDELINES.md)
            - [Troubleshooting Guide](./docs/TRANSLATION_TROUBLESHOOTING.md)

            *Automated rollback notification from translation deployment system*`;

            // Create issue for rollback notification
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['translation', 'deployment', 'rollback', 'priority-high']
            });

  # Deployment summary and cleanup
  deployment-summary:
    name: ğŸ“‹ Deployment Summary
    runs-on: ubuntu-latest
    needs:
      [
        detect-changes,
        pre-deployment-validation,
        build-translations,
        deploy-staging,
        deploy-production,
        handle-rollback,
      ]
    if: always()

    steps:
      - name: Generate deployment summary
        run: |
          echo "ğŸ“‹ Translation Deployment Summary"
          echo "================================"
          echo "Timestamp: $(date)"
          echo "Trigger: ${{ github.event_name }}"
          echo ""
          echo "ğŸ¯ Deployment Configuration:"
          echo "- Strategy: ${{ needs.detect-changes.outputs.deployment-strategy }}"
          echo "- Target Environment: ${{ needs.detect-changes.outputs.target-environment }}"
          echo "- Changed Languages: ${{ needs.detect-changes.outputs.changed-languages }}"
          echo "- Build Version: ${{ needs.build-translations.outputs.build-version }}"
          echo ""
          echo "âœ… Job Results:"
          echo "- Change Detection: ${{ needs.detect-changes.result }}"
          echo "- Pre-deployment Validation: ${{ needs.pre-deployment-validation.result }}"
          echo "- Build Translations: ${{ needs.build-translations.result }}"
          echo "- Staging Deployment: ${{ needs.deploy-staging.result }}"
          echo "- Production Deployment: ${{ needs.deploy-production.result }}"
          echo "- Rollback Handling: ${{ needs.handle-rollback.result }}"
          echo ""
          echo "ğŸ”¢ Quality Metrics:"
          if [[ "${{ needs.pre-deployment-validation.result }}" == "success" ]]; then
            echo "- Validation Score: ${{ needs.pre-deployment-validation.outputs.validation-score }}%"
            echo "- Critical Issues: ${{ needs.pre-deployment-validation.outputs.critical-issues }}"
          else
            echo "- Validation: Skipped or Failed"
          fi
          echo ""
          echo "ğŸŒ Deployment URLs:"
          if [[ "${{ needs.deploy-staging.outputs.staging-url }}" != "" ]]; then
            echo "- Staging: ${{ needs.deploy-staging.outputs.staging-url }}"
          fi
          if [[ "${{ needs.deploy-production.outputs.production-url }}" != "" ]]; then
            echo "- Production: ${{ needs.deploy-production.outputs.production-url }}"
          fi
          echo ""

          # Final status determination
          if [[ "${{ needs.handle-rollback.result }}" == "success" && "${{ needs.handle-rollback.result }}" != "skipped" ]]; then
            echo "ğŸ”„ Status: Deployment failed but rollback successful"
            exit 1
          elif [[ "${{ needs.deploy-production.result }}" == "success" || "${{ needs.deploy-staging.result }}" == "success" ]]; then
            echo "ğŸ‰ Status: Deployment completed successfully"
            exit 0
          elif [[ "${{ needs.detect-changes.outputs.should-deploy }}" == "false" ]]; then
            echo "â„¹ï¸ Status: No deployment needed"
            exit 0
          else
            echo "âŒ Status: Deployment failed"
            exit 1
          fi
