[
  {
    "filePath": "/project/workspace/Coolhgg/Relife/scripts/setup-convertkit.js",
    "messages": [
      {
        "ruleId": "no-useless-catch",
        "severity": 2,
        "message": "Unnecessary try/catch wrapper.",
        "line": 129,
        "column": 5,
        "nodeType": "TryStatement",
        "messageId": "unnecessaryCatch",
        "endLine": 153,
        "endColumn": 6
      },
      {
        "ruleId": "no-useless-catch",
        "severity": 2,
        "message": "Unnecessary try/catch wrapper.",
        "line": 177,
        "column": 5,
        "nodeType": "TryStatement",
        "messageId": "unnecessaryCatch",
        "endLine": 211,
        "endColumn": 6
      },
      {
        "ruleId": "no-useless-catch",
        "severity": 2,
        "message": "Unnecessary try/catch wrapper.",
        "line": 238,
        "column": 5,
        "nodeType": "TryStatement",
        "messageId": "unnecessaryCatch",
        "endLine": 264,
        "endColumn": 6
      },
      {
        "ruleId": "no-useless-catch",
        "severity": 2,
        "message": "Unnecessary try/catch wrapper.",
        "line": 280,
        "column": 5,
        "nodeType": "TryStatement",
        "messageId": "unnecessaryCatch",
        "endLine": 309,
        "endColumn": 6
      },
      {
        "ruleId": "no-useless-catch",
        "severity": 2,
        "message": "Unnecessary try/catch wrapper.",
        "line": 397,
        "column": 5,
        "nodeType": "TryStatement",
        "messageId": "unnecessaryCatch",
        "endLine": 424,
        "endColumn": 6
      }
    ],
    "suppressedMessages": [],
    "errorCount": 5,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "#!/usr/bin/env node\n/**\n * ConvertKit Setup Script for Relife Email Campaigns\n * Automatically creates forms, sequences, and tags for all personas\n */\n\nimport { createRequire } from 'module';\n\n// Load configurations\nconst require = createRequire(import.meta.url);\nconst {\n  PERSONA_CONVERTKIT_CONFIG,\n  CONVERTKIT_FORM_TEMPLATES,\n  CONVERTKIT_SEQUENCE_TEMPLATES,\n} = require('../src/config/convertkit-config.ts');\n\nclass ConvertKitSetup {\n  constructor() {\n    this.apiKey = process.env.CONVERTKIT_API_KEY;\n    this.apiSecret = process.env.CONVERTKIT_API_SECRET;\n    this.baseUrl = 'https://api.convertkit.com/v3';\n\n    if (!this.apiKey || !this.apiSecret) {\n      console.error('‚ùå ConvertKit API credentials not found!');\n      console.log(\n        'Please set CONVERTKIT_API_KEY and CONVERTKIT_API_SECRET environment variables'\n      );\n      process.exit(1);\n    }\n  }\n\n  async setup() {\n    console.log('üöÄ Starting ConvertKit setup for Relife email campaigns...');\n\n    try {\n      // Test authentication first\n      const isAuthenticated = await this.testAuthentication();\n      if (!isAuthenticated) {\n        console.error('‚ùå Authentication failed. Please check your API credentials.');\n        process.exit(1);\n      }\n\n      console.log('‚úÖ ConvertKit authentication successful');\n\n      // Create persona tags\n      console.log('üìã Creating persona tags...');\n      await this.createPersonaTags();\n\n      // Create forms for each persona\n      console.log('\\nüìù Creating forms for each persona...');\n      const forms = await this.createPersonaForms();\n\n      console.log('Creating email sequences for each persona...');\n      const sequences = await this.createPersonaSequences();\n\n      console.log('Generating configuration file...');\n      await this.generateConfigFile(forms, sequences);\n\n      // Setup webhooks\n      console.log('Setting up webhooks...');\n      await this.setupWebhooks();\n\n      console.log('ConvertKit setup completed successfully!');\n      console.log('Setup Summary:');\n      console.log(`   ‚Ä¢ Created ${Object.keys(sequences).length} sequences`);\n      console.log(`   ‚Ä¢ Configured 6 persona tags`);\n      console.log(`   ‚Ä¢ Set up webhook endpoints`);\n      console.log('Configuration saved to: src/config/convertkit-generated.ts');\n    } catch (error) {\n      console.error('‚ùå Setup failed:', error.message);\n      process.exit(1);\n    }\n  }\n\n  async testAuthentication() {\n    try {\n      const response = await fetch(\n        `${this.baseUrl}/account?api_secret=${this.apiSecret}`,\n        {\n          method: 'GET',\n          headers: { 'Content-Type': 'application/json' },\n        }\n      );\n\n      if (response.ok) {\n        const data = await response.json();\n        console.log(\n          `‚úÖ Authenticated as: ${data.name} (Account ID: ${data.account_id})`\n        );\n        return true;\n      } else {\n        console.error(`‚ùå Auth failed: ${response.status} ${response.statusText}`);\n        return false;\n      }\n    } catch (error) {\n      console.error('‚ùå Auth error:', error.message);\n      return false;\n    }\n  }\n\n  async createPersonaTags() {\n    const personas = [\n      'struggling_sam',\n      'busy_ben',\n      'professional_paula',\n      'enterprise_emma',\n      'student_sarah',\n      'lifetime_larry',\n    ];\n    const createdTags = [];\n\n    for (const persona of personas) {\n      try {\n        const tagName = `persona:${persona}`;\n        const tag = await this.createTag(tagName);\n        if (tag) {\n          createdTags.push(tag);\n          console.log(`  ‚úÖ Created tag: ${tagName}`);\n        }\n      } catch (error) {\n        console.error(`  ‚ùå Failed to create tag for ${persona}:`, error.message);\n      }\n    }\n\n    return createdTags;\n  }\n\n  async createTag(name) {\n    try {\n      const response = await fetch(`${this.baseUrl}/tags`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          api_key: this.apiKey,\n          tag: { name: name },\n        }),\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        return data.tag;\n      } else {\n        // Tag might already exist, that's ok\n        const error = await response.json();\n        if (error.message && error.message.includes('already exists')) {\n          console.log(`  ‚ÑπÔ∏è  Tag already exists: ${name}`);\n          return { id: null, name: name };\n        }\n        throw new Error(`Failed to create tag: ${error.message}`);\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async createPersonaForms() {\n    const personas = Object.keys(CONVERTKIT_FORM_TEMPLATES);\n    const createdForms = {};\n\n    for (const persona of personas) {\n      try {\n        const template = CONVERTKIT_FORM_TEMPLATES[persona];\n        const form = await this.createForm(template);\n        if (form) {\n          createdForms[persona] = form;\n          console.log(`  ‚úÖ Created form: ${template.name} (ID: ${form.id})`);\n        }\n      } catch (error) {\n        console.error(`  ‚ùå Failed to create form for ${persona}:`, error.message);\n      }\n    }\n\n    return createdForms;\n  }\n\n  async createForm(template) {\n    try {\n      const formData = {\n        api_key: this.apiKey,\n        form: {\n          name: template.name,\n          description: template.description,\n          sign_up_redirect_url: template.redirectUrl || '',\n          success_message: template.successMessage,\n          format: 'modal', // or 'inline', 'slide_in'\n          background_color: '#ffffff',\n          text_color: '#333333',\n          button_color: '#007cba',\n          button_text: 'Subscribe',\n          archived: false,\n        },\n      };\n\n      const response = await fetch(`${this.baseUrl}/forms`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(formData),\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        return data.form;\n      } else {\n        const error = await response.json();\n        throw new Error(\n          `Failed to create form: ${error.message || response.statusText}`\n        );\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async createPersonaSequences() {\n    const personas = Object.keys(CONVERTKIT_SEQUENCE_TEMPLATES);\n    const createdSequences = {};\n\n    for (const persona of personas) {\n      try {\n        const template = CONVERTKIT_SEQUENCE_TEMPLATES[persona];\n        const sequence = await this.createSequence(template);\n        if (sequence) {\n          createdSequences[persona] = sequence;\n          console.log(`  ‚úÖ Created sequence: ${template.name} (ID: ${sequence.id})`);\n\n          // Add emails to sequence\n          await this.addEmailsToSequence(sequence.id, template.emails);\n        }\n      } catch (error) {\n        console.error(`  ‚ùå Failed to create sequence for ${persona}:`, error.message);\n      }\n    }\n\n    return createdSequences;\n  }\n\n  async createSequence(template) {\n    try {\n      const sequenceData = {\n        api_secret: this.apiSecret,\n        course: {\n          name: template.name,\n          description: template.description,\n        },\n      };\n\n      const response = await fetch(`${this.baseUrl}/courses`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(sequenceData),\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        return data.course;\n      } else {\n        const error = await response.json();\n        throw new Error(\n          `Failed to create sequence: ${error.message || response.statusText}`\n        );\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async addEmailsToSequence(sequenceId, emails) {\n    for (let i = 0; i < emails.length; i++) {\n      try {\n        const email = emails[i];\n        await this.createSequenceEmail(sequenceId, email, i + 1);\n        console.log(`    ‚ûï Added email ${i + 1}: ${email.subject}`);\n      } catch (error) {\n        console.error(`    ‚ùå Failed to add email ${i + 1}:`, error.message);\n      }\n    }\n  }\n\n  async createSequenceEmail(sequenceId, emailTemplate, position) {\n    try {\n      const emailData = {\n        api_secret: this.apiSecret,\n        email: {\n          subject: emailTemplate.subject,\n          content: this.generateEmailContent(emailTemplate),\n          delay: emailTemplate.delayHours * 60, // Convert hours to minutes\n          position: position,\n          public: false,\n        },\n      };\n\n      const response = await fetch(`${this.baseUrl}/courses/${sequenceId}/emails`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(emailData),\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        return data.email;\n      } else {\n        const error = await response.json();\n        throw new Error(\n          `Failed to create email: ${error.message || response.statusText}`\n        );\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  generateEmailContent(emailTemplate) {\n    // Generate basic HTML content\n    let content = `\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>${emailTemplate.subject}</title>\n    <style>\n        body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }\n        .container { max-width: 600px; margin: 0 auto; padding: 20px; }\n        .header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; text-align: center; padding: 20px; border-radius: 8px 8px 0 0; }\n        .content { background: #ffffff; padding: 30px; border: 1px solid #ddd; }\n        .cta-button { display: inline-block; background: #007cba; color: white; padding: 12px 24px; text-decoration: none; border-radius: 4px; margin: 20px 0; }\n        .footer { background: #f8f9fa; padding: 20px; text-align: center; font-size: 12px; color: #666; border-radius: 0 0 8px 8px; }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"header\">\n            <h1>Relife</h1>\n            <p>Your Personal Productivity Assistant</p>\n        </div>\n        <div class=\"content\">\n            <h2>${emailTemplate.subject}</h2>\n            <p>Hi {{first_name | default: \"there\"}},</p>\n\n            <p>This is a placeholder email content for: <strong>${emailTemplate.content}</strong></p>\n\n            <p>This email sequence is designed to help you get the most out of Relife based on your specific needs and goals.</p>`;\n\n    if (emailTemplate.ctaButton) {\n      content += `\n            <p style=\"text-align: center;\">\n                <a href=\"${emailTemplate.ctaButton.url}\" class=\"cta-button\" style=\"background-color: ${emailTemplate.ctaButton.color};\">\n                    ${emailTemplate.ctaButton.text}\n                </a>\n            </p>`;\n    }\n\n    content += `\n            <p>Best regards,<br>\n            The Relife Team</p>\n        </div>\n        <div class=\"footer\">\n            <p>You're receiving this because you signed up for Relife updates.</p>\n            <p><a href=\"{{unsubscribe_url}}\">Unsubscribe</a> | <a href=\"{{manage_preferences_url}}\">Manage Preferences</a></p>\n            <p>&copy; 2024 Relife. All rights reserved.</p>\n        </div>\n    </div>\n</body>\n</html>`;\n\n    return content;\n  }\n\n  async setupWebhooks() {\n    try {\n      const webhookUrl =\n        process.env.RELIFE_WEBHOOK_URL || 'https://relife.app/api/webhooks/convertkit';\n\n      const events = [\n        'subscriber.subscriber_activate',\n        'subscriber.subscriber_unsubscribe',\n        'subscriber.tag_add',\n        'subscriber.form_subscribe',\n      ];\n\n      for (const event of events) {\n        try {\n          const webhook = await this.createWebhook(webhookUrl, event);\n          if (webhook) {\n            console.log(`  ‚úÖ Created webhook for: ${event}`);\n          }\n        } catch (error) {\n          console.error(`  ‚ùå Failed to create webhook for ${event}:`, error.message);\n        }\n      }\n    } catch (error) {\n      console.error('Failed to setup webhooks:', error.message);\n    }\n  }\n\n  async createWebhook(url, event) {\n    try {\n      const webhookData = {\n        api_secret: this.apiSecret,\n        webhook_url: url,\n        event: event,\n      };\n\n      const response = await fetch(`${this.baseUrl}/automations/hooks`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(webhookData),\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        return data.hook;\n      } else {\n        // Webhook might already exist, that's ok\n        const error = await response.json();\n        if (error.message && error.message.includes('already exists')) {\n          console.log(`  ‚ÑπÔ∏è  Webhook already exists for: ${event}`);\n          return { id: null, event: event };\n        }\n        throw new Error(`Failed to create webhook: ${error.message}`);\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async generateConfigFile(forms, sequences) {\n    const configContent = `// Auto-generated ConvertKit configuration\n// Generated on ${new Date().toISOString()}\n// DO NOT EDIT MANUALLY - Use scripts/setup-convertkit.js to regenerate\n\nimport { PersonaType } from '../types/email-campaigns';\n\nexport interface GeneratedConvertKitConfig {\n  forms: Record<PersonaType, { id: number; name: string }>;\n  sequences: Record<PersonaType, { id: number; name: string }>;\n  tags: Record<PersonaType, string>;\n  createdAt: string;\n}\n\nexport const CONVERTKIT_IDS = {\n  forms: {\n    // Generated forms configuration\n  },\n  sequences: {\n    // Generated sequences configuration\n  },\n  tags: {\n    struggling_sam: \"persona:struggling_sam\",\n    busy_ben: \"persona:busy_ben\",\n    professional_paula: \"persona:professional_paula\",\n    enterprise_emma: \"persona:enterprise_emma\",\n    student_sarah: \"persona:student_sarah\",\n    lifetime_larry: \"persona:lifetime_larry\"\n  },\n  createdAt: new Date().toISOString()\n};\n\n// Environment-specific URLs\nexport const WEBHOOK_URLS = {\n  production: \"https://relife.app/api/webhooks/convertkit\",\n  development: \"https://relife-dev.app/api/webhooks/convertkit\",\n  test: \"http://localhost:3000/api/webhooks/convertkit\"\n};\n\nexport default CONVERTKIT_IDS;`;\n\n    // Write the configuration file\n    const fs = require('fs');\n    const path = require('path');\n\n    const configPath = path.join(process.cwd(), 'src/config/convertkit-generated.ts');\n    fs.writeFileSync(configPath, configContent);\n\n    console.log(`‚úÖ Configuration file created: ${configPath}`);\n  }\n}\n\n// Run the setup if this script is called directly\nif (process.argv[1].endsWith('setup-convertkit.js')) {\n  const setup = new ConvertKitSetup();\n  setup.setup().catch(error => {\n    console.error('‚ùå Setup failed:', error);\n    process.exit(1);\n  });\n}\n\nexport default ConvertKitSetup;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/__tests__/providers/context-providers.tsx",
    "messages": [
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"useContext\" is called in function \"_useFeatureAccessTest\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 55,
        "column": 44,
        "nodeType": "Identifier",
        "endLine": 55,
        "endColumn": 54
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"useContext\" is called in function \"_useLanguageTest\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 141,
        "column": 39,
        "nodeType": "Identifier",
        "endLine": 141,
        "endColumn": 49
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"useContext\" is called in function \"_useAlarmTest\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 247,
        "column": 36,
        "nodeType": "Identifier",
        "endLine": 247,
        "endColumn": 46
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"useContext\" is called in function \"_useThemeTest\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 361,
        "column": 36,
        "nodeType": "Identifier",
        "endLine": 361,
        "endColumn": 46
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Context-Specific Test Providers\n *\n * Individual test providers for each application context with realistic mock implementations\n * and helper functions for testing context-dependent components.\n */\n\nimport React, { ReactNode, createContext, useContext } from 'react';\nimport { render, RenderOptions } from '@testing-library/react';\n\n// ===============================\n// FEATURE ACCESS CONTEXT\n// ===============================\n\nexport interface MockFeatureAccessContextValue {\n  hasAccess: jest.MockedFunction<(feature: string) => boolean>;\n  checkFeatureAccess: jest.MockedFunction<(feature: string, tier?: string) => boolean>;\n  isFeatureEnabled: jest.MockedFunction<(feature: string) => boolean>;\n  upgradeRequired: jest.MockedFunction<(feature: string) => boolean>;\n  getFeatureLimit: jest.MockedFunction<(feature: string) => number>;\n  getRemainingUsage: jest.MockedFunction<(feature: string) => number>;\n  trackFeatureUsage: jest.MockedFunction<(feature: string) => void>;\n  premiumFeatures: string[];\n  ultimateFeatures: string[];\n  currentTier: 'free' | 'premium' | 'ultimate';\n}\n\nconst defaultFeatureAccessValue: MockFeatureAccessContextValue = {\n  hasAccess: jest.fn(() => true),\n  checkFeatureAccess: jest.fn(() => true),\n  isFeatureEnabled: jest.fn(() => true),\n  upgradeRequired: jest.fn(() => false),\n  getFeatureLimit: jest.fn(() => 100),\n  getRemainingUsage: jest.fn(() => 50),\n  trackFeatureUsage: jest.fn(),\n  premiumFeatures: ['unlimited_alarms', 'custom_voices', 'themes', 'battle_mode'],\n  ultimateFeatures: ['ai_optimization', 'advanced_analytics', 'priority_support'],\n  currentTier: 'premium'\n};\n\nconst FeatureAccessTestContext = createContext<MockFeatureAccessContextValue>(defaultFeatureAccessValue);\n\nexport const FeatureAccessTestProvider: React.FC<{\n  children: ReactNode;\n  value?: Partial<MockFeatureAccessContextValue>;\n}> = ({ children, value = {} }) => {\n  const mockValue = { ...defaultFeatureAccessValue, ...value };\n  return (\n    <FeatureAccessTestContext.Provider value={mockValue}>\n      {children}\n    </FeatureAccessTestContext.Provider>\n  );\n};\n\nexport const _useFeatureAccessTest = () => useContext(FeatureAccessTestContext);\n\n// Feature Access Test Scenarios\nexport const _featureAccessScenarios = {\n  freeUser: {\n    hasAccess: jest.fn((feature: string) =>\n      ['basic_alarms', 'basic_themes'].includes(feature)\n    ),\n    upgradeRequired: jest.fn((feature: string) =>\n      !['basic_alarms', 'basic_themes'].includes(feature)\n    ),\n    currentTier: 'free' as const,\n    getFeatureLimit: jest.fn((feature: string) =>\n      feature === 'alarms' ? 5 : 0\n    )\n  },\n\n  premiumUser: {\n    hasAccess: jest.fn((feature: string) =>\n      !['ai_optimization', 'advanced_analytics'].includes(feature)\n    ),\n    upgradeRequired: jest.fn((feature: string) =>\n      ['ai_optimization', 'advanced_analytics'].includes(feature)\n    ),\n    currentTier: 'premium' as const,\n    getFeatureLimit: jest.fn(() => 100)\n  },\n\n  ultimateUser: {\n    hasAccess: jest.fn(() => true),\n    upgradeRequired: jest.fn(() => false),\n    currentTier: 'ultimate' as const,\n    getFeatureLimit: jest.fn(() => Infinity)\n  }\n};\n\n// ===============================\n// LANGUAGE CONTEXT\n// ===============================\n\nexport interface MockLanguageContextValue {\n  language: string;\n  setLanguage: jest.MockedFunction<(lang: string) => void>;\n  t: jest.MockedFunction<(key: string, options?: any) => string>;\n  dir: 'ltr' | 'rtl';\n  formatTime: jest.MockedFunction<(time: Date) => string>;\n  formatDate: jest.MockedFunction<(date: Date) => string>;\n  formatRelativeTime: jest.MockedFunction<(date: Date) => string>;\n  formatCurrency: jest.MockedFunction<(amount: number, currency?: string) => string>;\n  supportedLanguages: Array<{ code: string; name: string; rtl: boolean }>;\n  isLoading: boolean;\n  error: string | null;\n}\n\nconst defaultLanguageValue: MockLanguageContextValue = {\n  language: 'en',\n  setLanguage: jest.fn(),\n  t: jest.fn((key: string) => key.split('.').pop() || key),\n  dir: 'ltr',\n  formatTime: jest.fn((time: Date) => time.toLocaleTimeString('en-US')),\n  formatDate: jest.fn((date: Date) => date.toLocaleDateString('en-US')),\n  formatRelativeTime: jest.fn((date: Date) => 'just now'),\n  formatCurrency: jest.fn((amount: number, currency = 'USD') => `$${amount}`),\n  supportedLanguages: [\n    { code: 'en', name: 'English', rtl: false },\n    { code: 'es', name: 'Espa√±ol', rtl: false },\n    { code: 'ar', name: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©', rtl: true }\n  ],\n  isLoading: false,\n  error: null\n};\n\nconst LanguageTestContext = createContext<MockLanguageContextValue>(defaultLanguageValue);\n\nexport const LanguageTestProvider: React.FC<{\n  children: ReactNode;\n  value?: Partial<MockLanguageContextValue>;\n}> = ({ children, value = {} }) => {\n  const mockValue = { ...defaultLanguageValue, ...value };\n  return (\n    <LanguageTestContext.Provider value={mockValue}>\n      {children}\n    </LanguageTestContext.Provider>\n  );\n};\n\nexport const _useLanguageTest = () => useContext(LanguageTestContext);\n\n// Language Test Scenarios\nexport const _languageScenarios = {\n  english: {\n    language: 'en',\n    dir: 'ltr' as const,\n    t: jest.fn((key: string) => key.replace(/\\./g, ' ').toUpperCase())\n  },\n\n  spanish: {\n    language: 'es',\n    dir: 'ltr' as const,\n    t: jest.fn((key: string) => `es_${key}`)\n  },\n\n  arabic: {\n    language: 'ar',\n    dir: 'rtl' as const,\n    t: jest.fn((key: string) => `ar_${key}`),\n    formatTime: jest.fn((time: Date) => time.toLocaleTimeString('ar-SA'))\n  },\n\n  loading: {\n    isLoading: true,\n    t: jest.fn(() => '...')\n  },\n\n  error: {\n    error: 'Failed to load translations',\n    t: jest.fn((key: string) => key)\n  }\n};\n\n// ===============================\n// ALARM CONTEXT\n// ===============================\n\nexport interface MockAlarmContextValue {\n  alarms: any[];\n  activeAlarm: any | null;\n  addAlarm: jest.MockedFunction<(alarm: any) => Promise<void>>;\n  updateAlarm: jest.MockedFunction<(id: string, updates: any) => Promise<void>>;\n  deleteAlarm: jest.MockedFunction<(id: string) => Promise<void>>;\n  toggleAlarm: jest.MockedFunction<(id: string) => Promise<void>>;\n  snoozeAlarm: jest.MockedFunction<(id: string) => Promise<void>>;\n  stopAlarm: jest.MockedFunction<(id: string) => Promise<void>>;\n  duplicateAlarm: jest.MockedFunction<(id: string) => Promise<void>>;\n  bulkUpdateAlarms: jest.MockedFunction<(updates: any[]) => Promise<void>>;\n  getUpcomingAlarms: jest.MockedFunction<() => any[]>;\n  isLoading: boolean;\n  error: string | null;\n  lastSyncTime: Date | null;\n}\n\nconst defaultAlarmValue: MockAlarmContextValue = {\n  alarms: [\n    {\n      id: 'alarm-1',\n      time: '07:00',\n      label: 'Morning Alarm',\n      enabled: true,\n      days: [1, 2, 3, 4, 5], // Monday to Friday\n      sound: 'classic',\n      volume: 80,\n      snoozeEnabled: true,\n      snoozeInterval: 5\n    },\n    {\n      id: 'alarm-2',\n      time: '08:30',\n      label: 'Backup Alarm',\n      enabled: false,\n      days: [6, 0], // Weekend\n      sound: 'gentle',\n      volume: 60,\n      snoozeEnabled: false\n    }\n  ],\n  activeAlarm: null,\n  addAlarm: jest.fn(),\n  updateAlarm: jest.fn(),\n  deleteAlarm: jest.fn(),\n  toggleAlarm: jest.fn(),\n  snoozeAlarm: jest.fn(),\n  stopAlarm: jest.fn(),\n  duplicateAlarm: jest.fn(),\n  bulkUpdateAlarms: jest.fn(),\n  getUpcomingAlarms: jest.fn(() => []),\n  isLoading: false,\n  error: null,\n  lastSyncTime: new Date()\n};\n\nconst AlarmTestContext = createContext<MockAlarmContextValue>(defaultAlarmValue);\n\nexport const AlarmTestProvider: React.FC<{\n  children: ReactNode;\n  value?: Partial<MockAlarmContextValue>;\n}> = ({ children, value = {} }) => {\n  const mockValue = { ...defaultAlarmValue, ...value };\n  return (\n    <AlarmTestContext.Provider value={mockValue}>{children}</AlarmTestContext.Provider>\n  );\n};\n\nexport const _useAlarmTest = () => useContext(AlarmTestContext);\n\n// Alarm Test Scenarios\nexport const _alarmScenarios = {\n  noAlarms: {\n    alarms: [],\n    getUpcomingAlarms: jest.fn(() => [])\n  },\n\n  singleAlarm: {\n    alarms: [{\n      id: 'single-alarm',\n      time: '06:00',\n      label: 'Single Alarm',\n      enabled: true,\n      days: [1, 2, 3, 4, 5]\n    }]\n  },\n\n  multipleAlarms: {\n    alarms: Array.from({ length: 10 }, (_, i) => ({\n      id: `alarm-${i + 1}`,\n      time: `${String(6 + i).padStart(2, '0')}:00`,\n      label: `Alarm ${i + 1}`,\n      enabled: i % 2 === 0,\n      days: [1, 2, 3, 4, 5]\n    }))\n  },\n\n  activeAlarm: {\n    activeAlarm: {\n      id: 'active-alarm',\n      time: '07:00',\n      label: 'Currently Ringing',\n      enabled: true,\n      isRinging: true\n    }\n  },\n\n  loading: {\n    isLoading: true,\n    alarms: []\n  },\n\n  error: {\n    error: 'Failed to load alarms',\n    alarms: []\n  }\n};\n\n// ===============================\n// THEME CONTEXT\n// ===============================\n\nexport interface MockThemeContextValue {\n  theme: string;\n  setTheme: jest.MockedFunction<(theme: string) => void>;\n  isDark: boolean;\n  colors: Record<string, string>;\n  fonts: Record<string, string>;\n  animations: boolean;\n  setAnimations: jest.MockedFunction<(enabled: boolean) => void>;\n  customThemes: any[];\n  createCustomTheme: jest.MockedFunction<(theme: any) => Promise<void>>;\n  deleteCustomTheme: jest.MockedFunction<(id: string) => Promise<void>>;\n  exportTheme: jest.MockedFunction<(id: string) => Promise<string>>;\n  importTheme: jest.MockedFunction<(data: string) => Promise<void>>;\n  isLoading: boolean;\n  error: string | null;\n}\n\nconst defaultThemeValue: MockThemeContextValue = {\n  theme: 'dark',\n  setTheme: jest.fn(),\n  isDark: true,\n  colors: {\n    primary: '#6366f1',\n    secondary: '#8b5cf6',\n    background: '#0f172a',\n    surface: '#1e293b',\n    text: '#f1f5f9',\n    accent: '#06b6d4',\n    success: '#10b981',\n    warning: '#f59e0b',\n    error: '#ef4444'\n  },\n  fonts: {\n    primary: 'Inter',\n    secondary: 'Roboto Mono',\n    heading: 'Poppins'\n  },\n  animations: true,\n  setAnimations: jest.fn(),\n  customThemes: [],\n  createCustomTheme: jest.fn(),\n  deleteCustomTheme: jest.fn(),\n  exportTheme: jest.fn(),\n  importTheme: jest.fn(),\n  isLoading: false,\n  error: null\n};\n\nconst ThemeTestContext = createContext<MockThemeContextValue>(defaultThemeValue);\n\nexport const ThemeTestProvider: React.FC<{\n  children: ReactNode;\n  value?: Partial<MockThemeContextValue>;\n}> = ({ children, value = {} }) => {\n  const mockValue = { ...defaultThemeValue, ...value };\n  return (\n    <ThemeTestContext.Provider value={mockValue}>{children}</ThemeTestContext.Provider>\n  );\n};\n\nexport const _useThemeTest = () => useContext(ThemeTestContext);\n\n// Theme Test Scenarios\nexport const _themeScenarios = {\n  light: {\n    theme: 'light',\n    isDark: false,\n    colors: {\n      primary: '#6366f1',\n      background: '#ffffff',\n      surface: '#f8fafc',\n      text: '#0f172a'\n    }\n  },\n\n  dark: {\n    theme: 'dark',\n    isDark: true,\n    colors: {\n      primary: '#6366f1',\n      background: '#0f172a',\n      surface: '#1e293b',\n      text: '#f1f5f9'\n    }\n  },\n\n  gaming: {\n    theme: 'gaming',\n    isDark: true,\n    colors: {\n      primary: '#ff0080',\n      background: '#000000',\n      surface: '#1a1a1a',\n      text: '#ffffff',\n      accent: '#00ff80'\n    }\n  },\n\n  noAnimations: {\n    animations: false\n  },\n\n  customThemes: {\n    customThemes: [\n      {\n        id: 'custom-1',\n        name: 'My Custom Theme',\n        colors: { primary: '#ff6b6b' }\n      }\n    ]\n  }\n};\n\n// ===============================\n// COMBINED CONTEXT PROVIDER\n// ===============================\n\nexport interface ContextTestOptions {\n  featureAccess?: Partial<MockFeatureAccessContextValue>;\n  language?: Partial<MockLanguageContextValue>;\n  alarm?: Partial<MockAlarmContextValue>;\n  theme?: Partial<MockThemeContextValue>;\n}\n\nexport const ContextTestProvider: React.FC<{\n  children: ReactNode;\n  options?: ContextTestOptions;\n}> = ({ children, options = {} }) => {\n  const {\n    featureAccess = {},\n    language = {},\n    alarm = {},\n    theme = {}\n  } = options;\n\n  return (\n    <FeatureAccessTestProvider value={featureAccess}>\n      <LanguageTestProvider value={language}>\n        <AlarmTestProvider value={alarm}>\n          <ThemeTestProvider value={theme}>\n            {children}\n          </ThemeTestProvider>\n        </AlarmTestProvider>\n      </LanguageTestProvider>\n    </FeatureAccessTestProvider>\n  );\n};\n\n// Custom render function for context testing\nexport const _renderWithContexts = (\n  ui: React.ReactElement,\n  options: ContextTestOptions & RenderOptions = {}\n) => {\n  const { featureAccess, language, alarm, theme, ...renderOptions } = options;\n\n  const Wrapper: React.FC<{ children: ReactNode }> = ({ children }) => (\n    <ContextTestProvider options={{ featureAccess, language, alarm, theme }}>\n      {children}\n    </ContextTestProvider>\n  );\n\n  return render(ui, { wrapper: Wrapper, ...renderOptions });\n};\n\n// Pre-configured scenario testing\nexport const _renderWithScenario = (\n  ui: React.ReactElement,\n  scenarios: {\n    featureAccess?: keyof typeof featureAccessScenarios;\n    language?: keyof typeof languageScenarios;\n    alarm?: keyof typeof alarmScenarios;\n    theme?: keyof typeof themeScenarios;\n  }\n) => {\n  const options: ContextTestOptions = {};\n\n  if (scenarios.featureAccess) {\n    options.featureAccess = featureAccessScenarios[scenarios.featureAccess];\n  }\n  if (scenarios.language) {\n    options.language = languageScenarios[scenarios.language];\n  }\n  if (scenarios.alarm) {\n    options.alarm = alarmScenarios[scenarios.alarm];\n  }\n  if (scenarios.theme) {\n    options.theme = themeScenarios[scenarios.theme];\n  }\n\n  return renderWithContexts(ui, options);\n};\n\n// Alias exports without underscores\nexport const featureAccessScenarios = _featureAccessScenarios;\nexport const languageScenarios = _languageScenarios;\nexport const alarmScenarios = _alarmScenarios;\nexport const themeScenarios = _themeScenarios;\nexport const renderWithContexts = _renderWithContexts;\nexport const renderWithScenario = _renderWithScenario;\n\nexport default {\n  FeatureAccessTestProvider,\n  LanguageTestProvider,\n  AlarmTestProvider,\n  ThemeTestProvider,\n  ContextTestProvider,\n  renderWithContexts,\n  renderWithScenario,\n  featureAccessScenarios,\n  languageScenarios,\n  alarmScenarios,\n  themeScenarios\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/__tests__/providers/service-providers.tsx",
    "messages": [
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"useContext\" is called in function \"_useAlarmServiceTest\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 371,
        "column": 43,
        "nodeType": "Identifier",
        "endLine": 371,
        "endColumn": 53
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"useContext\" is called in function \"_useAnalyticsServiceTest\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 373,
        "column": 3,
        "nodeType": "Identifier",
        "endLine": 373,
        "endColumn": 13
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"useContext\" is called in function \"_useBattleServiceTest\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 374,
        "column": 44,
        "nodeType": "Identifier",
        "endLine": 374,
        "endColumn": 54
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"useContext\" is called in function \"_useSubscriptionServiceTest\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 376,
        "column": 3,
        "nodeType": "Identifier",
        "endLine": 376,
        "endColumn": 13
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"useContext\" is called in function \"_useVoiceServiceTest\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 377,
        "column": 43,
        "nodeType": "Identifier",
        "endLine": 377,
        "endColumn": 53
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"useContext\" is called in function \"_useNotificationServiceTest\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 379,
        "column": 3,
        "nodeType": "Identifier",
        "endLine": 379,
        "endColumn": 13
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"useContext\" is called in function \"_useAudioServiceTest\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 380,
        "column": 43,
        "nodeType": "Identifier",
        "endLine": 380,
        "endColumn": 53
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"useContext\" is called in function \"_useStorageServiceTest\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 381,
        "column": 45,
        "nodeType": "Identifier",
        "endLine": 381,
        "endColumn": 55
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"useContext\" is called in function \"_useSecurityServiceTest\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 382,
        "column": 46,
        "nodeType": "Identifier",
        "endLine": 382,
        "endColumn": 56
      }
    ],
    "suppressedMessages": [],
    "errorCount": 9,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Service-Specific Test Providers\n *\n * Mock implementations and providers for all application services with realistic\n * behavior patterns and comprehensive testing scenarios.\n */\n\nimport React, { ReactNode, createContext, useContext } from 'react';\n\n// ===============================\n// SERVICE INTERFACES\n// ===============================\n\nexport interface MockAlarmService {\n  createAlarm: jest.MockedFunction<(alarm: any) => Promise<any>>;\n  updateAlarm: jest.MockedFunction<(id: string, updates: any) => Promise<any>>;\n  deleteAlarm: jest.MockedFunction<(id: string) => Promise<void>>;\n  getAlarms: jest.MockedFunction<() => Promise<any[]>>;\n  getAlarm: jest.MockedFunction<(id: string) => Promise<any | null>>;\n  scheduleAlarm: jest.MockedFunction<(alarm: any) => Promise<void>>;\n  cancelAlarm: jest.MockedFunction<(id: string) => Promise<void>>;\n  snoozeAlarm: jest.MockedFunction<(id: string, minutes?: number) => Promise<void>>;\n  stopAlarm: jest.MockedFunction<(id: string) => Promise<void>>;\n  validateAlarmTime: jest.MockedFunction<(time: string) => boolean>;\n  getNextAlarmTime: jest.MockedFunction<() => Date | null>;\n  syncAlarms: jest.MockedFunction<() => Promise<void>>;\n  exportAlarms: jest.MockedFunction<() => Promise<string>>;\n  importAlarms: jest.MockedFunction<(data: string) => Promise<number>>;\n}\n\nexport interface MockAnalyticsService {\n  track: jest.MockedFunction<(event: string, properties?: any) => void>;\n  identify: jest.MockedFunction<(userId: string, traits?: any) => void>;\n  page: jest.MockedFunction<(name: string, properties?: any) => void>;\n  group: jest.MockedFunction<(groupId: string, traits?: any) => void>;\n  alias: jest.MockedFunction<(userId: string, previousId?: string) => void>;\n  reset: jest.MockedFunction<() => void>;\n  flush: jest.MockedFunction<() => Promise<void>>;\n  getAnalyticsData: jest.MockedFunction<(dateRange: any) => Promise<any>>;\n  setUserProperties: jest.MockedFunction<(properties: any) => void>;\n  trackConversion: jest.MockedFunction<(event: string, value?: number) => void>;\n  trackError: jest.MockedFunction<(error: Error, context?: any) => void>;\n}\n\nexport interface MockBattleService {\n  createBattle: jest.MockedFunction<(config: any) => Promise<any>>;\n  joinBattle: jest.MockedFunction<(battleId: string) => Promise<void>>;\n  leaveBattle: jest.MockedFunction<(battleId: string) => Promise<void>>;\n  getBattles: jest.MockedFunction<(status?: string) => Promise<any[]>>;\n  getBattle: jest.MockedFunction<(id: string) => Promise<any | null>>;\n  startBattle: jest.MockedFunction<(battleId: string) => Promise<void>>;\n  endBattle: jest.MockedFunction<(battleId: string) => Promise<any>>;\n  submitAnswer: jest.MockedFunction<(battleId: string, answer: any) => Promise<boolean>>;\n  getLeaderboard: jest.MockedFunction<() => Promise<any[]>>;\n  getUserStats: jest.MockedFunction<(userId: string) => Promise<any>>;\n  inviteToB\n\n\n\n  attle: jest.MockedFunction<(battleId: string, userIds: string[]) => Promise<void>>;\n  spectate: jest.MockedFunction<(battleId: string) => Promise<void>>;\n}\n\nexport interface MockSubscriptionService {\n  getSubscription: jest.MockedFunction<() => Promise<any | null>>;\n  getSubscriptions: jest.MockedFunction<() => Promise<any[]>>;\n  subscribe: jest.MockedFunction<(tier: string, paymentMethod?: any) => Promise<any>>;\n  cancelSubscription: jest.MockedFunction<(subscriptionId: string) => Promise<void>>;\n  updateSubscription: jest.MockedFunction<(subscriptionId: string, updates: any) => Promise<any>>;\n  resumeSubscription: jest.MockedFunction<(subscriptionId: string) => Promise<void>>;\n  getFeatures: jest.MockedFunction<(tier?: string) => string[]>;\n  checkAccess: jest.MockedFunction<(feature: string, tier?: string) => boolean>;\n  getUsage: jest.MockedFunction<(feature: string) => Promise<number>>;\n  getLimit: jest.MockedFunction<(feature: string) => number>;\n  trackUsage: jest.MockedFunction<(feature: string, amount?: number) => Promise<void>>;\n  getBillingHistory: jest.MockedFunction<() => Promise<any[]>>;\n  updatePaymentMethod: jest.MockedFunction<(paymentMethod: any) => Promise<void>>;\n}\n\nexport interface MockVoiceService {\n  generateVoice: jest.MockedFunction<(text: string, options?: any) => Promise<any>>;\n  uploadVoice: jest.MockedFunction<(file: File, metadata?: any) => Promise<any>>;\n  deleteVoice: jest.MockedFunction<(voiceId: string) => Promise<void>>;\n  getVoices: jest.MockedFunction<(userId?: string) => Promise<any[]>>;\n  getVoice: jest.MockedFunction<(voiceId: string) => Promise<any | null>>;\n  processVoice: jest.MockedFunction<(voiceId: string) => Promise<void>>;\n  synthesizeVoice: jest.MockedFunction<(voiceId: string, text: string) => Promise<string>>;\n  cloneVoice: jest.MockedFunction<(sourceId: string, name: string) => Promise<any>>;\n  trainVoiceModel: jest.MockedFunction<(voiceId: string, samples: File[]) => Promise<void>>;\n  getVoicePreview: jest.MockedFunction<(voiceId: string, text?: string) => Promise<string>>;\n  analyzeVoice: jest.MockedFunction<(voiceId: string) => Promise<any>>;\n}\n\nexport interface MockNotificationService {\n  requestPermission: jest.MockedFunction<() => Promise<NotificationPermission>>;\n  showNotification: jest.MockedFunction<(title: string, options?: any) => Promise<void>>;\n  scheduleNotification: jest.MockedFunction<(id: string, notification: any, when: Date) => Promise<void>>;\n  cancelNotification: jest.MockedFunction<(id: string) => Promise<void>>;\n  cancelAllNotifications: jest.MockedFunction<() => Promise<void>>;\n  getScheduledNotifications: jest.MockedFunction<() => Promise<any[]>>;\n  updateNotificationSettings: jest.MockedFunction<(settings: any) => Promise<void>>;\n  getNotificationSettings: jest.MockedFunction<() => Promise<any>>;\n  registerDevice: jest.MockedFunction<(token: string) => Promise<void>>;\n  unregisterDevice: jest.MockedFunction<() => Promise<void>>;\n}\n\nexport interface MockAudioService {\n  loadSound: jest.MockedFunction<(url: string) => Promise<any>>;\n  playSound: jest.MockedFunction<(soundId: string, options?: any) => Promise<void>>;\n  stopSound: jest.MockedFunction<(soundId: string) => Promise<void>>;\n  pauseSound: jest.MockedFunction<(soundId: string) => Promise<void>>;\n  resumeSound: jest.MockedFunction<(soundId: string) => Promise<void>>;\n  setVolume: jest.MockedFunction<(soundId: string, volume: number) => Promise<void>>;\n  fadeIn: jest.MockedFunction<(soundId: string, duration: number) => Promise<void>>;\n  fadeOut: jest.MockedFunction<(soundId: string, duration: number) => Promise<void>>;\n  getSoundDuration: jest.MockedFunction<(soundId: string) => Promise<number>>;\n  getCurrentTime: jest.MockedFunction<(soundId: string) => Promise<number>>;\n  seekTo: jest.MockedFunction<(soundId: string, time: number) => Promise<void>>;\n  createSoundGroup: jest.MockedFunction<(groupId: string, soundIds: string[]) => void>;\n  deleteSound: jest.MockedFunction<(soundId: string) => Promise<void>>;\n}\n\nexport interface MockStorageService {\n  set: jest.MockedFunction<(key: string, value: any, options?: any) => Promise<void>>;\n  get: jest.MockedFunction<(key: string) => Promise<any>>;\n  remove: jest.MockedFunction<(key: string) => Promise<void>>;\n  clear: jest.MockedFunction<() => Promise<void>>;\n  keys: jest.MockedFunction<() => Promise<string[]>>;\n  size: jest.MockedFunction<() => Promise<number>>;\n  has: jest.MockedFunction<(key: string) => Promise<boolean>>;\n  getMultiple: jest.MockedFunction<(keys: string[]) => Promise<Record<string, any>>>;\n  setMultiple: jest.MockedFunction<(items: Record<string, any>) => Promise<void>>;\n  removeMultiple: jest.MockedFunction<(keys: string[]) => Promise<void>>;\n  sync: jest.MockedFunction<() => Promise<void>>;\n  backup: jest.MockedFunction<() => Promise<string>>;\n  restore: jest.MockedFunction<(backup: string) => Promise<void>>;\n}\n\nexport interface MockSecurityService {\n  encrypt: jest.MockedFunction<(data: any, key?: string) => Promise<string>>;\n  decrypt: jest.MockedFunction<(encryptedData: string, key?: string) => Promise<any>>;\n  hash: jest.MockedFunction<(data: string, algorithm?: string) => Promise<string>>;\n  verify: jest.MockedFunction<(data: string, hash: string) => Promise<boolean>>;\n  generateToken: jest.MockedFunction<(payload?: any, expiresIn?: string) => Promise<string>>;\n  validateToken: jest.MockedFunction<(token: string) => Promise<boolean>>;\n  generateSecureId: jest.MockedFunction<() => string>;\n  generateKeyPair: jest.MockedFunction<() => Promise<{ publicKey: string; privateKey: string }>>;\n  signData: jest.MockedFunction<(data: any, privateKey: string) => Promise<string>>;\n  verifySignature: jest.MockedFunction<(data: any, signature: string, publicKey: string) => Promise<boolean>>;\n}\n\n// ===============================\n// SERVICE IMPLEMENTATIONS\n// ===============================\n\nconst createMockAlarmService = (): MockAlarmService => ({\n  createAlarm: jest.fn().mockResolvedValue({ id: 'new-alarm-id', created: true }),\n  updateAlarm: jest.fn().mockResolvedValue({ updated: true }),\n  deleteAlarm: jest.fn().mockResolvedValue(undefined),\n  getAlarms: jest.fn().mockResolvedValue([]),\n  getAlarm: jest.fn().mockResolvedValue(null),\n  scheduleAlarm: jest.fn().mockResolvedValue(undefined),\n  cancelAlarm: jest.fn().mockResolvedValue(undefined),\n  snoozeAlarm: jest.fn().mockResolvedValue(undefined),\n  stopAlarm: jest.fn().mockResolvedValue(undefined),\n  validateAlarmTime: jest.fn().mockReturnValue(true),\n  getNextAlarmTime: jest.fn().mockReturnValue(new Date(Date.now() + 24 * 60 * 60 * 1000)),\n  syncAlarms: jest.fn().mockResolvedValue(undefined),\n  exportAlarms: jest.fn().mockResolvedValue(JSON.stringify([])),\n  importAlarms: jest.fn().mockResolvedValue(0)\n});\n\nconst createMockAnalyticsService = (): MockAnalyticsService => ({\n  track: jest.fn(),\n  identify: jest.fn(),\n  page: jest.fn(),\n  group: jest.fn(),\n  alias: jest.fn(),\n  reset: jest.fn(),\n  flush: jest.fn().mockResolvedValue(undefined),\n  getAnalyticsData: jest.fn().mockResolvedValue({}),\n  setUserProperties: jest.fn(),\n  trackConversion: jest.fn(),\n  trackError: jest.fn()\n});\n\nconst createMockBattleService = (): MockBattleService => ({\n  createBattle: jest.fn().mockResolvedValue({ id: 'battle-123', created: true }),\n  joinBattle: jest.fn().mockResolvedValue(undefined),\n  leaveBattle: jest.fn().mockResolvedValue(undefined),\n  getBattles: jest.fn().mockResolvedValue([]),\n  getBattle: jest.fn().mockResolvedValue(null),\n  startBattle: jest.fn().mockResolvedValue(undefined),\n  endBattle: jest.fn().mockResolvedValue({ winner: 'user-123' }),\n  submitAnswer: jest.fn().mockResolvedValue(true),\n  getLeaderboard: jest.fn().mockResolvedValue([]),\n  getUserStats: jest.fn().mockResolvedValue({ wins: 0, losses: 0, score: 0 }),\n  inviteToBattle: jest.fn().mockResolvedValue(undefined),\n  spectate: jest.fn().mockResolvedValue(undefined)\n});\n\nconst createMockSubscriptionService = (): MockSubscriptionService => ({\n  getSubscription: jest.fn().mockResolvedValue(null),\n  getSubscriptions: jest.fn().mockResolvedValue([]),\n  subscribe: jest.fn().mockResolvedValue({ id: 'sub-123', tier: 'premium' }),\n  cancelSubscription: jest.fn().mockResolvedValue(undefined),\n  updateSubscription: jest.fn().mockResolvedValue({ updated: true }),\n  resumeSubscription: jest.fn().mockResolvedValue(undefined),\n  getFeatures: jest.fn().mockReturnValue(['basic_alarms']),\n  checkAccess: jest.fn().mockReturnValue(true),\n  getUsage: jest.fn().mockResolvedValue(0),\n  getLimit: jest.fn().mockReturnValue(100),\n  trackUsage: jest.fn().mockResolvedValue(undefined),\n  getBillingHistory: jest.fn().mockResolvedValue([]),\n  updatePaymentMethod: jest.fn().mockResolvedValue(undefined)\n});\n\nconst createMockVoiceService = (): MockVoiceService => ({\n  generateVoice: jest.fn().mockResolvedValue({ url: 'mock-audio-url' }),\n  uploadVoice: jest.fn().mockResolvedValue({ id: 'voice-123', processed: false }),\n  deleteVoice: jest.fn().mockResolvedValue(undefined),\n  getVoices: jest.fn().mockResolvedValue([]),\n  getVoice: jest.fn().mockResolvedValue(null),\n  processVoice: jest.fn().mockResolvedValue(undefined),\n  synthesizeVoice: jest.fn().mockResolvedValue('mock-audio-url'),\n  cloneVoice: jest.fn().mockResolvedValue({ id: 'cloned-voice-123' }),\n  trainVoiceModel: jest.fn().mockResolvedValue(undefined),\n  getVoicePreview: jest.fn().mockResolvedValue('mock-preview-url'),\n  analyzeVoice: jest.fn().mockResolvedValue({ quality: 'good', duration: 30 })\n});\n\nconst createMockNotificationService = (): MockNotificationService => ({\n  requestPermission: jest.fn().mockResolvedValue('granted' as NotificationPermission),\n  showNotification: jest.fn().mockResolvedValue(undefined),\n  scheduleNotification: jest.fn().mockResolvedValue(undefined),\n  cancelNotification: jest.fn().mockResolvedValue(undefined),\n  cancelAllNotifications: jest.fn().mockResolvedValue(undefined),\n  getScheduledNotifications: jest.fn().mockResolvedValue([]),\n  updateNotificationSettings: jest.fn().mockResolvedValue(undefined),\n  getNotificationSettings: jest.fn().mockResolvedValue({ enabled: true }),\n  registerDevice: jest.fn().mockResolvedValue(undefined),\n  unregisterDevice: jest.fn().mockResolvedValue(undefined)\n});\n\nconst createMockAudioService = (): MockAudioService => ({\n  loadSound: jest.fn().mockResolvedValue({ id: 'sound-123', loaded: true }),\n  playSound: jest.fn().mockResolvedValue(undefined),\n  stopSound: jest.fn().mockResolvedValue(undefined),\n  pauseSound: jest.fn().mockResolvedValue(undefined),\n  resumeSound: jest.fn().mockResolvedValue(undefined),\n  setVolume: jest.fn().mockResolvedValue(undefined),\n  fadeIn: jest.fn().mockResolvedValue(undefined),\n  fadeOut: jest.fn().mockResolvedValue(undefined),\n  getSoundDuration: jest.fn().mockResolvedValue(30),\n  getCurrentTime: jest.fn().mockResolvedValue(0),\n  seekTo: jest.fn().mockResolvedValue(undefined),\n  createSoundGroup: jest.fn(),\n  deleteSound: jest.fn().mockResolvedValue(undefined)\n});\n\nconst createMockStorageService = (): MockStorageService => ({\n  set: jest.fn().mockResolvedValue(undefined),\n  get: jest.fn().mockResolvedValue(null),\n  remove: jest.fn().mockResolvedValue(undefined),\n  clear: jest.fn().mockResolvedValue(undefined),\n  keys: jest.fn().mockResolvedValue([]),\n  size: jest.fn().mockResolvedValue(0),\n  has: jest.fn().mockResolvedValue(false),\n  getMultiple: jest.fn().mockResolvedValue({}),\n  setMultiple: jest.fn().mockResolvedValue(undefined),\n  removeMultiple: jest.fn().mockResolvedValue(undefined),\n  sync: jest.fn().mockResolvedValue(undefined),\n  backup: jest.fn().mockResolvedValue(JSON.stringify({})),\n  restore: jest.fn().mockResolvedValue(undefined)\n});\n\nconst createMockSecurityService = (): MockSecurityService => ({\n  encrypt: jest.fn().mockResolvedValue('encrypted-data'),\n  decrypt: jest.fn().mockResolvedValue('decrypted-data'),\n  hash: jest.fn().mockResolvedValue('hash-123'),\n  verify: jest.fn().mockResolvedValue(true),\n  generateToken: jest.fn().mockResolvedValue('token-123'),\n  validateToken: jest.fn().mockResolvedValue(true),\n  generateSecureId: jest.fn().mockReturnValue('secure-id-123'),\n  generateKeyPair: jest.fn().mockResolvedValue({\n    publicKey: 'public-key',\n    privateKey: 'private-key'\n  }),\n  signData: jest.fn().mockResolvedValue('signature-123'),\n  verifySignature: jest.fn().mockResolvedValue(true)\n});\n\n// ===============================\n// SERVICE CONTEXTS\n// ===============================\n\nconst AlarmServiceContext = createContext<MockAlarmService>(createMockAlarmService());\nconst AnalyticsServiceContext = createContext<MockAnalyticsService>(createMockAnalyticsService());\nconst BattleServiceContext = createContext<MockBattleService>(createMockBattleService());\nconst SubscriptionServiceContext = createContext<MockSubscriptionService>(createMockSubscriptionService());\nconst VoiceServiceContext = createContext<MockVoiceService>(createMockVoiceService());\nconst NotificationServiceContext = createContext<MockNotificationService>(createMockNotificationService());\nconst AudioServiceContext = createContext<MockAudioService>(createMockAudioService());\nconst StorageServiceContext = createContext<MockStorageService>(createMockStorageService());\nconst SecurityServiceContext = createContext<MockSecurityService>(createMockSecurityService());\n\n// ===============================\n// SERVICE PROVIDERS\n// ===============================\n\nexport const ServiceTestProviders: React.FC<{\n  children: ReactNode;\n  alarmService?: Partial<MockAlarmService>;\n  analyticsService?: Partial<MockAnalyticsService>;\n  battleService?: Partial<MockBattleService>;\n  subscriptionService?: Partial<MockSubscriptionService>;\n  voiceService?: Partial<MockVoiceService>;\n  notificationService?: Partial<MockNotificationService>;\n  audioService?: Partial<MockAudioService>;\n  storageService?: Partial<MockStorageService>;\n  securityService?: Partial<MockSecurityService>;\n}> = ({\n  children,\n  alarmService = {},\n  analyticsService = {},\n  battleService = {},\n  subscriptionService = {},\n  voiceService = {},\n  notificationService = {},\n  audioService = {},\n  storageService = {},\n  securityService = {}\n}) => {\n  const mockAlarmService = { ...createMockAlarmService(), ...alarmService };\n  const mockAnalyticsService = { ...createMockAnalyticsService(), ...analyticsService };\n  const mockBattleService = { ...createMockBattleService(), ...battleService };\n  const mockSubscriptionService = { ...createMockSubscriptionService(), ...subscriptionService };\n  const mockVoiceService = { ...createMockVoiceService(), ...voiceService };\n  const mockNotificationService = { ...createMockNotificationService(), ...notificationService };\n  const mockAudioService = { ...createMockAudioService(), ...audioService };\n  const mockStorageService = { ...createMockStorageService(), ...storageService };\n  const mockSecurityService = { ...createMockSecurityService(), ...securityService };\n\n  return (\n    <AlarmServiceContext.Provider value={mockAlarmService}>\n      <AnalyticsServiceContext.Provider value={mockAnalyticsService}>\n        <BattleServiceContext.Provider value={mockBattleService}>\n          <SubscriptionServiceContext.Provider value={mockSubscriptionService}>\n            <VoiceServiceContext.Provider value={mockVoiceService}>\n              <NotificationServiceContext.Provider value={mockNotificationService}>\n                <AudioServiceContext.Provider value={mockAudioService}>\n                  <StorageServiceContext.Provider value={mockStorageService}>\n                    <SecurityServiceContext.Provider value={mockSecurityService}>\n                      {children}\n                    </SecurityServiceContext.Provider>\n                  </StorageServiceContext.Provider>\n                </AudioServiceContext.Provider>\n              </NotificationServiceContext.Provider>\n            </VoiceServiceContext.Provider>\n          </SubscriptionServiceContext.Provider>\n        </BattleServiceContext.Provider>\n      </AnalyticsServiceContext.Provider>\n    </AlarmServiceContext.Provider>\n  );\n};\n\n// ===============================\n// HOOK UTILITIES\n// ===============================\n\nexport const _useAlarmServiceTest = () => useContext(AlarmServiceContext);\nexport const _useAnalyticsServiceTest = () =>\n  useContext(AnalyticsServiceContext);\nexport const _useBattleServiceTest = () => useContext(BattleServiceContext);\nexport const _useSubscriptionServiceTest = () =>\n  useContext(SubscriptionServiceContext);\nexport const _useVoiceServiceTest = () => useContext(VoiceServiceContext);\nexport const _useNotificationServiceTest = () =>\n  useContext(NotificationServiceContext);\nexport const _useAudioServiceTest = () => useContext(AudioServiceContext);\nexport const _useStorageServiceTest = () => useContext(StorageServiceContext);\nexport const _useSecurityServiceTest = () => useContext(SecurityServiceContext);\n\n// ===============================\n// SERVICE SCENARIOS\n// ===============================\n\nexport const _serviceScenarios = {\n  // Alarm Service Scenarios\n  alarmServiceScenarios: {\n    withAlarms: {\n      getAlarms: jest.fn().mockResolvedValue([\n        { id: 'alarm-1', time: '07:00', enabled: true },\n        { id: 'alarm-2', time: '08:30', enabled: false }\n      ])\n    },\n    noAlarms: {\n      getAlarms: jest.fn().mockResolvedValue([])\n    },\n    createError: {\n      createAlarm: jest.fn().mockRejectedValue(new Error('Failed to create alarm'))\n    },\n    syncError: {\n      syncAlarms: jest.fn().mockRejectedValue(new Error('Sync failed'))\n    }\n  },\n\n  // Analytics Service Scenarios\n  analyticsServiceScenarios: {\n    trackingEnabled: {\n      track: jest.fn(),\n      identify: jest.fn()\n    },\n    trackingDisabled: {\n      track: jest.fn(),\n      identify: jest.fn()\n    }\n  },\n\n  // Battle Service Scenarios\n  battleServiceScenarios: {\n    activeBattles: {\n      getBattles: jest.fn().mockResolvedValue([\n        { id: 'battle-1', status: 'active', participants: 2 }\n      ])\n    },\n    noBattles: {\n      getBattles: jest.fn().mockResolvedValue([])\n    },\n    joinError: {\n      joinBattle: jest.fn().mockRejectedValue(new Error('Battle is full'))\n    }\n  },\n\n  // Subscription Service Scenarios\n  subscriptionServiceScenarios: {\n    freeUser: {\n      getSubscription: jest.fn().mockResolvedValue(null),\n      checkAccess: jest.fn((feature: string) => feature === 'basic_alarms'),\n      getFeatures: jest.fn().mockReturnValue(['basic_alarms'])\n    },\n    premiumUser: {\n      getSubscription: jest.fn().mockResolvedValue({\n        tier: 'premium',\n        status: 'active'\n      }),\n      checkAccess: jest.fn(() => true),\n      getFeatures: jest.fn().mockReturnValue([\n        'unlimited_alarms', 'custom_voices', 'themes'\n      ])\n    },\n    expiredSubscription: {\n      getSubscription: jest.fn().mockResolvedValue({\n        tier: 'premium',\n        status: 'past_due'\n      }),\n      checkAccess: jest.fn((feature: string) => feature === 'basic_alarms')\n    }\n  },\n\n  // Audio Service Scenarios\n  audioServiceScenarios: {\n    soundsLoaded: {\n      loadSound: jest.fn().mockResolvedValue({ loaded: true }),\n      playSound: jest.fn().mockResolvedValue(undefined)\n    },\n    loadError: {\n      loadSound: jest.fn().mockRejectedValue(new Error('Failed to load sound'))\n    },\n    playbackError: {\n      playSound: jest.fn().mockRejectedValue(new Error('Playback failed'))\n    }\n  },\n\n  // Storage Service Scenarios\n  storageServiceScenarios: {\n    dataExists: {\n      get: jest.fn().mockResolvedValue({ data: 'test' }),\n      has: jest.fn().mockResolvedValue(true)\n    },\n    noData: {\n      get: jest.fn().mockResolvedValue(null),\n      has: jest.fn().mockResolvedValue(false)\n    },\n    storageError: {\n      set: jest.fn().mockRejectedValue(new Error('Storage quota exceeded'))\n    }\n  }\n};\n\nexport default {\n  ServiceTestProviders,\n  useAlarmServiceTest,\n  useAnalyticsServiceTest,\n  useBattleServiceTest,\n  useSubscriptionServiceTest,\n  useVoiceServiceTest,\n  useNotificationServiceTest,\n  useAudioServiceTest,\n  useStorageServiceTest,\n  useSecurityServiceTest,\n  serviceScenarios\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/__tests__/providers/test-providers.tsx",
    "messages": [
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"React.useContext\" is called in function \"_useTestContext\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 451,
        "column": 25,
        "nodeType": "MemberExpression",
        "endLine": 451,
        "endColumn": 41
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"React.useContext\" is called in function \"_useTestContext\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 452,
        "column": 20,
        "nodeType": "MemberExpression",
        "endLine": 452,
        "endColumn": 36
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"React.useContext\" is called in function \"_useTestContext\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 453,
        "column": 16,
        "nodeType": "MemberExpression",
        "endLine": 453,
        "endColumn": 32
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"React.useContext\" is called in function \"_useTestContext\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 454,
        "column": 17,
        "nodeType": "MemberExpression",
        "endLine": 454,
        "endColumn": 33
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"React.useContext\" is called in function \"_useTestContext\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 455,
        "column": 17,
        "nodeType": "MemberExpression",
        "endLine": 455,
        "endColumn": 33
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"React.useContext\" is called in function \"_useTestContext\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 456,
        "column": 24,
        "nodeType": "MemberExpression",
        "endLine": 456,
        "endColumn": 40
      },
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"React.useContext\" is called in function \"_useTestContext\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".",
        "line": 457,
        "column": 20,
        "nodeType": "MemberExpression",
        "endLine": 457,
        "endColumn": 36
      }
    ],
    "suppressedMessages": [],
    "errorCount": 7,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Test Wrapper Providers for Contexts and Services\n *\n * Comprehensive test wrapper providers that mock all application contexts and services\n * for isolated and integration testing scenarios.\n */\n\nimport React, { ReactNode } from 'react';\nimport { render, RenderOptions } from '@testing-library/react';\nimport { MemoryRouter, MemoryRouterProps } from 'react-router-dom';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n\n// Context Types\ninterface FeatureAccessContextValue {\n  hasAccess: (feature: string) => boolean;\n  checkFeatureAccess: (feature: string, tier?: string) => boolean;\n  isFeatureEnabled: (feature: string) => boolean;\n  upgradeRequired: (feature: string) => boolean;\n}\n\ninterface LanguageContextValue {\n  language: string;\n  setLanguage: (lang: string) => void;\n  t: (key: string, options?: any) => string;\n  dir: 'ltr' | 'rtl';\n  formatTime: (time: Date) => string;\n  formatDate: (date: Date) => string;\n}\n\ninterface AuthContextValue {\n  user: any | null;\n  login: (credentials: any) => Promise<void>;\n  logout: () => Promise<void>;\n  register: (userData: any) => Promise<void>;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: string | null;\n}\n\ninterface ThemeContextValue {\n  theme: string;\n  setTheme: (theme: string) => void;\n  isDark: boolean;\n  colors: Record<string, string>;\n  animations: boolean;\n  setAnimations: (enabled: boolean) => void;\n}\n\ninterface AlarmContextValue {\n  alarms: any[];\n  addAlarm: (alarm: any) => Promise<void>;\n  updateAlarm: (id: string, updates: any) => Promise<void>;\n  deleteAlarm: (id: string) => Promise<void>;\n  toggleAlarm: (id: string) => Promise<void>;\n  activeAlarm: any | null;\n  snoozeAlarm: (id: string) => Promise<void>;\n  stopAlarm: (id: string) => Promise<void>;\n}\n\ninterface SubscriptionContextValue {\n  subscription: any | null;\n  tier: 'free' | 'premium' | 'ultimate';\n  isSubscribed: boolean;\n  subscribe: (tier: string) => Promise<void>;\n  cancelSubscription: () => Promise<void>;\n  features: string[];\n  billing: any | null;\n}\n\n// Mock Context Implementations\nexport const _createMockFeatureAccessContext = (\n  overrides: Partial<FeatureAccessContextValue> = {}\n): FeatureAccessContextValue => ({\n  hasAccess: jest.fn(() => true),\n  checkFeatureAccess: jest.fn(() => true),\n  isFeatureEnabled: jest.fn(() => true),\n  upgradeRequired: jest.fn(() => false),\n  ...overrides,\n});\n\nexport const _createMockLanguageContext = (\n  overrides: Partial<LanguageContextValue> = {}\n): LanguageContextValue => ({\n  language: 'en',\n  setLanguage: jest.fn(),\n  t: jest.fn((key: string) => key),\n  dir: 'ltr',\n  formatTime: jest.fn((time: Date) => time.toLocaleTimeString()),\n  formatDate: jest.fn((date: Date) => date.toLocaleDateString()),\n  ...overrides,\n});\n\nexport const _createMockAuthContext = (\n  overrides: Partial<AuthContextValue> = {}\n): AuthContextValue => ({\n  user: {\n    id: 'test-user-123',\n    email: 'test@example.com',\n    name: 'Test User',\n    subscription: { tier: 'premium', status: 'active' },\n  },\n  login: jest.fn(),\n  logout: jest.fn(),\n  register: jest.fn(),\n  isAuthenticated: true,\n  isLoading: false,\n  error: null,\n  ...overrides,\n});\n\nexport const _createMockThemeContext = (\n  overrides: Partial<ThemeContextValue> = {}\n): ThemeContextValue => ({\n  theme: 'dark',\n  setTheme: jest.fn(),\n  isDark: true,\n  colors: {\n    primary: '#6366f1',\n    secondary: '#8b5cf6',\n    background: '#0f172a',\n    surface: '#1e293b',\n    text: '#f1f5f9',\n    accent: '#06b6d4',\n  },\n  animations: true,\n  setAnimations: jest.fn(),\n  ...overrides,\n});\n\nexport const _createMockAlarmContext = (\n  overrides: Partial<AlarmContextValue> = {}\n): AlarmContextValue => ({\n  alarms: [\n    {\n      id: 'alarm-1',\n      time: '07:00',\n      label: 'Wake up',\n      enabled: true,\n      days: [1, 2, 3, 4, 5],\n      sound: 'classic',\n    },\n  ],\n  addAlarm: jest.fn(),\n  updateAlarm: jest.fn(),\n  deleteAlarm: jest.fn(),\n  toggleAlarm: jest.fn(),\n  activeAlarm: null,\n  snoozeAlarm: jest.fn(),\n  stopAlarm: jest.fn(),\n  ...overrides,\n});\n\nexport const _createMockSubscriptionContext = (\n  overrides: Partial<SubscriptionContextValue> = {}\n): SubscriptionContextValue => ({\n  subscription: {\n    id: 'sub-123',\n    tier: 'premium',\n    status: 'active',\n    current_period_end: '2024-12-31T23:59:59Z',\n  },\n  tier: 'premium',\n  isSubscribed: true,\n  subscribe: jest.fn(),\n  cancelSubscription: jest.fn(),\n  features: ['unlimited_alarms', 'custom_voices', 'themes', 'battle_mode'],\n  billing: {\n    amount: 9.99,\n    currency: 'USD',\n    interval: 'month',\n  },\n  ...overrides,\n});\n\n// Context Providers\nconst FeatureAccessContext = React.createContext<FeatureAccessContextValue>(\n  createMockFeatureAccessContext()\n);\nconst LanguageContext = React.createContext<LanguageContextValue>(\n  createMockLanguageContext()\n);\nconst AuthContext = React.createContext<AuthContextValue>(createMockAuthContext());\nconst ThemeContext = React.createContext<ThemeContextValue>(createMockThemeContext());\nconst AlarmContext = React.createContext<AlarmContextValue>(createMockAlarmContext());\nconst SubscriptionContext = React.createContext<SubscriptionContextValue>(\n  createMockSubscriptionContext()\n);\n\n// Individual Provider Components\nexport const MockFeatureAccessProvider: React.FC<{\n  children: ReactNode;\n  value?: Partial<FeatureAccessContextValue>;\n}> = ({ children, value = {} }) => {\n  const mockValue = createMockFeatureAccessContext(value);\n  return (\n    <FeatureAccessContext.Provider value={mockValue}>\n      {children}\n    </FeatureAccessContext.Provider>\n  );\n};\n\nexport const MockLanguageProvider: React.FC<{\n  children: ReactNode;\n  value?: Partial<LanguageContextValue>;\n}> = ({ children, value = {} }) => {\n  const mockValue = createMockLanguageContext(value);\n  return (\n    <LanguageContext.Provider value={mockValue}>{children}</LanguageContext.Provider>\n  );\n};\n\nexport const MockAuthProvider: React.FC<{\n  children: ReactNode;\n  value?: Partial<AuthContextValue>;\n}> = ({ children, value = {} }) => {\n  const mockValue = createMockAuthContext(value);\n  return <AuthContext.Provider value={mockValue}>{children}</AuthContext.Provider>;\n};\n\nexport const MockThemeProvider: React.FC<{\n  children: ReactNode;\n  value?: Partial<ThemeContextValue>;\n}> = ({ children, value = {} }) => {\n  const mockValue = createMockThemeContext(value);\n  return <ThemeContext.Provider value={mockValue}>{children}</ThemeContext.Provider>;\n};\n\nexport const MockAlarmProvider: React.FC<{\n  children: ReactNode;\n  value?: Partial<AlarmContextValue>;\n}> = ({ children, value = {} }) => {\n  const mockValue = createMockAlarmContext(value);\n  return <AlarmContext.Provider value={mockValue}>{children}</AlarmContext.Provider>;\n};\n\nexport const MockSubscriptionProvider: React.FC<{\n  children: ReactNode;\n  value?: Partial<SubscriptionContextValue>;\n}> = ({ children, value = {} }) => {\n  const mockValue = createMockSubscriptionContext(value);\n  return (\n    <SubscriptionContext.Provider value={mockValue}>\n      {children}\n    </SubscriptionContext.Provider>\n  );\n};\n\n// Service Mocks\nexport const _createMockServices = () => ({\n  alarmService: {\n    createAlarm: jest.fn(),\n    updateAlarm: jest.fn(),\n    deleteAlarm: jest.fn(),\n    getAlarms: jest.fn(() => Promise.resolve([])),\n    scheduleAlarm: jest.fn(),\n    cancelAlarm: jest.fn(),\n    snoozeAlarm: jest.fn(),\n    stopAlarm: jest.fn(),\n  },\n\n  analyticsService: {\n    track: jest.fn(),\n    identify: jest.fn(),\n    page: jest.fn(),\n    group: jest.fn(),\n    alias: jest.fn(),\n    reset: jest.fn(),\n  },\n\n  battleService: {\n    createBattle: jest.fn(),\n    joinBattle: jest.fn(),\n    leaveBattle: jest.fn(),\n    getBattles: jest.fn(() => Promise.resolve([])),\n    startBattle: jest.fn(),\n    endBattle: jest.fn(),\n    submitAnswer: jest.fn(),\n  },\n\n  subscriptionService: {\n    getSubscription: jest.fn(),\n    subscribe: jest.fn(),\n    cancelSubscription: jest.fn(),\n    updateSubscription: jest.fn(),\n    getFeatures: jest.fn(() => []),\n    checkAccess: jest.fn(() => true),\n  },\n\n  voiceService: {\n    generateVoice: jest.fn(),\n    uploadVoice: jest.fn(),\n    deleteVoice: jest.fn(),\n    getVoices: jest.fn(() => Promise.resolve([])),\n    processVoice: jest.fn(),\n    synthesizeVoice: jest.fn(),\n  },\n\n  themeService: {\n    getThemes: jest.fn(() => Promise.resolve([])),\n    applyTheme: jest.fn(),\n    createCustomTheme: jest.fn(),\n    deleteTheme: jest.fn(),\n    exportTheme: jest.fn(),\n    importTheme: jest.fn(),\n  },\n\n  notificationService: {\n    requestPermission: jest.fn(() => Promise.resolve('granted')),\n    showNotification: jest.fn(),\n    scheduleNotification: jest.fn(),\n    cancelNotification: jest.fn(),\n    clearAllNotifications: jest.fn(),\n  },\n\n  audioService: {\n    loadSound: jest.fn(),\n    playSound: jest.fn(),\n    stopSound: jest.fn(),\n    pauseSound: jest.fn(),\n    setVolume: jest.fn(),\n    fadeIn: jest.fn(),\n    fadeOut: jest.fn(),\n  },\n\n  storageService: {\n    set: jest.fn(),\n    get: jest.fn(),\n    remove: jest.fn(),\n    clear: jest.fn(),\n    keys: jest.fn(() => []),\n    size: jest.fn(() => 0),\n  },\n\n  securityService: {\n    encrypt: jest.fn(data => Promise.resolve(btoa(JSON.stringify(data)))),\n    decrypt: jest.fn(data => Promise.resolve(JSON.parse(atob(data)))),\n    hash: jest.fn(data => Promise.resolve(`hash_${data}`)),\n    verify: jest.fn(() => Promise.resolve(true)),\n    generateToken: jest.fn(() => 'mock_token_123'),\n  },\n});\n\n// Service Provider Context\nconst ServiceContext = React.createContext(createMockServices());\n\nexport const MockServiceProvider: React.FC<{\n  children: ReactNode;\n  services?: Partial<ReturnType<typeof createMockServices>>;\n}> = ({ children, services = {} }) => {\n  const mockServices = { ...createMockServices(), ...services };\n  return (\n    <ServiceContext.Provider value={mockServices}>{children}</ServiceContext.Provider>\n  );\n};\n\n// Combined Test Provider\nexport interface TestProvidersOptions {\n  // Context overrides\n  featureAccess?: Partial<FeatureAccessContextValue>;\n  language?: Partial<LanguageContextValue>;\n  auth?: Partial<AuthContextValue>;\n  theme?: Partial<ThemeContextValue>;\n  alarm?: Partial<AlarmContextValue>;\n  subscription?: Partial<SubscriptionContextValue>;\n\n  // Service overrides\n  services?: Partial<ReturnType<typeof createMockServices>>;\n\n  // Router options\n  router?: MemoryRouterProps;\n\n  // Query client options\n  queryClient?: QueryClient;\n\n  // Additional wrappers\n  wrappers?: React.ComponentType<{ children: ReactNode }>[];\n}\n\nexport const TestProviders: React.FC<{\n  children: ReactNode;\n  options?: TestProvidersOptions;\n}> = ({ children, options = {} }) => {\n  const {\n    featureAccess = {},\n    language = {},\n    auth = {},\n    theme = {},\n    alarm = {},\n    subscription = {},\n    services = {},\n    router = { initialEntries: ['/'] },\n    queryClient = new QueryClient({\n      defaultOptions: {\n        queries: { retry: false },\n        mutations: { retry: false },\n      },\n    }),\n    wrappers = [],\n  } = options;\n\n  let wrappedChildren = (\n    <QueryClientProvider client={queryClient}>\n      <MemoryRouter {...router}>\n        <MockServiceProvider services={services}>\n          <MockFeatureAccessProvider value={featureAccess}>\n            <MockLanguageProvider value={language}>\n              <MockAuthProvider value={auth}>\n                <MockThemeProvider value={theme}>\n                  <MockAlarmProvider value={alarm}>\n                    <MockSubscriptionProvider value={subscription}>\n                      {children}\n                    </MockSubscriptionProvider>\n                  </MockAlarmProvider>\n                </MockThemeProvider>\n              </MockAuthProvider>\n            </MockLanguageProvider>\n          </MockFeatureAccessProvider>\n        </MockServiceProvider>\n      </MemoryRouter>\n    </QueryClientProvider>\n  );\n\n  // Apply additional wrappers\n  wrappers.forEach(Wrapper => {\n    wrappedChildren = <Wrapper>{wrappedChildren}</Wrapper>;\n  });\n\n  return <>{wrappedChildren}</>;\n};\n\n// Custom Render Function\nexport interface TestRenderOptions extends RenderOptions {\n  providerOptions?: TestProvidersOptions;\n}\n\nexport const _renderWithProviders = (\n  ui: React.ReactElement,\n  options: TestRenderOptions = {}\n) => {\n  const { providerOptions = {}, ...renderOptions } = options;\n\n  const Wrapper: React.FC<{ children: ReactNode }> = ({ children }) => (\n    <TestProviders options={providerOptions}>{children}</TestProviders>\n  );\n\n  return render(ui, { wrapper: Wrapper, ...renderOptions });\n};\n\n// Utility Hooks for Testing\nexport const _useTestContext = () => {\n  const featureAccess = React.useContext(FeatureAccessContext);\n  const language = React.useContext(LanguageContext);\n  const auth = React.useContext(AuthContext);\n  const theme = React.useContext(ThemeContext);\n  const alarm = React.useContext(AlarmContext);\n  const subscription = React.useContext(SubscriptionContext);\n  const services = React.useContext(ServiceContext);\n\n  return {\n    featureAccess,\n    language,\n    auth,\n    theme,\n    alarm,\n    subscription,\n    services,\n  };\n};\n\n// Pre-configured Test Scenarios\nexport const _testScenarios = {\n  // Free user scenario\n  freeUser: {\n    auth: {\n      user: {\n        id: 'free-user',\n        email: 'free@test.com',\n        subscription: { tier: 'free', status: 'active' },\n      },\n    },\n    subscription: {\n      tier: 'free' as const,\n      isSubscribed: false,\n      features: ['basic_alarms'],\n    },\n    featureAccess: {\n      hasAccess: jest.fn((feature: string) => feature === 'basic_alarms'),\n      upgradeRequired: jest.fn((feature: string) => feature !== 'basic_alarms'),\n    },\n  },\n\n  // Premium user scenario\n  premiumUser: {\n    auth: {\n      user: {\n        id: 'premium-user',\n        email: 'premium@test.com',\n        subscription: { tier: 'premium', status: 'active' },\n      },\n    },\n    subscription: {\n      tier: 'premium' as const,\n      isSubscribed: true,\n      features: ['unlimited_alarms', 'custom_voices', 'themes'],\n    },\n    featureAccess: {\n      hasAccess: jest.fn(() => true),\n      upgradeRequired: jest.fn(() => false),\n    },\n  },\n\n  // Unauthenticated scenario\n  unauthenticated: {\n    auth: {\n      user: null,\n      isAuthenticated: false,\n    },\n  },\n\n  // Mobile scenario\n  mobile: {\n    theme: {\n      theme: 'mobile-dark',\n      colors: {\n        primary: '#6366f1',\n        background: '#000000',\n        surface: '#1a1a1a',\n      },\n    },\n  },\n\n  // RTL language scenario\n  rtl: {\n    language: {\n      language: 'ar',\n      dir: 'rtl' as const,\n      t: jest.fn((key: string) => `ar_${key}`),\n    },\n  },\n\n  // Offline scenario\n  offline: {\n    services: {\n      storageService: {\n        get: jest.fn(),\n        set: jest.fn(),\n        // Simulate offline storage\n      },\n    },\n  },\n};\n\n// Helper function to render with pre-configured scenarios\nexport const _renderWithScenario = (\n  ui: React.ReactElement,\n  scenario: keyof typeof testScenarios,\n  additionalOptions: TestProvidersOptions = {}\n) => {\n  const scenarioOptions = testScenarios[scenario];\n  const mergedOptions = {\n    ...scenarioOptions,\n    ...additionalOptions,\n  };\n\n  return _renderWithProviders(ui, {\n    providerOptions: mergedOptions,\n  });\n};\n\n// Alias exports without underscores\nexport const renderWithProviders = _renderWithProviders;\nexport const renderWithScenario = _renderWithScenario;\nexport const testScenarios = _testScenarios;\nexport const useTestContext = _useTestContext;\nexport const createMockServices = _createMockServices;\n\nexport default {\n  TestProviders,\n  renderWithProviders,\n  renderWithScenario,\n  testScenarios,\n  useTestContext,\n  createMockServices,\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/__tests__/utils/assertion-helpers.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-namespace",
        "severity": 2,
        "message": "ES2015 module syntax is preferred over namespaces.",
        "line": 8,
        "column": 3,
        "nodeType": "TSModuleDeclaration",
        "messageId": "moduleSyntaxIsPreferred",
        "endLine": 18,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Custom Jest assertions and matchers for enhanced testing\n\n// Vitest globals are available globally, no need to import\nimport { TestAlarm, TestUser, TestTheme } from './index';\n\n// Extend Jest matchers\ndeclare global {\n  namespace jest {\n    interface Matchers<R> {\n      toBeValidAlarm(): R;\n      toBeValidUser(): R;\n      toBeValidTheme(): R;\n      toHaveAccessibilityAttributes(): R;\n      toBeResponsive(): R;\n      toHandleErrors(): R;\n      toLoadWithinTime(maxTime: number): R;\n    }\n  }\n}\n\n// Custom matcher: toBeValidAlarm\nexpect.extend({\n  toBeValidAlarm(received: any) {\n    const pass =\n      received &&\n      typeof received === 'object' &&\n      typeof received.id === 'string' &&\n      typeof received.userId === 'string' &&\n      typeof received.time === 'string' &&\n      typeof received.label === 'string' &&\n      typeof received.enabled === 'boolean' &&\n      Array.isArray(received.days) &&\n      Array.isArray(received.dayNames) &&\n      [\n        'gentle',\n        'motivational',\n        'drill-sergeant',\n        'zen',\n        'energetic',\n        'custom',\n      ].includes(received.voiceMood) &&\n      ['easy', 'medium', 'hard', 'nuclear'].includes(received.difficulty);\n\n    return {\n      message: () =>\n        pass\n          ? `Expected ${received} not to be a valid alarm`\n          : `Expected ${received} to be a valid alarm with required properties`,\n      pass,\n    };\n  },\n});\n\n// Custom matcher: toBeValidUser\nexpect.extend({\n  toBeValidUser(received: any) {\n    const pass =\n      received &&\n      typeof received === 'object' &&\n      typeof received.id === 'string' &&\n      typeof received.email === 'string' &&\n      typeof received.name === 'string' &&\n      ['user', 'premium', 'admin'].includes(received.role) &&\n      received.email.includes('@') &&\n      received.createdAt &&\n      received.updatedAt;\n\n    return {\n      message: () =>\n        pass\n          ? `Expected ${received} not to be a valid user`\n          : `Expected ${received} to be a valid user with required properties`,\n      pass,\n    };\n  },\n});\n\n// Custom matcher: toBeValidTheme\nexpect.extend({\n  toBeValidTheme(received: any) {\n    const pass =\n      received &&\n      typeof received === 'object' &&\n      typeof received.id === 'string' &&\n      typeof received.name === 'string' &&\n      ['light', 'dark', 'gaming', 'seasonal', 'custom'].includes(received.category) &&\n      received.colors &&\n      typeof received.colors.primary === 'string' &&\n      typeof received.colors.background === 'string';\n\n    return {\n      message: () =>\n        pass\n          ? `Expected ${received} not to be a valid theme`\n          : `Expected ${received} to be a valid theme with required properties`,\n      pass,\n    };\n  },\n});\n\n// Custom matcher: toHaveAccessibilityAttributes\nexpect.extend({\n  toHaveAccessibilityAttributes(received: HTMLElement) {\n    const hasAriaAttributes =\n      received.hasAttribute('aria-label') ||\n      received.hasAttribute('aria-labelledby') ||\n      received.hasAttribute('aria-describedby');\n\n    const hasRole = received.hasAttribute('role');\n    const isFocusable =\n      received.tabIndex >= 0 ||\n      ['button', 'input', 'select', 'textarea', 'a'].includes(\n        received.tagName.toLowerCase()\n      );\n\n    const pass = hasAriaAttributes || hasRole || isFocusable;\n\n    return {\n      message: () =>\n        pass\n          ? `Expected element not to have accessibility attributes`\n          : `Expected element to have accessibility attributes (aria-*, role, or be focusable)`,\n      pass,\n    };\n  },\n});\n\n// Custom matcher: toBeResponsive\nexpect.extend({\n  toBeResponsive(received: HTMLElement) {\n    const styles = window.getComputedStyle(received);\n    const hasResponsiveWidth =\n      styles.width === '100%' ||\n      styles.maxWidth === '100%' ||\n      styles.width.includes('vw');\n\n    const hasFlexbox = styles.display === 'flex' || styles.display === 'grid';\n    const hasResponsiveMargins =\n      styles.marginLeft === 'auto' && styles.marginRight === 'auto';\n\n    const pass = hasResponsiveWidth || hasFlexbox || hasResponsiveMargins;\n\n    return {\n      message: () =>\n        pass\n          ? `Expected element not to be responsive`\n          : `Expected element to have responsive styling (width: 100%, flex/grid, or auto margins)`,\n      pass,\n    };\n  },\n});\n\n// Custom matcher: toHandleErrors\nexpect.extend({\n  async toHandleErrors(received: () => Promise<any> | any) {\n    let errorThrown = false;\n    let result;\n\n    try {\n      if (typeof received === 'function') {\n        result = await received();\n      } else {\n        result = received;\n      }\n    } catch (error) {\n      errorThrown = true;\n    }\n\n    const pass = !errorThrown;\n\n    return {\n      message: () =>\n        pass\n          ? `Expected function to throw an error`\n          : `Expected function not to throw an error`,\n      pass,\n    };\n  },\n});\n\n// Custom matcher: toLoadWithinTime\nexpect.extend({\n  async toLoadWithinTime(received: () => Promise<any>, maxTime: number) {\n    const startTime = performance.now();\n    let loadedInTime = false;\n\n    try {\n      await received();\n      const endTime = performance.now();\n      loadedInTime = endTime - startTime <= maxTime;\n    } catch (error) {\n      loadedInTime = false;\n    }\n\n    return {\n      message: () =>\n        loadedInTime\n          ? `Expected operation to take more than ${maxTime}ms`\n          : `Expected operation to complete within ${maxTime}ms`,\n      pass: loadedInTime,\n    };\n  },\n});\n\n// Helper functions for assertions\nexport const _assertValidAlarm = (alarm: any): alarm is TestAlarm => {\n  expect(alarm).toBeValidAlarm();\n  return true;\n};\n\nexport const _assertValidUser = (user: any): user is TestUser => {\n  expect(user).toBeValidUser();\n  return true;\n};\n\nexport const _assertValidTheme = (theme: any): theme is TestTheme => {\n  expect(theme).toBeValidTheme();\n  return true;\n};\n\nexport const _assertAccessible = (element: HTMLElement) => {\n  expect(element).toHaveAccessibilityAttributes();\n};\n\nexport const _assertResponsive = (element: HTMLElement) => {\n  expect(element).toBeResponsive();\n};\n\nexport const _assertNoErrors = async (fn: () => Promise<any> | any) => {\n  expect(fn).toHandleErrors();\n};\n\nexport const _assertFastLoad = async (\n  fn: () => Promise<any>,\n  maxTime: number = 1000\n) => {\n  expect(fn).toLoadWithinTime(maxTime);\n};\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/backend/api.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/triple-slash-reference",
        "severity": 2,
        "message": "Do not use a triple slash reference for ../vite-env.d.ts, use `import` style instead.",
        "line": 1,
        "column": 1,
        "nodeType": "Line",
        "messageId": "tripleSlashReference",
        "endLine": 1,
        "endColumn": 42
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference path=\"../vite-env.d.ts\" />\n// Enhanced API worker for Relife Alarms with Battle System and Performance Monitoring\n// This runs on Cloudflare Workers at the edge\n\n// Import monitoring integration\nimport { MonitoringIntegrationService } from './monitoring-integration';\n\n// Import types from the main application\nimport type { User, UserPreferences as _UserPreferences, VoiceMood, D1Database, KVNamespace, R2Bucket, PersonalizationSettings } from '../types/index';\n\n// Default personalization settings for new users\nconst defaultPersonalizationSettings: PersonalizationSettings = {\n  theme: 'light',\n  colorPreferences: {\n    favoriteColors: [],\n    avoidColors: [],\n    colorblindFriendly: false,\n    highContrastMode: false,\n    saturationLevel: 50,\n    brightnessLevel: 50,\n    warmthLevel: 50\n  },\n  typographyPreferences: {\n    preferredFontSize: 'medium',\n    fontSizeScale: 1.0,\n    preferredFontFamily: 'system',\n    lineHeightPreference: 'comfortable',\n    letterSpacingPreference: 'normal',\n    fontWeight: 'normal',\n    dyslexiaFriendly: false\n  },\n  motionPreferences: {\n    enableAnimations: true,\n    animationSpeed: 'normal',\n    reduceMotion: false,\n    preferCrossfade: false,\n    enableParallax: true,\n    enableHoverEffects: true,\n    enableFocusAnimations: true\n  },\n  soundPreferences: {\n    enableSounds: true,\n    soundVolume: 75,\n    soundTheme: 'default',\n    customSounds: {},\n    muteOnFocus: false,\n    hapticFeedback: true,\n    spatialAudio: false\n  },\n  layoutPreferences: {\n    density: 'comfortable',\n    navigation: 'bottom',\n    cardStyle: 'elevated',\n    borderRadius: 'rounded',\n    showLabels: true,\n    showIcons: true,\n    iconSize: 'medium',\n    gridColumns: 2,\n    listSpacing: 'normal'\n  },\n  accessibilityPreferences: {\n    screenReaderOptimized: false,\n    keyboardNavigationOnly: false,\n    highContrastMode: false,\n    largeTargets: false,\n    reducedTransparency: false,\n    boldText: false,\n    underlineLinks: false,\n    flashingElementsReduced: false,\n    colorOnlyIndicators: false,\n    focusIndicatorStyle: 'outline'\n  },\n  lastUpdated: new Date(),\n  syncAcrossDevices: true\n};\n\ninterface Alarm {\n  id: string;\n  userId: string;\n  time: string;\n  label: string;\n  enabled: boolean;\n  days: number[];\n  voiceMood: string;\n  sound: string;\n  difficulty: string;\n  battleId?: string;\n  createdAt: string;\n}\n\ninterface Battle {\n  id: string;\n  type: string;\n  participants: BattleParticipant[];\n  creatorId: string;\n  status: string;\n  startTime: string;\n  endTime: string;\n  settings: BattleSettings;\n  winner?: string;\n  maxParticipants?: number;\n  entryFee?: number;\n  createdAt: string;\n}\n\ninterface BattleParticipant {\n  userId: string;\n  joinedAt: string;\n  status: string;\n  score: number;\n  wakeTime: string | null;\n  completedTasks: string[];\n}\n\ninterface BattleSettings {\n  wakeWindow: number;\n  allowSnooze: boolean;\n  maxSnoozes: number;\n  difficulty: string;\n  weatherBonus: boolean;\n  taskChallenge: boolean;\n}\n\ninterface Tournament {\n  id: string;\n  name: string;\n  description: string;\n  type: string;\n  status: string;\n  participants: any[];\n  maxParticipants: number;\n  entryFee: number;\n  startTime: string;\n  endTime: string;\n  createdAt: string;\n}\n\n// Mock data - in production, you'd use a database like D1 or KV\nconst mockUsers: User[] = [\n  {\n    id: '1',\n    name: 'Alice Johnson',\n    email: 'alice@example.com',\n    username: 'alice_wake',\n    displayName: 'Alice Johnson',\n    avatar: 'https://api.dicebear.com/7.x/avatars/svg?seed=alice',\n    level: 5,\n    experience: 1250,\n    joinDate: '2024-01-01',\n    lastActive: new Date().toISOString(),\n    preferences: {\n      personalization: { ...defaultPersonalizationSettings, theme: 'system' },\n      theme: 'system',\n      soundEnabled: true,\n      notificationsEnabled: true,\n      voiceDismissalSensitivity: 5,\n      defaultVoiceMood: 'motivational' as VoiceMood,\n      hapticFeedback: true,\n      snoozeMinutes: 5,\n      maxSnoozes: 3,\n      rewardsEnabled: true,\n      aiInsightsEnabled: true,\n      personalizedMessagesEnabled: true,\n      shareAchievements: true\n    },\n    subscriptionTier: 'premium',\n    createdAt: \"2024-01-01\"\n  },\n  {\n    id: '2',\n    name: 'Bob Smith',\n    email: 'bob@example.com',\n    username: 'bob_early',\n    displayName: 'Bob Smith',\n    avatar: 'https://api.dicebear.com/7.x/avatars/svg?seed=bob',\n    level: 3,\n    experience: 750,\n    joinDate: '2024-01-02',\n    lastActive: '2024-01-02',\n    preferences: {\n      personalization: { ...defaultPersonalizationSettings, theme: 'light' },\n      theme: 'light',\n      soundEnabled: true,\n      notificationsEnabled: true,\n      voiceDismissalSensitivity: 7,\n      defaultVoiceMood: 'drill-sergeant' as VoiceMood,\n      hapticFeedback: true,\n      snoozeMinutes: 3,\n      maxSnoozes: 2,\n      rewardsEnabled: true,\n      aiInsightsEnabled: true,\n      personalizedMessagesEnabled: true,\n      shareAchievements: false\n    },\n    subscriptionTier: 'free',\n    createdAt: \"2024-01-02\"\n  },\n];\n\nconst mockAlarms: Alarm[] = [\n  {\n    id: 'alarm_1',\n    userId: '1',\n    time: '07:00',\n    label: 'Morning Workout',\n    enabled: true,\n    days: [1, 2, 3, 4, 5],\n    voiceMood: \"drill-sergeant\",\n    sound: \"default\",\n    difficulty: \"medium\",\n    battleId: \"battle_1\",\n    createdAt: \"2024-01-01\"\n  },\n];\n\nconst mockBattles: Battle[] = [\n  {\n    id: 'battle_1',\n    type: 'speed',\n    participants: [\n      {\n        userId: '1',\n        joinedAt: '2024-01-01T08:00:00Z',\n        status: 'joined',\n        score: 0,\n        wakeTime: null,\n        completedTasks: []\n      }\n    ],\n    creatorId: '1',\n    status: 'registration',\n    startTime: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\n    endTime: new Date(Date.now() + 25 * 60 * 60 * 1000).toISOString(),\n    settings: {\n      wakeWindow: 30,\n      allowSnooze: false,\n      maxSnoozes: 0,\n      difficulty: 'medium',\n      weatherBonus: false,\n      taskChallenge: false\n    },\n    maxParticipants: 10,\n    entryFee: 50,\n    createdAt: \"2024-01-01\"\n  }\n];\n\nconst mockTournaments: Tournament[] = [\n  {\n    id: 'tournament_1',\n    name: 'Weekly Wake Challenge',\n    description: 'Who can wake up most consistently this week?',\n    type: 'round-robin',\n    status: 'registration',\n    participants: [],\n    maxParticipants: 16,\n    entryFee: 100,\n    startTime: new Date(Date.now() + 48 * 60 * 60 * 1000).toISOString(),\n    endTime: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),\n    createdAt: \"2024-01-01\"\n  }\n];\n\n// Helper function for CORS headers\nfunction corsHeaders(origin: string): HeadersInit {\n  return {\n    'Access-Control-Allow-Origin': origin || '*',\n    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n    'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n    'Content-Type': 'application/json',\n  };\n}\n\n// Main worker handler with performance monitoring integration\nexport default {\n  async fetch(request: Request, env: Env): Promise<Response> {\n    const url = new URL(request.url);\n    const method = request.method;\n    const origin = request.headers.get('Origin') || '*';\n\n    // Handle CORS preflight\n    if (method === 'OPTIONS') {\n      return new Response(null, { headers: corsHeaders(origin) });\n    }\n\n    // Route performance monitoring requests\n    if (url.pathname.startsWith('/api/performance/') ||\n        url.pathname.startsWith('/api/analytics/') ||\n        url.pathname.startsWith('/api/monitoring/') ||\n        url.pathname.startsWith('/api/external-monitoring/') ||\n        url.pathname.startsWith('/api/deployment/')) {\n      const monitoringService = new MonitoringIntegrationService(env);\n      return await monitoringService.handleMonitoringRequest(request);\n    }\n\n    // Router - match paths and methods\n    try {\n      // GET /api/health - Health check endpoint\n      if (url.pathname === '/api/health' && method === 'GET') {\n        return Response.json(\n          {\n            status: 'healthy',\n            timestamp: new Date().toISOString(),\n            version: \"1.0.0\"\n          },\n          { headers: corsHeaders(origin) }\n        );\n      }\n\n      // GET /api/users - List all users with battle stats\n      if (url.pathname === \"/api/users\" && method === \"GET\") {\n        const enhancedUsers = mockUsers.map(user => ({\n          ...user,\n          battlesWon: mockBattles.filter(b => b.winner === user.id).length,\n          totalBattles: mockBattles.filter(b => b.participants.some(p => p.userId === user.id)).length\n        }));\n\n        return Response.json(\n          { users: enhancedUsers },\n          { headers: corsHeaders(origin) }\n        );\n      }\n\n      // GET /api/users/:id - Get specific user\n      const userMatch = url.pathname.match(/^\\/api\\/users\\/(\\d+)$/);\n      if (userMatch && method === 'GET') {\n        const userId = userMatch[1];\n        const user = mockUsers.find(u => u.id === userId);\n\n        if (!user) {\n          return Response.json(\n            { error: \"User not found\" },\n            { status: 404, headers: corsHeaders(origin) }\n          );\n        }\n\n        return Response.json(\n          { user },\n          { headers: corsHeaders(origin) }\n        );\n      }\n\n      // POST /api/users - Create new user\n      if (url.pathname === \"/api/users\" && method === \"POST\") {\n        const body = await request.json() as Partial<User>;\n\n        // Validate input\n        if (!body.name || !body.email) {\n          return Response.json(\n            { error: \"Name and email are required\" },\n            { status: 400, headers: corsHeaders(origin) }\n          );\n        }\n\n        const newUser: User = {\n          id: String(mockUsers.length + 1),\n          name: body.name,\n          email: body.email,\n          username: body.name.toLowerCase().replace(/\\s+/g, '.'),\n          displayName: body.name,\n          level: 1,\n          experience: 0,\n          joinDate: new Date().toISOString(),\n          lastActive: new Date().toISOString(),\n          preferences: {\n            personalization: { ...defaultPersonalizationSettings, theme: 'system' },\n            theme: 'system',\n            soundEnabled: true,\n            notificationsEnabled: true,\n            voiceDismissalSensitivity: 5,\n            defaultVoiceMood: 'motivational' as VoiceMood,\n            hapticFeedback: true,\n            snoozeMinutes: 5,\n            maxSnoozes: 3,\n            rewardsEnabled: true,\n            aiInsightsEnabled: true,\n            personalizedMessagesEnabled: true,\n            shareAchievements: true\n          },\n          subscriptionTier: 'free',\n          createdAt: new Date().toISOString(),\n        };\n\n        // In production, you'd save to database here\n        mockUsers.push(newUser);\n\n        return Response.json(\n          { user: newUser },\n          { status: 201, headers: corsHeaders(origin) }\n        );\n      }\n\n      // GET /api/alarms - List alarms with optional filtering\n      if (url.pathname === '/api/alarms' && method === 'GET') {\n        const userId = url.searchParams.get('userId');\n        const enabled = url.searchParams.get('enabled');\n        const withBattles = url.searchParams.get('withBattles');\n\n        let filteredAlarms = mockAlarms;\n\n        if (userId) {\n          filteredAlarms = filteredAlarms.filter(a => a.userId === userId);\n        }\n\n        if (enabled !== null) {\n          filteredAlarms = filteredAlarms.filter(a => a.enabled === (enabled === \"true\"));\n        }\n\n        if (withBattles === \"true\") {\n          filteredAlarms = filteredAlarms.filter(a => a.battleId);\n        }\n\n        return Response.json(\n          { alarms: filteredAlarms },\n          { headers: corsHeaders(origin) }\n        );\n      }\n\n      // POST /api/alarms - Create new alarm\n      if (url.pathname === \"/api/alarms\" && method === \"POST\") {\n        const body = await request.json() as Partial<Alarm>;\n\n        // Validate input\n        if (!body.userId || !body.time || !body.label) {\n          return Response.json(\n            { error: \"UserId, time, and label are required\" },\n            { status: 400, headers: corsHeaders(origin) }\n          );\n        }\n\n        const newAlarm: Alarm = {\n          id: `alarm_${Date.now()}`,\n          userId: body.userId,\n          time: body.time,\n          label: body.label,\n          enabled: body.enabled ?? true,\n          days: body.days ?? [1, 2, 3, 4, 5, 6, 0],\n          voiceMood: body.voiceMood ?? 'motivational',\n          sound: body.sound ?? 'default',\n          difficulty: body.difficulty ?? 'medium',\n          battleId: body.battleId,\n          createdAt: new Date().toISOString(),\n        };\n\n        mockAlarms.push(newAlarm);\n\n        return Response.json(\n          { alarm: newAlarm },\n          { status: 201, headers: corsHeaders(origin) }\n        );\n      }\n\n      // GET /api/battles - List battles with optional filtering\n      if (url.pathname === '/api/battles' && method === 'GET') {\n        const type = url.searchParams.get('type');\n        const status = url.searchParams.get('status');\n        const userId = url.searchParams.get('userId');\n\n        let filteredBattles = mockBattles;\n\n        if (type) {\n          filteredBattles = filteredBattles.filter(b => b.type === type);\n        }\n\n        if (status) {\n          filteredBattles = filteredBattles.filter(b => b.status === status);\n        }\n\n        if (userId) {\n          filteredBattles = filteredBattles.filter(b =>\n            b.creatorId === userId || b.participants.some(p => p.userId === userId)\n          );\n        }\n\n        return Response.json(\n          { battles: filteredBattles },\n          { headers: corsHeaders(origin) }\n        );\n      }\n\n      // POST /api/battles - Create new battle\n      if (url.pathname === \"/api/battles\" && method === \"POST\") {\n        const body = await request.json() as Partial<Battle>;\n\n        // Validate input\n        if (!body.type || !body.creatorId || !body.startTime || !body.endTime) {\n          return Response.json(\n            { error: \"Type, creatorId, startTime, and endTime are required\" },\n            { status: 400, headers: corsHeaders(origin) }\n          );\n        }\n\n        const newBattle: Battle = {\n          id: `battle_${Date.now()}`,\n          type: body.type,\n          participants: [],\n          creatorId: body.creatorId,\n          status: 'registration',\n          startTime: body.startTime,\n          endTime: body.endTime,\n          settings: body.settings ?? {\n            wakeWindow: 30,\n            allowSnooze: false,\n            maxSnoozes: 0,\n            difficulty: 'medium',\n            weatherBonus: false,\n            taskChallenge: false\n          },\n          maxParticipants: body.maxParticipants,\n          entryFee: body.entryFee,\n          createdAt: new Date().toISOString(),\n        };\n\n        mockBattles.push(newBattle);\n\n        return Response.json(\n          { battle: newBattle },\n          { status: 201, headers: corsHeaders(origin) }\n        );\n      }\n\n      // GET /api/battles/:id - Get specific battle\n      const battleMatch = url.pathname.match(/^\\/api\\/battles\\/([^/]+)$/);\n      if (battleMatch && method === 'GET') {\n        const battleId = battleMatch[1];\n        const battle = mockBattles.find(b => b.id === battleId);\n\n        if (!battle) {\n          return Response.json(\n            { error: \"Battle not found\" },\n            { status: 404, headers: corsHeaders(origin) }\n          );\n        }\n\n        return Response.json(\n          { battle },\n          { headers: corsHeaders(origin) }\n        );\n      }\n\n      // POST /api/battles/:id/join - Join battle\n      const joinBattleMatch = url.pathname.match(/^\\/api\\/battles\\/([^/]+)\\/join$/);\n      if (joinBattleMatch && method === \"POST\") {\n        const battleId = joinBattleMatch[1];\n        const body = await request.json() as { userId: string };\n\n        const battle = mockBattles.find(b => b.id === battleId);\n\n        if (!battle) {\n          return Response.json(\n            { error: \"Battle not found\" },\n            { status: 404, headers: corsHeaders(origin) }\n          );\n        }\n\n        if (battle.status !== 'registration') {\n          return Response.json(\n            { error: \"Battle registration is closed\" },\n            { status: 400, headers: corsHeaders(origin) }\n          );\n        }\n\n        if (battle.maxParticipants && battle.participants.length >= battle.maxParticipants) {\n          return Response.json(\n            { error: \"Battle is full\" },\n            { status: 400, headers: corsHeaders(origin) }\n          );\n        }\n\n        const isAlreadyParticipant = battle.participants.some(p => p.userId === body.userId);\n        if (isAlreadyParticipant) {\n          return Response.json(\n            { error: \"User already in battle\" },\n            { status: 400, headers: corsHeaders(origin) }\n          );\n        }\n\n        const participant: BattleParticipant = {\n          userId: body.userId,\n          joinedAt: new Date().toISOString(),\n          status: 'joined',\n          score: 0,\n          wakeTime: null,\n          completedTasks: []\n        };\n\n        battle.participants.push(participant);\n\n        return Response.json(\n          { success: true, battle },\n          { headers: corsHeaders(origin) }\n        );\n      }\n\n      // GET /api/tournaments - List tournaments\n      if (url.pathname === '/api/tournaments' && method === 'GET') {\n        const status = url.searchParams.get('status');\n\n        let filteredTournaments = mockTournaments;\n\n        if (status) {\n          filteredTournaments = filteredTournaments.filter(t => t.status === status);\n        }\n\n        return Response.json(\n          { tournaments: filteredTournaments },\n          { headers: corsHeaders(origin) }\n        );\n      }\n\n      // POST /api/battles/:id/wake - Record wake up time\n      const wakeMatch = url.pathname.match(/^\\/api\\/battles\\/([^/]+)\\/wake$/);\n      if (wakeMatch && method === 'POST') {\n        const battleId = wakeMatch[1];\n        const body = await request.json() as { userId: string; wakeTime: string };\n\n        const battle = mockBattles.find(b => b.id === battleId);\n\n        if (!battle) {\n          return Response.json(\n            { error: \"Battle not found\" },\n            { status: 404, headers: corsHeaders(origin) }\n          );\n        }\n\n        const participant = battle.participants.find(p => p.userId === body.userId);\n        if (!participant) {\n          return Response.json(\n            { error: \"User not in battle\" },\n            { status: 404, headers: corsHeaders(origin) }\n          );\n        }\n\n        participant.wakeTime = body.wakeTime;\n\n        // Calculate score based on wake time\n        const targetTime = new Date(battle.startTime);\n        const actualWakeTime = new Date(body.wakeTime);\n        const diffMinutes = Math.abs((actualWakeTime.getTime() - targetTime.getTime()) / 60000);\n        participant.score = Math.max(0, 100 - diffMinutes);\n\n        return Response.json(\n          { success: true, score: participant.score },\n          { headers: corsHeaders(origin) }\n        );\n      }\n\n      // GET /api/users/:id/stats - Get user battle statistics\n      const userStatsMatch = url.pathname.match(/^\\/api\\/users\\/([^/]+)\\/stats$/);\n      if (userStatsMatch && method === \"GET\") {\n        const userId = userStatsMatch[1];\n\n        const userBattles = mockBattles.filter(b =>\n          b.participants.some(p => p.userId === userId) && b.status === \"completed\"\n        );\n\n        const wins = mockBattles.filter(b => b.winner === userId).length;\n        const totalBattles = userBattles.length;\n        const winRate = totalBattles > 0 ? (wins / totalBattles) * 100 : 0;\n\n        const stats = {\n          totalBattles,\n          wins,\n          losses: totalBattles - wins,\n          winRate: Math.round(winRate),\n          averageScore: 0, // Would calculate from participant scores\n          currentStreak: 0, // Would track current win streak\n          longestStreak: 0 // Would track longest win streak\n        };\n\n        return Response.json(\n          { stats },\n          { headers: corsHeaders(origin) }\n        );\n      }\n\n      // POST /api/echo - Echo endpoint for testing\n      if (url.pathname === '/api/echo' && method === 'POST') {\n        const body = await request.json();\n        return Response.json(\n          {\n            echo: body,\n            headers: Object.fromEntries(request.headers.entries()),\n            timestamp: new Date().toISOString()\n          },\n          { headers: corsHeaders(origin) }\n        );\n      }\n\n      // 404 for unmatched routes\n      return Response.json(\n        { error: \"Not Found\", path: url.pathname },\n        { status: 404, headers: corsHeaders(origin) }\n      );\n\n    } catch (error) {\n      console.error('API Error:', error);\n      return Response.json(\n        { error: \"Internal Server Error\" },\n        { status: 500, headers: corsHeaders(origin) }\n      );\n    }\n  }\n};\n\n// Environment bindings interface for enhanced monitoring\ninterface Env {\n  // Database connections\n  DB: D1Database;                    // For SQL database\n  KV: KVNamespace;                   // For key-value storage\n  BUCKET?: R2Bucket;                 // For file storage\n\n  // API Keys and secrets\n  API_KEY?: string;                  // For general API access\n  JWT_SECRET: string;                // For JWT token signing\n\n  // Database connections\n  SUPABASE_URL: string;              // Supabase URL\n  SUPABASE_KEY: string;              // Supabase API key\n  SUPABASE_SERVICE_KEY: string;      // Supabase service role key\n\n  // External monitoring services\n  POSTHOG_API_KEY?: string;          // PostHog analytics\n  SENTRY_DSN?: string;               // Sentry error tracking\n  DATADOG_API_KEY?: string;          // DataDog monitoring\n  NEWRELIC_API_KEY?: string;         // New Relic APM\n  AMPLITUDE_API_KEY?: string;        // Amplitude analytics\n\n  // Configuration\n  ENVIRONMENT: string;               // Environment (dev/staging/prod)\n}\n\n// Available API Endpoints:\n//\n// Core Application Endpoints:\n// GET  /api/health - Health check\n// GET  /api/users - List users with battle stats\n// GET  /api/users/:id - Get specific user\n// POST /api/users - Create new user\n// GET  /api/users/:id/stats - Get user battle statistics\n// GET  /api/alarms - List alarms (with userId, enabled, withBattles filters)\n// POST /api/alarms - Create new alarm\n// GET  /api/battles - List battles (with type, status, userId filters)\n// POST /api/battles - Create new battle\n// GET  /api/battles/:id - Get specific battle\n// POST /api/battles/:id/join - Join battle\n// POST /api/battles/:id/wake - Record wake up time\n// GET  /api/tournaments - List tournaments (with status filter)\n// POST /api/echo - Echo endpoint for testing\n//\n// Performance Monitoring Endpoints:\n// POST /api/performance/metrics - Collect performance metrics\n// POST /api/performance/web-vitals - Collect Web Vitals data\n// POST /api/performance/errors - Log application errors\n// POST /api/performance/analytics - Track analytics events\n// GET  /api/performance/dashboard - Get performance dashboard\n// GET  /api/performance/user-metrics - Get user-specific metrics\n// GET  /api/performance/system-health - Get system health status\n// GET  /api/performance/real-time - Get real-time metrics\n// GET  /api/performance/trends - Get performance trends\n// GET  /api/performance/anomalies - Detect performance anomalies\n// GET  /api/performance/recommendations - Get optimization recommendations\n// GET  /api/performance/health - Performance monitoring health check\n//\n// External Service Integration Endpoints:\n// POST /api/external-monitoring/datadog/metrics - Forward metrics to DataDog\n// POST /api/external-monitoring/newrelic/events - Forward events to New Relic\n// POST /api/external-monitoring/amplitude/events - Forward events to Amplitude\n// POST /api/external-monitoring/webhook/alerts - Handle external alert webhooks\n//\n// Deployment Monitoring Endpoints:\n// POST /api/deployment/track - Track deployment events\n// GET  /api/deployment/metrics - Get deployment metrics\n// POST /api/deployment/health - Track deployment health\n// GET  /api/deployment/status - Get deployment status",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/backend/cloudflare-functions.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'D1Database' is not defined.",
        "line": 33,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 33,
        "endColumn": 17
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'KVNamespace' is not defined.",
        "line": 34,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 34,
        "endColumn": 18
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'DurableObjectNamespace' is not defined.",
        "line": 35,
        "column": 20,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 35,
        "endColumn": 42
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Enhanced Cloudflare Worker Functions for Relife Smart Alarm\n// Advanced cloud functions for real-time analytics, notifications, and AI processing\n\n// Using official @cloudflare/workers-types\nimport {\n  DatabaseUser,\n  DatabaseAlarm,\n  DatabaseAlarmEvent,\n  DatabaseAnalyticsEvent,\n  DatabaseUserStats,\n  DatabaseEmotionalProfile,\n  DatabaseBattleStats,\n  DatabasePerformanceMetric,\n  DatabaseDeploymentData,\n  DatabaseHealthData,\n  DatabaseAIResponse,\n  DatabaseRecommendation,\n  DatabaseVoiceAnalysis,\n  DatabaseQueryResult,\n  isDatabaseUser,\n  isDatabaseAlarm,\n  isDatabaseAlarmEvent,\n  isNumeric,\n  isStringValue,\n  asNumber,\n  asString,\n  asObject\n} from './database-types';\n\n// Environment bindings interface\ninterface Env {\n  // Database connections\n  DB: D1Database;           // D1 SQL database\n  KV: KVNamespace;          // Key-value storage for caching\n  DURABLE_OBJECTS: DurableObjectNamespace; // For real-time features\n\n  // External service keys\n  SUPABASE_URL: string;\n  SUPABASE_SERVICE_KEY: string;\n  ELEVENLABS_API_KEY: string;\n  OPENAI_API_KEY: string;\n  PUSH_PUBLIC_KEY: string;\n  PUSH_PRIVATE_KEY: string;\n\n  // Configuration\n  ENVIRONMENT: string;\n  JWT_SECRET: string;\n}\n\n// Real-time alarm trigger processing\nexport class AlarmTriggerProcessor {\n  private env: Env;\n\n  constructor(env: Env) {\n    this.env = env;\n  }\n\n  // Process alarm trigger with advanced analytics\n  async processAlarmTrigger(alarmData: {\n    alarmId: string;\n    userId: string;\n    triggeredAt: string;\n    deviceInfo: any;\n    context: any;\n  }): Promise<Response> {\n    try {\n      const startTime = Date.now();\n\n      // Store trigger event with detailed context\n      await this.storeAlarmEvent(alarmData);\n\n      // Update real-time analytics\n      await this.updateRealtimeAnalytics(alarmData);\n\n      // Generate personalized wake-up content\n      const personalizedContent = await this.generatePersonalizedContent(alarmData);\n\n      // Send push notification if needed\n      await this.sendPushNotification(alarmData);\n\n      // Update user's sleep pattern analysis\n      await this.updateSleepPatternAnalysis(alarmData);\n\n      const processingTime = Date.now() - startTime;\n\n      return Response.json({\n        success: true,\n        personalizedContent,\n        processingTime,\n        timestamp: new Date().toISOString()\n      });\n\n    } catch (error) {\n      console.error('Error processing alarm trigger:', error);\n      return Response.json({\n        success: false,\n        error: 'Failed to process alarm trigger'\n      }, { status: 500 });\n    }\n  }\n\n  private async storeAlarmEvent(alarmData: any): Promise<void> {\n    const event = {\n      id: `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n      alarm_id: alarmData.alarmId,\n      fired_at: alarmData.triggeredAt,\n      device_type: alarmData.deviceInfo.type,\n      network_type: alarmData.deviceInfo.networkType,\n      battery_level: alarmData.deviceInfo.batteryLevel,\n      ambient_light: alarmData.context.ambientLight,\n      sleep_stage: alarmData.context.sleepStage || 'unknown',\n      app_load_time: alarmData.context.appLoadTime,\n      created_at: new Date().toISOString()\n    };\n\n    // Store in both D1 and cache in KV for quick access\n    await this.env.DB.prepare(`\n      INSERT INTO alarm_events\n      (id, alarm_id, fired_at, device_type, network_type, battery_level,\n       ambient_light, sleep_stage, app_load_time, created_at)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `).bind(\n      event.id, event.alarm_id, event.fired_at, event.device_type,\n      event.network_type, event.battery_level, event.ambient_light,\n      event.sleep_stage, event.app_load_time, event.created_at\n    ).run();\n\n    // Cache recent events for quick access\n    const cacheKey = `events:${alarmData.userId}:recent`;\n    await this.env.KV.put(cacheKey, JSON.stringify(event), { expirationTtl: 3600 });\n  }\n\n  private async updateRealtimeAnalytics(alarmData: any): Promise<void> {\n    const analyticsData = {\n      userId: alarmData.userId,\n      timestamp: Date.now(),\n      metric: 'alarm_triggered',\n      value: 1,\n      context: alarmData.context,\n      deviceInfo: alarmData.deviceInfo\n    };\n\n    // Update real-time analytics in KV store\n    const analyticsKey = `analytics:${alarmData.userId}:${new Date().toISOString().split('T')[0]}`;\n    const existingData = await this.env.KV.get(analyticsKey, 'json');\n    const existing = existingData && typeof existingData === 'object' ?\n      existingData as { events: any[], totalTriggers: number, lastUpdated?: string } :\n      { events: [], totalTriggers: 0 };\n\n    existing.events.push(analyticsData);\n    existing.totalTriggers += 1;\n    existing.lastUpdated = new Date().toISOString();\n\n    await this.env.KV.put(analyticsKey, JSON.stringify(existing), { expirationTtl: 86400 * 7 });\n  }\n\n  private async generatePersonalizedContent(alarmData: any): Promise<any> {\n    try {\n      // Get user's historical data for personalization\n      const userHistory = await this.getUserAlarmHistory(alarmData.userId);\n      const sleepPattern = await this.getUserSleepPattern(alarmData.userId);\n\n      // Generate personalized wake-up message using AI\n      const personalizedMessage = await this.generateAIWakeupMessage({\n        userHistory,\n        sleepPattern,\n        currentContext: alarmData.context,\n        timeOfDay: new Date().getHours()\n      });\n\n      // Get optimal voice settings for user\n      const voiceSettings = await this.getOptimalVoiceSettings(alarmData.userId, alarmData.context);\n\n      return {\n        message: personalizedMessage,\n        voiceSettings,\n        escalationStrategy: await this.getOptimalEscalationStrategy(alarmData.userId),\n        motivationalBoost: await this.getMotivationalContent(alarmData.userId)\n      };\n\n    } catch (error) {\n      console.error('Error generating personalized content:', error);\n      return {\n        message: \"Time to wake up! You've got this!\",\n        voiceSettings: { mood: 'motivational', rate: 1.0, pitch: 1.0 }\n      };\n    }\n  }\n\n  private async generateAIWakeupMessage(context: any): Promise<string> {\n    if (!this.env.OPENAI_API_KEY) {\n      return 'Rise and shine! Time to start your amazing day!';\n    }\n\n    try {\n      const prompt = `Generate a personalized wake-up message for someone with these characteristics:\n      - Sleep pattern: ${JSON.stringify(context.sleepPattern)}\n      - Time of day: ${context.timeOfDay}\n      - Recent alarm history: ${context.userHistory.recentEffectiveness || 'unknown'}\n      - Current context: ${JSON.stringify(context.currentContext)}\n\n      Make it motivating, personalized, and appropriate for the time of day. Keep it under 50 words.`;\n\n      const response = await fetch('https://api.openai.com/v1/chat/completions', {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.env.OPENAI_API_KEY}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          model: 'gpt-3.5-turbo',\n          messages: [{ role: 'user', content: prompt }],\n          max_tokens: 100,\n          temperature: 0.8,\n        }),\n      });\n\n      const data = await response.json() as DatabaseAIResponse;\n      return data.choices?.[0]?.message?.content || \"Time to wake up and seize the day!\";\n\n    } catch (error) {\n      console.error('AI message generation failed:', error);\n      return \"Time to wake up and seize the day!\";\n    }\n  }\n\n  private async getUserAlarmHistory(userId: string): Promise<any> {\n    const cacheKey = `history:${userId}`;\n    const cached = await this.env.KV.get(cacheKey, 'json');\n\n    if (cached) {\n      return cached;\n    }\n\n    // Query recent alarm history from database\n    const history = await this.env.DB.prepare(`\n      SELECT\n        AVG(effectiveness_rating) as avg_effectiveness,\n        AVG(response_time) as avg_response_time,\n        COUNT(*) as total_alarms,\n        COUNT(CASE WHEN dismissed = true THEN 1 END) as dismissed_count\n      FROM alarm_events ae\n      JOIN alarms a ON ae.alarm_id = a.id\n      WHERE a.user_id = ? AND ae.fired_at > datetime('now', '-30 days')\n    `).bind(userId).first();\n\n    const historyData = {\n      avgEffectiveness: asNumber(history?.avg_effectiveness, 0),\n      avgResponseTime: asNumber(history?.avg_response_time, 0),\n      totalAlarms: asNumber(history?.total_alarms, 0),\n      successRate: history ? (asNumber(history.dismissed_count, 0) / asNumber(history.total_alarms, 1)) : 0\n    };\n\n    // Cache for 1 hour\n    await this.env.KV.put(cacheKey, JSON.stringify(historyData), { expirationTtl: 3600 });\n\n    return historyData;\n  }\n\n  private async getUserSleepPattern(userId: string): Promise<any> {\n    const cacheKey = `sleep_pattern:${userId}`;\n    const cached = await this.env.KV.get(cacheKey, 'json');\n\n    if (cached) {\n      return cached;\n    }\n\n    // Query sleep pattern from database\n    const sleepData = await this.env.DB.prepare(`\n      SELECT\n        AVG(total_duration) as avg_sleep_duration,\n        AVG(sleep_efficiency) as avg_efficiency,\n        AVG(restfulness_score) as avg_quality\n      FROM sleep_sessions\n      WHERE user_id = ? AND sleep_start > datetime('now', '-14 days')\n    `).bind(userId).first();\n\n    const patternData = {\n      avgDuration: sleepData?.avg_sleep_duration || 480, // 8 hours default\n      avgEfficiency: sleepData?.avg_efficiency || 85,\n      avgQuality: sleepData?.avg_quality || 75\n    };\n\n    // Cache for 6 hours\n    await this.env.KV.put(cacheKey, JSON.stringify(patternData), { expirationTtl: 21600 });\n\n    return patternData;\n  }\n\n  private async getOptimalVoiceSettings(userId: string, _context: any): Promise<any> {\n    // Get user's most effective voice settings based on history\n    const effectiveSettings = await this.env.DB.prepare(`\n      SELECT uv.voice_mood, uv.speech_rate, uv.pitch, uv.volume,\n             AVG(ae.effectiveness_rating) as effectiveness\n      FROM user_voices uv\n      JOIN alarms a ON a.voice_mood = uv.voice_mood AND a.user_id = uv.user_id\n      JOIN alarm_events ae ON ae.alarm_id = a.id\n      WHERE uv.user_id = ? AND ae.fired_at > datetime('now', '-30 days')\n      GROUP BY uv.voice_mood, uv.speech_rate, uv.pitch, uv.volume\n      ORDER BY effectiveness DESC\n      LIMIT 1\n    `).bind(userId).first();\n\n    return effectiveSettings || {\n      voice_mood: 'motivational',\n      speech_rate: 1.0,\n      pitch: 1.0,\n      volume: 0.8\n    };\n  }\n\n  private async getOptimalEscalationStrategy(userId: string): Promise<any> {\n    // Determine optimal escalation based on user's response patterns\n    const responsePatterns = await this.env.DB.prepare(`\n      SELECT\n        AVG(response_time) as avg_response_time,\n        COUNT(CASE WHEN response_time <= 30 THEN 1 END) as quick_responses,\n        COUNT(*) as total_responses\n      FROM alarm_events\n      WHERE alarm_id IN (\n        SELECT id FROM alarms WHERE user_id = ?\n      ) AND fired_at > datetime('now', '-30 days')\n      AND response_time IS NOT NULL\n    `).bind(userId).first();\n\n    const avgResponseTime = asNumber(responsePatterns?.avg_response_time, 60);\n    const quickResponseRate = responsePatterns ?\n      (asNumber(responsePatterns.quick_responses, 0) / asNumber(responsePatterns.total_responses, 1)) : 0.5;\n\n    // Adjust escalation based on user patterns\n    let escalationSteps;\n    if (quickResponseRate > 0.8) {\n      // User responds quickly, use gentle escalation\n      escalationSteps = [\n        { delay: 30, volume: 0.6, vibration: false },\n        { delay: 90, volume: 0.8, vibration: true },\n        { delay: 180, volume: 1.0, vibration: true, flashlight: true }\n      ];\n    } else if (quickResponseRate < 0.3) {\n      // User responds slowly, use aggressive escalation\n      escalationSteps = [\n        { delay: 15, volume: 0.8, vibration: true },\n        { delay: 45, volume: 1.0, vibration: true, flashlight: true },\n        { delay: 90, volume: 1.0, vibration: true, flashlight: true, repeat: true }\n      ];\n    } else {\n      // Standard escalation\n      escalationSteps = [\n        { delay: 30, volume: 0.7, vibration: false },\n        { delay: 75, volume: 0.9, vibration: true },\n        { delay: 150, volume: 1.0, vibration: true, flashlight: true }\n      ];\n    }\n\n    return { steps: escalationSteps, avgResponseTime, quickResponseRate };\n  }\n\n  private async getMotivationalContent(userId: string): Promise<any> {\n    // Get user's goals and preferences for motivational content\n    const userPrefs = await this.env.DB.prepare(`\n      SELECT preferences, ai_settings\n      FROM users\n      WHERE id = ?\n    `).bind(userId).first();\n\n    const _preferences = userPrefs ? JSON.parse(asString(userPrefs.preferences, '{}')) : {};\n    const aiSettings = userPrefs ? JSON.parse(asString(userPrefs.ai_settings, '{}')) : {};\n\n    if (!aiSettings.moodBasedAlarms) {\n      return { enabled: false };\n    }\n\n    // Generate contextual motivational boost\n    const timeOfDay = new Date().getHours();\n    let motivationalTheme;\n\n    if (timeOfDay < 6) {\n      motivationalTheme = 'early-riser';\n    } else if (timeOfDay < 9) {\n      motivationalTheme = 'morning-energy';\n    } else if (timeOfDay < 12) {\n      motivationalTheme = 'productive-day';\n    } else {\n      motivationalTheme = 'afternoon-reset';\n    }\n\n    return {\n      enabled: true,\n      theme: motivationalTheme,\n      personalizedTip: await this.getPersonalizedTip(userId, motivationalTheme),\n      energyBoost: await this.getEnergyBoostContent(motivationalTheme)\n    };\n  }\n\n  private async getPersonalizedTip(userId: string, theme: string): Promise<string> {\n    const tips = {\n      'early-riser': [\n        \"You're ahead of 90% of people already! The early hours are your secret weapon.\",\n        \"The world is quiet and yours to conquer. What will you create today?\",\n        \"Champions wake up early. You're already winning.\"\n      ],\n      'morning-energy': [\n        \"Your energy is your superpower. Channel it into something amazing today!\",\n        \"The morning momentum you create will carry you through the entire day.\",\n        \"You're not just waking up, you're rising up to meet your potential!\"\n      ],\n      'productive-day': [\n        \"Time to turn possibilities into reality. What's your priority today?\",\n        \"Your future self is counting on what you do in the next few hours.\",\n        \"Success starts with the decision to wake up and show up.\"\n      ],\n      'afternoon-reset': [\n        \"It's never too late to make today count. Reset and refocus.\",\n        \"The afternoon is your second chance to make today extraordinary.\",\n        \"Power naps are for champions preparing for their next victory.\"\n      ]\n    };\n\n    const themeTips = tips[theme as keyof typeof tips] || tips['morning-energy'];\n    return themeTips[Math.floor(Math.random() * themeTips.length)];\n  }\n\n  private async getEnergyBoostContent(theme: string): Promise<any> {\n    return {\n      breathingExercise: {\n        name: \"4-7-8 Energizing Breath\",\n        instructions: \"Inhale for 4, hold for 7, exhale for 8. Repeat 3 times.\",\n        duration: 60\n      },\n      quickWin: {\n        action: \"Make your bed and drink a glass of water\",\n        benefit: \"Instant sense of accomplishment and hydration boost\",\n        timeRequired: 2\n      },\n      affirmation: this.getContextualAffirmation(theme)\n    };\n  }\n\n  private getContextualAffirmation(theme: string): string {\n    const affirmations = {\n      'early-riser': \"I am disciplined, focused, and ahead of my goals.\",\n      'morning-energy': \"I have abundant energy and unlimited potential.\",\n      'productive-day': \"I accomplish meaningful work that matters to me.\",\n      'afternoon-reset': \"I refresh my mind and approach challenges with clarity.\"\n    };\n\n    return affirmations[theme as keyof typeof affirmations] || affirmations['morning-energy'];\n  }\n\n  private async sendPushNotification(alarmData: any): Promise<void> {\n    // Implementation for sending push notifications\n    // This would integrate with service worker for web push notifications\n    try {\n      const notificationPayload = {\n        title: 'Wake Up Call! ‚è∞',\n        body: 'Your alarm is ringing. Time to start your amazing day!',\n        icon: '/icon-192x192.png',\n        badge: '/icon-72x72.png',\n        tag: `alarm-${alarmData.alarmId}`,\n        timestamp: Date.now(),\n        actions: [\n          { action: 'dismiss', title: 'I\\'m Up!' },\n          { action: 'snooze', title: 'Snooze 5 min' }\n        ]\n      };\n\n      // Store notification for service worker to pick up\n      const notificationKey = `notification:${alarmData.userId}:${Date.now()}`;\n      await this.env.KV.put(notificationKey, JSON.stringify(notificationPayload), {\n        expirationTtl: 300 // 5 minutes\n      });\n\n    } catch (error) {\n      console.error('Failed to send push notification:', error);\n    }\n  }\n\n  private async updateSleepPatternAnalysis(alarmData: any): Promise<void> {\n    // Update sleep pattern analysis based on alarm timing and user response\n    const analysisData = {\n      alarmTime: alarmData.triggeredAt,\n      responseTime: null, // Will be updated when user responds\n      context: alarmData.context,\n      deviceInfo: alarmData.deviceInfo,\n      timestamp: Date.now()\n    };\n\n    // Store for sleep analysis processing\n    const analysisKey = `sleep_analysis:${alarmData.userId}:${Date.now()}`;\n    await this.env.KV.put(analysisKey, JSON.stringify(analysisData), {\n      expirationTtl: 86400 * 30 // 30 days\n    });\n  }\n}\n\n// Smart recommendations processor\nexport class SmartRecommendationsProcessor {\n  private env: Env;\n\n  constructor(env: Env) {\n    this.env = env;\n  }\n\n  async generateRecommendations(userId: string): Promise<Response> {\n    try {\n      const recommendations = await this.analyzeAndRecommend(userId);\n      return Response.json({\n        success: true,\n        recommendations,\n        generatedAt: new Date().toISOString()\n      });\n    } catch (error) {\n      console.error('Error generating recommendations:', error);\n      return Response.json({\n        success: false,\n        error: 'Failed to generate recommendations'\n      }, { status: 500 });\n    }\n  }\n\n  private async analyzeAndRecommend(userId: string): Promise<any[]> {\n    const recommendations: any[] = [];\n\n    // Analyze alarm effectiveness\n    const effectivenessAnalysis = await this.analyzeAlarmEffectiveness(userId);\n    if (effectivenessAnalysis.recommendation) {\n      recommendations.push(effectivenessAnalysis.recommendation);\n    }\n\n    // Analyze sleep patterns\n    const sleepAnalysis = await this.analyzeSleepPatterns(userId);\n    if (sleepAnalysis.recommendation) {\n      recommendations.push(sleepAnalysis.recommendation);\n    }\n\n    // Analyze voice preferences\n    const voiceAnalysis = await this.analyzeVoicePreferences(userId);\n    if (voiceAnalysis.recommendation) {\n      recommendations.push(voiceAnalysis.recommendation);\n    }\n\n    // Analyze timing patterns\n    const timingAnalysis = await this.analyzeTimingPatterns(userId);\n    if (timingAnalysis.recommendation) {\n      recommendations.push(timingAnalysis.recommendation);\n    }\n\n    return recommendations.filter(rec => asNumber(rec.confidence_score, 0) > 0.6);\n  }\n\n  private async analyzeAlarmEffectiveness(userId: string): Promise<any> {\n    const effectiveness = await this.env.DB.prepare(`\n      SELECT\n        AVG(effectiveness_rating) as avg_rating,\n        AVG(response_time) as avg_response,\n        COUNT(*) as total_alarms,\n        a.alarm_type,\n        a.voice_mood\n      FROM alarm_events ae\n      JOIN alarms a ON ae.alarm_id = a.id\n      WHERE a.user_id = ? AND ae.fired_at > datetime('now', '-30 days')\n      GROUP BY a.alarm_type, a.voice_mood\n      ORDER BY avg_rating DESC\n    `).bind(userId).all();\n\n    if (!effectiveness.results || effectiveness.results.length === 0) {\n      return {};\n    }\n\n    const bestPerforming = effectiveness.results[0];\n    const worstPerforming = effectiveness.results[effectiveness.results.length - 1];\n\n    if (asNumber(bestPerforming.avg_rating, 0) > asNumber(worstPerforming.avg_rating, 0) + 1) {\n      return {\n        recommendation: {\n          id: `rec_${Date.now()}`,\n          user_id: userId,\n          recommendation_type: 'alarm_optimization',\n          title: 'Optimize Your Alarm Settings',\n          description: `Your ${asString(bestPerforming.alarm_type)} alarms with ${asString(bestPerforming.voice_mood)} mood are ${Math.round((asNumber(bestPerforming.avg_rating, 0) - asNumber(worstPerforming.avg_rating, 0)) * 20)}% more effective.`,\n          suggested_value: {\n            alarm_type: asString(bestPerforming.alarm_type),\n            voice_mood: asString(bestPerforming.voice_mood)\n          },\n          confidence_score: Math.min(0.95, (asNumber(bestPerforming.avg_rating, 0) - asNumber(worstPerforming.avg_rating, 0)) / 2),\n          reasoning: `Based on ${bestPerforming.total_alarms} alarm interactions over the past 30 days`,\n          category: ['effectiveness', 'personalization'],\n          priority: 2\n        }\n      };\n    }\n\n    return {};\n  }\n\n  private async analyzeSleepPatterns(userId: string): Promise<any> {\n    const sleepData = await this.env.DB.prepare(`\n      SELECT\n        AVG(total_duration) as avg_duration,\n        AVG(sleep_efficiency) as avg_efficiency,\n        AVG(restfulness_score) as avg_quality,\n        COUNT(*) as sessions_count\n      FROM sleep_sessions\n      WHERE user_id = ? AND sleep_start > datetime('now', '-14 days')\n    `).bind(userId).first();\n\n    if (!sleepData || asNumber(sleepData.sessions_count, 0) < 5) {\n      return {};\n    }\n\n    // Recommend earlier bedtime if sleep duration is consistently low\n    const avgDuration = asNumber(sleepData.avg_duration, 480);\n    if (avgDuration < 420) { // Less than 7 hours\n      return {\n        recommendation: {\n          id: `rec_${Date.now()}`,\n          user_id: userId,\n          recommendation_type: 'bedtime',\n          title: 'Earlier Bedtime Recommended',\n          description: `You're averaging ${Math.round(avgDuration / 60 * 10) / 10} hours of sleep. Consider going to bed 30-45 minutes earlier.`,\n          suggested_value: {\n            adjustment: -45, // minutes earlier\n            target_duration: 480 // 8 hours\n          },\n          confidence_score: Math.min(0.9, (420 - asNumber(sleepData.avg_duration, 480)) / 120),\n          reasoning: `Based on ${asNumber(sleepData.sessions_count, 0)} sleep sessions showing consistently short sleep duration`,\n          category: ['sleep_health', 'schedule_optimization'],\n          priority: 1\n        }\n      };\n    }\n\n    return {};\n  }\n\n  private async analyzeVoicePreferences(userId: string): Promise<any> {\n    const voiceEffectiveness = await this.env.DB.prepare(`\n      SELECT\n        a.voice_mood,\n        AVG(ae.effectiveness_rating) as avg_effectiveness,\n        COUNT(*) as usage_count\n      FROM alarms a\n      JOIN alarm_events ae ON a.id = ae.alarm_id\n      WHERE a.user_id = ? AND ae.fired_at > datetime('now', '-30 days')\n      AND ae.effectiveness_rating IS NOT NULL\n      GROUP BY a.voice_mood\n      HAVING usage_count >= 3\n      ORDER BY avg_effectiveness DESC\n    `).bind(userId).all();\n\n    if (!voiceEffectiveness.results || voiceEffectiveness.results.length < 2) {\n      return {};\n    }\n\n    const best = voiceEffectiveness.results[0];\n    const current = voiceEffectiveness.results.find((v: any) => v.usage_count === Math.max(...voiceEffectiveness.results.map((r: any) => r.usage_count)));\n\n    if (best.voice_mood !== current?.voice_mood && asNumber(best.avg_effectiveness, 0) > asNumber(current?.avg_effectiveness, 0) + 0.5) {\n      return {\n        recommendation: {\n          id: `rec_${Date.now()}`,\n          user_id: userId,\n          recommendation_type: 'voice_optimization',\n          title: 'Switch to More Effective Voice Mood',\n          description: `Your ${asString(best.voice_mood)} voice mood is performing ${Math.round((asNumber(best.avg_effectiveness, 0) - asNumber(current?.avg_effectiveness, 0)) * 20)}% better than your current preference.`,\n          suggested_value: {\n            voice_mood: asString(best.voice_mood),\n            expected_improvement: Math.round((asNumber(best.avg_effectiveness, 0) - asNumber(current?.avg_effectiveness, 0)) * 20)\n          },\n          confidence_score: Math.min(0.9, (asNumber(best.avg_effectiveness, 0) - asNumber(current?.avg_effectiveness, 0)) / 2),\n          reasoning: `${best.voice_mood} mood shows consistently higher effectiveness ratings`,\n          category: ['voice_personalization', 'effectiveness'],\n          priority: 2\n        }\n      };\n    }\n\n    return {};\n  }\n\n  private async analyzeTimingPatterns(userId: string): Promise<any> {\n    const timingData = await this.env.DB.prepare(`\n      SELECT\n        strftime('%H', a.time) as hour,\n        AVG(ae.effectiveness_rating) as avg_effectiveness,\n        AVG(ae.response_time) as avg_response_time,\n        COUNT(*) as alarm_count\n      FROM alarms a\n      JOIN alarm_events ae ON a.id = ae.alarm_id\n      WHERE a.user_id = ? AND ae.fired_at > datetime('now', '-30 days')\n      AND ae.effectiveness_rating IS NOT NULL\n      GROUP BY strftime('%H', a.time)\n      HAVING alarm_count >= 3\n      ORDER BY avg_effectiveness DESC\n    `).bind(userId).all();\n\n    if (!timingData.results || timingData.results.length < 2) {\n      return {};\n    }\n\n    const bestHour = timingData.results[0];\n    const worstHour = timingData.results[timingData.results.length - 1];\n\n    if (asNumber(bestHour.avg_effectiveness, 0) > asNumber(worstHour.avg_effectiveness, 0) + 1) {\n      return {\n        recommendation: {\n          id: `rec_${Date.now()}`,\n          user_id: userId,\n          recommendation_type: 'timing_optimization',\n          title: 'Optimize Your Wake-Up Time',\n          description: `You respond best to alarms around ${asString(bestHour.hour)}:00. Consider adjusting your schedule.`,\n          suggested_value: {\n            optimal_hour: parseInt(asString(bestHour.hour, '7')),\n            effectiveness_boost: Math.round((asNumber(bestHour.avg_effectiveness, 0) - asNumber(worstHour.avg_effectiveness, 0)) * 20)\n          },\n          confidence_score: Math.min(0.85, (asNumber(bestHour.avg_effectiveness, 0) - asNumber(worstHour.avg_effectiveness, 0)) / 3),\n          reasoning: `${asString(bestHour.hour)}:00 alarms show ${Math.round((asNumber(bestHour.avg_effectiveness, 0) - asNumber(worstHour.avg_effectiveness, 0)) * 20)}% higher effectiveness`,\n          category: ['timing', 'circadian_rhythm'],\n          priority: 3\n        }\n      };\n    }\n\n    return {};\n  }\n}\n\n// Real-time analytics aggregation\nexport class AnalyticsAggregator {\n  private env: Env;\n\n  constructor(env: Env) {\n    this.env = env;\n  }\n\n  async processRealtimeAnalytics(): Promise<Response> {\n    try {\n      // Process analytics from KV store\n      const analytics = await this.aggregateDailyAnalytics();\n      const insights = await this.generateInsights(analytics);\n\n      return Response.json({\n        success: true,\n        analytics,\n        insights,\n        processedAt: new Date().toISOString()\n      });\n    } catch (error) {\n      console.error('Error processing analytics:', error);\n      return Response.json({\n        success: false,\n        error: 'Failed to process analytics'\n      }, { status: 500 });\n    }\n  }\n\n  private async aggregateDailyAnalytics(): Promise<any> {\n    // Get today's analytics from KV\n    const today = new Date().toISOString().split('T')[0];\n    const analyticsKeys = await this.env.KV.list({ prefix: `analytics:*:${today}` });\n\n    const aggregatedData = {\n      totalUsers: 0,\n      totalAlarmTriggers: 0,\n      avgResponseTime: 0,\n      topPerformingVoiceMoods: new Map(),\n      deviceTypeDistribution: new Map(),\n      hourlyDistribution: new Array(24).fill(0)\n    };\n\n    for (const key of analyticsKeys.keys) {\n      const data = await this.env.KV.get(key.name, 'json');\n      if (data && typeof data === 'object' && 'events' in data) {\n        const typedData = data as { events: any[], totalTriggers: number };\n        aggregatedData.totalUsers++;\n        aggregatedData.totalAlarmTriggers += typedData.totalTriggers;\n\n        for (const event of typedData.events) {\n          // Aggregate hourly distribution\n          const hour = new Date(event.timestamp).getHours();\n          aggregatedData.hourlyDistribution[hour]++;\n\n          // Track device types\n          const deviceType = event.deviceInfo?.type || 'unknown';\n          aggregatedData.deviceTypeDistribution.set(\n            deviceType,\n            (aggregatedData.deviceTypeDistribution.get(deviceType) || 0) + 1\n          );\n        }\n      }\n    }\n\n    return {\n      ...aggregatedData,\n      deviceTypeDistribution: Object.fromEntries(aggregatedData.deviceTypeDistribution),\n      topPerformingVoiceMoods: Object.fromEntries(aggregatedData.topPerformingVoiceMoods)\n    };\n  }\n\n  private async generateInsights(analytics: any): Promise<any[]> {\n    const insights = [];\n\n    // Peak usage hours\n    const peakHour = analytics.hourlyDistribution.indexOf(Math.max(...analytics.hourlyDistribution));\n    insights.push({\n      type: 'usage_pattern',\n      title: 'Peak Wake-Up Hour',\n      description: `Most users wake up at ${peakHour}:00`,\n      value: peakHour,\n      impact: 'high'\n    });\n\n    // Device preferences\n    const totalDeviceUsage = Object.values(analytics.deviceTypeDistribution).reduce((a, b) => (a as number) + (b as number), 0);\n    const topDevice = Object.entries(analytics.deviceTypeDistribution)\n      .sort(([,a], [,b]) => (b as number) - (a as number))[0];\n\n    if (topDevice) {\n      insights.push({\n        type: 'device_preference',\n        title: 'Primary Device Type',\n        description: `${Math.round((topDevice[1] as number) / (totalDeviceUsage as number) * 100)}% of alarms triggered on ${topDevice[0]}`,\n        value: topDevice[0],\n        impact: 'medium'\n      });\n    }\n\n    return insights;\n  }\n}\n\n// Main request router for cloud functions\nexport default {\n  async fetch(request: Request, env: Env): Promise<Response> {\n    const url = new URL(request.url);\n    const method = request.method;\n\n    // CORS headers\n    const corsHeaders = {\n      'Access-Control-Allow-Origin': '*',\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n    };\n\n    if (method === 'OPTIONS') {\n      return new Response(null, { headers: corsHeaders });\n    }\n\n    try {\n      // Route to appropriate processor\n      if (url.pathname === '/api/cloud/alarm-trigger' && method === 'POST') {\n        const processor = new AlarmTriggerProcessor(env);\n        const alarmData = asObject(await request.json(), {});\n        const response = await processor.processAlarmTrigger(alarmData as any);\n\n        // Add CORS headers to response\n        Object.entries(corsHeaders).forEach(([key, value]) => {\n          response.headers.set(key, value);\n        });\n\n        return response;\n      }\n\n      if (url.pathname === '/api/cloud/recommendations' && method === 'POST') {\n        const processor = new SmartRecommendationsProcessor(env);\n        const requestData = asObject(await request.json(), {});\n        const userId = asString(requestData.userId, '');\n        const response = await processor.generateRecommendations(userId);\n\n        Object.entries(corsHeaders).forEach(([key, value]) => {\n          response.headers.set(key, value);\n        });\n\n        return response;\n      }\n\n      if (url.pathname === '/api/cloud/analytics' && method === 'GET') {\n        const aggregator = new AnalyticsAggregator(env);\n        const response = await aggregator.processRealtimeAnalytics();\n\n        Object.entries(corsHeaders).forEach(([key, value]) => {\n          response.headers.set(key, value);\n        });\n\n        return response;\n      }\n\n      // Health check\n      if (url.pathname === '/api/cloud/health' && method === 'GET') {\n        return Response.json({\n          status: 'healthy',\n          timestamp: new Date().toISOString(),\n          environment: env.ENVIRONMENT || 'production'\n        }, { headers: corsHeaders });\n      }\n\n      return Response.json({\n        error: 'Not found'\n      }, { status: 404, headers: corsHeaders });\n\n    } catch (error) {\n      console.error('Cloud function error:', error);\n      return Response.json({\n        error: 'Internal server error'\n      }, { status: 500, headers: corsHeaders });\n    }\n  },\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/backend/monitoring-integration.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/triple-slash-reference",
        "severity": 2,
        "message": "Do not use a triple slash reference for ../vite-env.d.ts, use `import` style instead.",
        "line": 1,
        "column": 1,
        "nodeType": "Line",
        "messageId": "tripleSlashReference",
        "endLine": 1,
        "endColumn": 42
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference path=\"../vite-env.d.ts\" />\n// Performance Monitoring Integration Service\n// Centralized service to coordinate performance monitoring across all backend components\n\nimport { PerformanceMonitoringAPI } from './performance-monitoring';\nimport type { D1Database, KVNamespace } from '../types/index';\nimport {\n  DatabaseUser,\n  DatabaseAlarm,\n  DatabaseAlarmEvent,\n  DatabaseAnalyticsEvent,\n  DatabaseUserStats,\n  DatabaseEmotionalProfile,\n  DatabaseBattleStats,\n  DatabasePerformanceMetric,\n  DatabaseDeploymentData,\n  DatabaseHealthData,\n  DatabaseAIResponse,\n  DatabaseRecommendation,\n  DatabaseVoiceAnalysis,\n  DatabaseQueryResult,\n  isDatabaseUser,\n  isDatabaseAlarm,\n  isDatabaseAlarmEvent,\n  isNumeric,\n  isStringValue,\n  asNumber,\n  asString,\n  asObject\n} from './database-types';\n\n// Integration service environment\ninterface MonitoringEnv {\n  DB: D1Database;\n  KV: KVNamespace;\n  SUPABASE_URL: string;\n  SUPABASE_SERVICE_KEY: string;\n  POSTHOG_API_KEY?: string;\n  SENTRY_DSN?: string;\n  DATADOG_API_KEY?: string;\n  NEWRELIC_API_KEY?: string;\n  AMPLITUDE_API_KEY?: string;\n  ENVIRONMENT: string;\n  JWT_SECRET: string;\n}\n\n// Enhanced monitoring service with external integrations\nexport class MonitoringIntegrationService {\n  private performanceAPI: PerformanceMonitoringAPI;\n  private env: MonitoringEnv;\n\n  constructor(env: MonitoringEnv) {\n    this.env = env;\n    this.performanceAPI = new PerformanceMonitoringAPI(env);\n  }\n\n  // Main request router for all monitoring endpoints\n  async handleMonitoringRequest(request: Request): Promise<Response> {\n    const url = new URL(request.url);\n\n    // Route performance monitoring requests\n    if (url.pathname.startsWith('/api/performance/') ||\n        url.pathname.startsWith('/api/analytics/') ||\n        url.pathname.startsWith('/api/monitoring/')) {\n      return await this.performanceAPI.handleRequest(request);\n    }\n\n    // Route additional monitoring requests\n    if (url.pathname.startsWith('/api/external-monitoring/')) {\n      return await this.handleExternalMonitoringRequest(request);\n    }\n\n    // Route deployment monitoring requests\n    if (url.pathname.startsWith('/api/deployment/')) {\n      return await this.handleDeploymentMonitoringRequest(request);\n    }\n\n    return Response.json(\n      { error: \"Monitoring endpoint not found\" },\n      { status: 404 }\n    );\n  }\n\n  // Handle external monitoring service integrations\n  private async handleExternalMonitoringRequest(request: Request): Promise<Response> {\n    const url = new URL(request.url);\n    const method = request.method;\n    const corsHeaders = this.getCorsHeaders(request.headers.get(\"Origin\") || \"*\");\n\n    if (method === 'OPTIONS') {\n      return new Response(null, { headers: corsHeaders });\n    }\n\n    try {\n      // DataDog integration\n      if (url.pathname === '/api/external-monitoring/datadog/metrics' && method === 'POST') {\n        return await this.forwardToDataDog(request, corsHeaders);\n      }\n\n      // New Relic integration\n      if (url.pathname === '/api/external-monitoring/newrelic/events' && method === 'POST') {\n        return await this.forwardToNewRelic(request, corsHeaders);\n      }\n\n      // Amplitude integration\n      if (url.pathname === '/api/external-monitoring/amplitude/events' && method === 'POST') {\n        return await this.forwardToAmplitude(request, corsHeaders);\n      }\n\n      // Webhook endpoints for external services\n      if (url.pathname === '/api/external-monitoring/webhook/alerts' && method === 'POST') {\n        return await this.handleAlertWebhook(request, corsHeaders);\n      }\n\n      return Response.json(\n        { error: \"External monitoring endpoint not found\" },\n        { status: 404, headers: corsHeaders }\n      );\n\n    } catch (error) {\n      console.error('External monitoring error:', error);\n      return Response.json(\n        { error: \"External monitoring request failed\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Handle deployment monitoring\n  private async handleDeploymentMonitoringRequest(request: Request): Promise<Response> {\n    const url = new URL(request.url);\n    const method = request.method;\n    const corsHeaders = this.getCorsHeaders(request.headers.get(\"Origin\") || \"*\");\n\n    if (method === 'OPTIONS') {\n      return new Response(null, { headers: corsHeaders });\n    }\n\n    try {\n      // Track deployment events\n      if (url.pathname === '/api/deployment/track' && method === 'POST') {\n        return await this.trackDeploymentEvent(request, corsHeaders);\n      }\n\n      // Get deployment metrics\n      if (url.pathname === '/api/deployment/metrics' && method === 'GET') {\n        return await this.getDeploymentMetrics(request, corsHeaders);\n      }\n\n      // Track deployment health\n      if (url.pathname === '/api/deployment/health' && method === 'POST') {\n        return await this.trackDeploymentHealth(request, corsHeaders);\n      }\n\n      // Get deployment status\n      if (url.pathname === '/api/deployment/status' && method === 'GET') {\n        return await this.getDeploymentStatus(request, corsHeaders);\n      }\n\n      return Response.json(\n        { error: \"Deployment monitoring endpoint not found\" },\n        { status: 404, headers: corsHeaders }\n      );\n\n    } catch (error) {\n      console.error('Deployment monitoring error:', error);\n      return Response.json(\n        { error: \"Deployment monitoring request failed\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // DataDog integration\n  private async forwardToDataDog(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    if (!this.env.DATADOG_API_KEY) {\n      return Response.json(\n        { error: \"DataDog API key not configured\" },\n        { status: 400, headers: corsHeaders }\n      );\n    }\n\n    try {\n      const data = await request.json();\n      const metrics = Array.isArray(data) ? data : [data];\n\n      // Transform metrics to DataDog format\n      const datadogMetrics = metrics.map(metric => ({\n        metric: `relife.${metric.name}`,\n        points: [[Math.floor(Date.now() / 1000), metric.value]],\n        tags: [\n          `environment:${this.env.ENVIRONMENT}`,\n          `device_type:${metric.device_type || 'unknown'}`,\n          `page:${metric.page_path || '/'}`,\n          ...(metric.tags || [])\n        ],\n        type: metric.type || 'gauge'\n      }));\n\n      // Send to DataDog\n      const response = await fetch('https://api.datadoghq.com/api/v1/series', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'DD-API-KEY': this.env.DATADOG_API_KEY,\n        },\n        body: JSON.stringify({ series: datadogMetrics })\n      });\n\n      if (!response.ok) {\n        throw new Error(`DataDog API error: ${response.status}`);\n      }\n\n      const result = await response.json();\n\n      return Response.json(\n        {\n          success: true,\n          datadog_response: result,\n          metrics_sent: datadogMetrics.length\n        },\n        { headers: corsHeaders }\n      );\n\n    } catch (error) {\n      console.error('DataDog forwarding error:', error);\n      return Response.json(\n        { error: \"Failed to forward metrics to DataDog\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // New Relic integration\n  private async forwardToNewRelic(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    if (!this.env.NEWRELIC_API_KEY) {\n      return Response.json(\n        { error: \"New Relic API key not configured\" },\n        { status: 400, headers: corsHeaders }\n      );\n    }\n\n    try {\n      const data = await request.json();\n      const events = Array.isArray(data) ? data : [data];\n\n      // Transform events to New Relic format\n      const newRelicEvents = events.map(event => ({\n        eventType: `RelifePerformance`,\n        timestamp: Date.now(),\n        appName: 'Relife Smart Alarm',\n        environment: this.env.ENVIRONMENT,\n        ...event\n      }));\n\n      // Send to New Relic Insights API\n      const response = await fetch('https://insights-collector.newrelic.com/v1/accounts/YOUR_ACCOUNT_ID/events', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Insert-Key': this.env.NEWRELIC_API_KEY,\n        },\n        body: JSON.stringify(newRelicEvents)\n      });\n\n      if (!response.ok) {\n        throw new Error(`New Relic API error: ${response.status}`);\n      }\n\n      return Response.json(\n        {\n          success: true,\n          events_sent: newRelicEvents.length\n        },\n        { headers: corsHeaders }\n      );\n\n    } catch (error) {\n      console.error('New Relic forwarding error:', error);\n      return Response.json(\n        { error: \"Failed to forward events to New Relic\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Amplitude integration\n  private async forwardToAmplitude(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    if (!this.env.AMPLITUDE_API_KEY) {\n      return Response.json(\n        { error: \"Amplitude API key not configured\" },\n        { status: 400, headers: corsHeaders }\n      );\n    }\n\n    try {\n      const data = await request.json();\n      const events = Array.isArray(data) ? data : [data];\n\n      // Transform events to Amplitude format\n      const amplitudeEvents = events.map(event => ({\n        event_type: event.event_name || 'performance_metric',\n        user_id: event.user_id,\n        device_id: event.session_id,\n        time: new Date(event.timestamp).getTime(),\n        event_properties: {\n          ...event.properties,\n          environment: this.env.ENVIRONMENT,\n          source: 'relife_monitoring'\n        },\n        user_properties: event.user_properties || {}\n      }));\n\n      // Send to Amplitude\n      const response = await fetch('https://api2.amplitude.com/2/httpapi', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          api_key: this.env.AMPLITUDE_API_KEY,\n          events: amplitudeEvents\n        })\n      });\n\n      if (!response.ok) {\n        throw new Error(`Amplitude API error: ${response.status}`);\n      }\n\n      const result = await response.json();\n\n      return Response.json(\n        {\n          success: true,\n          amplitude_response: result,\n          events_sent: amplitudeEvents.length\n        },\n        { headers: corsHeaders }\n      );\n\n    } catch (error) {\n      console.error('Amplitude forwarding error:', error);\n      return Response.json(\n        { error: \"Failed to forward events to Amplitude\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Handle alert webhooks from external services\n  private async handleAlertWebhook(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      const alertData = asObject(await request.json(), {});\n      const alertId = `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      // Store alert in database for tracking\n      await this.env.DB.prepare(`\n        INSERT INTO error_logs\n        (id, session_id, error_message, error_category, severity,\n         page_path, metadata, occurrence_count, first_seen, last_seen, created_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `).bind(\n        alertId,\n        'webhook_alert',\n        asString(alertData.message, 'External alert received'),\n        'external_alert',\n        asString(alertData.severity, 'medium'),\n        asString(alertData.source, 'external'),\n        JSON.stringify(alertData),\n        1,\n        new Date().toISOString(),\n        new Date().toISOString(),\n        new Date().toISOString()\n      ).run();\n\n      // Cache for immediate response\n      await this.env.KV.put(\n        `alert:${alertId}`,\n        JSON.stringify(alertData),\n        { expirationTtl: 3600 }\n      );\n\n      return Response.json(\n        {\n          success: true,\n          alert_id: alertId,\n          processed: true\n        },\n        { headers: corsHeaders }\n      );\n\n    } catch (error) {\n      console.error('Alert webhook error:', error);\n      return Response.json(\n        { error: \"Failed to process alert webhook\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Track deployment events\n  private async trackDeploymentEvent(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      const deploymentData = asObject(await request.json(), {});\n      const deploymentId = `deploy_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      // Store deployment event as performance metric\n      await this.env.DB.prepare(`\n        INSERT INTO performance_analytics\n        (id, session_id, metric_name, metric_value, metric_unit,\n         page_path, metadata, timestamp, created_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `).bind(\n        deploymentId,\n        asString(deploymentData.deployment_id, 'unknown'),\n        'deployment_event',\n        1,\n        'count',\n        asString(deploymentData.environment, this.env.ENVIRONMENT),\n        JSON.stringify(deploymentData),\n        new Date().toISOString(),\n        new Date().toISOString()\n      ).run();\n\n      // Cache deployment status\n      await this.env.KV.put(\n        `deployment:latest`,\n        JSON.stringify({\n          ...asObject(deploymentData),\n          deployment_id: deploymentId,\n          timestamp: new Date().toISOString()\n        }),\n        { expirationTtl: 86400 * 7 } // 7 days\n      );\n\n      // Send deployment notification to external services\n      await this.notifyDeployment(deploymentData, deploymentId);\n\n      return Response.json(\n        {\n          success: true,\n          deployment_id: deploymentId,\n          tracked: true\n        },\n        { headers: corsHeaders }\n      );\n\n    } catch (error) {\n      console.error('Deployment tracking error:', error);\n      return Response.json(\n        { error: \"Failed to track deployment\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Get deployment metrics\n  private async getDeploymentMetrics(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      const url = new URL(request.url);\n      const timeRange = url.searchParams.get('timeRange') || '7d';\n      const environment = url.searchParams.get('environment') || this.env.ENVIRONMENT;\n\n      const timeFilter = this.getTimeFilter(timeRange);\n\n      // Get deployment frequency\n      const deploymentQuery = `\n        SELECT\n          DATE(timestamp) as deployment_date,\n          COUNT(*) as deployment_count,\n          MAX(timestamp) as last_deployment\n        FROM performance_analytics\n        WHERE metric_name = 'deployment_event'\n        AND timestamp > datetime('now', '${timeFilter}')\n        AND page_path = ?\n        GROUP BY DATE(timestamp)\n        ORDER BY deployment_date DESC\n      `;\n\n      const deploymentResults = await this.env.DB.prepare(deploymentQuery)\n        .bind(environment).all();\n\n      // Get deployment success rate (based on error logs after deployments)\n      const errorQuery = `\n        SELECT\n          COUNT(*) as error_count,\n          SUM(occurrence_count) as total_errors\n        FROM error_logs\n        WHERE created_at > datetime('now', '${timeFilter}')\n        AND error_category IN ('deployment_error', 'system_error')\n      `;\n\n      const errorResults = await this.env.DB.prepare(errorQuery).first();\n\n      // Get latest deployment info\n      const latestDeployment = await this.env.KV.get('deployment:latest', 'json');\n\n      const metrics = {\n        timeRange,\n        environment,\n        generatedAt: new Date().toISOString(),\n        deployments: {\n          frequency: deploymentResults.results || [],\n          totalCount: (deploymentResults.results || []).reduce((sum: number, d: any) => sum + asNumber(d.deployment_count, 0), 0),\n          latest: latestDeployment\n        },\n        stability: {\n          errorCount: asNumber(errorResults?.error_count, 0),\n          totalErrors: asNumber(errorResults?.total_errors, 0),\n          successRate: this.calculateDeploymentSuccessRate(deploymentResults.results || [], errorResults)\n        }\n      };\n\n      return Response.json(metrics, { headers: corsHeaders });\n\n    } catch (error) {\n      console.error('Error getting deployment metrics:', error);\n      return Response.json(\n        { error: \"Failed to get deployment metrics\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Track deployment health\n  private async trackDeploymentHealth(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      const healthData = asObject(await request.json(), {});\n      const healthId = `health_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      // Store health metric\n      await this.env.DB.prepare(`\n        INSERT INTO performance_analytics\n        (id, session_id, metric_name, metric_value, metric_unit,\n         device_type, metadata, timestamp, created_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `).bind(\n        healthId,\n        asString(healthData.deployment_id, 'unknown'),\n        'deployment_health',\n        asNumber(healthData.health_score, 0),\n        'score',\n        asString(healthData.environment, this.env.ENVIRONMENT),\n        JSON.stringify(healthData),\n        new Date().toISOString(),\n        new Date().toISOString()\n      ).run();\n\n      // Update deployment health cache\n      await this.env.KV.put(\n        `deployment:health:${asString(healthData.deployment_id, 'unknown')}`,\n        JSON.stringify(healthData),\n        { expirationTtl: 3600 }\n      );\n\n      return Response.json(\n        {\n          success: true,\n          health_id: healthId,\n          tracked: true\n        },\n        { headers: corsHeaders }\n      );\n\n    } catch (error) {\n      console.error('Deployment health tracking error:', error);\n      return Response.json(\n        { error: \"Failed to track deployment health\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Get deployment status\n  private async getDeploymentStatus(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      const url = new URL(request.url);\n      const deploymentId = url.searchParams.get('deploymentId');\n\n      if (deploymentId) {\n        // Get specific deployment health\n        const health = await this.env.KV.get(`deployment:health:${deploymentId}`, 'json');\n\n        return Response.json(\n          {\n            deployment_id: deploymentId,\n            health: health || { status: 'unknown' },\n            timestamp: new Date().toISOString()\n          },\n          { headers: corsHeaders }\n        );\n      } else {\n        // Get overall deployment status\n        const latest = await this.env.KV.get('deployment:latest', 'json');\n\n        // Get recent health scores\n        const recentHealth = await this.env.DB.prepare(`\n          SELECT AVG(metric_value) as avg_health\n          FROM performance_analytics\n          WHERE metric_name = 'deployment_health'\n          AND timestamp > datetime('now', '-1 hour')\n        `).first();\n\n        return Response.json(\n          {\n            latest_deployment: latest,\n            overall_health: asNumber(recentHealth?.avg_health, 0),\n            status: asNumber(recentHealth?.avg_health, 0) > 0.8 ? 'healthy' : 'warning',\n            timestamp: new Date().toISOString()\n          },\n          { headers: corsHeaders }\n        );\n      }\n\n    } catch (error) {\n      console.error('Error getting deployment status:', error);\n      return Response.json(\n        { error: \"Failed to get deployment status\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Helper methods\n\n  private getCorsHeaders(origin: string): HeadersInit {\n    return {\n      'Access-Control-Allow-Origin': origin || '*',\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n      'Content-Type': 'application/json',\n    };\n  }\n\n  private getTimeFilter(timeRange: string): string {\n    const timeMap: Record<string, string> = {\n      '1h': '-1 hour',\n      '24h': '-24 hours',\n      '7d': '-7 days',\n      '30d': '-30 days',\n      '90d': '-90 days'\n    };\n    return timeMap[timeRange] || '-7 days';\n  }\n\n  private calculateDeploymentSuccessRate(deployments: any[], errors: any): number {\n    if (!deployments || deployments.length === 0) return 1.0;\n\n    const totalDeployments = deployments.reduce((sum, d) => sum + asNumber(d.deployment_count, 0), 0);\n    const errorCount = asNumber(errors?.error_count, 0);\n\n    return Math.max(0, (totalDeployments - errorCount) / totalDeployments);\n  }\n\n  // Notify external services about deployment\n  private async notifyDeployment(deploymentData: any, deploymentId: string): Promise<void> {\n    // Send to DataDog if configured\n    if (this.env.DATADOG_API_KEY) {\n      try {\n        await fetch('https://api.datadoghq.com/api/v1/events', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'DD-API-KEY': this.env.DATADOG_API_KEY,\n          },\n          body: JSON.stringify({\n            title: 'Relife Deployment',\n            text: `New deployment: ${deploymentData.version || 'unknown'} to ${deploymentData.environment || this.env.ENVIRONMENT}`,\n            tags: [\n              `environment:${this.env.ENVIRONMENT}`,\n              `version:${deploymentData.version}`,\n              'source:relife'\n            ],\n            alert_type: 'info'\n          })\n        });\n      } catch (error) {\n        console.error('Failed to notify DataDog about deployment:', error);\n      }\n    }\n\n    // Send to Sentry if configured\n    if (this.env.SENTRY_DSN) {\n      try {\n        await fetch('https://sentry.io/api/0/organizations/YOUR_ORG/releases/', {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Authorization': `Bearer ${this.env.SENTRY_DSN}`,\n          },\n          body: JSON.stringify({\n            version: deploymentData.version || deploymentId,\n            environment: this.env.ENVIRONMENT,\n            dateReleased: new Date().toISOString()\n          })\n        });\n      } catch (error) {\n        console.error('Failed to notify Sentry about deployment:', error);\n      }\n    }\n  }\n}\n\n// Main worker export for monitoring integration\nexport default {\n  async fetch(request: Request, env: MonitoringEnv): Promise<Response> {\n    const integrationService = new MonitoringIntegrationService(env);\n    return await integrationService.handleMonitoringRequest(request);\n  }\n};\n\n// Available Monitoring Integration Endpoints:\n//\n// Performance Monitoring (delegated to PerformanceMonitoringAPI):\n// POST /api/performance/* - All performance monitoring endpoints\n// GET  /api/analytics/* - All analytics endpoints\n// GET  /api/monitoring/* - All monitoring endpoints\n//\n// External Service Integrations:\n// POST /api/external-monitoring/datadog/metrics - Forward metrics to DataDog\n// POST /api/external-monitoring/newrelic/events - Forward events to New Relic\n// POST /api/external-monitoring/amplitude/events - Forward events to Amplitude\n// POST /api/external-monitoring/webhook/alerts - Handle external alert webhooks\n//\n// Deployment Monitoring:\n// POST /api/deployment/track - Track deployment events\n// GET  /api/deployment/metrics - Get deployment metrics\n// POST /api/deployment/health - Track deployment health\n// GET  /api/deployment/status - Get deployment status",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/backend/performance-monitoring.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/triple-slash-reference",
        "severity": 2,
        "message": "Do not use a triple slash reference for ../vite-env.d.ts, use `import` style instead.",
        "line": 1,
        "column": 1,
        "nodeType": "Line",
        "messageId": "tripleSlashReference",
        "endLine": 1,
        "endColumn": 42
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference path=\"../vite-env.d.ts\" />\n// Enhanced Performance Monitoring API for Relife Smart Alarm\n// Advanced performance tracking, analytics, and real-world usage monitoring\n// Built for Cloudflare Workers with D1 Database integration\n\nimport type { D1Database, KVNamespace } from '../types/index';\n\n// Environment bindings interface\ninterface Env {\n  // Database connections\n  DB: D1Database;           // D1 SQL database\n  KV: KVNamespace;          // Key-value storage for caching\n\n  // External service keys\n  SUPABASE_URL: string;\n  SUPABASE_SERVICE_KEY: string;\n  POSTHOG_API_KEY?: string;\n  SENTRY_DSN?: string;\n\n  // Configuration\n  ENVIRONMENT: string;\n  JWT_SECRET: string;\n}\n\n// Performance metrics interfaces\ninterface PerformanceMetric {\n  id?: string;\n  user_id?: string;\n  session_id: string;\n  metric_name: string;\n  metric_value: number;\n  metric_unit?: string;\n  page_path?: string;\n  user_agent?: string;\n  device_type?: string;\n  network_type?: string;\n  timestamp?: string;\n  metadata?: any;\n}\n\ninterface WebVitalsData {\n  session_id: string;\n  user_id?: string;\n  url: string;\n  fcp?: number;    // First Contentful Paint\n  lcp?: number;    // Largest Contentful Paint\n  fid?: number;    // First Input Delay\n  cls?: number;    // Cumulative Layout Shift\n  ttfb?: number;   // Time to First Byte\n  inp?: number;    // Interaction to Next Paint\n  device_type: string;\n  connection_type?: string;\n  viewport_size?: string;\n  user_agent?: string;\n  timestamp: string;\n}\n\ninterface ErrorEvent {\n  user_id?: string;\n  session_id: string;\n  error_message: string;\n  error_stack?: string;\n  error_category: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  page_path?: string;\n  user_agent?: string;\n  device_info?: any;\n  app_version?: string;\n  fingerprint: string;\n}\n\ninterface AnalyticsEvent {\n  event_name: string;\n  user_id?: string;\n  session_id: string;\n  properties: Record<string, any>;\n  timestamp: string;\n  page_path?: string;\n  device_type?: string;\n}\n\n// Performance Monitoring API Class\nexport class PerformanceMonitoringAPI {\n  private env: Env;\n\n  constructor(env: Env) {\n    this.env = env;\n  }\n\n  // Main request handler\n  async handleRequest(request: Request): Promise<Response> {\n    const url = new URL(request.url);\n    const method = request.method;\n    const origin = request.headers.get('Origin') || '*';\n\n    // CORS headers\n    const corsHeaders = this.getCorsHeaders(origin);\n\n    if (method === 'OPTIONS') {\n      return new Response(null, { headers: corsHeaders });\n    }\n\n    try {\n      // Performance metrics collection endpoints\n      if (url.pathname === '/api/performance/metrics' && method === 'POST') {\n        return await this.collectPerformanceMetrics(request, corsHeaders);\n      }\n\n      if (url.pathname === '/api/performance/web-vitals' && method === 'POST') {\n        return await this.collectWebVitals(request, corsHeaders);\n      }\n\n      if (url.pathname === '/api/performance/errors' && method === 'POST') {\n        return await this.logError(request, corsHeaders);\n      }\n\n      if (url.pathname === '/api/performance/analytics' && method === 'POST') {\n        return await this.trackAnalyticsEvent(request, corsHeaders);\n      }\n\n      // Performance data retrieval endpoints\n      if (url.pathname === '/api/performance/dashboard' && method === 'GET') {\n        return await this.getPerformanceDashboard(request, corsHeaders);\n      }\n\n      if (url.pathname === \"/api/performance/user-metrics\" && method === \"GET\") {\n        return await this.getUserMetrics(request, corsHeaders);\n      }\n\n      if (url.pathname === \"/api/performance/system-health\" && method === \"GET\") {\n        return await this.getSystemHealth(request, corsHeaders);\n      }\n\n      if (url.pathname === '/api/performance/real-time' && method === 'GET') {\n        return await this.getRealTimeMetrics(request, corsHeaders);\n      }\n\n      // Advanced analytics endpoints\n      if (url.pathname === '/api/performance/trends' && method === 'GET') {\n        return await this.getPerformanceTrends(request, corsHeaders);\n      }\n\n      if (url.pathname === '/api/performance/anomalies' && method === 'GET') {\n        return await this.detectAnomalies(request, corsHeaders);\n      }\n\n      if (url.pathname === \"/api/performance/recommendations\" && method === \"GET\") {\n        return await this.getOptimizationRecommendations(request, corsHeaders);\n      }\n\n      // Health check\n      if (url.pathname === '/api/performance/health' && method === 'GET') {\n        return this.healthCheck(corsHeaders);\n      }\n\n      return Response.json(\n        { error: \"Not Found\", path: url.pathname },\n        { status: 404, headers: corsHeaders }\n      );\n\n    } catch (error) {\n      console.error('Performance API Error:', error);\n\n      // Log critical errors to monitoring\n      await this.logCriticalError(error, request);\n\n      return Response.json(\n        { error: \"Internal Server Error\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Collect performance metrics\n  private async collectPerformanceMetrics(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      const metrics: PerformanceMetric[] = await request.json();\n\n      if (!Array.isArray(metrics)) {\n        return Response.json(\n          { error: \"Metrics must be an array\" },\n          { status: 400, headers: corsHeaders }\n        );\n      }\n\n      const processedMetrics = [];\n      const timestamp = new Date().toISOString();\n\n      for (const metric of metrics) {\n        const processedMetric = {\n          id: `perf_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n          user_id: metric.user_id || undefined,\n          session_id: metric.session_id,\n          metric_name: metric.metric_name,\n          metric_value: metric.metric_value,\n          metric_unit: metric.metric_unit || 'ms',\n          page_path: metric.page_path || '/',\n          user_agent: metric.user_agent || request.headers.get('User-Agent') || undefined,\n          device_type: metric.device_type || this.detectDeviceType(request.headers.get('User-Agent') || ''),\n          network_type: metric.network_type || 'unknown',\n          timestamp: metric.timestamp || timestamp,\n          metadata: JSON.stringify(metric.metadata || {}),\n          created_at: timestamp\n        };\n\n        processedMetrics.push(processedMetric);\n\n        // Store in D1 database\n        await this.env.DB.prepare(`\n          INSERT INTO performance_analytics\n          (id, user_id, session_id, metric_name, metric_value, metric_unit,\n           page_path, user_agent, device_type, network_type, timestamp, metadata, created_at)\n          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n        `).bind(\n          processedMetric.id, processedMetric.user_id, processedMetric.session_id,\n          processedMetric.metric_name, processedMetric.metric_value, processedMetric.metric_unit,\n          processedMetric.page_path, processedMetric.user_agent, processedMetric.device_type,\n          processedMetric.network_type, processedMetric.timestamp, processedMetric.metadata,\n          processedMetric.created_at\n        ).run();\n\n        // Cache recent metrics for real-time access\n        await this.cacheRecentMetric(processedMetric);\n      }\n\n      // Update real-time aggregations\n      await this.updateRealTimeAggregations(processedMetrics);\n\n      return Response.json(\n        {\n          success: true,\n          processed: processedMetrics.length,\n          timestamp\n        },\n        { headers: corsHeaders }\n      );\n\n    } catch (error) {\n      console.error('Error collecting performance metrics:', error);\n      return Response.json(\n        { error: \"Failed to collect metrics\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Collect Web Vitals data\n  private async collectWebVitals(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      const vitalsData: WebVitalsData = await request.json();\n\n      const timestamp = new Date().toISOString();\n      const vitalsId = `vitals_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      // Store individual Web Vitals metrics\n      const vitalsMetrics = [\n        { name: 'FCP', value: vitalsData.fcp, unit: 'ms' },\n        { name: 'LCP', value: vitalsData.lcp, unit: 'ms' },\n        { name: 'FID', value: vitalsData.fid, unit: 'ms' },\n        { name: 'CLS', value: vitalsData.cls, unit: 'score' },\n        { name: 'TTFB', value: vitalsData.ttfb, unit: 'ms' },\n        { name: 'INP', value: vitalsData.inp, unit: 'ms' }\n      ];\n\n      for (const vital of vitalsMetrics) {\n        if (vital.value !== undefined && vital.value !== null) {\n          await this.env.DB.prepare(`\n            INSERT INTO performance_analytics\n            (id, user_id, session_id, metric_name, metric_value, metric_unit,\n             page_path, user_agent, device_type, network_type, timestamp, metadata, created_at)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n          `).bind(\n            `${vitalsId}_${vital.name.toLowerCase()}`,\n            vitalsData.user_id || null,\n            vitalsData.session_id,\n            `web_vitals_${vital.name.toLowerCase()}`,\n            vital.value,\n            vital.unit,\n            vitalsData.url,\n            vitalsData.user_agent || request.headers.get('User-Agent'),\n            vitalsData.device_type,\n            vitalsData.connection_type || 'unknown',\n            vitalsData.timestamp,\n            JSON.stringify({\n              viewport_size: vitalsData.viewport_size,\n              connection_type: vitalsData.connection_type\n            }),\n            timestamp\n          ).run();\n        }\n      }\n\n      // Cache aggregated Web Vitals for real-time dashboard\n      await this.cacheWebVitalsAggregation(vitalsData);\n\n      // Check for performance budget violations\n      await this.checkPerformanceBudgets(vitalsData);\n\n      return Response.json(\n        {\n          success: true,\n          vitals_id: vitalsId,\n          timestamp\n        },\n        { headers: corsHeaders }\n      );\n\n    } catch (error) {\n      console.error('Error collecting Web Vitals:', error);\n      return Response.json(\n        { error: \"Failed to collect Web Vitals\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Log errors with enhanced context\n  private async logError(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      const errorData: ErrorEvent = await request.json();\n\n      const timestamp = new Date().toISOString();\n      const errorId = `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      // Generate error fingerprint for deduplication\n      const fingerprint = errorData.fingerprint || this.generateErrorFingerprint(errorData);\n\n      // Check if error already exists\n      const existingError = await this.env.DB.prepare(`\n        SELECT id, occurrence_count FROM error_logs\n        WHERE fingerprint = ? AND created_at > datetime('now', '-24 hours')\n        LIMIT 1\n      `).bind(fingerprint).first();\n\n      if (existingError) {\n        // Update existing error count\n        await this.env.DB.prepare(`\n          UPDATE error_logs\n          SET occurrence_count = occurrence_count + 1, last_seen = ?\n          WHERE id = ?\n        `).bind(timestamp, existingError.id).run();\n\n        return Response.json(\n          {\n            success: true,\n            error_id: existingError.id,\n            action: 'updated_existing',\n            occurrence_count: existingError.occurrence_count + 1\n          },\n          { headers: corsHeaders }\n        );\n      }\n\n      // Create new error log\n      await this.env.DB.prepare(`\n        INSERT INTO error_logs\n        (id, user_id, session_id, error_message, error_stack, error_category,\n         severity, page_path, user_agent, device_info, app_version, fingerprint,\n         occurrence_count, first_seen, last_seen, created_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `).bind(\n        errorId,\n        errorData.user_id || null,\n        errorData.session_id,\n        errorData.error_message,\n        errorData.error_stack || null,\n        errorData.error_category,\n        errorData.severity,\n        errorData.page_path || '/',\n        errorData.user_agent || request.headers.get('User-Agent'),\n        JSON.stringify(errorData.device_info || {}),\n        errorData.app_version || 'unknown',\n        fingerprint,\n        1,\n        timestamp,\n        timestamp,\n        timestamp\n      ).run();\n\n      // Cache critical errors for immediate alerting\n      if (errorData.severity === 'critical') {\n        await this.cacheCriticalError(errorData, errorId);\n      }\n\n      // Send to external monitoring services if configured\n      if (this.env.SENTRY_DSN) {\n        await this.sendToSentry(errorData);\n      }\n\n      return Response.json(\n        {\n          success: true,\n          error_id: errorId,\n          action: 'created_new',\n          fingerprint\n        },\n        { headers: corsHeaders }\n      );\n\n    } catch (error) {\n      console.error('Error logging error:', error);\n      return Response.json(\n        { error: \"Failed to log error\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Track analytics events\n  private async trackAnalyticsEvent(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      const eventData: AnalyticsEvent = await request.json();\n\n      const timestamp = new Date().toISOString();\n      const eventId = `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      // Store as performance metric for unified analytics\n      await this.env.DB.prepare(`\n        INSERT INTO performance_analytics\n        (id, user_id, session_id, metric_name, metric_value, metric_unit,\n         page_path, user_agent, device_type, network_type, timestamp, metadata, created_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `).bind(\n        eventId,\n        eventData.user_id || null,\n        eventData.session_id,\n        `analytics_${eventData.event_name}`,\n        1, // Event occurrence count\n        'count',\n        eventData.page_path || '/',\n        request.headers.get('User-Agent'),\n        eventData.device_type || this.detectDeviceType(request.headers.get('User-Agent') || ''),\n        'unknown',\n        eventData.timestamp,\n        JSON.stringify(eventData.properties),\n        timestamp\n      ).run();\n\n      // Cache for real-time analytics\n      await this.cacheAnalyticsEvent(eventData, eventId);\n\n      // Forward to external analytics if configured\n      if (this.env.POSTHOG_API_KEY) {\n        await this.forwardToPostHog(eventData);\n      }\n\n      return Response.json(\n        {\n          success: true,\n          event_id: eventId,\n          timestamp\n        },\n        { headers: corsHeaders }\n      );\n\n    } catch (error) {\n      console.error('Error tracking analytics event:', error);\n      return Response.json(\n        { error: \"Failed to track event\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Get performance dashboard data\n  private async getPerformanceDashboard(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      const url = new URL(request.url);\n      const timeRange = url.searchParams.get('timeRange') || '24h';\n      const userId = url.searchParams.get('userId');\n\n      const timeFilter = this.getTimeFilter(timeRange);\n\n      // Get Web Vitals summary\n      const vitalsQuery = `\n        SELECT\n          metric_name,\n          AVG(metric_value) as avg_value,\n          MIN(metric_value) as min_value,\n          MAX(metric_value) as max_value,\n          COUNT(*) as sample_count\n        FROM performance_analytics\n        WHERE metric_name LIKE 'web_vitals_%'\n        AND timestamp > datetime('now', '${timeFilter}')\n        ${userId ? 'AND user_id = ?' : ''}\n        GROUP BY metric_name\n      `;\n\n      const vitalsResults = userId\n        ? await this.env.DB.prepare(vitalsQuery).bind(userId).all()\n        : await this.env.DB.prepare(vitalsQuery).all();\n\n      // Get error summary\n      const errorQuery = `\n        SELECT\n          severity,\n          COUNT(*) as error_count,\n          SUM(occurrence_count) as total_occurrences\n        FROM error_logs\n        WHERE created_at > datetime('now', '${timeFilter}')\n        ${userId ? 'AND user_id = ?' : ''}\n        GROUP BY severity\n      `;\n\n      const errorResults = userId\n        ? await this.env.DB.prepare(errorQuery).bind(userId).all()\n        : await this.env.DB.prepare(errorQuery).all();\n\n      // Get device type distribution\n      const deviceQuery = `\n        SELECT\n          device_type,\n          COUNT(*) as count\n        FROM performance_analytics\n        WHERE timestamp > datetime('now', '${timeFilter}')\n        ${userId ? 'AND user_id = ?' : ''}\n        GROUP BY device_type\n        ORDER BY count DESC\n      `;\n\n      const deviceResults = userId\n        ? await this.env.DB.prepare(deviceQuery).bind(userId).all()\n        : await this.env.DB.prepare(deviceQuery).all();\n\n      // Get performance trends (hourly)\n      const trendsQuery = `\n        SELECT\n          strftime('%H', timestamp) as hour,\n          metric_name,\n          AVG(metric_value) as avg_value\n        FROM performance_analytics\n        WHERE metric_name IN ('web_vitals_lcp', 'web_vitals_fid', 'web_vitals_cls')\n        AND timestamp > datetime('now', '${timeFilter}')\n        ${userId ? 'AND user_id = ?' : ''}\n        GROUP BY hour, metric_name\n        ORDER BY hour, metric_name\n      `;\n\n      const trendsResults = userId\n        ? await this.env.DB.prepare(trendsQuery).bind(userId).all()\n        : await this.env.DB.prepare(trendsQuery).all();\n\n      const dashboard = {\n        timeRange,\n        generatedAt: new Date().toISOString(),\n        webVitals: this.processVitalsResults(vitalsResults.results || []),\n        errors: this.processErrorResults(errorResults.results || []),\n        deviceDistribution: deviceResults.results || [],\n        performanceTrends: this.processeTrendsResults(trendsResults.results || []),\n        summary: {\n          totalMetrics: vitalsResults.results?.reduce((sum: number, v: any) => sum + v.sample_count, 0) || 0,\n          totalErrors: errorResults.results?.reduce((sum: number, e: any) => sum + e.total_occurrences, 0) || 0,\n          uniqueUsers: await this.getUniqueUsersCount(timeFilter, userId),\n          avgPerformanceScore: await this.calculatePerformanceScore(timeFilter, userId)\n        }\n      };\n\n      return Response.json(dashboard, { headers: corsHeaders });\n\n    } catch (error) {\n      console.error('Error getting performance dashboard:', error);\n      return Response.json(\n        { error: \"Failed to get dashboard data\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Get user-specific metrics\n  private async getUserMetrics(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      const url = new URL(request.url);\n      const userId = url.searchParams.get('userId');\n      const sessionId = url.searchParams.get('sessionId');\n      const timeRange = url.searchParams.get('timeRange') || '7d';\n\n      if (!userId && !sessionId) {\n        return Response.json(\n          { error: \"Either userId or sessionId is required\" },\n          { status: 400, headers: corsHeaders }\n        );\n      }\n\n      const timeFilter = this.getTimeFilter(timeRange);\n      let whereClause = `WHERE timestamp > datetime('now', '${timeFilter}')`;\n      const bindParams: string[] = [];\n\n      if (userId) {\n        whereClause += ` AND user_id = ?`;\n        bindParams.push(userId);\n      }\n\n      if (sessionId) {\n        whereClause += ` AND session_id = ?`;\n        bindParams.push(sessionId);\n      }\n\n      // Get user's performance metrics over time\n      const metricsQuery = `\n        SELECT\n          DATE(timestamp) as date,\n          metric_name,\n          AVG(metric_value) as avg_value,\n          MIN(metric_value) as min_value,\n          MAX(metric_value) as max_value,\n          COUNT(*) as sample_count\n        FROM performance_analytics\n        ${whereClause}\n        GROUP BY DATE(timestamp), metric_name\n        ORDER BY date DESC, metric_name\n      `;\n\n      const stmt = this.env.DB.prepare(metricsQuery);\n      const metricsResults = bindParams.length > 0\n        ? await stmt.bind(...bindParams).all()\n        : await stmt.all();\n\n      // Get user's error patterns\n      const errorsQuery = `\n        SELECT\n          DATE(created_at) as date,\n          error_category,\n          severity,\n          COUNT(*) as error_count,\n          SUM(occurrence_count) as total_occurrences\n        FROM error_logs\n        ${whereClause.replace('timestamp', 'created_at')}\n        GROUP BY DATE(created_at), error_category, severity\n        ORDER BY date DESC\n      `;\n\n      const errorStmt = this.env.DB.prepare(errorsQuery);\n      const errorResults = bindParams.length > 0\n        ? await errorStmt.bind(...bindParams).all()\n        : await errorStmt.all();\n\n      const userMetrics = {\n        userId,\n        sessionId,\n        timeRange,\n        generatedAt: new Date().toISOString(),\n        performanceMetrics: metricsResults.results || [],\n        errorPatterns: errorResults.results || [],\n        insights: await this.generateUserInsights(userId, sessionId, timeFilter)\n      };\n\n      return Response.json(userMetrics, { headers: corsHeaders });\n\n    } catch (error) {\n      console.error('Error getting user metrics:', error);\n      return Response.json(\n        { error: \"Failed to get user metrics\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Get system health status\n  private async getSystemHealth(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      const currentTime = new Date().toISOString();\n\n      // Check recent error rates\n      const recentErrors = await this.env.DB.prepare(`\n        SELECT COUNT(*) as error_count, SUM(occurrence_count) as total_occurrences\n        FROM error_logs\n        WHERE created_at > datetime('now', '-1 hour')\n      `).first();\n\n      // Check performance thresholds\n      const recentPerformance = await this.env.DB.prepare(`\n        SELECT\n          metric_name,\n          AVG(metric_value) as avg_value\n        FROM performance_analytics\n        WHERE metric_name IN ('web_vitals_lcp', 'web_vitals_fid', 'web_vitals_cls')\n        AND timestamp > datetime('now', '-1 hour')\n        GROUP BY metric_name\n      `).all();\n\n      // Check database health\n      const dbHealth = await this.checkDatabaseHealth();\n\n      // Calculate overall health score\n      const healthScore = this.calculateHealthScore(recentErrors, recentPerformance.results || []);\n\n      const healthStatus = {\n        status: healthScore > 0.8 ? 'healthy' : healthScore > 0.6 ? 'warning' : 'critical',\n        score: healthScore,\n        timestamp: currentTime,\n        checks: {\n          database: dbHealth,\n          errors: {\n            recentCount: recentErrors?.error_count || 0,\n            totalOccurrences: recentErrors?.total_occurrences || 0,\n            status: (recentErrors?.total_occurrences || 0) < 10 ? 'healthy' : 'warning'\n          },\n          performance: {\n            metrics: recentPerformance.results || [],\n            status: this.getPerformanceHealthStatus(recentPerformance.results || [])\n          }\n        }\n      };\n\n      return Response.json(healthStatus, { headers: corsHeaders });\n\n    } catch (error) {\n      console.error('Error getting system health:', error);\n      return Response.json(\n        {\n          status: 'critical',\n          error: \"Failed to get system health\",\n          timestamp: new Date().toISOString()\n        },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Get real-time metrics\n  private async getRealTimeMetrics(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      // Get cached real-time data from KV\n      const realtimeKey = 'performance:realtime:current';\n      const cached = await this.env.KV.get(realtimeKey, 'json');\n\n      if (cached) {\n        return Response.json(cached, { headers: corsHeaders });\n      }\n\n      // Fallback to recent database data\n      const realtimeData = await this.generateRealTimeMetrics();\n\n      // Cache for 30 seconds\n      await this.env.KV.put(realtimeKey, JSON.stringify(realtimeData), {\n        expirationTtl: 30\n      });\n\n      return Response.json(realtimeData, { headers: corsHeaders });\n\n    } catch (error) {\n      console.error('Error getting real-time metrics:', error);\n      return Response.json(\n        { error: \"Failed to get real-time metrics\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Get performance trends\n  private async getPerformanceTrends(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      const url = new URL(request.url);\n      const timeRange = url.searchParams.get('timeRange') || '7d';\n      const metric = url.searchParams.get('metric') || 'web_vitals_lcp';\n      const granularity = url.searchParams.get('granularity') || 'hour';\n\n      const timeFilter = this.getTimeFilter(timeRange);\n      const timeFormat = granularity === 'hour' ? '%Y-%m-%d %H:00:00' : '%Y-%m-%d';\n\n      const trendsQuery = `\n        SELECT\n          strftime('${timeFormat}', timestamp) as time_bucket,\n          AVG(metric_value) as avg_value,\n          MIN(metric_value) as min_value,\n          MAX(metric_value) as max_value,\n          COUNT(*) as sample_count,\n          PERCENTILE(metric_value, 0.5) as p50,\n          PERCENTILE(metric_value, 0.95) as p95\n        FROM performance_analytics\n        WHERE metric_name = ?\n        AND timestamp > datetime('now', '${timeFilter}')\n        GROUP BY time_bucket\n        ORDER BY time_bucket\n      `;\n\n      const results = await this.env.DB.prepare(trendsQuery).bind(metric).all();\n\n      const trends = {\n        metric,\n        timeRange,\n        granularity,\n        generatedAt: new Date().toISOString(),\n        data: results.results || [],\n        analysis: this.analyzeTrends(results.results || [])\n      };\n\n      return Response.json(trends, { headers: corsHeaders });\n\n    } catch (error) {\n      console.error('Error getting performance trends:', error);\n      return Response.json(\n        { error: \"Failed to get performance trends\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Detect anomalies\n  private async detectAnomalies(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      const url = new URL(request.url);\n      const timeRange = url.searchParams.get('timeRange') || '24h';\n      const sensitivity = parseFloat(url.searchParams.get('sensitivity') || '2.0');\n\n      const anomalies = await this.performAnomalyDetection(timeRange, sensitivity);\n\n      return Response.json({\n        timeRange,\n        sensitivity,\n        generatedAt: new Date().toISOString(),\n        anomalies\n      }, { headers: corsHeaders });\n\n    } catch (error) {\n      console.error('Error detecting anomalies:', error);\n      return Response.json(\n        { error: \"Failed to detect anomalies\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Get optimization recommendations\n  private async getOptimizationRecommendations(request: Request, corsHeaders: HeadersInit): Promise<Response> {\n    try {\n      const url = new URL(request.url);\n      const userId = url.searchParams.get('userId');\n      const timeRange = url.searchParams.get('timeRange') || '7d';\n\n      const recommendations = await this.generateOptimizationRecommendations(userId, timeRange);\n\n      return Response.json({\n        userId,\n        timeRange,\n        generatedAt: new Date().toISOString(),\n        recommendations\n      }, { headers: corsHeaders });\n\n    } catch (error) {\n      console.error('Error getting optimization recommendations:', error);\n      return Response.json(\n        { error: \"Failed to get recommendations\" },\n        { status: 500, headers: corsHeaders }\n      );\n    }\n  }\n\n  // Health check endpoint\n  private healthCheck(corsHeaders: HeadersInit): Response {\n    return Response.json(\n      {\n        status: 'healthy',\n        timestamp: new Date().toISOString(),\n        version: \"2.0.0\",\n        environment: this.env.ENVIRONMENT || \"production\"\n      },\n      { headers: corsHeaders }\n    );\n  }\n\n  // Helper methods\n\n  private getCorsHeaders(origin: string): HeadersInit {\n    return {\n      'Access-Control-Allow-Origin': origin || '*',\n      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',\n      'Access-Control-Allow-Headers': 'Content-Type, Authorization',\n      'Content-Type': 'application/json',\n    };\n  }\n\n  private detectDeviceType(userAgent: string): string {\n    if (/Mobile|Android|iPhone|iPad/i.test(userAgent)) {\n      return 'mobile';\n    } else if (/Tablet|iPad/i.test(userAgent)) {\n      return 'tablet';\n    }\n    return 'desktop';\n  }\n\n  private generateErrorFingerprint(error: ErrorEvent): string {\n    const content = `${error.error_message}${error.error_category}${error.page_path}`;\n    return btoa(content).substring(0, 32);\n  }\n\n  private getTimeFilter(timeRange: string): string {\n    const timeMap: Record<string, string> = {\n      '1h': '-1 hour',\n      '24h': '-24 hours',\n      '7d': '-7 days',\n      '30d': '-30 days',\n      '90d': '-90 days'\n    };\n    return timeMap[timeRange] || '-24 hours';\n  }\n\n  private processVitalsResults(results: any[]): any {\n    const processed: Record<string, any> = {};\n    for (const result of results) {\n      const metric = result.metric_name.replace('web_vitals_', '');\n      processed[metric] = {\n        average: result.avg_value,\n        min: result.min_value,\n        max: result.max_value,\n        samples: result.sample_count\n      };\n    }\n    return processed;\n  }\n\n  private processErrorResults(results: any[]): any {\n    const processed: Record<string, any> = {};\n    for (const result of results) {\n      processed[result.severity] = {\n        count: result.error_count,\n        occurrences: result.total_occurrences\n      };\n    }\n    return processed;\n  }\n\n  private processeTrendsResults(results: any[]): any {\n    const processed: Record<string, any[]> = {};\n    for (const result of results) {\n      if (!processed[result.metric_name]) {\n        processed[result.metric_name] = [];\n      }\n      processed[result.metric_name].push({\n        hour: result.hour,\n        value: result.avg_value\n      });\n    }\n    return processed;\n  }\n\n  private async getUniqueUsersCount(timeFilter: string, userId?: string | null): Promise<number> {\n    const query = `\n      SELECT COUNT(DISTINCT user_id) as unique_users\n      FROM performance_analytics\n      WHERE timestamp > datetime('now', '${timeFilter}')\n      AND user_id IS NOT NULL\n      ${userId ? 'AND user_id = ?' : ''}\n    `;\n\n    const result = userId\n      ? await this.env.DB.prepare(query).bind(userId).first()\n      : await this.env.DB.prepare(query).first();\n\n    return result?.unique_users || 0;\n  }\n\n  private async calculatePerformanceScore(timeFilter: string, userId?: string | null): Promise<number> {\n    // Simplified performance score calculation\n    const query = `\n      SELECT\n        AVG(CASE WHEN metric_name = 'web_vitals_lcp' THEN metric_value END) as avg_lcp,\n        AVG(CASE WHEN metric_name = 'web_vitals_fid' THEN metric_value END) as avg_fid,\n        AVG(CASE WHEN metric_name = 'web_vitals_cls' THEN metric_value END) as avg_cls\n      FROM performance_analytics\n      WHERE timestamp > datetime('now', '${timeFilter}')\n      AND metric_name LIKE 'web_vitals_%'\n      ${userId ? 'AND user_id = ?' : ''}\n    `;\n\n    const result = userId\n      ? await this.env.DB.prepare(query).bind(userId).first()\n      : await this.env.DB.prepare(query).first();\n\n    if (!result) return 0;\n\n    // Score based on Web Vitals thresholds\n    let score = 100;\n    if (result.avg_lcp > 4000) score -= 30;\n    else if (result.avg_lcp > 2500) score -= 15;\n\n    if (result.avg_fid > 300) score -= 25;\n    else if (result.avg_fid > 100) score -= 10;\n\n    if (result.avg_cls > 0.25) score -= 25;\n    else if (result.avg_cls > 0.1) score -= 10;\n\n    return Math.max(0, score) / 100;\n  }\n\n  private async checkDatabaseHealth(): Promise<any> {\n    try {\n      const start = Date.now();\n      await this.env.DB.prepare('SELECT 1').first();\n      const responseTime = Date.now() - start;\n\n      return {\n        status: responseTime < 100 ? 'healthy' : 'warning',\n        responseTime: responseTime,\n        timestamp: new Date().toISOString()\n      };\n    } catch (_error) {\n      return {\n        status: 'critical',\n        error: 'Database connection failed',\n        timestamp: new Date().toISOString()\n      };\n    }\n  }\n\n  private calculateHealthScore(recentErrors: any, performanceMetrics: any[]): number {\n    let score = 1.0;\n\n    // Deduct for errors\n    if (recentErrors?.total_occurrences) {\n      score -= Math.min(0.4, recentErrors.total_occurrences / 100);\n    }\n\n    // Deduct for poor performance\n    for (const metric of performanceMetrics) {\n      if (metric.metric_name === 'web_vitals_lcp' && metric.avg_value > 4000) {\n        score -= 0.2;\n      }\n      if (metric.metric_name === 'web_vitals_fid' && metric.avg_value > 300) {\n        score -= 0.2;\n      }\n      if (metric.metric_name === 'web_vitals_cls' && metric.avg_value > 0.25) {\n        score -= 0.2;\n      }\n    }\n\n    return Math.max(0, score);\n  }\n\n  private getPerformanceHealthStatus(metrics: any[]): string {\n    for (const metric of metrics) {\n      if (metric.metric_name === 'web_vitals_lcp' && metric.avg_value > 4000) return 'warning';\n      if (metric.metric_name === 'web_vitals_fid' && metric.avg_value > 300) return 'warning';\n      if (metric.metric_name === 'web_vitals_cls' && metric.avg_value > 0.25) return 'warning';\n    }\n    return 'healthy';\n  }\n\n  private async generateRealTimeMetrics(): Promise<any> {\n    const current5Min = await this.env.DB.prepare(`\n      SELECT\n        metric_name,\n        AVG(metric_value) as avg_value,\n        COUNT(*) as sample_count\n      FROM performance_analytics\n      WHERE timestamp > datetime('now', '-5 minutes')\n      GROUP BY metric_name\n    `).all();\n\n    return {\n      timestamp: new Date().toISOString(),\n      period: '5 minutes',\n      metrics: current5Min.results || []\n    };\n  }\n\n  private analyzeTrends(data: any[]): any {\n    if (data.length < 2) return { trend: 'insufficient_data' };\n\n    const values = data.map(d => d.avg_value);\n    const first = values[0];\n    const last = values[values.length - 1];\n    const change = ((last - first) / first) * 100;\n\n    return {\n      trend: change > 5 ? 'increasing' : change < -5 ? 'decreasing' : 'stable',\n      changePercent: change,\n      direction: change > 0 ? 'up' : 'down'\n    };\n  }\n\n  private async performAnomalyDetection(timeRange: string, sensitivity: number): Promise<any[]> {\n    // Simplified anomaly detection using statistical methods\n    const timeFilter = this.getTimeFilter(timeRange);\n\n    const results = await this.env.DB.prepare(`\n      SELECT\n        metric_name,\n        metric_value,\n        timestamp\n      FROM performance_analytics\n      WHERE timestamp > datetime('now', '${timeFilter}')\n      AND metric_name IN ('web_vitals_lcp', 'web_vitals_fid', 'web_vitals_cls')\n      ORDER BY timestamp\n    `).all();\n\n    // Group by metric and detect anomalies\n    const anomalies: any[] = [];\n    const metricGroups: Record<string, any[]> = {};\n\n    for (const result of (results.results || [])) {\n      if (!metricGroups[result.metric_name]) {\n        metricGroups[result.metric_name] = [];\n      }\n      metricGroups[result.metric_name].push(result);\n    }\n\n    for (const [metricName, values] of Object.entries(metricGroups)) {\n      const mean = values.reduce((sum, v) => sum + v.metric_value, 0) / values.length;\n      const variance = values.reduce((sum, v) => sum + Math.pow(v.metric_value - mean, 2), 0) / values.length;\n      const stdDev = Math.sqrt(variance);\n\n      const threshold = mean + (sensitivity * stdDev);\n\n      for (const value of values) {\n        if (value.metric_value > threshold) {\n          anomalies.push({\n            metric: metricName,\n            value: value.metric_value,\n            timestamp: value.timestamp,\n            threshold,\n            severity: value.metric_value > (threshold * 1.5) ? 'high' : 'medium'\n          });\n        }\n      }\n    }\n\n    return anomalies;\n  }\n\n  private async generateOptimizationRecommendations(userId: string | null, timeRange: string): Promise<any[]> {\n    const recommendations: any[] = [];\n\n    // Analyze performance patterns and generate recommendations\n    const timeFilter = this.getTimeFilter(timeRange);\n    let whereClause = `WHERE timestamp > datetime('now', '${timeFilter}')`;\n\n    if (userId) {\n      whereClause += ` AND user_id = '${userId}'`;\n    }\n\n    const analysis = await this.env.DB.prepare(`\n      SELECT\n        metric_name,\n        AVG(metric_value) as avg_value,\n        device_type,\n        COUNT(*) as sample_count\n      FROM performance_analytics\n      ${whereClause}\n      AND metric_name LIKE 'web_vitals_%'\n      GROUP BY metric_name, device_type\n    `).all();\n\n    // Generate recommendations based on analysis\n    for (const result of (analysis.results || [])) {\n      if (result.metric_name === 'web_vitals_lcp' && result.avg_value > 2500) {\n        recommendations.push({\n          type: 'performance',\n          severity: result.avg_value > 4000 ? 'high' : 'medium',\n          title: 'Optimize Largest Contentful Paint',\n          description: `LCP is ${Math.round(result.avg_value)}ms on ${result.device_type} devices. Target: <2500ms`,\n          suggestion: 'Consider optimizing images, improving server response times, or preloading critical resources.',\n          impact: 'User experience and SEO rankings',\n          metric: 'web_vitals_lcp',\n          deviceType: result.device_type,\n          currentValue: result.avg_value,\n          targetValue: 2500\n        });\n      }\n\n      if (result.metric_name === 'web_vitals_fid' && result.avg_value > 100) {\n        recommendations.push({\n          type: 'interactivity',\n          severity: result.avg_value > 300 ? 'high' : 'medium',\n          title: 'Improve First Input Delay',\n          description: `FID is ${Math.round(result.avg_value)}ms on ${result.device_type} devices. Target: <100ms`,\n          suggestion: 'Reduce JavaScript execution time, break up long tasks, or use web workers for heavy computations.',\n          impact: 'User interaction responsiveness',\n          metric: 'web_vitals_fid',\n          deviceType: result.device_type,\n          currentValue: result.avg_value,\n          targetValue: 100\n        });\n      }\n\n      if (result.metric_name === 'web_vitals_cls' && result.avg_value > 0.1) {\n        recommendations.push({\n          type: 'stability',\n          severity: result.avg_value > 0.25 ? 'high' : 'medium',\n          title: 'Reduce Cumulative Layout Shift',\n          description: `CLS is ${result.avg_value.toFixed(3)} on ${result.device_type} devices. Target: <0.1`,\n          suggestion: 'Add size attributes to images and videos, avoid inserting content above existing content, or preload fonts.',\n          impact: 'Visual stability and user experience',\n          metric: 'web_vitals_cls',\n          deviceType: result.device_type,\n          currentValue: result.avg_value,\n          targetValue: 0.1\n        });\n      }\n    }\n\n    return recommendations;\n  }\n\n  private async generateUserInsights(userId: string | null, sessionId: string | null, _timeFilter: string): Promise<any[]> {\n    const insights: any[] = [];\n\n    // Add user-specific insights based on their patterns\n    if (userId || sessionId) {\n      insights.push({\n        type: 'user_pattern',\n        title: 'Performance Pattern Analysis',\n        description: 'Based on your usage patterns over the selected time period.',\n        confidence: 0.8\n      });\n    }\n\n    return insights;\n  }\n\n  // Cache management methods\n  private async cacheRecentMetric(metric: PerformanceMetric): Promise<void> {\n    const key = `metric:recent:${metric.session_id}:${Date.now()}`;\n    await this.env.KV.put(key, JSON.stringify(metric), { expirationTtl: 3600 });\n  }\n\n  private async cacheWebVitalsAggregation(vitals: WebVitalsData): Promise<void> {\n    const key = `vitals:${vitals.session_id}:${Date.now()}`;\n    await this.env.KV.put(key, JSON.stringify(vitals), { expirationTtl: 86400 });\n  }\n\n  private async cacheAnalyticsEvent(event: AnalyticsEvent, eventId: string): Promise<void> {\n    const key = `analytics:${event.session_id}:${eventId}`;\n    await this.env.KV.put(key, JSON.stringify(event), { expirationTtl: 3600 });\n  }\n\n  private async cacheCriticalError(error: ErrorEvent, errorId: string): Promise<void> {\n    const key = `error:critical:${errorId}`;\n    await this.env.KV.put(key, JSON.stringify(error), { expirationTtl: 3600 });\n  }\n\n  private async updateRealTimeAggregations(metrics: PerformanceMetric[]): Promise<void> {\n    // Update real-time aggregations in KV for dashboard\n    const realtimeKey = 'performance:realtime:current';\n    const current = await this.env.KV.get(realtimeKey, 'json') || {\n      metrics: {},\n      lastUpdated: new Date().toISOString()\n    };\n\n    // Aggregate new metrics\n    for (const metric of metrics) {\n      if (!current.metrics[metric.metric_name]) {\n        current.metrics[metric.metric_name] = { sum: 0, count: 0, avg: 0 };\n      }\n\n      const existing = current.metrics[metric.metric_name];\n      existing.sum += metric.metric_value;\n      existing.count += 1;\n      existing.avg = existing.sum / existing.count;\n    }\n\n    current.lastUpdated = new Date().toISOString();\n\n    await this.env.KV.put(realtimeKey, JSON.stringify(current), { expirationTtl: 60 });\n  }\n\n  private async checkPerformanceBudgets(vitals: WebVitalsData): Promise<void> {\n    // Define performance budgets\n    const budgets = {\n      lcp: 2500,    // milliseconds\n      fid: 100,     // milliseconds\n      cls: 0.1,     // score\n      ttfb: 800     // milliseconds\n    };\n\n    const violations: string[] = [];\n\n    if (vitals.lcp && vitals.lcp > budgets.lcp) violations.push('LCP');\n    if (vitals.fid && vitals.fid > budgets.fid) violations.push('FID');\n    if (vitals.cls && vitals.cls > budgets.cls) violations.push('CLS');\n    if (vitals.ttfb && vitals.ttfb > budgets.ttfb) violations.push('TTFB');\n\n    if (violations.length > 0) {\n      // Cache budget violations for alerting\n      const violationKey = `budget_violation:${vitals.session_id}:${Date.now()}`;\n      await this.env.KV.put(violationKey, JSON.stringify({\n        session_id: vitals.session_id,\n        user_id: vitals.user_id,\n        violations,\n        vitals,\n        timestamp: new Date().toISOString()\n      }), { expirationTtl: 3600 });\n    }\n  }\n\n  // External service integrations\n  private async sendToSentry(error: ErrorEvent): Promise<void> {\n    if (!this.env.SENTRY_DSN) return;\n\n    try {\n      // Send to Sentry (simplified)\n      await fetch(`https://sentry.io/api/0/store/`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Sentry-Auth': `Sentry sentry_version=7, sentry_key=${this.env.SENTRY_DSN}`\n        },\n        body: JSON.stringify({\n          message: error.error_message,\n          level: error.severity,\n          platform: 'javascript',\n          exception: {\n            values: [{\n              type: error.error_category,\n              value: error.error_message,\n              stacktrace: error.error_stack\n            }]\n          },\n          user: { id: error.user_id },\n          contexts: {\n            device: error.device_info\n          }\n        })\n      });\n    } catch (e) {\n      console.error('Failed to send to Sentry:', e);\n    }\n  }\n\n  private async forwardToPostHog(event: AnalyticsEvent): Promise<void> {\n    if (!this.env.POSTHOG_API_KEY) return;\n\n    try {\n      await fetch('https://app.posthog.com/capture/', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          api_key: this.env.POSTHOG_API_KEY,\n          event: event.event_name,\n          distinct_id: event.user_id || event.session_id,\n          properties: {\n            ...event.properties,\n            $current_url: event.page_path,\n            $device_type: event.device_type,\n            timestamp: event.timestamp\n          }\n        })\n      });\n    } catch (e) {\n      console.error('Failed to forward to PostHog:', e);\n    }\n  }\n\n  private async logCriticalError(error: any, request: Request): Promise<void> {\n    try {\n      const errorData: ErrorEvent = {\n        session_id: 'system',\n        error_message: error.message || 'Unknown error',\n        error_stack: error.stack,\n        error_category: 'system_error',\n        severity: 'critical',\n        page_path: new URL(request.url).pathname,\n        user_agent: request.headers.get('User-Agent') || 'unknown',\n        app_version: '2.0.0',\n        fingerprint: this.generateErrorFingerprint({\n          session_id: 'system',\n          error_message: error.message || 'Unknown error',\n          error_category: 'system_error',\n          severity: 'critical',\n          fingerprint: ''\n        })\n      };\n\n      const errorId = `system_error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n      await this.env.DB.prepare(`\n        INSERT INTO error_logs\n        (id, session_id, error_message, error_stack, error_category,\n         severity, page_path, user_agent, app_version, fingerprint,\n         occurrence_count, first_seen, last_seen, created_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `).bind(\n        errorId, errorData.session_id, errorData.error_message, errorData.error_stack,\n        errorData.error_category, errorData.severity, errorData.page_path,\n        errorData.user_agent, errorData.app_version, errorData.fingerprint,\n        1, new Date().toISOString(), new Date().toISOString(), new Date().toISOString()\n      ).run();\n\n    } catch (logError) {\n      console.error('Failed to log critical error:', logError);\n    }\n  }\n}\n\n// Worker request handler\nexport default {\n  async fetch(request: Request, env: Env): Promise<Response> {\n    const api = new PerformanceMonitoringAPI(env);\n    return await api.handleRequest(request);\n  }\n};\n\n// Available Performance Monitoring API Endpoints:\n//\n// Data Collection:\n// POST /api/performance/metrics - Collect general performance metrics\n// POST /api/performance/web-vitals - Collect Web Vitals data\n// POST /api/performance/errors - Log application errors\n// POST /api/performance/analytics - Track analytics events\n//\n// Data Retrieval:\n// GET  /api/performance/dashboard - Get performance dashboard data\n// GET  /api/performance/user-metrics - Get user-specific metrics\n// GET  /api/performance/system-health - Get overall system health\n// GET  /api/performance/real-time - Get real-time performance data\n//\n// Advanced Analytics:\n// GET  /api/performance/trends - Get performance trends over time\n// GET  /api/performance/anomalies - Detect performance anomalies\n// GET  /api/performance/recommendations - Get optimization recommendations\n//\n// Health Check:\n// GET  /api/performance/health - API health check",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/AdvancedSchedulingDashboard.tsx",
    "messages": [
      {
        "ruleId": null,
        "nodeType": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 704,
        "column": 0
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect, useCallback } from 'react';\nimport {\n  Calendar,\n  Clock,\n  Brain,\n  MapPin,\n  TrendingUp,\n  Zap,\n  Settings,\n  ChevronRight,\n  AlertCircle,\n  CheckCircle,\n  Target,\n  Sun,\n  Moon,\n  BarChart3,\n  Activity,\n  Lightbulb,\n  Bell,\n  Sparkles,\n} from \"lucide-react\";\nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\nimport { Button } from \"@/components/ui/button\";\nimport { Badge } from \"@/components/ui/badge\";\nimport { Progress } from \"@/components/ui/progress\";\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from \"@/components/ui/tabs\";\nimport { Switch } from \"@/components/ui/switch\";\nimport { Slider } from \"@/components/ui/slider\";\n\nimport MLAlarmOptimizer from \"../services/ml-alarm-optimizer\";\nimport EnhancedLocationService from \"../services/enhanced-location-service\";\nimport PredictiveAnalyticsService from \"../services/predictive-analytics-service\";\nimport { User } from \"../types/index\";\n\ninterface AdvancedSchedulingDashboardProps {\n  alarms: any[];\n  user: User;\n  onUpdateAlarm: (id: string, updates: any) => void;\n  onCreateAlarm: () => void;\n}\n\nexport function AdvancedSchedulingDashboard({\n  alarms,\n  user,\n  onUpdateAlarm,\n  onCreateAlarm\n}: AdvancedSchedulingDashboardProps) {\n  const [activeTab, setActiveTab] = useState<'overview' | 'ml' | 'location' | 'analytics' | 'settings'>('overview');\n  const [mlEnabled, setMlEnabled] = useState(false);\n  const [locationEnabled, setLocationEnabled] = useState(false);\n  const [analyticsEnabled, setAnalyticsEnabled] = useState(false);\n\n  // ML Optimization State\n  const [predictions, setPredictions] = useState<any[]>([]);\n  const [mlStats, setMlStats] = useState({ patterns: 0, predictions: 0, accuracy: 0 });\n  const [optimizationSuggestions, setOptimizationSuggestions] = useState<any[]>([]);\n\n  // Location State\n  const [locationPatterns, setLocationPatterns] = useState<any[]>([]);\n  const [geofences, setGeofences] = useState<any[]>([]);\n  const [locationStats, setLocationStats] = useState({ patterns: 0, geofences: 0, historyPoints: 0, isTracking: false });\n\n  // Analytics State\n  const [detectedPatterns, setDetectedPatterns] = useState<any[]>([]);\n  const [predictiveInsights, setPredictiveInsights] = useState<any[]>([]);\n  const [analyticsStats, setAnalyticsStats] = useState({ patterns: 0, insights: 0, lastAnalysis: null, isEnabled: false });\n\n  // Loading States\n  const [loading, setLoading] = useState({ ml: false, location: false, analytics: false });\n\n  useEffect(() => {\n    loadAdvancedSchedulingData();\n  }, []);\n\n  const loadAdvancedSchedulingData = useCallback(async () => {\n    try {\n      // Load ML data\n      setMlEnabled(MLAlarmOptimizer.isMLEnabled());\n      setMlStats(MLAlarmOptimizer.getMLStats());\n\n      // Load location data\n      setLocationEnabled(EnhancedLocationService.isLocationEnabled());\n      setLocationPatterns(EnhancedLocationService.getLocationPatterns());\n      setGeofences(EnhancedLocationService.getGeofences());\n      setLocationStats(EnhancedLocationService.getLocationStats());\n\n      // Load analytics data\n      setAnalyticsEnabled(PredictiveAnalyticsService.isAnalyticsEnabled());\n      setDetectedPatterns(PredictiveAnalyticsService.getDetectedPatterns());\n      setPredictiveInsights(PredictiveAnalyticsService.getRecentInsights(7));\n      setAnalyticsStats(PredictiveAnalyticsService.getAnalyticsStats());\n\n      // Load optimization suggestions\n      if (MLAlarmOptimizer.isMLEnabled()) {\n        const suggestions = await MLAlarmOptimizer.getOptimizationSuggestions(user.id);\n        setOptimizationSuggestions(suggestions);\n      }\n\n    } catch (error) {\n      console.error('Error loading advanced scheduling data:', error);\n    }\n  }, [user.id]);\n\n  const handleMLToggle = async (enabled: boolean) => {\n    setLoading(prev => ({ ...prev, ml: true }));\n    try {\n      await MLAlarmOptimizer.enableMLOptimization(enabled);\n      setMlEnabled(enabled);\n      if (enabled) {\n        await loadAdvancedSchedulingData();\n      }\n    } catch (error) {\n      console.error('Error toggling ML optimization:', error);\n    } finally {\n      setLoading(prev => ({ ...prev, ml: false }));\n    }\n  };\n\n  const handleLocationToggle = async (enabled: boolean) => {\n    setLoading(prev => ({ ...prev, location: true }));\n    try {\n      await EnhancedLocationService.enableLocationServices(enabled);\n      setLocationEnabled(enabled);\n      if (enabled) {\n        await loadAdvancedSchedulingData();\n      }\n    } catch (error) {\n      console.error('Error toggling location services:', error);\n    } finally {\n      setLoading(prev => ({ ...prev, location: false }));\n    }\n  };\n\n  const handleAnalyticsToggle = async (enabled: boolean) => {\n    setLoading(prev => ({ ...prev, analytics: true }));\n    try {\n      await PredictiveAnalyticsService.enablePredictiveAnalytics(enabled);\n      setAnalyticsEnabled(enabled);\n      if (enabled) {\n        await loadAdvancedSchedulingData();\n      }\n    } catch (error) {\n      console.error('Error toggling predictive analytics:', error);\n    } finally {\n      setLoading(prev => ({ ...prev, analytics: false }));\n    }\n  };\n\n    if (!mlEnabled) return;\n\n    try {\n      const prediction = await MLAlarmOptimizer.predictOptimalWakeTime(user.id, alarm, new Date());\n      setPredictions(prev => [...prev.filter(p => p.alarmId !== alarm.id), {\n        alarmId: alarm.id,\n        ...prediction\n      }]);\n    } catch (error) {\n      console.error('Error generating prediction:', error);\n    }\n  };\n\n  const applyOptimization = async (alarmId: string, optimizedTime: string) => {\n    try {\n      onUpdateAlarm(alarmId, { time: optimizedTime });\n      // Record that user applied ML suggestion\n      await MLAlarmOptimizer.recordUserBehavior(user.id, 'wake_time', {\n        appliedOptimization: true,\n        originalTime: alarms.find(a => a.id === alarmId)?.time,\n        optimizedTime\n      });\n    } catch (error) {\n      console.error('Error applying optimization:', error);\n    }\n  };\n\n  const OverviewPanel = () => (\n    <div className=\"space-y-6\">\n      {/* Status Cards */}\n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n        <Card>\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">ML Optimization</CardTitle>\n            <Brain className=\"h-4 w-4 text-muted-foreground\" />\n          </CardHeader>\n          <CardContent>\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <div className=\"text-2xl font-bold\">{mlStats.accuracy}%</div>\n                <p className=\"text-xs text-muted-foreground\">Accuracy</p>\n              </div>\n              <Badge variant={mlEnabled ? 'default' : 'secondary'}>\n                {mlEnabled ? 'Active' : 'Inactive'}\n              </Badge>\n            </div>\n            <Progress value={mlStats.accuracy} className=\"mt-2\" />\n          </CardContent>\n        </Card>\n\n        <Card>\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Location Services</CardTitle>\n            <MapPin className=\"h-4 w-4 text-muted-foreground\" />\n          </CardHeader>\n          <CardContent>\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <div className=\"text-2xl font-bold\">{locationStats.patterns}</div>\n                <p className=\"text-xs text-muted-foreground\">Patterns</p>\n              </div>\n              <Badge variant={locationEnabled ? 'default' : 'secondary'}>\n                {locationEnabled ? 'Tracking' : 'Disabled'}\n              </Badge>\n            </div>\n            <div className=\"text-xs text-muted-foreground mt-1\">\n              {locationStats.geofences} geofences active\n            </div>\n          </CardContent>\n        </Card>\n\n        <Card>\n          <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n            <CardTitle className=\"text-sm font-medium\">Predictive Analytics</CardTitle>\n            <TrendingUp className=\"h-4 w-4 text-muted-foreground\" />\n          </CardHeader>\n          <CardContent>\n            <div className=\"flex items-center justify-between\">\n              <div>\n                <div className=\"text-2xl font-bold\">{analyticsStats.patterns}</div>\n                <p className=\"text-xs text-muted-foreground\">Patterns</p>\n              </div>\n              <Badge variant={analyticsEnabled ? 'default' : 'secondary'}>\n                {analyticsEnabled ? 'Learning' : 'Disabled'}\n              </Badge>\n            </div>\n            <div className=\"text-xs text-muted-foreground mt-1\">\n              {predictiveInsights.length} new insights\n            </div>\n          </CardContent>\n        </Card>\n      </div>\n\n      {/* Quick Actions */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Sparkles className=\"h-5 w-5\" />\n            Quick Optimizations\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          {optimizationSuggestions.slice(0, 3).map((suggestion, index) => (\n            <div key={index} className=\"flex items-center justify-between p-3 border rounded-lg\">\n              <div>\n                <div className=\"font-medium\">{suggestion.suggestion}</div>\n                <div className=\"text-sm text-muted-foreground\">\n                  {Math.round(suggestion.confidence * 100)}% confidence ‚Ä¢ {suggestion.impact} impact\n                </div>\n              </div>\n              <Button size=\"sm\">Apply</Button>\n            </div>\n          ))}\n\n          {optimizationSuggestions.length === 0 && (\n            <div className=\"text-center py-8 text-muted-foreground\">\n              <Lightbulb className=\"h-8 w-8 mx-auto mb-2\" />\n              <p>No optimization suggestions available</p>\n              <p className=\"text-sm\">Enable services to start collecting data</p>\n            </div>\n          )}\n        </CardContent>\n      </Card>\n\n      {/* Recent Insights */}\n      {predictiveInsights.length > 0 && (\n        <Card>\n          <CardHeader>\n            <CardTitle className=\"flex items-center gap-2\">\n              <Activity className=\"h-5 w-5\" />\n              Recent Insights\n            </CardTitle>\n          </CardHeader>\n          <CardContent className=\"space-y-3\">\n            {predictiveInsights.slice(0, 5).map((insight) => (\n              <div key={insight.id} className=\"flex items-start gap-3 p-3 border rounded-lg\">\n                <div className={`p-1 rounded-full ${\n                  insight.priority === 'high' ? 'bg-red-100 text-red-600' :\n                  insight.priority === 'medium' ? 'bg-yellow-100 text-yellow-600' :\n                  'bg-blue-100 text-blue-600'\n                }`}>\n                  <AlertCircle className=\"h-4 w-4\" />\n                </div>\n                <div className=\"flex-1\">\n                  <div className=\"font-medium\">{insight.title}</div>\n                  <div className=\"text-sm text-muted-foreground\">{insight.description}</div>\n                  <div className=\"flex items-center gap-2 mt-2\">\n                    <Badge variant=\"outline\" className=\"text-xs\">\n                      {insight.category.replace('_', ' ')}\n                    </Badge>\n                    <span className=\"text-xs text-muted-foreground\">\n                      {Math.round(insight.confidence * 100)}% confidence\n                    </span>\n                  </div>\n                </div>\n              </div>\n            ))}\n          </CardContent>\n        </Card>\n      )}\n    </div>\n  );\n\n  const MLPanel = () => (\n    <div className=\"space-y-6\">\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Brain className=\"h-5 w-5\" />\n            Machine Learning Optimization\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <div className=\"font-medium\">Enable ML Optimization</div>\n              <div className=\"text-sm text-muted-foreground\">\n                Use AI to predict optimal wake times based on your patterns\n              </div>\n            </div>\n            <Switch\n              checked={mlEnabled}\n              onCheckedChange={handleMLToggle}\n              disabled={loading.ml}\n            />\n          </div>\n\n          {mlEnabled && (\n            <>\n              <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4 pt-4\">\n                <div className=\"text-center\">\n                  <div className=\"text-2xl font-bold\">{mlStats.patterns}</div>\n                  <div className=\"text-sm text-muted-foreground\">Behavior Patterns</div>\n                </div>\n                <div className=\"text-center\">\n                  <div className=\"text-2xl font-bold\">{mlStats.predictions}</div>\n                  <div className=\"text-sm text-muted-foreground\">Predictions Made</div>\n                </div>\n                <div className=\"text-center\">\n                  <div className=\"text-2xl font-bold\">{mlStats.accuracy}%</div>\n                  <div className=\"text-sm text-muted-foreground\">Accuracy</div>\n                </div>\n              </div>\n\n              <div className=\"space-y-3\">\n                <h4 className=\"font-medium\">Alarm Predictions</h4>\n                {alarms.filter(a => a.enabled).map((alarm) => {\n                  const prediction = predictions.find(p => p.alarmId === alarm.id);\n\n                  return (\n                    <div key={alarm.id} className=\"flex items-center justify-between p-3 border rounded-lg\">\n                      <div>\n                        <div className=\"font-medium\">{alarm.label}</div>\n                        <div className=\"text-sm text-muted-foreground\">\n                          Current: {alarm.time}\n                          {prediction && (\n                            <> ‚Ä¢ Optimal: {prediction.optimalWakeTime}</>\n                          )}\n                        </div>\n                      </div>\n                      <div className=\"flex items-center gap-2\">\n                        {prediction && prediction.adjustmentMinutes !== 0 && (\n                          <Badge variant={prediction.adjustmentMinutes > 0 ? \"destructive\" : \"default\"}>\n                            {prediction.adjustmentMinutes > 0 ? '+' : ''}{prediction.adjustmentMinutes}min\n                          </Badge>\n                        )}\n                        <Button\n                          size=\"sm\"\n                          variant=\"outline\"\n                          onClick={() => generatePrediction(alarm)}\n                        >\n                          Predict\n                        </Button>\n                        {prediction && prediction.adjustmentMinutes !== 0 && (\n                          <Button\n                            size=\"sm\"\n                            onClick={() => applyOptimization(alarm.id, prediction.optimalWakeTime)}\n                          >\n                            Apply\n                          </Button>\n                        )}\n                      </div>\n                    </div>\n                  );\n                })}\n              </div>\n            </>\n          )}\n        </CardContent>\n      </Card>\n    </div>\n  );\n\n  const LocationPanel = () => (\n    <div className=\"space-y-6\">\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <MapPin className=\"h-5 w-5\" />\n            Location-Based Scheduling\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <div className=\"font-medium\">Enable Location Services</div>\n              <div className=\"text-sm text-muted-foreground\">\n                Automatically adjust alarms based on your location\n              </div>\n            </div>\n            <Switch\n              checked={locationEnabled}\n              onCheckedChange={handleLocationToggle}\n              disabled={loading.location}\n            />\n          </div>\n\n          {locationEnabled && (\n            <>\n              <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 pt-4\">\n                <div className=\"text-center\">\n                  <div className=\"text-2xl font-bold\">{locationStats.patterns}</div>\n                  <div className=\"text-sm text-muted-foreground\">Patterns</div>\n                </div>\n                <div className=\"text-center\">\n                  <div className=\"text-2xl font-bold\">{locationStats.geofences}</div>\n                  <div className=\"text-sm text-muted-foreground\">Geofences</div>\n                </div>\n                <div className=\"text-center\">\n                  <div className=\"text-2xl font-bold\">{locationStats.historyPoints}</div>\n                  <div className=\"text-sm text-muted-foreground\">History Points</div>\n                </div>\n                <div className=\"text-center\">\n                  <div className=\"text-2xl font-bold\">\n                    {locationStats.isTracking ? '‚óè' : '‚óã'}\n                  </div>\n                  <div className=\"text-sm text-muted-foreground\">Tracking</div>\n                </div>\n              </div>\n\n              <div className=\"space-y-3\">\n                <h4 className=\"font-medium\">Location Patterns</h4>\n                {locationPatterns.map((pattern) => (\n                  <div key={pattern.id} className=\"flex items-center justify-between p-3 border rounded-lg\">\n                    <div>\n                      <div className=\"font-medium\">{pattern.name}</div>\n                      <div className=\"text-sm text-muted-foreground\">\n                        {pattern.type} ‚Ä¢ {pattern.visits} visits ‚Ä¢ {Math.round(pattern.confidence * 100)}% confidence\n                      </div>\n                    </div>\n                    <Badge variant=\"outline\">{pattern.type}</Badge>\n                  </div>\n                ))}\n\n                {locationPatterns.length === 0 && (\n                  <div className=\"text-center py-8 text-muted-foreground\">\n                    <MapPin className=\"h-8 w-8 mx-auto mb-2\" />\n                    <p>No location patterns detected yet</p>\n                    <p className=\"text-sm\">Keep location services enabled to build patterns</p>\n                  </div>\n                )}\n              </div>\n            </>\n          )}\n        </CardContent>\n      </Card>\n    </div>\n  );\n\n  const AnalyticsPanel = () => (\n    <div className=\"space-y-6\">\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <BarChart3 className=\"h-5 w-5\" />\n            Predictive Analytics\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"flex items-center justify-between\">\n            <div>\n              <div className=\"font-medium\">Enable Predictive Analytics</div>\n              <div className=\"text-sm text-muted-foreground\">\n                Analyze patterns and predict optimal alarm settings\n              </div>\n            </div>\n            <Switch\n              checked={analyticsEnabled}\n              onCheckedChange={handleAnalyticsToggle}\n              disabled={loading.analytics}\n            />\n          </div>\n\n          {analyticsEnabled && (\n            <>\n              <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 pt-4\">\n                <div className=\"text-center\">\n                  <div className=\"text-2xl font-bold\">{analyticsStats.patterns}</div>\n                  <div className=\"text-sm text-muted-foreground\">Patterns</div>\n                </div>\n                <div className=\"text-center\">\n                  <div className=\"text-2xl font-bold\">{analyticsStats.insights}</div>\n                  <div className=\"text-sm text-muted-foreground\">Insights</div>\n                </div>\n                <div className=\"text-center\">\n                  <div className=\"text-2xl font-bold\">\n                    {analyticsStats.lastAnalysis ? '‚úì' : '‚óã'}\n                  </div>\n                  <div className=\"text-sm text-muted-foreground\">Analysis</div>\n                </div>\n                <div className=\"text-center\">\n                  <div className=\"text-2xl font-bold\">{predictiveInsights.length}</div>\n                  <div className=\"text-sm text-muted-foreground\">Recent</div>\n                </div>\n              </div>\n\n              <div className=\"space-y-3\">\n                <h4 className=\"font-medium\">Detected Patterns</h4>\n                {detectedPatterns.map((pattern) => (\n                  <div key={pattern.id} className=\"flex items-center justify-between p-3 border rounded-lg\">\n                    <div>\n                      <div className=\"font-medium\">{pattern.name}</div>\n                      <div className=\"text-sm text-muted-foreground\">\n                        {pattern.description}\n                      </div>\n                      <div className=\"flex items-center gap-2 mt-1\">\n                        <Badge variant=\"outline\" className=\"text-xs\">\n                          {Math.round(pattern.confidence * 100)}% confidence\n                        </Badge>\n                        <Badge variant={\n                          pattern.trend === 'improving' ? 'default' :\n                          pattern.trend === 'declining' ? 'destructive' : 'secondary'\n                        } className=\"text-xs\">\n                          {pattern.trend}\n                        </Badge>\n                      </div>\n                    </div>\n                    <div className=\"text-right\">\n                      <div className=\"text-sm font-medium\">{pattern.frequency}</div>\n                      <div className=\"text-xs text-muted-foreground\">occurrences</div>\n                    </div>\n                  </div>\n                ))}\n\n                {detectedPatterns.length === 0 && (\n                  <div className=\"text-center py-8 text-muted-foreground\">\n                    <TrendingUp className=\"h-8 w-8 mx-auto mb-2\" />\n                    <p>No patterns detected yet</p>\n                    <p className=\"text-sm\">Use alarms regularly to build pattern data</p>\n                  </div>\n                )}\n              </div>\n            </>\n          )}\n        </CardContent>\n      </Card>\n    </div>\n  );\n\n  const SettingsPanel = () => (\n    <div className=\"space-y-6\">\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Settings className=\"h-5 w-5\" />\n            Advanced Scheduling Settings\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-6\">\n          <div className=\"space-y-4\">\n            <h4 className=\"font-medium\">Service Status</h4>\n\n            <div className=\"space-y-3\">\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center gap-2\">\n                  <Brain className=\"h-4 w-4\" />\n                  <span>ML Optimization</span>\n                  <Badge variant={mlEnabled ? 'default' : 'secondary'}>\n                    {mlEnabled ? 'Enabled' : 'Disabled'}\n                  </Badge>\n                </div>\n                <Button variant=\"outline\" size=\"sm\" onClick={() => handleMLToggle(!mlEnabled)}>\n                  {mlEnabled ? \"Disable\" : \"Enable\"}\n                </Button>\n              </div>\n\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center gap-2\">\n                  <MapPin className=\"h-4 w-4\" />\n                  <span>Location Services</span>\n                  <Badge variant={locationEnabled ? 'default' : 'secondary'}>\n                    {locationEnabled ? 'Enabled' : 'Disabled'}\n                  </Badge>\n                </div>\n                <Button variant=\"outline\" size=\"sm\" onClick={() => handleLocationToggle(!locationEnabled)}>\n                  {locationEnabled ? \"Disable\" : \"Enable\"}\n                </Button>\n              </div>\n\n              <div className=\"flex items-center justify-between\">\n                <div className=\"flex items-center gap-2\">\n                  <BarChart3 className=\"h-4 w-4\" />\n                  <span>Predictive Analytics</span>\n                  <Badge variant={analyticsEnabled ? 'default' : 'secondary'}>\n                    {analyticsEnabled ? 'Enabled' : 'Disabled'}\n                  </Badge>\n                </div>\n                <Button variant=\"outline\" size=\"sm\" onClick={() => handleAnalyticsToggle(!analyticsEnabled)}>\n                  {analyticsEnabled ? \"Disable\" : \"Enable\"}\n                </Button>\n              </div>\n            </div>\n          </div>\n\n          <div className=\"space-y-4\">\n            <h4 className=\"font-medium\">Quick Actions</h4>\n\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n              <Button variant=\"outline\" onClick={loadAdvancedSchedulingData}>\n                <Activity className=\"h-4 w-4 mr-2\" />\n                Refresh Data\n              </Button>\n\n              <Button variant=\"outline\">\n                <Bell className=\"h-4 w-4 mr-2\" />\n                Test Notifications\n              </Button>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n    </div>\n  );\n\n  return (\n    <div className=\"max-w-6xl mx-auto p-6 space-y-6\">\n      <div className=\"flex items-center justify-between\">\n        <div>\n          <h1 className=\"text-3xl font-bold\">Advanced Scheduling</h1>\n          <p className=\"text-muted-foreground\">\n            AI-powered alarm optimization with location awareness and predictive analytics\n          </p>\n        </div>\n        <Button onClick={loadAdvancedSchedulingData}>\n          <Activity className=\"h-4 w-4 mr-2\" />\n          Refresh\n        </Button>\n      </div>\n\n      <Tabs value={activeTab} onValueChange={(value: any) => setActiveTab(value)}>\n        <TabsList className=\"grid w-full grid-cols-5\">\n          <TabsTrigger value=\"overview\" className=\"flex items-center gap-2\">\n            <Activity className=\"h-4 w-4\" />\n            Overview\n          </TabsTrigger>\n          <TabsTrigger value=\"ml\" className=\"flex items-center gap-2\">\n            <Brain className=\"h-4 w-4\" />\n            ML Optimization\n          </TabsTrigger>\n          <TabsTrigger value=\"location\" className=\"flex items-center gap-2\">\n            <MapPin className=\"h-4 w-4\" />\n            Location\n          </TabsTrigger>\n          <TabsTrigger value=\"analytics\" className=\"flex items-center gap-2\">\n            <BarChart3 className=\"h-4 w-4\" />\n            Analytics\n          </TabsTrigger>\n          <TabsTrigger value=\"settings\" className=\"flex items-center gap-2\">\n            <Settings className=\"h-4 w-4\" />\n            Settings\n          </TabsTrigger>\n        </TabsList>\n\n        <TabsContent value=\"overview\">\n          <OverviewPanel />\n        </TabsContent>\n\n        <TabsContent value=\"ml\">\n          <MLPanel />\n        </TabsContent>\n\n        <TabsContent value=\"location\">\n          <LocationPanel />\n        </TabsContent>\n\n        <TabsContent value=\"analytics\">\n          <AnalyticsPanel />\n        </TabsContent>\n\n        <TabsContent value=\"settings\">\n          <SettingsPanel />\n        </TabsContent>\n      </Tabs>\n    </div>\n  );\n};\n\nexport default AdvancedSchedulingDashboard;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/AlarmThemeBrowser.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'getWeatherIcon' is not defined.",
        "line": 636,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 636,
        "endColumn": 30
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Enhanced Alarm Theme Browser Component\n * Advanced theme selection interface with collections, filtering, and preview\n */\n\nimport React, { useState, useEffect, useMemo } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport {\n  themeCombinations,\n  ThemeCombination,\n  ThemeCollection,\n  ThemeCategory,\n  AlarmIntensity,\n  ThemeMood,\n  TimeOfDay,\n  WeatherCondition\n} from '../services/theme-combinations';\nimport { contextualThemes } from '../services/contextual-themes';\nimport { visualAlarmThemes } from '../services/visual-alarm-themes';\nimport {\n  Search, Filter, Grid, List, Heart, Star, Play, Eye,\n  Clock, Cloud, Zap, Volume2, Mic, Shuffle, TrendingUp,\n  Settings, Download, Upload, Plus, X, ChevronDown,\n  Sun, Moon, CloudRain, Snowflake, Wind\n} from 'lucide-react';\n\ninterface AlarmThemeBrowserProps {\n  selectedTheme?: string;\n  onThemeSelect: (combination: ThemeCombination) => void;\n  onPreview: (combination: ThemeCombination) => void;\n  className?: string;\n}\n\ntype ViewMode = 'grid' | 'list' | 'collections';\ntype SortMode = 'popularity' | 'recent' | 'alphabetical' | 'rating' | 'category';\n\nexport const AlarmThemeBrowser: React.FC<AlarmThemeBrowserProps> = ({\n  selectedTheme,\n  onThemeSelect,\n  onPreview,\n  className = ''\n}) => {\n  // State management\n  const [viewMode, setViewMode] = useState<ViewMode>('collections');\n  const [sortMode, setSortMode] = useState<SortMode>('popularity');\n  const [searchQuery, setSearchQuery] = useState('');\n  const [selectedCategory, setSelectedCategory] = useState<ThemeCategory | 'all'>('all');\n  const [selectedIntensity, setSelectedIntensity] = useState<AlarmIntensity | 'all'>('all');\n  const [selectedMood, setSelectedMood] = useState<ThemeMood | 'all'>('all');\n  const [selectedTimeOfDay, setSelectedTimeOfDay] = useState<TimeOfDay | 'all'>('all');\n  const [showPremiumOnly, setShowPremiumOnly] = useState(false);\n  const [showFavoritesOnly, setShowFavoritesOnly] = useState(false);\n  const [showFilters, setShowFilters] = useState(false);\n  const [previewingTheme, setPreviewingTheme] = useState<string | null>(null);\n\n  // Data\n  const [allCombinations, setAllCombinations] = useState<ThemeCombination[]>([]);\n  const [collections, setCollections] = useState<ThemeCollection[]>([]);\n  const [contextualRecommendations, setContextualRecommendations] = useState<ThemeCombination[]>([]);\n\n  // Load data\n  useEffect(() => {\n    const loadData = async () => {\n      setAllCombinations(themeCombinations.getAllCombinations());\n      setCollections(themeCombinations.getAllCollections());\n\n      // Get contextual recommendations for current time\n      try {\n        const now = new Date();\n        const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;\n        const recommendation = await contextualThemes.getContextualRecommendation(currentTime);\n\n        // Find combinations that match the recommendation\n        const matchingCombos = themeCombinations.getAllCombinations().filter(combo =>\n          combo.visual === recommendation.visual ||\n          combo.sound === recommendation.sound ||\n          combo.voice === recommendation.voice\n        );\n        setContextualRecommendations(matchingCombos.slice(0, 3));\n      } catch (error) {\n        console.warn('Failed to load contextual recommendations:', error);\n      }\n    };\n\n    loadData();\n  }, []);\n\n  // Filtered and sorted combinations\n  const filteredCombinations = useMemo(() => {\n    let filtered = allCombinations;\n\n    // Apply search\n    if (searchQuery) {\n      filtered = themeCombinations.searchCombinations(searchQuery);\n    }\n\n    // Apply filters\n    filtered = filtered.filter(combo => {\n      if (selectedCategory !== 'all' && combo.category !== selectedCategory) return false;\n      if (selectedIntensity !== 'all' && combo.difficulty !== selectedIntensity) return false;\n      if (selectedMood !== 'all' && combo.mood !== selectedMood) return false;\n      if (selectedTimeOfDay !== 'all' && !combo.timeOfDay.includes(selectedTimeOfDay)) return false;\n      if (showPremiumOnly && !combo.premium) return false;\n      if (showFavoritesOnly && !themeCombinations.isFavorite(combo.id)) return false;\n\n      return true;\n    });\n\n    // Apply sorting\n    switch (sortMode) {\n      case 'popularity':\n        filtered.sort((a, b) => b.popularity - a.popularity);\n        break;\n      case 'recent':\n        filtered.sort((a, b) => (b.lastUsed?.getTime() || 0) - (a.lastUsed?.getTime() || 0));\n        break;\n      case 'alphabetical':\n        filtered.sort((a, b) => a.name.localeCompare(b.name));\n        break;\n      case 'rating':\n        filtered.sort((a, b) => (b.rating || 0) - (a.rating || 0));\n        break;\n      case 'category':\n        filtered.sort((a, b) => a.category.localeCompare(b.category));\n        break;\n    }\n\n    return filtered;\n  }, [\n    allCombinations, searchQuery, selectedCategory, selectedIntensity,\n    selectedMood, selectedTimeOfDay, showPremiumOnly, showFavoritesOnly, sortMode\n  ]);\n\n  // Event handlers\n  const handleThemeSelect = (combination: ThemeCombination) => {\n    themeCombinations.recordUsage(combination.id);\n    onThemeSelect(combination);\n  };\n\n  const handlePreview = (combination: ThemeCombination) => {\n    setPreviewingTheme(combination.id);\n    onPreview(combination);\n\n    // Auto-hide preview after 3 seconds\n    setTimeout(() => {\n      setPreviewingTheme(null);\n    }, 3000);\n  };\n\n  const toggleFavorite = (combinationId: string) => {\n    if (themeCombinations.isFavorite(combinationId)) {\n      themeCombinations.removeFromFavorites(combinationId);\n    } else {\n      themeCombinations.addToFavorites(combinationId);\n    }\n    // Force re-render\n    setAllCombinations([...themeCombinations.getAllCombinations()]);\n  };\n\n  const clearFilters = () => {\n    setSearchQuery('');\n    setSelectedCategory('all');\n    setSelectedIntensity('all');\n    setSelectedMood('all');\n    setSelectedTimeOfDay('all');\n    setShowPremiumOnly(false);\n    setShowFavoritesOnly(false);\n  };\n\n  // Helper functions\n  const getWeatherIcon = (weather: WeatherCondition) => {\n    switch (weather) {\n      case 'sunny': return <Sun className=\"w-4 h-4\" />;\n      case 'cloudy': return <Cloud className=\"w-4 h-4\" />;\n      case 'rainy': return <CloudRain className=\"w-4 h-4\" />;\n      case 'snowy': return <Snowflake className=\"w-4 h-4\" />;\n      case 'windy': return <Wind className=\"w-4 h-4\" />;\n      default: return <Cloud className=\"w-4 h-4\" />;\n    }\n  };\n\n  const getIntensityColor = (intensity: AlarmIntensity) => {\n    switch (intensity) {\n      case 'gentle': return 'text-green-600 bg-green-100';\n      case 'moderate': return 'text-blue-600 bg-blue-100';\n      case 'intense': return 'text-orange-600 bg-orange-100';\n      case 'extreme': return 'text-red-600 bg-red-100';\n    }\n  };\n\n  const getMoodEmoji = (mood: ThemeMood) => {\n    switch (mood) {\n      case 'peaceful': return 'üòå';\n      case 'energizing': return '‚ö°';\n      case 'dramatic': return 'üé≠';\n      case 'mystical': return 'üîÆ';\n      case 'scary': return 'üëª';\n      case 'motivational': return 'üí™';\n      case 'romantic': return 'üíï';\n      case 'nostalgic': return 'üìº';\n      default: return '‚ú®';\n    }\n  };\n\n  return (\n    <div className={`alarm-theme-browser ${className}`}>\n      {/* Header */}\n      <div className=\"browser-header p-6 border-b border-gray-200 dark:border-gray-700\">\n        <div className=\"flex justify-between items-center mb-4\">\n          <h2 className=\"text-3xl font-bold text-gray-900 dark:text-white\">Alarm Themes</h2>\n\n          <div className=\"flex items-center space-x-2\">\n            {/* View Mode Toggle */}\n            <div className=\"flex bg-gray-100 dark:bg-gray-800 rounded-lg p-1\">\n              {[\n                { mode: 'collections', icon: Grid, label: 'Collections' },\n                { mode: 'grid', icon: Grid, label: 'Grid' },\n                { mode: 'list', icon: List, label: 'List' }\n              ].map(({ mode, icon: Icon, label }) => (\n                <button\n                  key={mode}\n                  onClick={() => setViewMode(mode as ViewMode)}\n                  className={`flex items-center space-x-1 px-3 py-2 rounded-md text-sm transition-colors\n                    ${viewMode === mode\n                      ? 'bg-white dark:bg-gray-700 text-blue-600 dark:text-blue-400 shadow-sm'\n                      : 'text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-gray-200'\n                    }`}\n                >\n                  <Icon className=\"w-4 h-4\" />\n                  <span className=\"hidden sm:inline\">{label}</span>\n                </button>\n              ))}\n            </div>\n\n            {/* Actions */}\n            <button className=\"p-2 text-gray-600 hover:text-blue-600 dark:text-gray-400 dark:hover:text-blue-400\">\n              <Shuffle className=\"w-5 h-5\" />\n            </button>\n            <button className=\"p-2 text-gray-600 hover:text-blue-600 dark:text-gray-400 dark:hover:text-blue-400\">\n              <Plus className=\"w-5 h-5\" />\n            </button>\n          </div>\n        </div>\n\n        {/* Search and Filters */}\n        <div className=\"space-y-4\">\n          <div className=\"flex flex-col sm:flex-row gap-4\">\n            {/* Search */}\n            <div className=\"relative flex-1\">\n              <Search className=\"absolute left-3 top-3 w-4 h-4 text-gray-400\" />\n              <input\n                type=\"text\"\n                placeholder=\"Search themes, moods, or categories...\"\n                value={searchQuery}\n                onChange={e => setSearchQuery(e.target.value)}\n                className=\"w-full pl-10 pr-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl\n                           focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-800 text-lg\"\n              />\n            </div>\n\n            {/* Sort */}\n            <select\n              value={sortMode}\n              onChange={e => setSortMode(e.target.value as SortMode)}\n              className=\"px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl\n                         focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-800 min-w-[150px]\"\n            >\n              <option value=\"popularity\">Most Popular</option>\n              <option value=\"recent\">Recently Used</option>\n              <option value=\"alphabetical\">A to Z</option>\n              <option value=\"rating\">Highest Rated</option>\n              <option value=\"category\">By Category</option>\n            </select>\n\n            {/* Filter Toggle */}\n            <button\n              onClick={() => setShowFilters(!showFilters)}\n              className={`flex items-center space-x-2 px-4 py-3 border rounded-xl transition-colors\n                ${showFilters\n                  ? 'border-blue-500 text-blue-600 bg-blue-50 dark:bg-blue-900/20'\n                  : 'border-gray-300 dark:border-gray-600 text-gray-600 hover:text-blue-600'\n                }`}\n            >\n              <Filter className=\"w-4 h-4\" />\n              <span>Filters</span>\n              <ChevronDown className={`w-4 h-4 transition-transform ${showFilters ? 'rotate-180' : ''}`} />\n            </button>\n          </div>\n\n          {/* Advanced Filters */}\n          <AnimatePresence>\n            {showFilters && (\n              <motion.div\n                initial={{ opacity: 0, height: 0 }}\n                animate={{ opacity: 1, height: 'auto' }}\n                exit={{ opacity: 0, height: 0 }}\n                className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 p-4 bg-gray-50 dark:bg-gray-800 rounded-xl\"\n              >\n                {/* Category Filter */}\n                <div>\n                  <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n                    Category\n                  </label>\n                  <select\n                    value={selectedCategory}\n                    onChange={(e) => setSelectedCategory(e.target.value as ThemeCategory | 'all')}\n                    className=\"w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg\n                               focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-700\"\n                  >\n                    <option value=\"all\">All Categories</option>\n                    <option value=\"gentle\">Gentle</option>\n                    <option value=\"energetic\">Energetic</option>\n                    <option value=\"nature\">Nature</option>\n                    <option value=\"electronic\">Electronic</option>\n                    <option value=\"fantasy\">Fantasy</option>\n                    <option value=\"horror\">Horror</option>\n                    <option value=\"workout\">Workout</option>\n                    <option value=\"meditation\">Meditation</option>\n                    <option value=\"cosmic\">Cosmic</option>\n                    <option value=\"minimal\">Minimal</option>\n                  </select>\n                </div>\n\n                {/* Intensity Filter */}\n                <div>\n                  <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n                    Intensity\n                  </label>\n                  <select\n                    value={selectedIntensity}\n                    onChange={(e) => setSelectedIntensity(e.target.value as AlarmIntensity | 'all')}\n                    className=\"w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg\n                               focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-700\"\n                  >\n                    <option value=\"all\">All Intensities</option>\n                    <option value=\"gentle\">Gentle</option>\n                    <option value=\"moderate\">Moderate</option>\n                    <option value=\"intense\">Intense</option>\n                    <option value=\"extreme\">Extreme</option>\n                  </select>\n                </div>\n\n                {/* Time of Day Filter */}\n                <div>\n                  <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2\">\n                    Time of Day\n                  </label>\n                  <select\n                    value={selectedTimeOfDay}\n                    onChange={(e) => setSelectedTimeOfDay(e.target.value as TimeOfDay | 'all')}\n                    className=\"w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg\n                               focus:ring-2 focus:ring-blue-500 bg-white dark:bg-gray-700\"\n                  >\n                    <option value=\"all\">Any Time</option>\n                    <option value=\"early-morning\">Early Morning</option>\n                    <option value=\"morning\">Morning</option>\n                    <option value=\"midday\">Midday</option>\n                    <option value=\"afternoon\">Afternoon</option>\n                    <option value=\"evening\">Evening</option>\n                    <option value=\"night\">Night</option>\n                    <option value=\"late-night\">Late Night</option>\n                  </select>\n                </div>\n\n                {/* Toggle Filters */}\n                <div className=\"space-y-3\">\n                  <label className=\"flex items-center space-x-2\">\n                    <input\n                      type=\"checkbox\"\n                      checked={showPremiumOnly}\n                      onChange={e => setShowPremiumOnly(e.target.checked)}\n                      className=\"w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500\"\n                    />\n                    <span className=\"text-sm text-gray-700 dark:text-gray-300\">Premium Only</span>\n                  </label>\n\n                  <label className=\"flex items-center space-x-2\">\n                    <input\n                      type=\"checkbox\"\n                      checked={showFavoritesOnly}\n                      onChange={e => setShowFavoritesOnly(e.target.checked)}\n                      className=\"w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500\"\n                    />\n                    <span className=\"text-sm text-gray-700 dark:text-gray-300\">Favorites Only</span>\n                  </label>\n\n                  <button\n                    onClick={clearFilters}\n                    className=\"w-full px-3 py-2 text-sm text-blue-600 hover:text-blue-700\n                               border border-blue-200 rounded-lg hover:bg-blue-50 dark:hover:bg-blue-900/20\"\n                  >\n                    Clear Filters\n                  </button>\n                </div>\n              </motion.div>\n            )}\n          </AnimatePresence>\n        </div>\n\n        {/* Quick Stats */}\n        <div className=\"flex items-center justify-between text-sm text-gray-600 dark:text-gray-400 mt-4\">\n          <span>{filteredCombinations.length} themes found</span>\n          <div className=\"flex items-center space-x-4\">\n            <span className=\"flex items-center space-x-1\">\n              <TrendingUp className=\"w-4 h-4\" />\n              <span>Popular themes trending</span>\n            </span>\n          </div>\n        </div>\n      </div>\n\n      {/* Content */}\n      <div className=\"browser-content p-6\">\n        {/* Contextual Recommendations */}\n        {contextualRecommendations.length > 0 && (\n          <div className=\"mb-8\">\n            <h3 className=\"text-xl font-semibold text-gray-900 dark:text-white mb-4 flex items-center space-x-2\">\n              <Clock className=\"w-5 h-5 text-blue-500\" />\n              <span>Recommended for You</span>\n            </h3>\n            <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n              {contextualRecommendations.map(combo => (\n                <ThemeCard\n                  key={combo.id}\n                  combination={combo}\n                  isSelected={selectedTheme === combo.id}\n                  isPreviewing={previewingTheme === combo.id}\n                  onSelect={() => handleThemeSelect(combo)}\n                  onPreview={() => handlePreview(combo)}\n                  onToggleFavorite={() => toggleFavorite(combo.id)}\n                  isFavorite={themeCombinations.isFavorite(combo.id)}\n                  compact={true}\n                />\n              ))}\n            </div>\n          </div>\n        )}\n\n        {/* Main Content */}\n        <AnimatePresence mode=\"wait\">\n          {viewMode === 'collections' && (\n            <motion.div\n              key=\"collections\"\n              initial={{ opacity: 0, y: 20 }}\n              animate={{ opacity: 1, y: 0 }}\n              exit={{ opacity: 0, y: -20 }}\n              className=\"space-y-8\"\n            >\n              {collections.map(collection => (\n                <CollectionView\n                  key={collection.id}\n                  collection={collection}\n                  combinations={themeCombinations.getCombinationsInCollection(collection.id)}\n                  selectedTheme={selectedTheme}\n                  previewingTheme={previewingTheme}\n                  onSelect={handleThemeSelect}\n                  onPreview={handlePreview}\n                  onToggleFavorite={toggleFavorite}\n                />\n              ))}\n            </motion.div>\n          )}\n\n          {viewMode === 'grid' && (\n            <motion.div\n              key=\"grid\"\n              initial={{ opacity: 0, y: 20 }}\n              animate={{ opacity: 1, y: 0 }}\n              exit={{ opacity: 0, y: -20 }}\n              className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6\"\n            >\n              {filteredCombinations.map(combo => (\n                <ThemeCard\n                  key={combo.id}\n                  combination={combo}\n                  isSelected={selectedTheme === combo.id}\n                  isPreviewing={previewingTheme === combo.id}\n                  onSelect={() => handleThemeSelect(combo)}\n                  onPreview={() => handlePreview(combo)}\n                  onToggleFavorite={() => toggleFavorite(combo.id)}\n                  isFavorite={themeCombinations.isFavorite(combo.id)}\n                />\n              ))}\n            </motion.div>\n          )}\n\n          {viewMode === 'list' && (\n            <motion.div\n              key=\"list\"\n              initial={{ opacity: 0, y: 20 }}\n              animate={{ opacity: 1, y: 0 }}\n              exit={{ opacity: 0, y: -20 }}\n              className=\"space-y-4\"\n            >\n              {filteredCombinations.map(combo => (\n                <ThemeListItem\n                  key={combo.id}\n                  combination={combo}\n                  isSelected={selectedTheme === combo.id}\n                  isPreviewing={previewingTheme === combo.id}\n                  onSelect={() => handleThemeSelect(combo)}\n                  onPreview={() => handlePreview(combo)}\n                  onToggleFavorite={() => toggleFavorite(combo.id)}\n                  isFavorite={themeCombinations.isFavorite(combo.id)}\n                />\n              ))}\n            </motion.div>\n          )}\n        </AnimatePresence>\n      </div>\n    </div>\n  );\n};\n\n// Theme Card Component\ninterface ThemeCardProps {\n  combination: ThemeCombination;\n  isSelected: boolean;\n  isPreviewing: boolean;\n  onSelect: () => void;\n  onPreview: () => void;\n  onToggleFavorite: () => void;\n  isFavorite: boolean;\n  compact?: boolean;\n}\n\nconst ThemeCard: React.FC<ThemeCardProps> = ({\n  combination,\n  isSelected,\n  isPreviewing,\n  onSelect,\n  onPreview,\n  onToggleFavorite,\n  isFavorite,\n  compact = false\n}) => {\n  const theme = visualAlarmThemes.getTheme(combination.visual);\n\n  return (\n    <motion.div\n      whileHover={{ scale: 1.02 }}\n      whileTap={{ scale: 0.98 }}\n      className={`theme-card relative p-4 rounded-xl border cursor-pointer transition-all\n        ${isSelected ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20 shadow-lg' :\n          'border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 hover:shadow-md hover:border-blue-300'}\n        ${combination.premium ? 'ring-2 ring-yellow-400/20' : ''}\n        ${compact ? 'p-3' : 'p-4'}\n      `}\n      onClick={onSelect}\n    >\n      {/* Premium Badge */}\n      {combination.premium && (\n        <div className=\"absolute top-2 right-2 px-2 py-1 bg-yellow-400 text-yellow-900 text-xs font-bold rounded z-10\">\n          PRO\n        </div>\n      )}\n\n      {/* Favorite Button */}\n      <button\n        onClick={e => {\n          e.stopPropagation();\n          onToggleFavorite();\n        }}\n        className={`absolute top-2 left-2 p-1 rounded-full transition-colors z-10\n          ${isFavorite ? 'text-red-500' : 'text-gray-400 hover:text-red-500'}\n        `}\n      >\n        <Heart className={`w-4 h-4 ${isFavorite ? 'fill-current' : ''}`} />\n      </button>\n\n      {/* Theme Preview */}\n      <div className=\"mt-6 mb-3\">\n        <div\n          className=\"w-full h-16 rounded-lg mb-3 border border-gray-200 relative overflow-hidden\"\n          style={{\n            background: theme ? `linear-gradient(135deg, ${theme.colors.gradientStart}, ${theme.colors.gradientEnd})` : '#6B7280'\n          }}\n        >\n          {/* Visual effect overlay */}\n          <div className=\"absolute inset-0 opacity-30\">\n            {theme?.effects.particles && (\n              <div className=\"absolute inset-0 bg-gradient-to-br from-white/20 to-transparent animate-pulse\" />\n            )}\n          </div>\n        </div>\n\n        <h3 className={`font-semibold mb-1 ${compact ? 'text-sm' : 'text-lg'}`}>\n          {combination.name}\n        </h3>\n\n        {!compact && (\n          <p className=\"text-sm text-gray-600 dark:text-gray-400 mb-3\">\n            {combination.description}\n          </p>\n        )}\n      </div>\n\n      {/* Theme Components */}\n      <div className=\"flex flex-wrap gap-1 mb-3\">\n        <span className=\"px-2 py-1 text-xs bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 rounded\">\n          <Eye className=\"w-3 h-3 inline mr-1\" />\n          {theme?.name}\n        </span>\n        <span className=\"px-2 py-1 text-xs bg-green-100 dark:bg-green-900/30 text-green-700 dark:text-green-300 rounded\">\n          <Volume2 className=\"w-3 h-3 inline mr-1\" />\n          {combination.sound}\n        </span>\n        <span className=\"px-2 py-1 text-xs bg-purple-100 dark:bg-purple-900/30 text-purple-700 dark:text-purple-300 rounded\">\n          <Mic className=\"w-3 h-3 inline mr-1\" />\n          {combination.voice}\n        </span>\n      </div>\n\n      {/* Metadata */}\n      {!compact && (\n        <div className=\"flex items-center justify-between text-xs text-gray-500 mb-3\">\n          <div className=\"flex items-center space-x-2\">\n            <span className={`px-2 py-1 rounded ${getIntensityColor(combination.difficulty)}`}>\n              {combination.difficulty}\n            </span>\n            <span>{getMoodEmoji(combination.mood)}</span>\n          </div>\n\n          <div className=\"flex items-center space-x-1\">\n            <Star className=\"w-3 h-3 text-yellow-500\" />\n            <span>{combination.popularity}%</span>\n          </div>\n        </div>\n      )}\n\n      {/* Actions */}\n      <div className=\"flex items-center justify-between\">\n        <div className=\"flex items-center space-x-1\">\n          {combination.weatherSuitability.slice(0, 3).map((weather, index) => (\n            <span key={index} className=\"text-gray-400\" title={weather}>\n              {getWeatherIcon(weather)}\n            </span>\n          ))}\n        </div>\n\n        <button\n          onClick={e => {\n            e.stopPropagation();\n            onPreview();\n          }}\n          disabled={isPreviewing}\n          className={`p-2 rounded-full transition-colors\n            ${isPreviewing\n              ? 'text-blue-600 bg-blue-100 animate-pulse'\n              : 'text-gray-400 hover:text-blue-600 hover:bg-blue-50'\n            }`}\n        >\n          <Play className=\"w-4 h-4\" />\n        </button>\n      </div>\n    </motion.div>\n  );\n};\n\n// Collection View Component\ninterface CollectionViewProps {\n  collection: ThemeCollection;\n  combinations: ThemeCombination[];\n  selectedTheme?: string;\n  previewingTheme: string | null;\n  onSelect: (combination: ThemeCombination) => void;\n  onPreview: (combination: ThemeCombination) => void;\n  onToggleFavorite: (id: string) => void;\n}\n\nconst CollectionView: React.FC<CollectionViewProps> = ({\n  collection,\n  combinations,\n  selectedTheme,\n  previewingTheme,\n  onSelect,\n  onPreview,\n  onToggleFavorite\n}) => (\n  <div className=\"collection-view\">\n    <div className=\"flex items-center justify-between mb-4\">\n      <div>\n        <h3 className=\"text-xl font-semibold text-gray-900 dark:text-white flex items-center space-x-2\">\n          <span>{collection.name}</span>\n          {collection.premium && (\n            <span className=\"px-2 py-1 bg-yellow-400 text-yellow-900 text-xs font-bold rounded\">\n              PRO\n            </span>\n          )}\n        </h3>\n        <p className=\"text-gray-600 dark:text-gray-400 mt-1\">{collection.description}</p>\n      </div>\n\n      <div className=\"flex items-center space-x-2 text-sm text-gray-500\">\n        <span>{combinations.length} themes</span>\n      </div>\n    </div>\n\n    <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4\">\n      {combinations.map(combo => (\n        <ThemeCard\n          key={combo.id}\n          combination={combo}\n          isSelected={selectedTheme === combo.id}\n          isPreviewing={previewingTheme === combo.id}\n          onSelect={() => onSelect(combo)}\n          onPreview={() => onPreview(combo)}\n          onToggleFavorite={() => onToggleFavorite(combo.id)}\n          isFavorite={themeCombinations.isFavorite(combo.id)}\n          compact={true}\n        />\n      ))}\n    </div>\n  </div>\n);\n\n// Theme List Item Component\ninterface ThemeListItemProps {\n  combination: ThemeCombination;\n  isSelected: boolean;\n  isPreviewing: boolean;\n  onSelect: () => void;\n  onPreview: () => void;\n  onToggleFavorite: () => void;\n  isFavorite: boolean;\n}\n\nconst ThemeListItem: React.FC<ThemeListItemProps> = ({\n  combination,\n  isSelected,\n  isPreviewing,\n  onSelect,\n  onPreview,\n  onToggleFavorite,\n  isFavorite\n}) => {\n  const theme = visualAlarmThemes.getTheme(combination.visual);\n\n  return (\n    <motion.div\n      whileHover={{ scale: 1.01 }}\n      className={`theme-list-item flex items-center p-4 rounded-xl border cursor-pointer transition-all\n        ${isSelected ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20' :\n          'border-gray-200 dark:border-gray-700 bg-white dark:bg-gray-800 hover:shadow-md'}\n      `}\n      onClick={onSelect}\n    >\n      {/* Preview */}\n      <div\n        className=\"w-16 h-16 rounded-lg mr-4 border border-gray-200 flex-shrink-0\"\n        style={{\n          background: theme ? `linear-gradient(135deg, ${theme.colors.gradientStart}, ${theme.colors.gradientEnd})` : '#6B7280'\n        }}\n      />\n\n      {/* Content */}\n      <div className=\"flex-1 min-w-0\">\n        <div className=\"flex items-center space-x-2 mb-1\">\n          <h3 className=\"font-semibold text-lg truncate\">{combination.name}</h3>\n          {combination.premium && (\n            <span className=\"px-2 py-1 bg-yellow-400 text-yellow-900 text-xs font-bold rounded\">PRO</span>\n          )}\n        </div>\n\n        <p className=\"text-sm text-gray-600 dark:text-gray-400 mb-2 truncate\">\n          {combination.description}\n        </p>\n\n        <div className=\"flex items-center space-x-4 text-xs text-gray-500\">\n          <span className=\"flex items-center space-x-1\">\n            <Eye className=\"w-3 h-3\" />\n            <span>{theme?.name}</span>\n          </span>\n          <span className=\"flex items-center space-x-1\">\n            <Volume2 className=\"w-3 h-3\" />\n            <span>{combination.sound}</span>\n          </span>\n          <span className=\"flex items-center space-x-1\">\n            <Mic className=\"w-3 h-3\" />\n            <span>{combination.voice}</span>\n          </span>\n          <span className={`px-2 py-1 rounded ${getIntensityColor(combination.difficulty)}`}>\n            {combination.difficulty}\n          </span>\n        </div>\n      </div>\n\n      {/* Actions */}\n      <div className=\"flex items-center space-x-2 ml-4\">\n        <button\n          onClick={e => {\n            e.stopPropagation();\n            onToggleFavorite();\n          }}\n          className={`p-2 rounded-full transition-colors\n            ${isFavorite ? 'text-red-500' : 'text-gray-400 hover:text-red-500'}\n          `}\n        >\n          <Heart className={`w-4 h-4 ${isFavorite ? 'fill-current' : ''}`} />\n        </button>\n\n        <button\n          onClick={e => {\n            e.stopPropagation();\n            onPreview();\n          }}\n          disabled={isPreviewing}\n          className={`p-2 rounded-full transition-colors\n            ${isPreviewing\n              ? 'text-blue-600 bg-blue-100 animate-pulse'\n              : 'text-gray-400 hover:text-blue-600 hover:bg-blue-50'\n            }`}\n        >\n          <Play className=\"w-4 h-4\" />\n        </button>\n\n        <div className=\"flex items-center space-x-1 text-sm text-gray-500\">\n          <Star className=\"w-3 h-3 text-yellow-500\" />\n          <span>{combination.popularity}%</span>\n        </div>\n      </div>\n    </motion.div>\n  );\n};\n\n// Helper functions (moved from inline)\nconst getIntensityColor = (intensity: AlarmIntensity) => {\n  switch (intensity) {\n    case 'gentle': return 'text-green-600 bg-green-100 dark:bg-green-900/30 dark:text-green-300';\n    case 'moderate': return 'text-blue-600 bg-blue-100 dark:bg-blue-900/30 dark:text-blue-300';\n    case 'intense': return 'text-orange-600 bg-orange-100 dark:bg-orange-900/30 dark:text-orange-300';\n    case 'extreme': return 'text-red-600 bg-red-100 dark:bg-red-900/30 dark:text-red-300';\n  }\n};\n\nconst getMoodEmoji = (mood: ThemeMood) => {\n  switch (mood) {\n    case 'peaceful': return 'üòå';\n    case 'energizing': return '‚ö°';\n    case 'dramatic': return 'üé≠';\n    case 'mystical': return 'üîÆ';\n    case 'scary': return 'üëª';\n    case 'motivational': return 'üí™';\n    case 'romantic': return 'üíï';\n    case 'nostalgic': return 'üìº';\n    default: return '‚ú®';\n  }\n};\n\nexport default AlarmThemeBrowser;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/EnhancedMediaContent.tsx",
    "messages": [
      {
        "ruleId": "react-hooks/rules-of-hooks",
        "severity": 2,
        "message": "React Hook \"useAudioLazyLoading\" cannot be called inside a callback. React Hooks must be called in a React function component or a custom React Hook function.",
        "line": 229,
        "column": 26,
        "nodeType": "Identifier",
        "endLine": 229,
        "endColumn": 45
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from './ui/card';\nimport { Button } from './ui/button';\nimport { Badge } from './ui/badge';\nimport { Input } from './ui/input';\nimport { Label } from './ui/label';\nimport { Progress } from './ui/progress';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs';\nimport { Textarea } from './ui/textarea';\nimport { Slider } from './ui/slider';\nimport {\n  Music,\n  Upload,\n  Download,\n  Play,\n  Pause,\n  Heart,\n  Share,\n  Camera,\n  Quote,\n  Volume2,\n  FileAudio,\n  Star,\n  Plus,\n  Search,\n  Filter,\n  Shuffle,\n  SkipForward,\n  SkipBack,\n  Mic,\n  Headphones,\n  MessageSquare,\n  Sparkles,\n  Trophy,\n  CheckCircle,\n  Loader2,\n  AlertCircle,\n  Settings,\n  VolumeX\n} from 'lucide-react';\n\n// Import our audio services\nimport { audioManager } from '../services/audio-manager';\nimport { lazyAudioLoader } from '../services/lazy-audio-loader';\nimport { useAudioLazyLoading, usePlaylistLazyLoading } from '../hooks/useAudioLazyLoading';\nimport { useEnhancedCaching } from '../hooks/useEnhancedCaching';\nimport type { CustomSound, Playlist, MotivationalQuote, MediaLibrary } from '../services/types/media';\n\ninterface EnhancedMediaContentProps {\n  currentUser: { id: string; username: string; displayName: string };\n  mediaLibrary?: MediaLibrary;\n  onUploadSound?: (file: File) => Promise<void>;\n  onCreatePlaylist?: (playlist: Partial<Playlist>) => Promise<void>;\n  onSubmitQuote?: (quote: Partial<MotivationalQuote>) => Promise<void>;\n  onCompletePhotoChallenge?: (challengeId: string, photo: File, caption?: string) => Promise<void>;\n}\n\n// Enhanced mock data with real audio capabilities\nconst ENHANCED_MOCK_SOUNDS: CustomSound[] = [\n  {\n    id: '1',\n    name: 'Morning Birds',\n    description: 'Peaceful chirping birds to start your day',\n    fileName: 'morning-birds.mp3',\n    fileUrl: 'https://www.soundjay.com/misc/sounds/nature.mp3', // Using placeholder URL\n    duration: 120,\n    category: 'nature',\n    tags: ['peaceful', 'birds', 'morning'],\n    isCustom: false,\n    downloads: 1542,\n    rating: 4.8,\n    format: 'audio/mpeg',\n    size: 1920000, // ~1.9MB\n    compressionLevel: 'light'\n  },\n  {\n    id: '2',\n    name: 'Energetic Beat',\n    description: 'Upbeat music to energize your morning',\n    fileName: 'energetic-beat.mp3',\n    fileUrl: 'https://www.soundjay.com/misc/sounds/energetic.mp3', // Using placeholder URL\n    duration: 90,\n    category: 'music',\n    tags: ['upbeat', 'energetic', 'workout'],\n    isCustom: false,\n    downloads: 2103,\n    rating: 4.6,\n    format: 'audio/mpeg',\n    size: 1440000, // ~1.4MB\n    compressionLevel: 'medium'\n  },\n  {\n    id: '3',\n    name: 'Ocean Waves',\n    description: 'Calming ocean waves for relaxation',\n    fileName: 'ocean-waves.mp3',\n    fileUrl: 'https://www.soundjay.com/misc/sounds/waves.mp3', // Using placeholder URL\n    duration: 180,\n    category: 'ambient',\n    tags: ['ocean', 'waves', 'calm', 'relaxation'],\n    isCustom: false,\n    downloads: 890,\n    rating: 4.7,\n    format: 'audio/mpeg',\n    size: 2880000, // ~2.8MB\n    compressionLevel: 'light'\n  }\n];\n\nconst ENHANCED_MOCK_PLAYLISTS: Playlist[] = [\n  {\n    id: '1',\n    name: 'Morning Energy',\n    description: 'Perfect playlist to start your day with energy',\n    sounds: [\n      { soundId: '2', sound: ENHANCED_MOCK_SOUNDS[1], order: 1, volume: 0.8, fadeIn: 2 },\n      { soundId: '1', sound: ENHANCED_MOCK_SOUNDS[0], order: 2, volume: 0.6, fadeIn: 5 }\n    ],\n    isPublic: true,\n    createdBy: 'user1',\n    createdAt: new Date(Date.now() - 86400000).toISOString(),\n    updatedAt: new Date().toISOString(),\n    tags: ['morning', 'energy', 'motivation'],\n    playCount: 156,\n    likeCount: 23,\n    shareCount: 7,\n    totalDuration: 210,\n    isPreloaded: false\n  }\n];\n\ninterface AudioPlayerState {\n  isPlaying: boolean;\n  currentTrack: string | null;\n  currentPlaylist: string | null;\n  volume: number;\n  currentTime: number;\n  duration: number;\n  loading: boolean;\n  error: string | null;\n}\n\nexport function EnhancedMediaContent({\n  currentUser,\n  mediaLibrary,\n  onUploadSound,\n  onCreatePlaylist,\n  onSubmitQuote,\n  onCompletePhotoChallenge\n}: EnhancedMediaContentProps) {\n  const [selectedTab, setSelectedTab] = useState('sounds');\n  const [searchQuery, setSearchQuery] = useState('');\n  const [selectedCategory, setSelectedCategory] = useState<string>('all');\n  const [uploadProgress, setUploadProgress] = useState(0);\n  const [isUploading, setIsUploading] = useState(false);\n\n  // Audio player state\n  const [playerState, setPlayerState] = useState<AudioPlayerState>({\n    isPlaying: false,\n    currentTrack: null,\n    currentPlaylist: null,\n    volume: 0.7,\n    currentTime: 0,\n    duration: 0,\n    loading: false,\n    error: null\n  });\n\n  // Audio context and source\n  const currentAudioSource = useRef<AudioBufferSourceNode | null>(null);\n  const [audioSources, setAudioSources] = useState<Map<string, AudioBufferSourceNode>>(new Map());\n\n  // Use our enhanced caching\n  const { cacheState, warmCache, getCacheEntry } = useEnhancedCaching();\n\n  // Mock media library if not provided\n  const effectiveMediaLibrary: MediaLibrary = mediaLibrary || {\n    id: '1',\n    userId: currentUser.id,\n    sounds: ENHANCED_MOCK_SOUNDS,\n    playlists: ENHANCED_MOCK_PLAYLISTS,\n    quotes: [\n      {\n        id: '1',\n        text: 'The way to get started is to quit talking and begin doing.',\n        author: 'Walt Disney',\n        category: 'motivation',\n        tags: ['action', 'success', 'start'],\n        isCustom: false,\n        likes: 342,\n        uses: 1205\n      }\n    ],\n    photos: [],\n    storage: {\n      used: cacheState.stats.totalSize,\n      total: 104857600, // 100MB\n      percentage: (cacheState.stats.totalSize / 104857600) * 100,\n      audioCache: cacheState.stats.totalSize,\n      availableForPreload: 104857600 - cacheState.stats.totalSize\n    },\n    cacheSettings: {\n      maxCacheSize: 150 * 1024 * 1024,\n      preloadDistance: 15,\n      compressionEnabled: true,\n      priorityLoading: true,\n      autoCleanup: true,\n      cleanupThreshold: 80\n    },\n    compressionSettings: {\n      enabledForLargeFiles: true,\n      largeFileThreshold: 1024 * 1024,\n      defaultCompressionLevel: 'medium',\n      preserveQualityForFavorites: true\n    }\n  };\n\n  // Initialize audio manager\n  useEffect(() => {\n    audioManager.initialize();\n\n    // Warm cache with popular sounds\n    warmCache(effectiveMediaLibrary.sounds.slice(0, 5));\n  }, []);\n\n  // Audio loading hook for individual sounds\n  const soundLoadingStates = new Map();\n  effectiveMediaLibrary.sounds.forEach(sound => {\n    const loadingState = useAudioLazyLoading(sound, 'medium');\n    soundLoadingStates.set(sound.id, loadingState);\n  });\n\n  // Playlist loading hook\n  const playlistLoadingState = usePlaylistLazyLoading(\n    playerState.currentPlaylist ?\n      effectiveMediaLibrary.playlists.find(p => p.id === playerState.currentPlaylist) || null :\n      null\n  );\n\n  const playSound = useCallback(async (sound: CustomSound) => {\n    setPlayerState(prev => ({ ...prev, loading: true, error: null }));\n\n    try {\n      // Stop current audio if playing\n      if (currentAudioSource.current) {\n        currentAudioSource.current.stop();\n        currentAudioSource.current = null;\n      }\n\n      // Load and play audio using our audio manager\n      const audioSource = await audioManager.playAudioFile(sound.fileUrl, {\n        volume: playerState.volume,\n        onEnded: () => {\n          setPlayerState(prev => ({\n            ...prev,\n            isPlaying: false,\n            currentTrack: null,\n            currentTime: 0\n          }));\n        }\n      });\n\n      if (audioSource) {\n        currentAudioSource.current = audioSource;\n        setPlayerState(prev => ({\n          ...prev,\n          isPlaying: true,\n          currentTrack: sound.id,\n          loading: false,\n          duration: sound.duration,\n          currentTime: 0\n        }));\n\n        // Set up time updates\n        const startTime = performance.now();\n        const updateTime = () => {\n          if (currentAudioSource.current === audioSource) {\n            const elapsed = (performance.now() - startTime) / 1000;\n            setPlayerState(prev => ({\n              ...prev,\n              currentTime: Math.min(elapsed, sound.duration)\n            }));\n\n            if (elapsed < sound.duration) {\n              requestAnimationFrame(updateTime);\n            }\n          }\n        };\n        requestAnimationFrame(updateTime);\n      } else {\n        throw new Error('Failed to create audio source');\n      }\n    } catch (error) {\n      console.error('Error playing sound:', error);\n      setPlayerState(prev => ({\n        ...prev,\n        loading: false,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      }));\n\n      // Fallback to beep if audio fails\n      try {\n        await audioManager.playFallbackBeep('single');\n      } catch (fallbackError) {\n        console.error('Fallback beep also failed:', fallbackError);\n      }\n    }\n  }, [playerState.volume]);\n\n  const pauseSound = useCallback(() => {\n    if (currentAudioSource.current) {\n      currentAudioSource.current.stop();\n      currentAudioSource.current = null;\n    }\n    setPlayerState(prev => ({\n      ...prev,\n      isPlaying: false,\n      currentTrack: null\n    }));\n  }, []);\n\n  const handleVolumeChange = useCallback((newVolume: number[]) => {\n    const volume = newVolume[0] / 100;\n    setPlayerState(prev => ({ ...prev, volume }));\n\n    // Update current audio volume if playing\n    // Note: Web Audio API doesn't allow real-time volume changes easily\n    // In a real implementation, you'd use a GainNode for this\n  }, []);\n\n  const playPlaylist = useCallback(async (playlist: Playlist) => {\n    if (playlist.sounds.length === 0) return;\n\n    setPlayerState(prev => ({ ...prev, currentPlaylist: playlist.id }));\n\n    // Start with the first sound\n    const firstSound = playlist.sounds\n      .sort((a, b) => a.order - b.order)[0];\n\n    await playSound(firstSound.sound);\n  }, [playSound]);\n\n  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0];\n    if (!file) return;\n\n    // Validate file type\n    if (!file.type.startsWith('audio/')) {\n      alert('Please select an audio file');\n      return;\n    }\n\n    // Validate file size (max 10MB)\n    if (file.size > 10 * 1024 * 1024) {\n      alert('File size must be less than 10MB');\n      return;\n    }\n\n    setIsUploading(true);\n    setUploadProgress(0);\n\n    try {\n      // Simulate upload progress\n      const progressInterval = setInterval(() => {\n        setUploadProgress(prev => {\n          const next = prev + 10;\n          if (next >= 100) {\n            clearInterval(progressInterval);\n            return 100;\n          }\n          return next;\n        });\n      }, 200);\n\n      // Call the upload handler if provided\n      if (onUploadSound) {\n        await onUploadSound(file);\n      }\n\n      // Simulate processing time\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      alert('File uploaded successfully!');\n    } catch (error) {\n      console.error('Upload failed:', error);\n      alert('Upload failed. Please try again.');\n    } finally {\n      setIsUploading(false);\n      setUploadProgress(0);\n    }\n  };\n\n  // Filter sounds based on search and category\n  const filteredSounds = effectiveMediaLibrary.sounds.filter(sound => {\n    const matchesSearch = sound.name.toLowerCase().includes(searchQuery.toLowerCase()) ||\n                         sound.tags.some(tag => tag.toLowerCase().includes(searchQuery.toLowerCase()));\n    const matchesCategory = selectedCategory === 'all' || sound.category === selectedCategory;\n    return matchesSearch && matchesCategory;\n  });\n\n  const categories = ['all', ...new Set(effectiveMediaLibrary.sounds.map(s => s.category))];\n\n  const formatDuration = (seconds: number) => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  const formatFileSize = (bytes: number) => {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  };\n\n  const getCategoryIcon = (category: string) => {\n    switch (category) {\n      case 'nature': return <Music className=\"h-4 w-4 text-green-500\" />;\n      case 'music': return <Headphones className=\"h-4 w-4 text-blue-500\" />;\n      case 'voice': return <Mic className=\"h-4 w-4 text-purple-500\" />;\n      case 'ambient': return <Volume2 className=\"h-4 w-4 text-gray-500\" />;\n      default: return <FileAudio className=\"h-4 w-4 text-gray-500\" />;\n    }\n  };\n\n  const renderAudioPlayer = () => (\n    <Card className=\"border-2 border-primary/20\">\n      <CardContent className=\"p-4\">\n        <div className=\"flex items-center justify-between mb-3\">\n          <div className=\"flex items-center gap-3\">\n            <div className=\"w-12 h-12 bg-primary/10 rounded-lg flex items-center justify-center\">\n              <Music className=\"h-6 w-6 text-primary\" />\n            </div>\n            <div>\n              <div className=\"font-medium\">\n                {playerState.currentTrack ?\n                  effectiveMediaLibrary.sounds.find(s => s.id === playerState.currentTrack)?.name || 'Unknown'\n                  : 'No track selected'\n                }\n              </div>\n              <div className=\"text-sm text-muted-foreground\">\n                {formatDuration(playerState.currentTime)} / {formatDuration(playerState.duration)}\n              </div>\n            </div>\n          </div>\n\n          <div className=\"flex items-center gap-2\">\n            <Button size=\"sm\" variant=\"outline\">\n              <SkipBack className=\"h-4 w-4\" />\n            </Button>\n\n            <Button\n              size=\"sm\"\n              onClick={playerState.isPlaying ? pauseSound : () => {\n                if (playerState.currentTrack) {\n                  const sound = effectiveMediaLibrary.sounds.find(s => s.id === playerState.currentTrack);\n                  if (sound) playSound(sound);\n                }\n              }}\n              disabled={playerState.loading}\n            >\n              {playerState.loading ? (\n                <Loader2 className=\"h-4 w-4 animate-spin\" />\n              ) : playerState.isPlaying ? (\n                <Pause className=\"h-4 w-4\" />\n              ) : (\n                <Play className=\"h-4 w-4\" />\n              )}\n            </Button>\n\n            <Button size=\"sm\" variant=\"outline\">\n              <SkipForward className=\"h-4 w-4\" />\n            </Button>\n          </div>\n        </div>\n\n        {/* Progress bar */}\n        <Progress\n          value={playerState.duration > 0 ? (playerState.currentTime / playerState.duration) * 100 : 0}\n          className=\"mb-3\"\n        />\n\n        {/* Volume control */}\n        <div className=\"flex items-center gap-3\">\n          <VolumeX className=\"h-4 w-4 text-muted-foreground\" />\n          <Slider\n            value={[playerState.volume * 100]}\n            onValueChange={handleVolumeChange}\n            max={100}\n            step={1}\n            className=\"flex-1\"\n          />\n          <Volume2 className=\"h-4 w-4 text-muted-foreground\" />\n          <span className=\"text-sm font-medium w-8\">\n            {Math.round(playerState.volume * 100)}%\n          </span>\n        </div>\n\n        {/* Error display */}\n        {playerState.error && (\n          <div className=\"mt-3 p-2 bg-destructive/10 border border-destructive/20 rounded text-sm text-destructive flex items-center gap-2\">\n            <AlertCircle className=\"h-4 w-4\" />\n            {playerState.error}\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  );\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Audio Player */}\n      {(playerState.currentTrack || playerState.isPlaying) && renderAudioPlayer()}\n\n      {/* Cache Status */}\n      <Card>\n        <CardContent className=\"p-4\">\n          <div className=\"flex items-center justify-between mb-2\">\n            <span className=\"text-sm font-medium\">Audio Cache</span>\n            <span className=\"text-sm text-muted-foreground\">\n              {formatFileSize(cacheState.stats.totalSize)} ‚Ä¢ {cacheState.stats.totalEntries} files\n            </span>\n          </div>\n          <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n            <span>Hit Rate: {Math.round(cacheState.stats.hitRate * 100)}%</span>\n            <span>‚Ä¢</span>\n            <span>Memory: {cacheState.memoryPressure}</span>\n            {cacheState.isOptimizing && (\n              <>\n                <span>‚Ä¢</span>\n                <Loader2 className=\"h-3 w-3 animate-spin\" />\n                <span>Optimizing</span>\n              </>\n            )}\n          </div>\n        </CardContent>\n      </Card>\n\n      <Tabs value={selectedTab} onValueChange={setSelectedTab} className=\"w-full\">\n        <TabsList className=\"grid w-full grid-cols-4\">\n          <TabsTrigger value=\"sounds\">Sounds</TabsTrigger>\n          <TabsTrigger value=\"playlists\">Playlists</TabsTrigger>\n          <TabsTrigger value=\"quotes\">Quotes</TabsTrigger>\n          <TabsTrigger value=\"challenges\">Photos</TabsTrigger>\n        </TabsList>\n\n        <TabsContent value=\"sounds\" className=\"space-y-4\">\n          {/* Upload & Search */}\n          <div className=\"flex flex-col gap-4\">\n            <div className=\"flex gap-2\">\n              <div className=\"flex-1\">\n                <Input\n                  placeholder=\"Search sounds...\"\n                  value={searchQuery}\n                  onChange={e => setSearchQuery(e.target.value)}\n                />\n              </div>\n              <label htmlFor=\"category-filter\" className=\"sr-only\">Filter by category</label>\n              <select\n                id=\"category-filter\"\n                value={selectedCategory}\n                onChange={e => setSelectedCategory(e.target.value)}\n                className=\"px-3 py-2 border rounded-md bg-background\"\n                aria-label=\"Filter media by category\"\n              >\n                {categories.map(cat => (\n                  <option key={cat} value={cat}>\n                    {cat === 'all' ? 'All Categories' : cat.charAt(0).toUpperCase() + cat.slice(1)}\n                  </option>\n                ))}\n              </select>\n            </div>\n\n            <div className=\"flex gap-2\">\n              <label htmlFor=\"file-upload\" className=\"cursor-pointer\">\n                <Button asChild disabled={isUploading}>\n                  <span>\n                    <Upload className=\"h-4 w-4 mr-2\" />\n                    Upload Audio\n                  </span>\n                </Button>\n              </label>\n              <input\n                id=\"file-upload\"\n                type=\"file\"\n                accept=\"audio/*\"\n                onChange={handleFileUpload}\n                className=\"hidden\"\n              />\n              <Button variant=\"outline\" onClick={() => warmCache(filteredSounds.slice(0, 5))}>\n                <Download className=\"h-4 w-4 mr-2\" />\n                Preload Popular\n              </Button>\n            </div>\n\n            {/* Upload Progress */}\n            {isUploading && (\n              <Card>\n                <CardContent className=\"p-4\">\n                  <div className=\"flex items-center gap-3\">\n                    <Loader2 className=\"h-4 w-4 animate-spin\" />\n                    <div className=\"flex-1\">\n                      <div className=\"text-sm font-medium mb-1\">Uploading audio file...</div>\n                      <Progress value={uploadProgress} />\n                    </div>\n                    <span className=\"text-sm font-medium\">{uploadProgress}%</span>\n                  </div>\n                </CardContent>\n              </Card>\n            )}\n          </div>\n\n          {/* Sounds List */}\n          <div className=\"grid gap-3\">\n            {filteredSounds.map(sound => {\n              const loadingState = soundLoadingStates.get(sound.id);\n              const isCurrentTrack = playerState.currentTrack === sound.id;\n\n              return (\n                <Card key={sound.id} className={isCurrentTrack ? 'border-primary' : ''}>\n                  <CardContent className=\"p-4\">\n                    <div className=\"flex items-center justify-between\">\n                      <div className=\"flex items-center gap-3\">\n                        {getCategoryIcon(sound.category)}\n                        <div>\n                          <div className=\"font-medium flex items-center gap-2\">\n                            {sound.name}\n                            {sound.isCustom && (\n                              <Badge variant=\"secondary\" className=\"text-xs\">Custom</Badge>\n                            )}\n                            {loadingState?.state === 'loading' && (\n                              <Loader2 className=\"h-3 w-3 animate-spin text-blue-500\" />\n                            )}\n                          </div>\n                          <div className=\"text-sm text-muted-foreground flex items-center gap-2\">\n                            <span>{formatDuration(sound.duration)}</span>\n                            <span>‚Ä¢</span>\n                            <span className=\"capitalize\">{sound.category}</span>\n                            <span>‚Ä¢</span>\n                            <span>{formatFileSize(sound.size || 0)}</span>\n                            {sound.rating && (\n                              <>\n                                <span>‚Ä¢</span>\n                                <div className=\"flex items-center gap-1\">\n                                  <Star className=\"h-3 w-3 fill-yellow-400 text-yellow-400\" />\n                                  <span>{sound.rating}</span>\n                                </div>\n                              </>\n                            )}\n                          </div>\n                        </div>\n                      </div>\n\n                      <div className=\"flex items-center gap-2\">\n                        <Button\n                          size=\"sm\"\n                          variant=\"ghost\"\n                          onClick={() => {\n                            if (isCurrentTrack && playerState.isPlaying) {\n                              pauseSound();\n                            } else {\n                              playSound(sound);\n                            }\n                          }}\n                          disabled={loadingState?.state === 'loading'}\n                        >\n                          {loadingState?.state === 'loading' ? (\n                            <Loader2 className=\"h-4 w-4 animate-spin\" />\n                          ) : isCurrentTrack && playerState.isPlaying ? (\n                            <Pause className=\"h-4 w-4\" />\n                          ) : (\n                            <Play className=\"h-4 w-4\" />\n                          )}\n                        </Button>\n\n                        <Button size=\"sm\" variant=\"ghost\">\n                          <Heart className=\"h-4 w-4\" />\n                        </Button>\n\n                        <Button size=\"sm\" variant=\"ghost\">\n                          <Share className=\"h-4 w-4\" />\n                        </Button>\n                      </div>\n                    </div>\n\n                    {/* Loading Progress */}\n                    {loadingState?.state === 'loading' && loadingState.progress > 0 && (\n                      <div className=\"mt-3\">\n                        <Progress value={loadingState.progress} className=\"h-1\" />\n                        <div className=\"text-xs text-muted-foreground mt-1\">\n                          Loading... {Math.round(loadingState.progress)}%\n                          {loadingState.estimatedTimeRemaining && (\n                            <span> ‚Ä¢ ~{Math.round(loadingState.estimatedTimeRemaining)}s remaining</span>\n                          )}\n                        </div>\n                      </div>\n                    )}\n                  </CardContent>\n                </Card>\n              );\n            })}\n          </div>\n        </TabsContent>\n\n        <TabsContent value=\"playlists\" className=\"space-y-4\">\n          <div className=\"flex justify-between items-center\">\n            <h3 className=\"text-lg font-semibold\">Your Playlists</h3>\n            <Button onClick={() => onCreatePlaylist?.({ name: 'New Playlist' })}>\n              <Plus className=\"h-4 w-4 mr-2\" />\n              Create Playlist\n            </Button>\n          </div>\n\n          {effectiveMediaLibrary.playlists.map(playlist => (\n            <Card key={playlist.id}>\n              <CardContent className=\"p-4\">\n                <div className=\"flex items-center justify-between mb-3\">\n                  <div>\n                    <h3 className=\"font-medium\">{playlist.name}</h3>\n                    <p className=\"text-sm text-muted-foreground\">{playlist.description}</p>\n                  </div>\n                  <Badge variant={playlist.isPublic ? 'default' : 'secondary'}>\n                    {playlist.isPublic ? 'Public' : 'Private'}\n                  </Badge>\n                </div>\n\n                <div className=\"space-y-2 mb-3\">\n                  {playlist.sounds.map((playlistSound) => (\n                    <div key={playlistSound.soundId} className=\"flex items-center gap-2 text-sm\">\n                      <span className=\"text-muted-foreground w-6\">{playlistSound.order}.</span>\n                      <div className=\"flex-1\">{playlistSound.sound.name}</div>\n                      <span className=\"text-muted-foreground\">\n                        {formatDuration(playlistSound.sound.duration)}\n                      </span>\n                    </div>\n                  ))}\n                </div>\n\n                <div className=\"flex items-center justify-between\">\n                  <div className=\"flex items-center gap-4 text-sm text-muted-foreground\">\n                    <span>Duration: {formatDuration(playlist.totalDuration || 0)}</span>\n                    <span>‚Ä¢</span>\n                    <span>{playlist.playCount} plays</span>\n                  </div>\n                  <div className=\"flex gap-2\">\n                    <Button\n                      size=\"sm\"\n                      onClick={() => playPlaylist(playlist)}\n                      disabled={playlist.sounds.length === 0}\n                    >\n                      <Play className=\"h-4 w-4 mr-2\" />\n                      Play\n                    </Button>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n          ))}\n        </TabsContent>\n\n        <TabsContent value=\"quotes\" className=\"space-y-4\">\n          <div className=\"flex justify-between items-center\">\n            <h3 className=\"text-lg font-semibold\">Motivational Quotes</h3>\n            <Button onClick={() => onSubmitQuote?.({ text: '', category: 'motivation' })}>\n              <Plus className=\"h-4 w-4 mr-2\" />\n              Add Quote\n            </Button>\n          </div>\n\n          {effectiveMediaLibrary.quotes.map(quote => (\n            <Card key={quote.id}>\n              <CardContent className=\"p-4\">\n                <div className=\"flex items-start gap-3\">\n                  <Quote className=\"h-6 w-6 text-primary mt-1 flex-shrink-0\" />\n                  <div className=\"flex-1\">\n                    <blockquote className=\"text-lg font-medium leading-relaxed mb-2\">\n                      \"{quote.text}\"\n                    </blockquote>\n                    {quote.author && (\n                      <cite className=\"text-sm text-muted-foreground\">‚Äî {quote.author}</cite>\n                    )}\n                  </div>\n                </div>\n\n                <div className=\"flex items-center justify-between mt-4\">\n                  <Badge variant=\"outline\" className=\"capitalize\">\n                    {quote.category}\n                  </Badge>\n                  <div className=\"flex items-center gap-4 text-sm text-muted-foreground\">\n                    <span>{quote.likes} likes</span>\n                    <span>‚Ä¢</span>\n                    <span>{quote.uses} uses</span>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n          ))}\n        </TabsContent>\n\n        <TabsContent value=\"challenges\" className=\"space-y-4\">\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2\">\n                <Camera className=\"h-5 w-5\" />\n                Photo Challenges\n              </CardTitle>\n            </CardHeader>\n            <CardContent>\n              <div className=\"text-center py-8 text-muted-foreground\">\n                <Camera className=\"h-12 w-12 mx-auto mb-4 opacity-50\" />\n                <p>Photo challenges feature coming soon!</p>\n                <p className=\"text-sm mt-2\">Capture moments and earn rewards for completing daily challenges.</p>\n              </div>\n            </CardContent>\n          </Card>\n        </TabsContent>\n      </Tabs>\n    </div>\n  );\n}\n\nexport default EnhancedMediaContent;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/ErrorBoundaryTest.tsx",
    "messages": [
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 38,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 38,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [1114, 1194],
              "text": "{ const nullObj: any = null;\n        console.log(nullObj.property);\n        break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 44,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 44,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [1251, 1333],
              "text": "{ const undefinedVar: any = undefined;\n        undefinedVar.method();\n        break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState } from 'react';\nimport { Bug, Zap, AlertTriangle, Database, Wifi, Brain, Volume2 } from 'lucide-react';\n\ninterface ErrorBoundaryTestProps {\n  onClose?: () => void;\n}\n\n/**\n * Error Boundary Test Component\n * Only available in development mode for testing error boundaries\n */\nconst ErrorBoundaryTest: React.FC<ErrorBoundaryTestProps> = ({ onClose }) => {\n  const [errorType, setErrorType] = useState<string>('');\n\n  // Only render in development mode\n  if (process.env.NODE_ENV !== 'development') {\n    return null;\n  }\n\n  const triggerError = (type: string) => {\n    setErrorType(type);\n\n    // Trigger different types of errors\n    switch (type) {\n      case 'render':\n        // This will cause a render error\n        throw new Error('Test render error - This is intentional for testing error boundaries');\n\n      case 'async':\n        // Simulate async error\n        setTimeout(() => {\n          throw new Error('Test async error - This is intentional for testing error boundaries');\n        }, 100);\n        break;\n\n      case 'null-reference':\n        // Null reference error\n        const nullObj: any = null;\n        console.log(nullObj.property);\n        break;\n\n      case 'type-error':\n        // Type error\n        const undefinedVar: any = undefined;\n        undefinedVar.method();\n        break;\n\n      case 'network-simulation':\n        // Simulate network error\n        throw new Error('Network request failed - This is intentional for testing error boundaries');\n\n      case 'media-error':\n        // Simulate media/audio error\n        throw new Error('Audio playback failed - This is intentional for testing error boundaries');\n\n      case 'ai-error':\n        // Simulate AI service error\n        throw new Error('AI service unavailable - This is intentional for testing error boundaries');\n\n      case 'data-error':\n        // Simulate data/storage error\n        throw new Error('Failed to save data - This is intentional for testing error boundaries');\n\n      default:\n        throw new Error(`Unknown test error type: ${type}`);\n    }\n  };\n\n  const CrashComponent = () => {\n    if (errorType === 'render') {\n      throw new Error('Test render error - This is intentional for testing error boundaries');\n    }\n    return <div>This component would crash with render error</div>;\n  };\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50\">\n      <div className=\"bg-white dark:bg-dark-800 rounded-xl shadow-2xl p-6 max-w-md w-full\">\n        <div className=\"flex items-center justify-between mb-6\">\n          <h2 className=\"text-xl font-bold text-gray-900 dark:text-white flex items-center gap-2\">\n            <Bug className=\"w-6 h-6 text-orange-600\" />\n            Error Boundary Testing\n          </h2>\n          {onClose && (\n            <button\n              onClick={onClose}\n              className=\"text-gray-400 hover:text-gray-600 dark:hover:text-gray-300\"\n            >\n              <span className=\"sr-only\">Close</span>\n              <svg className=\"w-6 h-6\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n              </svg>\n            </button>\n          )}\n        </div>\n\n        <div className=\"mb-6\">\n          <div className=\"bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-4\">\n            <div className=\"flex items-start gap-2\">\n              <AlertTriangle className=\"w-5 h-5 text-yellow-600 dark:text-yellow-400 flex-shrink-0 mt-0.5\" />\n              <div>\n                <p className=\"text-yellow-800 dark:text-yellow-200 text-sm font-medium\">\n                  Development Mode Only\n                </p>\n                <p className=\"text-yellow-700 dark:text-yellow-300 text-sm mt-1\">\n                  These buttons trigger intentional errors to test error boundaries.\n                  The app should gracefully handle these errors without crashing.\n                </p>\n              </div>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"space-y-3\">\n          <h3 className=\"font-semibold text-gray-900 dark:text-white text-sm\">Test Error Types:</h3>\n\n          <button\n            onClick={() => triggerError('render')}\n            className=\"w-full flex items-center gap-3 p-3 bg-red-50 hover:bg-red-100 dark:bg-red-900/20 dark:hover:bg-red-900/30 border border-red-200 dark:border-red-800 rounded-lg text-red-800 dark:text-red-200 transition-colors\"\n          >\n            <Zap className=\"w-4 h-4\" />\n            <div className=\"text-left\">\n              <div className=\"font-medium\">Render Error</div>\n              <div className=\"text-xs opacity-75\">Component throws during render</div>\n            </div>\n          </button>\n\n          <button\n            onClick={() => triggerError('network-simulation')}\n            className=\"w-full flex items-center gap-3 p-3 bg-blue-50 hover:bg-blue-100 dark:bg-blue-900/20 dark:hover:bg-blue-900/30 border border-blue-200 dark:border-blue-800 rounded-lg text-blue-800 dark:text-blue-200 transition-colors\"\n          >\n            <Wifi className=\"w-4 h-4\" />\n            <div className=\"text-left\">\n              <div className=\"font-medium\">Network Error</div>\n              <div className=\"text-xs opacity-75\">Simulates API/network failure</div>\n            </div>\n          </button>\n\n          <button\n            onClick={() => triggerError('media-error')}\n            className=\"w-full flex items-center gap-3 p-3 bg-purple-50 hover:bg-purple-100 dark:bg-purple-900/20 dark:hover:bg-purple-900/30 border border-purple-200 dark:border-purple-800 rounded-lg text-purple-800 dark:text-purple-200 transition-colors\"\n          >\n            <Volume2 className=\"w-4 h-4\" />\n            <div className=\"text-left\">\n              <div className=\"font-medium\">Media Error</div>\n              <div className=\"text-xs opacity-75\">Simulates audio/media failure</div>\n            </div>\n          </button>\n\n          <button\n            onClick={() => triggerError('ai-error')}\n            className=\"w-full flex items-center gap-3 p-3 bg-green-50 hover:bg-green-100 dark:bg-green-900/20 dark:hover:bg-green-900/30 border border-green-200 dark:border-green-800 rounded-lg text-green-800 dark:text-green-200 transition-colors\"\n          >\n            <Brain className=\"w-4 h-4\" />\n            <div className=\"text-left\">\n              <div className=\"font-medium\">AI Service Error</div>\n              <div className=\"text-xs opacity-75\">Simulates AI/ML service failure</div>\n            </div>\n          </button>\n\n          <button\n            onClick={() => triggerError('data-error')}\n            className=\"w-full flex items-center gap-3 p-3 bg-orange-50 hover:bg-orange-100 dark:bg-orange-900/20 dark:hover:bg-orange-900/30 border border-orange-200 dark:border-orange-800 rounded-lg text-orange-800 dark:text-orange-200 transition-colors\"\n          >\n            <Database className=\"w-4 h-4\" />\n            <div className=\"text-left\">\n              <div className=\"font-medium\">Data Error</div>\n              <div className=\"text-xs opacity-75\">Simulates database/storage failure</div>\n            </div>\n          </button>\n\n          <button\n            onClick={() => triggerError('null-reference')}\n            className=\"w-full flex items-center gap-3 p-3 bg-gray-50 hover:bg-gray-100 dark:bg-gray-800 dark:hover:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg text-gray-800 dark:text-gray-200 transition-colors\"\n          >\n            <AlertTriangle className=\"w-4 h-4\" />\n            <div className=\"text-left\">\n              <div className=\"font-medium\">Null Reference Error</div>\n              <div className=\"text-xs opacity-75\">Common JavaScript error</div>\n            </div>\n          </button>\n        </div>\n\n        {errorType === 'render' && <CrashComponent />}\n\n        <div className=\"mt-6 text-center\">\n          <p className=\"text-xs text-gray-500 dark:text-gray-400\">\n            After triggering an error, check that the error boundary displays properly\n            and allows you to recover or retry.\n          </p>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ErrorBoundaryTest;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/NuclearModeChallenge.tsx",
    "messages": [
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 77,
        "column": 13,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 77,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [2084, 2389],
              "text": "{ const a = Math.floor(Math.random() * 50) + 1;\n            const b = Math.floor(Math.random() * 50) + 1;\n            const op = ['+', '-', '*'][Math.floor(Math.random() * 3)];\n            question = `${a} ${op} ${b}`;\n            answer = op === '+' ? a + b : op === '-' ? a - b : a * b;\n            break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 78,
        "column": 13,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 78,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [2084, 2389],
              "text": "{ const a = Math.floor(Math.random() * 50) + 1;\n            const b = Math.floor(Math.random() * 50) + 1;\n            const op = ['+', '-', '*'][Math.floor(Math.random() * 3)];\n            question = `${a} ${op} ${b}`;\n            answer = op === '+' ? a + b : op === '-' ? a - b : a * b;\n            break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 79,
        "column": 13,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 79,
        "endColumn": 71,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [2084, 2389],
              "text": "{ const a = Math.floor(Math.random() * 50) + 1;\n            const b = Math.floor(Math.random() * 50) + 1;\n            const op = ['+', '-', '*'][Math.floor(Math.random() * 3)];\n            question = `${a} ${op} ${b}`;\n            answer = op === '+' ? a + b : op === '-' ? a - b : a * b;\n            break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 85,
        "column": 13,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 85,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [2430, 2698],
              "text": "{ const x = Math.floor(Math.random() * 20) + 1;\n            const y = Math.floor(Math.random() * 20) + 1;\n            const z = Math.floor(Math.random() * 10) + 1;\n            question = `(${x} * ${y}) + ${z}¬≤`;\n            answer = (x * y) + (z * z);\n            break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 86,
        "column": 13,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 86,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [2430, 2698],
              "text": "{ const x = Math.floor(Math.random() * 20) + 1;\n            const y = Math.floor(Math.random() * 20) + 1;\n            const z = Math.floor(Math.random() * 10) + 1;\n            question = `(${x} * ${y}) + ${z}¬≤`;\n            answer = (x * y) + (z * z);\n            break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 87,
        "column": 13,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 87,
        "endColumn": 58,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [2430, 2698],
              "text": "{ const x = Math.floor(Math.random() * 20) + 1;\n            const y = Math.floor(Math.random() * 20) + 1;\n            const z = Math.floor(Math.random() * 10) + 1;\n            question = `(${x} * ${y}) + ${z}¬≤`;\n            answer = (x * y) + (z * z);\n            break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 93,
        "column": 13,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 93,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [2737, 3033],
              "text": "{ const base = Math.floor(Math.random() * 10) + 2;\n            const exp = Math.floor(Math.random() * 3) + 2;\n            const mult = Math.floor(Math.random() * 5) + 1;\n            question = `${base}^${exp} - ${mult} * 7`;\n            answer = Math.pow(base, exp) - (mult * 7);\n            break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 94,
        "column": 13,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 94,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [2737, 3033],
              "text": "{ const base = Math.floor(Math.random() * 10) + 2;\n            const exp = Math.floor(Math.random() * 3) + 2;\n            const mult = Math.floor(Math.random() * 5) + 1;\n            question = `${base}^${exp} - ${mult} * 7`;\n            answer = Math.pow(base, exp) - (mult * 7);\n            break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 95,
        "column": 13,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 95,
        "endColumn": 60,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [2737, 3033],
              "text": "{ const base = Math.floor(Math.random() * 10) + 2;\n            const exp = Math.floor(Math.random() * 3) + 2;\n            const mult = Math.floor(Math.random() * 5) + 1;\n            question = `${base}^${exp} - ${mult} * 7`;\n            answer = Math.pow(base, exp) - (mult * 7);\n            break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 9,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect, useRef } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from './ui/card';\nimport { Button } from './ui/button';\nimport { Input } from './ui/input';\nimport { Progress } from './ui/progress';\nimport { Badge } from './ui/badge';\nimport { Alert, AlertDescription } from './ui/alert';\nimport { Separator } from './ui/separator';\nimport { Label } from './ui/label';\nimport {\n  Zap,\n  Clock,\n  Target,\n  CheckCircle,\n  XCircle,\n  AlertTriangle,\n  Brain,\n  Camera,\n  Mic,\n  BarChart3,\n  QrCode,\n  Keyboard,\n  Shield,\n  Volume2,\n  Eye,\n  Lightbulb,\n  Trophy,\n  Flame,\n  Timer\n} from 'lucide-react';\nimport type {\n  NuclearModeChallenge,\n  NuclearChallengeType,\n  NuclearModeSession,\n  NuclearChallengeAttempt\n} from '../types';\nimport { nuclearModeService } from '../services/nuclear-mode';\nimport { cn } from '../lib/utils';\n\ninterface NuclearModeChallengeProps {\n  session: NuclearModeSession;\n  currentChallenge: NuclearModeChallenge;\n  onChallengeComplete: (successful: boolean, data?: any) => void;\n  onSessionComplete: () => void;\n  onSessionFailed: () => void;\n  className?: string;\n}\n\n// Math Challenge Component\nconst MathChallenge: React.FC<{\n  challenge: NuclearModeChallenge;\n  onComplete: (success: boolean, data: any) => void;\n}> = ({ challenge, onComplete }) => {\n  const [problems, setProblems] = useState<Array<{\n    question: string;\n    answer: number;\n    userAnswer: string;\n    correct?: boolean;\n  }>>([]);\n  const [currentProblem, setCurrentProblem] = useState(0);\n  const [userAnswer, setUserAnswer] = useState('');\n  const [errors, setErrors] = useState(0);\n\n  useEffect(() => {\n    // Generate math problems based on difficulty\n    const generateProblems = () => {\n      const numProblems = challenge.configuration.sequenceLength || 5;\n      const complexity = challenge.configuration.mathComplexity || 'advanced';\n      const newProblems = [];\n\n      for (let i = 0; i < numProblems; i++) {\n        let question = '';\n        let answer = 0;\n\n        switch (complexity) {\n          case 'basic':\n            const a = Math.floor(Math.random() * 50) + 1;\n            const b = Math.floor(Math.random() * 50) + 1;\n            const op = ['+', '-', '*'][Math.floor(Math.random() * 3)];\n            question = `${a} ${op} ${b}`;\n            answer = op === '+' ? a + b : op === '-' ? a - b : a * b;\n            break;\n\n          case 'advanced':\n            const x = Math.floor(Math.random() * 20) + 1;\n            const y = Math.floor(Math.random() * 20) + 1;\n            const z = Math.floor(Math.random() * 10) + 1;\n            question = `(${x} * ${y}) + ${z}¬≤`;\n            answer = (x * y) + (z * z);\n            break;\n\n          case 'expert':\n            const base = Math.floor(Math.random() * 10) + 2;\n            const exp = Math.floor(Math.random() * 3) + 2;\n            const mult = Math.floor(Math.random() * 5) + 1;\n            question = `${base}^${exp} - ${mult} * 7`;\n            answer = Math.pow(base, exp) - (mult * 7);\n            break;\n        }\n\n        newProblems.push({\n          question,\n          answer,\n          userAnswer: '',\n          correct: undefined\n        });\n      }\n\n      setProblems(newProblems);\n    };\n\n    generateProblems();\n  }, [challenge]);\n\n  const handleSubmit = () => {\n    const currentAnswerNum = parseFloat(userAnswer);\n    const correctAnswer = problems[currentProblem].answer;\n    const isCorrect = Math.abs(currentAnswerNum - correctAnswer) < 0.001;\n\n    const updatedProblems = [...problems];\n    updatedProblems[currentProblem] = {\n      ...updatedProblems[currentProblem],\n      userAnswer,\n      correct: isCorrect\n    };\n    setProblems(updatedProblems);\n\n    if (!isCorrect) {\n      const newErrors = errors + 1;\n      setErrors(newErrors);\n\n      if (newErrors >= 2) {\n        // Reset sequence on too many errors\n        setCurrentProblem(0);\n        setProblems(problems.map(p => ({ ...p, userAnswer: '', correct: undefined })));\n        setErrors(0);\n        setUserAnswer('');\n        return;\n      }\n    }\n\n    if (currentProblem < problems.length - 1) {\n      setCurrentProblem(currentProblem + 1);\n      setUserAnswer('');\n    } else {\n      // All problems completed successfully\n      onComplete(true, {\n        totalProblems: problems.length,\n        errors,\n        answers: updatedProblems\n      });\n    }\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"text-center\">\n        <h3 className=\"text-2xl font-bold text-gray-900 mb-2\">\n          Problem {currentProblem + 1} of {problems.length}\n        </h3>\n        <Progress value={(currentProblem / problems.length) * 100} className=\"h-3\" />\n      </div>\n\n      {problems[currentProblem] && (\n        <div className=\"text-center space-y-4\">\n          <div className=\"text-4xl font-mono bg-gray-100 p-6 rounded-lg border-2\">\n            {problems[currentProblem].question} = ?\n          </div>\n\n          <Input\n            type=\"number\"\n            value={userAnswer}\n            onChange={e => setUserAnswer(e.target.value)}\n            placeholder=\"Enter your answer\"\n            className=\"text-center text-2xl h-16\"\n            autoFocus\n            onKeyPress={(e) => e.key === 'Enter' && handleSubmit()}\n          />\n\n          <Button\n            onClick={handleSubmit}\n            disabled={!userAnswer.trim()}\n            className=\"w-full h-12 text-lg bg-blue-600 hover:bg-blue-700\"\n          >\n            Submit Answer\n          </Button>\n        </div>\n      )}\n\n      {errors > 0 && (\n        <Alert className=\"border-red-200 bg-red-50\">\n          <AlertTriangle className=\"w-4 h-4 text-red-600\" />\n          <AlertDescription className=\"text-red-800\">\n            {errors} error{errors !== 1 ? 's' : ''} made.\n            {errors >= 1 && ' One more error will reset the sequence!'}\n          </AlertDescription>\n        </Alert>\n      )}\n    </div>\n  );\n};\n\n// Memory Challenge Component\nconst MemoryChallenge: React.FC<{\n  challenge: NuclearModeChallenge;\n  onComplete: (success: boolean, data: any) => void;\n}> = ({ challenge, onComplete }) => {\n  const [sequence, setSequence] = useState<number[]>([]);\n  const [userSequence, setUserSequence] = useState<number[]>([]);\n  const [showingSequence, setShowingSequence] = useState(false);\n  const [currentRound, setCurrentRound] = useState(1);\n  const [gameState, setGameState] = useState<'waiting' | 'showing' | 'input'>('waiting');\n\n  const maxRounds = challenge.configuration.sequenceLength || 8;\n  const colors = ['bg-red-500', 'bg-blue-500', 'bg-green-500', 'bg-yellow-500', 'bg-purple-500', 'bg-pink-500'];\n\n  const startRound = () => {\n    const newSequence = [];\n    for (let i = 0; i < currentRound; i++) {\n      newSequence.push(Math.floor(Math.random() * 6));\n    }\n    setSequence(newSequence);\n    setUserSequence([]);\n    setGameState('showing');\n\n    // Show sequence\n    setShowingSequence(true);\n    setTimeout(() => {\n      setShowingSequence(false);\n      setGameState('input');\n    }, newSequence.length * 800 + 1000);\n  };\n\n  const handleColorClick = (colorIndex: number) => {\n    if (gameState !== 'input') return;\n\n    const newUserSequence = [...userSequence, colorIndex];\n    setUserSequence(newUserSequence);\n\n    if (newUserSequence[newUserSequence.length - 1] !== sequence[newUserSequence.length - 1]) {\n      // Wrong sequence - reset\n      onComplete(false, {\n        round: currentRound,\n        sequence,\n        userSequence: newUserSequence,\n        error: 'wrong_sequence'\n      });\n      return;\n    }\n\n    if (newUserSequence.length === sequence.length) {\n      // Round completed\n      if (currentRound >= maxRounds) {\n        // All rounds completed!\n        onComplete(true, {\n          totalRounds: maxRounds,\n          completed: true\n        });\n      } else {\n        // Next round\n        setCurrentRound(currentRound + 1);\n        setGameState('waiting');\n        setTimeout(startRound, 1000);\n      }\n    }\n  };\n\n  useEffect(() => {\n    if (gameState === 'waiting') {\n      setTimeout(startRound, 1000);\n    }\n  }, [gameState]);\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"text-center\">\n        <h3 className=\"text-2xl font-bold text-gray-900 mb-2\">\n          Round {currentRound} of {maxRounds}\n        </h3>\n        <Progress value={(currentRound / maxRounds) * 100} className=\"h-3\" />\n      </div>\n\n      <div className=\"text-center\">\n        {gameState === 'waiting' && (\n          <div className=\"text-lg text-gray-600\">Get ready for round {currentRound}...</div>\n        )}\n        {gameState === 'showing' && (\n          <div className=\"text-lg text-blue-600\">Watch the sequence carefully!</div>\n        )}\n        {gameState === 'input' && (\n          <div className=\"text-lg text-green-600\">Repeat the sequence by clicking the colors</div>\n        )}\n      </div>\n\n      <div className=\"grid grid-cols-3 gap-4 max-w-md mx-auto\">\n        {colors.map((color, index) => (\n          <button\n            key={index}\n            className={cn(\n              'w-20 h-20 rounded-lg border-4 transition-all transform',\n              color,\n              gameState === 'input' ? 'hover:scale-105 cursor-pointer' : 'cursor-not-allowed',\n              showingSequence && sequence[Math.floor((Date.now() % (sequence.length * 800)) / 800)] === index\n                ? 'scale-110 border-white shadow-lg'\n                : 'border-gray-300'\n            )}\n            onClick={() => handleColorClick(index)}\n            disabled={gameState !== 'input'}\n          />\n        ))}\n      </div>\n\n      {userSequence.length > 0 && (\n        <div className=\"text-center\">\n          <div className=\"text-sm text-gray-600 mb-2\">Your sequence:</div>\n          <div className=\"flex gap-2 justify-center\">\n            {userSequence.map((colorIndex, index) => (\n              <div\n                key={index}\n                className={cn('w-6 h-6 rounded', colors[colorIndex])}\n              />\n            ))}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\n// Photo Challenge Component\nconst PhotoChallenge: React.FC<{\n  challenge: NuclearModeChallenge;\n  onComplete: (success: boolean, data: any) => void;\n}> = ({ challenge, onComplete }) => {\n  const [photosTaken, setPhotosTaken] = useState<File[]>([]);\n  const [currentPhotoIndex, setCurrentPhotoIndex] = useState(0);\n  const fileInputRef = useRef<HTMLInputElement>(null);\n\n  const photoRequirements = [\n    {\n      title: \"Clear Selfie\",\n      description: \"Take a clear photo of your face with eyes open and visible\",\n      type: \"selfie\"\n    },\n    {\n      title: \"Location Proof\",\n      description: \"Take a photo showing you're in a different room than your bedroom\",\n      type: \"location\"\n    },\n    {\n      title: \"Date Verification\",\n      description: \"Include a clock, phone screen, or newspaper showing today's date/time\",\n      type: \"date_proof\"\n    }\n  ];\n\n  const handlePhotoCapture = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0];\n    if (file) {\n      const newPhotos = [...photosTaken, file];\n      setPhotosTaken(newPhotos);\n\n      if (currentPhotoIndex < photoRequirements.length - 1) {\n        setCurrentPhotoIndex(currentPhotoIndex + 1);\n      } else {\n        // All photos taken\n        onComplete(true, {\n          photos: newPhotos,\n          requirements: photoRequirements\n        });\n      }\n    }\n  };\n\n  const currentRequirement = photoRequirements[currentPhotoIndex];\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"text-center\">\n        <h3 className=\"text-2xl font-bold text-gray-900 mb-2\">\n          Photo {currentPhotoIndex + 1} of {photoRequirements.length}\n        </h3>\n        <Progress value={((currentPhotoIndex) / photoRequirements.length) * 100} className=\"h-3\" />\n      </div>\n\n      <div className=\"text-center space-y-4\">\n        <div className=\"bg-blue-50 p-6 rounded-lg border-2 border-blue-200\">\n          <Camera className=\"w-12 h-12 text-blue-600 mx-auto mb-4\" />\n          <h4 className=\"text-xl font-semibold text-blue-900 mb-2\">\n            {currentRequirement.title}\n          </h4>\n          <p className=\"text-blue-700\">\n            {currentRequirement.description}\n          </p>\n        </div>\n\n        <input\n          ref={fileInputRef}\n          type=\"file\"\n          accept=\"image/*\"\n          capture=\"environment\"\n          onChange={handlePhotoCapture}\n          className=\"hidden\"\n        />\n\n        <Button\n          onClick={() => fileInputRef.current?.click()}\n          className=\"w-full h-16 text-lg bg-blue-600 hover:bg-blue-700\"\n        >\n          <Camera className=\"w-6 h-6 mr-2\" />\n          Take Photo\n        </Button>\n\n        {photosTaken.length > 0 && (\n          <div className=\"mt-6\">\n            <h5 className=\"text-sm font-medium text-gray-700 mb-2\">Photos taken:</h5>\n            <div className=\"flex gap-2 justify-center\">\n              {photosTaken.map((_, index) => (\n                <CheckCircle key={index} className=\"w-6 h-6 text-green-500\" />\n              ))}\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\n// Voice Challenge Component\nconst VoiceChallenge: React.FC<{\n  challenge: NuclearModeChallenge;\n  onComplete: (success: boolean, data: any) => void;\n}> = ({ challenge, onComplete }) => {\n  const [isRecording, setIsRecording] = useState(false);\n  const [currentPhrase, setCurrentPhrase] = useState(0);\n  const [completedPhrases, setCompletedPhrases] = useState<boolean[]>([]);\n\n  const tongueTwisters = [\n    \"She sells seashells by the seashore\",\n    \"How much wood would a woodchuck chuck if a woodchuck could chuck wood\",\n    \"Peter Piper picked a peck of pickled peppers\",\n    \"Fuzzy Wuzzy was a bear, Fuzzy Wuzzy had no hair\",\n    \"Red leather, yellow leather\"\n  ];\n\n  const handleRecording = async () => {\n    if (!isRecording) {\n      setIsRecording(true);\n      // Simulate recording for 3 seconds\n      setTimeout(() => {\n        setIsRecording(false);\n        // Simulate voice recognition success (in real app, would use actual voice recognition)\n        const newCompleted = [...completedPhrases];\n        newCompleted[currentPhrase] = Math.random() > 0.3; // 70% success rate for demo\n        setCompletedPhrases(newCompleted);\n\n        if (newCompleted[currentPhrase]) {\n          if (currentPhrase < tongueTwisters.length - 1) {\n            setCurrentPhrase(currentPhrase + 1);\n          } else {\n            // All phrases completed\n            onComplete(true, {\n              phrases: tongueTwisters,\n              completed: newCompleted\n            });\n          }\n        }\n      }, 3000);\n    }\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"text-center\">\n        <h3 className=\"text-2xl font-bold text-gray-900 mb-2\">\n          Phrase {currentPhrase + 1} of {tongueTwisters.length}\n        </h3>\n        <Progress value={((currentPhrase + completedPhrases.filter(Boolean).length) / tongueTwisters.length) * 100} className=\"h-3\" />\n      </div>\n\n      <div className=\"text-center space-y-4\">\n        <div className=\"bg-purple-50 p-6 rounded-lg border-2 border-purple-200\">\n          <Volume2 className=\"w-12 h-12 text-purple-600 mx-auto mb-4\" />\n          <h4 className=\"text-lg font-semibold text-purple-900 mb-4\">\n            Speak this phrase clearly:\n          </h4>\n          <p className=\"text-2xl font-mono text-purple-800 leading-relaxed\">\n            \"{tongueTwisters[currentPhrase]}\"\n          </p>\n        </div>\n\n        <Button\n          onClick={handleRecording}\n          disabled={isRecording}\n          className={cn(\n            'w-full h-16 text-lg',\n            isRecording\n              ? \"bg-red-600 hover:bg-red-700\"\n              : \"bg-purple-600 hover:bg-purple-700\"\n          )}\n        >\n          {isRecording ? (\n            <>\n              <div className=\"animate-pulse w-6 h-6 bg-white rounded-full mr-2\" />\n              Recording... ({3}s)\n            </>\n          ) : (\n            <>\n              <Mic className=\"w-6 h-6 mr-2\" />\n              Start Recording\n            </>\n          )}\n        </Button>\n\n        {completedPhrases.length > 0 && (\n          <div className=\"space-y-2\">\n            {tongueTwisters.slice(0, currentPhrase + 1).map((phrase, index) => (\n              <div key={index} className=\"flex items-center gap-2 text-sm\">\n                {completedPhrases[index] ? (\n                  <CheckCircle className=\"w-5 h-5 text-green-500\" />\n                ) : index === currentPhrase ? (\n                  <Clock className=\"w-5 h-5 text-yellow-500\" />\n                ) : (\n                  <XCircle className=\"w-5 h-5 text-red-500\" />\n                )}\n                <span className={completedPhrases[index] ? 'text-green-600' : 'text-gray-600'}>\n                  {phrase}\n                </span>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\n// Main Nuclear Mode Challenge Component\nexport const NuclearModeChallenge: React.FC<NuclearModeChallengeProps> = ({\n  session,\n  currentChallenge,\n  onChallengeComplete,\n  onSessionComplete,\n  onSessionFailed,\n  className\n}) => {\n  const [timeRemaining, setTimeRemaining] = useState(currentChallenge.timeLimit || 300);\n  const [hintsUsed, setHintsUsed] = useState(0);\n  const [showHint, setShowHint] = useState(false);\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setTimeRemaining(prev => {\n        if (prev <= 1) {\n          // Time's up!\n          onChallengeComplete(false, { reason: 'timeout' });\n          return 0;\n        }\n        return prev - 1;\n      });\n    }, 1000);\n\n    return () => clearInterval(timer);\n  }, [onChallengeComplete]);\n\n  const formatTime = (seconds: number) => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  const useHint = () => {\n    if (hintsUsed < (currentChallenge.hints?.length || 0)) {\n      setHintsUsed(hintsUsed + 1);\n      setShowHint(true);\n    }\n  };\n\n  const renderChallenge = () => {\n    switch (currentChallenge.type) {\n      case 'multi_step_math':\n        return (\n          <MathChallenge\n            challenge={currentChallenge}\n            onComplete={onChallengeComplete}\n          />\n        );\n      case 'memory_sequence':\n        return (\n          <MemoryChallenge\n            challenge={currentChallenge}\n            onComplete={onChallengeComplete}\n          />\n        );\n      case 'photo_proof':\n        return (\n          <PhotoChallenge\n            challenge={currentChallenge}\n            onComplete={onChallengeComplete}\n          />\n        );\n      case 'voice_recognition':\n        return (\n          <VoiceChallenge\n            challenge={currentChallenge}\n            onComplete={onChallengeComplete}\n          />\n        );\n      default:\n        return (\n          <div className=\"text-center\">\n            <p className=\"text-gray-600\">Challenge type not implemented: {currentChallenge.type}</p>\n            <Button onClick={() => onChallengeComplete(true, {})}>\n              Skip Challenge\n            </Button>\n          </div>\n        );\n    }\n  };\n\n  return (\n    <Card className={cn('min-h-screen bg-gradient-to-br from-red-50 to-orange-50', className)}>\n      <CardHeader className=\"bg-gradient-to-r from-red-600 to-orange-600 text-white\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center gap-3\">\n            <div className=\"p-2 bg-white/20 rounded-lg\">\n              <Zap className=\"w-8 h-8\" />\n            </div>\n            <div>\n              <CardTitle className=\"text-2xl\">üí£ Nuclear Mode Active</CardTitle>\n              <p className=\"text-red-100\">Challenge {session.successfulChallenges + 1} of {session.challenges.length}</p>\n            </div>\n          </div>\n          <div className=\"text-right\">\n            <div className={cn(\n              'text-2xl font-mono font-bold',\n              timeRemaining < 60 ? 'text-yellow-300 animate-pulse' : 'text-white'\n            )}>\n              {formatTime(timeRemaining)}\n            </div>\n            <div className=\"text-red-100 text-sm\">Time Remaining</div>\n          </div>\n        </div>\n      </CardHeader>\n\n      <CardContent className=\"p-8\">\n        {/* Challenge Header */}\n        <div className=\"text-center mb-8\">\n          <h2 className=\"text-3xl font-bold text-gray-900 mb-2\">\n            {currentChallenge.title}\n          </h2>\n          <p className=\"text-gray-600 mb-4\">\n            {currentChallenge.description}\n          </p>\n          <div className=\"flex items-center justify-center gap-4 mb-6\">\n            <Badge variant=\"destructive\" className=\"px-4 py-2\">\n              <Target className=\"w-4 h-4 mr-1\" />\n              Difficulty {currentChallenge.difficulty}/10\n            </Badge>\n            <Badge variant=\"outline\" className=\"px-4 py-2\">\n              <Flame className=\"w-4 h-4 mr-1\" />\n              Attempt {currentChallenge.attempts + 1}/{currentChallenge.maxAttempts}\n            </Badge>\n          </div>\n        </div>\n\n        {/* Challenge Component */}\n        <div className=\"max-w-2xl mx-auto\">\n          {renderChallenge()}\n        </div>\n\n        {/* Hints Section */}\n        {currentChallenge.hints && currentChallenge.hints.length > 0 && (\n          <div className=\"mt-8 max-w-2xl mx-auto\">\n            <div className=\"flex items-center justify-between mb-4\">\n              <h4 className=\"text-sm font-semibold text-gray-700\">Need Help?</h4>\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={useHint}\n                disabled={hintsUsed >= currentChallenge.hints.length}\n              >\n                <Lightbulb className=\"w-4 h-4 mr-1\" />\n                Use Hint ({hintsUsed}/{currentChallenge.hints.length})\n              </Button>\n            </div>\n\n            {showHint && hintsUsed > 0 && (\n              <Alert className=\"border-blue-200 bg-blue-50\">\n                <Lightbulb className=\"w-4 h-4 text-blue-600\" />\n                <AlertDescription className=\"text-blue-800\">\n                  <strong>Hint {hintsUsed}:</strong> {currentChallenge.hints[hintsUsed - 1]}\n                </AlertDescription>\n              </Alert>\n            )}\n          </div>\n        )}\n\n        {/* Session Progress */}\n        <div className=\"mt-8 max-w-2xl mx-auto\">\n          <Separator className=\"mb-4\" />\n          <div className=\"flex items-center justify-between text-sm text-gray-600\">\n            <span>Session Progress</span>\n            <span>{session.successfulChallenges} / {session.challenges.length} completed</span>\n          </div>\n          <Progress\n            value={(session.successfulChallenges / session.challenges.length) * 100}\n            className=\"mt-2 h-2\"\n          />\n        </div>\n\n        {/* Warning */}\n        <Alert className=\"mt-6 max-w-2xl mx-auto border-red-200 bg-red-50\">\n          <AlertTriangle className=\"w-4 h-4 text-red-600\" />\n          <AlertDescription className=\"text-red-800\">\n            Nuclear Mode is active. You must complete all challenges to dismiss the alarm.\n            Snoozing is disabled.\n          </AlertDescription>\n        </Alert>\n      </CardContent>\n    </Card>\n  );\n};export default NuclearModeChallenge;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/NuclearModeSelector.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'NuclearChallengeType' is not defined.",
        "line": 47,
        "column": 23,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 47,
        "endColumn": 43
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'NuclearChallengeType' is not defined.",
        "line": 50,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 50,
        "endColumn": 56
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'NuclearChallengeType' is not defined.",
        "line": 56,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 56,
        "endColumn": 50
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'NuclearChallengeType' is not defined.",
        "line": 88,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 88,
        "endColumn": 31
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'setUserTier' is not defined.",
        "line": 104,
        "column": 9,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 104,
        "endColumn": 20
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'NuclearChallengeType' is not defined.",
        "line": 117,
        "column": 49,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 117,
        "endColumn": 69
      }
    ],
    "suppressedMessages": [],
    "errorCount": 6,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect } from \"react\";\nimport {\n  Card,\n  CardContent,\n  CardDescription,\n  CardHeader,\n  CardTitle,\n} from \"./ui/card\";\nimport { Badge } from \"./ui/badge\";\nimport { Button } from \"./ui/button\";\nimport { Checkbox } from \"./ui/checkbox\";\nimport { Label } from \"./ui/label\";\nimport { Slider } from \"./ui/slider\";\nimport { Alert, AlertDescription, AlertTriangle } from \"./ui/alert\";\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n  DialogTrigger,\n} from \"./ui/dialog\";\nimport { Separator } from \"./ui/separator\";\nimport { Progress } from \"./ui/progress\";\nimport { Switch } from \"./ui/switch\";\nimport {\n  Zap,\n  Shield,\n  Brain,\n  Camera,\n  BarChart3,\n  Mic,\n  QrCode,\n  Keyboard,\n  Target,\n  Crown,\n  Lock,\n  AlertTriangle as AlertTriangleIcon,\n} from \"lucide-react\";\nimport { nuclearModeService } from \"../services/nuclear-mode\";\nimport { premiumService } from \"../services/premium\";\nimport { cn } from \"../lib/utils\";\n\ninterface NuclearModeSelectorProps {\n  isEnabled: boolean;\n  selectedChallenges: NuclearChallengeType[];\n  customDifficulty: number;\n  onEnabledChange: (enabled: boolean) => void;\n  onChallengesChange: (challenges: NuclearChallengeType[]) => void;\n  onDifficultyChange: (difficulty: number) => void;\n  userId: string;\n  className?: string;\n}\n\nconst challengeIcons: Record<NuclearChallengeType, React.ComponentType<any>> = {\n  multi_step_math: BarChart3,\n  memory_sequence: Brain,\n  physical_movement: Target,\n  barcode_scan: QrCode,\n  photo_proof: Camera,\n  voice_recognition: Mic,\n  typing_challenge: Keyboard,\n  pattern_matching: Shield,\n  location_verification: Target,\n  qr_code_hunt: QrCode,\n  shake_intensity: Zap,\n  sound_matching: Mic,\n  color_sequence: Shield,\n  puzzle_solving: Brain,\n  riddle_answer: Brain\n};\n\nexport const NuclearModeSelector: React.FC<NuclearModeSelectorProps> = ({\n  isEnabled,\n  selectedChallenges,\n  customDifficulty,\n  onEnabledChange,\n  onChallengesChange,\n  onDifficultyChange,\n  userId,\n  className\n}) => {\n  const [hasAccess, setHasAccess] = useState(false);\n  const [upgradeUrl, setUpgradeUrl] = useState<string>();\n  const [isLoading, setIsLoading] = useState(true);\n  const [challengeTypes, setChallengeTypes] = useState<Array<{\n    type: NuclearChallengeType;\n    name: string;\n    description: string;\n    difficulty: number;\n    estimatedTime: number;\n  }>>([]);\n  const [showPreview, setShowPreview] = useState(false);\n\n  useEffect(() => {\n    const checkAccess = async () => {\n      setIsLoading(true);\n      try {\n        const access = await nuclearModeService.canAccessNuclearMode(userId);\n        const types = nuclearModeService.getChallengeTypes();\n\n        setHasAccess(access.hasAccess);\n        setUserTier(access.userTier);\n        setUpgradeUrl(access.upgradeUrl);\n        setChallengeTypes(types);\n      } catch (error) {\n        console.error('Error checking nuclear mode access:', error);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    checkAccess();\n  }, [userId]);\n\n  const handleChallengeToggle = (challengeType: NuclearChallengeType, checked: boolean) => {\n    if (checked) {\n      onChallengesChange([...selectedChallenges, challengeType]);\n    } else {\n      onChallengesChange(selectedChallenges.filter(c => c !== challengeType));\n    }\n  };\n\n  const getDifficultyLabel = (difficulty: number) => {\n    if (difficulty <= 3) return { label: 'Moderate', color: 'bg-yellow-500' };\n    if (difficulty <= 6) return { label: 'Intense', color: 'bg-orange-500' };\n    if (difficulty <= 8) return { label: 'Extreme', color: 'bg-red-500' };\n    return { label: 'NUCLEAR', color: 'bg-red-600' };\n  };\n\n  const calculateEstimatedTime = () => {\n    const totalTime = selectedChallenges.reduce((total, challengeType) => {\n      const challenge = challengeTypes.find(c => c.type === challengeType);\n      return total + (challenge?.estimatedTime || 300);\n    }, 0);\n    return Math.round(totalTime / 60); // Convert to minutes\n  };\n\n  const difficultyInfo = getDifficultyLabel(customDifficulty);\n\n  if (isLoading) {\n    return (\n      <Card className={cn('border-orange-200', className)}>\n        <CardHeader>\n          <div className=\"flex items-center gap-2\">\n            <div className=\"w-6 h-6 bg-gray-200 rounded animate-pulse\" />\n            <div className=\"w-32 h-5 bg-gray-200 rounded animate-pulse\" />\n          </div>\n        </CardHeader>\n        <CardContent>\n          <div className=\"space-y-3\">\n            <div className=\"w-full h-4 bg-gray-200 rounded animate-pulse\" />\n            <div className=\"w-3/4 h-4 bg-gray-200 rounded animate-pulse\" />\n          </div>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  if (!hasAccess) {\n    return (\n      <Card className={cn('border-orange-200 bg-gradient-to-r from-orange-50 to-red-50', className)}>\n        <CardHeader>\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-2\">\n              <div className=\"p-2 bg-orange-100 rounded-lg\">\n                <Zap className=\"w-6 h-6 text-orange-600\" />\n              </div>\n              <div>\n                <CardTitle className=\"text-orange-900 flex items-center gap-2\">\n                  üí£ Nuclear Mode\n                  <Badge variant=\"secondary\" className=\"bg-orange-100 text-orange-800\">\n                    <Crown className=\"w-3 h-3 mr-1\" />\n                    Premium\n                  </Badge>\n                </CardTitle>\n                <CardDescription className=\"text-orange-700\">\n                  Extreme difficulty challenges for the ultimate wake-up experience\n                </CardDescription>\n              </div>\n            </div>\n            <Lock className=\"w-5 h-5 text-orange-400\" />\n          </div>\n        </CardHeader>\n        <CardContent>\n          <Alert className=\"border-orange-200 bg-orange-50\">\n            <AlertTriangleIcon className=\"w-4 h-4 text-orange-600\" />\n            <AlertDescription className=\"text-orange-800\">\n              Nuclear Mode requires a Premium subscription. This feature includes extreme difficulty challenges\n              with math problems, memory tests, physical movements, and more.\n            </AlertDescription>\n          </Alert>\n\n          <div className=\"mt-4 grid grid-cols-2 gap-2\">\n            {challengeTypes.slice(0, 4).map(challenge => {\n              const Icon = challengeIcons[challenge.type];\n              return (\n                <div key={challenge.type} className=\"flex items-center gap-2 p-2 bg-white rounded-lg border border-orange-100 opacity-60\">\n                  <Icon className=\"w-4 h-4 text-gray-400\" />\n                  <span className=\"text-sm text-gray-500\">{challenge.name}</span>\n                  <Lock className=\"w-3 h-3 text-gray-400 ml-auto\" />\n                </div>\n              );\n            })}\n          </div>\n\n          <div className=\"mt-4 flex flex-col gap-2\">\n            <Button\n              className=\"w-full bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600\"\n              onClick={() => window.open(upgradeUrl, '_blank')}\n            >\n              <Crown className=\"w-4 h-4 mr-2\" />\n              Upgrade to Premium\n            </Button>\n            <Dialog open={showPreview} onOpenChange={setShowPreview}>\n              <DialogTrigger asChild>\n                <Button variant=\"outline\" className=\"w-full border-orange-200 text-orange-700 hover:bg-orange-50\">\n                  Preview Nuclear Mode\n                </Button>\n              </DialogTrigger>\n              <DialogContent className=\"max-w-2xl\">\n                <DialogHeader>\n                  <DialogTitle className=\"flex items-center gap-2\">\n                    <Zap className=\"w-5 h-5 text-orange-500\" />\n                    Nuclear Mode Preview\n                  </DialogTitle>\n                  <DialogDescription>\n                    See what you'll get with Nuclear Mode challenges\n                  </DialogDescription>\n                </DialogHeader>\n\n                <div className=\"space-y-4 max-h-96 overflow-y-auto\">\n                  {challengeTypes.map(challenge => {\n                    const Icon = challengeIcons[challenge.type];\n                    return (\n                      <div key={challenge.type} className=\"p-4 border rounded-lg\">\n                        <div className=\"flex items-start gap-3\">\n                          <div className=\"p-2 bg-orange-100 rounded-lg\">\n                            <Icon className=\"w-5 h-5 text-orange-600\" />\n                          </div>\n                          <div className=\"flex-1\">\n                            <h4 className=\"font-semibold text-gray-900\">{challenge.name}</h4>\n                            <p className=\"text-sm text-gray-600 mt-1\">{challenge.description}</p>\n                            <div className=\"flex items-center gap-4 mt-2\">\n                              <Badge variant=\"outline\" className=\"text-xs\">\n                                Difficulty: {challenge.difficulty}/10\n                              </Badge>\n                              <Badge variant=\"outline\" className=\"text-xs\">\n                                ~{Math.round(challenge.estimatedTime / 60)} min\n                              </Badge>\n                            </div>\n                          </div>\n                        </div>\n                      </div>\n                    );\n                  })}\n                </div>\n\n                <DialogFooter>\n                  <Button variant=\"outline\" onClick={() => setShowPreview(false)}>\n                    Close Preview\n                  </Button>\n                  <Button\n                    className=\"bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600\"\n                    onClick={() => window.open(upgradeUrl, '_blank')}\n                  >\n                    <Crown className=\"w-4 h-4 mr-2\" />\n                    Get Premium\n                  </Button>\n                </DialogFooter>\n              </DialogContent>\n            </Dialog>\n          </div>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  return (\n    <Card className={cn('border-red-200 bg-gradient-to-r from-red-50 to-orange-50', className)}>\n      <CardHeader>\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center gap-2\">\n            <div className=\"p-2 bg-red-100 rounded-lg\">\n              <Zap className=\"w-6 h-6 text-red-600\" />\n            </div>\n            <div>\n              <CardTitle className=\"text-red-900 flex items-center gap-2\">\n                üí£ Nuclear Mode\n                <Badge variant=\"secondary\" className=\"bg-green-100 text-green-800\">\n                  <Crown className=\"w-3 h-3 mr-1\" />\n                  Premium Active\n                </Badge>\n              </CardTitle>\n              <CardDescription className=\"text-red-700\">\n                Extreme difficulty challenges that are nearly impossible to ignore\n              </CardDescription>\n            </div>\n          </div>\n          <Switch\n            checked={isEnabled}\n            onCheckedChange={onEnabledChange}\n            className=\"data-[state=checked]:bg-red-500\"\n          />\n        </div>\n      </CardHeader>\n\n      {isEnabled && (\n        <CardContent>\n          <Alert className=\"border-red-200 bg-red-50 mb-6\">\n            <AlertTriangle className=\"w-4 h-4 text-red-600\" />\n            <AlertDescription className=\"text-red-800\">\n              <strong>Warning:</strong> Nuclear Mode disables snoozing and requires completing all selected challenges\n              to dismiss the alarm. Choose your challenges carefully!\n            </AlertDescription>\n          </Alert>\n\n          {/* Difficulty Selector */}\n          <div className=\"space-y-4 mb-6\">\n            <div className=\"flex items-center justify-between\">\n              <Label className=\"text-sm font-semibold\">Difficulty Level</Label>\n              <Badge className={cn('text-white', difficultyInfo.color)}>\n                {difficultyInfo.label} ({customDifficulty}/10)\n              </Badge>\n            </div>\n            <Slider\n              value={[customDifficulty]}\n              onValueChange={value => onDifficultyChange(value[0])}\n              min={1}\n              max={10}\n              step={1}\n              className=\"w-full\"\n            />\n            <div className=\"flex justify-between text-xs text-gray-500\">\n              <span>Moderate</span>\n              <span>Extreme</span>\n              <span>NUCLEAR</span>\n            </div>\n          </div>\n\n          <Separator className=\"my-6\" />\n\n          {/* Challenge Selection */}\n          <div className=\"space-y-4\">\n            <div className=\"flex items-center justify-between\">\n              <Label className=\"text-sm font-semibold\">Select Challenges</Label>\n              <Badge variant=\"outline\">{selectedChallenges.length} selected</Badge>\n            </div>\n\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-3\">\n              {challengeTypes.map(challenge => {\n                const Icon = challengeIcons[challenge.type];\n                const isSelected = selectedChallenges.includes(challenge.type);\n\n                return (\n                  <div\n                    key={challenge.type}\n                    className={cn(\n                      'p-3 border rounded-lg cursor-pointer transition-all hover:shadow-md',\n                      isSelected\n                        ? 'border-red-200 bg-red-50 shadow-sm'\n                        : 'border-gray-200 bg-white hover:border-gray-300'\n                    )}\n                    onClick={() => handleChallengeToggle(challenge.type, !isSelected)}\n                  >\n                    <div className=\"flex items-start gap-3\">\n                      <Checkbox\n                        checked={isSelected}\n                        onCheckedChange={(checked) =>\n                          handleChallengeToggle(challenge.type, checked as boolean)\n                        }\n                        className=\"mt-1\"\n                      />\n                      <div className=\"flex-1\">\n                        <div className=\"flex items-center gap-2\">\n                          <Icon className={cn(\n                            'w-4 h-4',\n                            isSelected ? 'text-red-600' : 'text-gray-400'\n                          )} />\n                          <h4 className={cn(\n                            'font-medium text-sm',\n                            isSelected ? 'text-red-900' : 'text-gray-900'\n                          )}>\n                            {challenge.name}\n                          </h4>\n                        </div>\n                        <p className=\"text-xs text-gray-600 mt-1\">\n                          {challenge.description}\n                        </p>\n                        <div className=\"flex items-center gap-2 mt-2\">\n                          <Badge variant=\"outline\" className=\"text-xs\">\n                            Level {challenge.difficulty}\n                          </Badge>\n                          <Badge variant=\"outline\" className=\"text-xs\">\n                            ~{Math.round(challenge.estimatedTime / 60)}m\n                          </Badge>\n                        </div>\n                      </div>\n                    </div>\n                  </div>\n                );\n              })}\n            </div>\n\n            {selectedChallenges.length === 0 && (\n              <Alert className=\"border-yellow-200 bg-yellow-50\">\n                <AlertTriangle className=\"w-4 h-4 text-yellow-600\" />\n                <AlertDescription className=\"text-yellow-800\">\n                  Select at least one challenge to enable Nuclear Mode\n                </AlertDescription>\n              </Alert>\n            )}\n          </div>\n\n          {selectedChallenges.length > 0 && (\n            <>\n              <Separator className=\"my-6\" />\n\n              {/* Summary */}\n              <div className=\"bg-gray-50 p-4 rounded-lg space-y-3\">\n                <h4 className=\"font-semibold text-gray-900\">Nuclear Mode Summary</h4>\n                <div className=\"grid grid-cols-2 gap-4 text-sm\">\n                  <div>\n                    <span className=\"text-gray-600\">Challenges:</span>\n                    <span className=\"font-medium ml-2\">{selectedChallenges.length}</span>\n                  </div>\n                  <div>\n                    <span className=\"text-gray-600\">Est. Time:</span>\n                    <span className=\"font-medium ml-2\">{calculateEstimatedTime()}m</span>\n                  </div>\n                  <div>\n                    <span className=\"text-gray-600\">Difficulty:</span>\n                    <span className=\"font-medium ml-2\">{difficultyInfo.label}</span>\n                  </div>\n                  <div>\n                    <span className=\"text-gray-600\">Snooze:</span>\n                    <span className=\"font-medium ml-2 text-red-600\">Disabled</span>\n                  </div>\n                </div>\n\n                <div className=\"mt-3\">\n                  <div className=\"flex items-center justify-between mb-2\">\n                    <span className=\"text-xs text-gray-600\">Challenge Intensity</span>\n                    <span className=\"text-xs font-medium\">{customDifficulty}/10</span>\n                  </div>\n                  <Progress\n                    value={customDifficulty * 10}\n                    className=\"h-2\"\n                  />\n                </div>\n              </div>\n            </>\n          )}\n        </CardContent>\n      )}\n    </Card>\n  );\n};export default NuclearModeSelector;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/PremiumFeatureCard.tsx",
    "messages": [
      {
        "ruleId": null,
        "nodeType": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 368,
        "column": 0
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState } from 'react';\nimport {\n  Lock,\n  Crown,\n  Star,\n  Check,\n  ChevronRight,\n  Zap,\n  Info,\n  Eye,\n} from \"lucide-react\";\nimport UpgradePrompt from \"./UpgradePrompt\";\nimport { User } from \"../types\";\n\ninterface PremiumFeatureCardProps {\n  /** Feature information */\n  feature: {\n    id: string;\n    name: string;\n    description: string;\n    icon: React.ComponentType<any>;\n    benefits?: string[];\n    comingSoon?: boolean;\n  };\n  /** Current user */\n  user: User;\n  /** Whether user has access to this feature */\n  hasAccess: boolean;\n  /** Callback when feature is clicked */\n  onClick?: () => void;\n  /** Callback when upgrade is requested */\n  onUpgrade?: () => void;\n  /** Card variant */\n  variant?: 'default' | 'compact' | 'detailed';\n  /** Whether to show preview for locked features */\n  showPreview?: boolean;\n}\n\nconst PremiumFeatureCard: React.FC<PremiumFeatureCardProps> = ({\n  feature,\n  user,\n  hasAccess,\n  onClick,\n  onUpgrade,\n  variant = 'default',\n  showPreview = false\n}) => {\n  const [showUpgradeModal, setShowUpgradeModal] = useState(false);\n  const [isHovered, setIsHovered] = useState(false);\n\n  const getTierBadge = () => {\n    if (feature.tier === 'ultimate') {\n      return (\n        <div className=\"flex items-center gap-1 bg-gradient-to-r from-purple-500 to-pink-500 text-white px-2 py-1 rounded-full text-xs font-bold\">\n          <Star className=\"h-3 w-3\" />\n          ULTIMATE\n        </div>\n      );\n    } else if (feature.tier === 'premium') {\n      return (\n        <div className=\"flex items-center gap-1 bg-gradient-to-r from-orange-500 to-red-500 text-white px-2 py-1 rounded-full text-xs font-bold\">\n          <Crown className=\"h-3 w-3\" />\n          PREMIUM\n        </div>\n      );\n    }\n    return null;\n  };\n\n  const getTierColor = () => {\n    if (feature.tier === 'ultimate') {\n      return {\n        gradient: 'from-purple-500 to-pink-500',\n        border: 'border-purple-200',\n        bg: 'bg-purple-50',\n        text: 'text-purple-600'\n      };\n    } else if (feature.tier === 'premium') {\n      return {\n        gradient: 'from-orange-500 to-red-500',\n        border: 'border-orange-200',\n        bg: 'bg-orange-50',\n        text: 'text-orange-600'\n      };\n    }\n    return {\n      gradient: 'from-gray-500 to-gray-600',\n      border: 'border-gray-200',\n      bg: 'bg-gray-50',\n      text: 'text-gray-600'\n    };\n  };\n\n  const colors = getTierColor();\n  const Icon = feature.icon;\n\n  const handleClick = () => {\n    if (hasAccess && onClick) {\n      onClick();\n    } else if (!hasAccess) {\n      if (onUpgrade) {\n        onUpgrade(feature.tier);\n      } else {\n        setShowUpgradeModal(true);\n      }\n    }\n  };\n\n    setShowUpgradeModal(false);\n    if (onUpgrade) {\n      onUpgrade(tier);\n    } else {\n      // Default upgrade action - redirect to pricing\n      console.log(`Upgrading to ${tier}...`);\n    }\n  };\n\n  if (variant === 'compact') {\n    return (\n      <>\n        <div\n          className={`relative bg-white border-2 rounded-lg p-4 transition-all duration-300 cursor-pointer hover:shadow-md ${\n            hasAccess ? 'border-green-200 hover:border-green-300' : `${colors.border} hover:shadow-lg`\n          } ${isHovered && !hasAccess ? 'scale-105' : ''}`}\n          onClick={handleClick}\n          onMouseEnter={() => setIsHovered(true)}\n          onMouseLeave={() => setIsHovered(false)}\n        >\n          {!hasAccess && (\n            <div className=\"absolute top-2 right-2\">\n              <Lock className=\"h-4 w-4 text-gray-400\" />\n            </div>\n          )}\n\n          <div className=\"flex items-center gap-3\">\n            <div className={`w-10 h-10 rounded-full flex items-center justify-center ${\n              hasAccess ? 'bg-green-100 text-green-600' : `${colors.bg} ${colors.text}`\n            }`}>\n              <Icon className=\"h-5 w-5\" />\n            </div>\n\n            <div className=\"flex-1\">\n              <h3 className=\"font-semibold text-gray-900 text-sm\">{feature.name}</h3>\n              <p className=\"text-xs text-gray-600 line-clamp-1\">{feature.description}</p>\n            </div>\n\n            {hasAccess ? (\n              <Check className=\"h-5 w-5 text-green-500\" />\n            ) : (\n              <ChevronRight className=\"h-4 w-4 text-gray-400\" />\n            )}\n          </div>\n        </div>\n\n        {showUpgradeModal && (\n          <UpgradePrompt\n            feature={feature.id}\n            onUpgrade={handleUpgrade}\n            onDismiss={() => setShowUpgradeModal(false)}\n          />\n        )}\n      </>\n    );\n  }\n\n  if (variant === 'detailed') {\n    return (\n      <>\n        <div\n          className={`relative bg-white border-2 rounded-xl p-6 transition-all duration-300 ${\n            hasAccess\n              ? 'border-green-200'\n              : `${colors.border} hover:shadow-lg cursor-pointer`\n          } ${isHovered && !hasAccess ? 'transform scale-105' : ''}`}\n          onClick={!hasAccess ? handleClick : undefined}\n          onMouseEnter={() => setIsHovered(true)}\n          onMouseLeave={() => setIsHovered(false)}\n        >\n          {/* Status indicators */}\n          <div className=\"absolute top-4 right-4 flex items-center gap-2\">\n            {feature.comingSoon && (\n              <div className=\"bg-blue-100 text-blue-600 px-2 py-1 rounded-full text-xs font-medium\">\n                Coming Soon\n              </div>\n            )}\n            {getTierBadge()}\n            {!hasAccess && <Lock className=\"h-4 w-4 text-gray-400\" />}\n            {hasAccess && <Check className=\"h-5 w-5 text-green-500\" />}\n          </div>\n\n          <div className=\"mb-4\">\n            <div className={`w-16 h-16 rounded-full flex items-center justify-center mb-4 ${\n              hasAccess ? 'bg-green-100 text-green-600' : `${colors.bg} ${colors.text}`\n            }`}>\n              <Icon className=\"h-8 w-8\" />\n            </div>\n\n            <h3 className=\"text-xl font-bold text-gray-900 mb-2\">{feature.name}</h3>\n            <p className=\"text-gray-600 mb-4\">{feature.description}</p>\n\n            {feature.benefits && feature.benefits.length > 0 && (\n              <div className=\"space-y-2 mb-4\">\n                {feature.benefits.slice(0, 4).map((benefit, index) => (\n                  <div key={index} className=\"flex items-center gap-2 text-sm text-gray-700\">\n                    <div className=\"bg-green-100 text-green-600 p-0.5 rounded-full\">\n                      <Check className=\"h-3 w-3\" />\n                    </div>\n                    {benefit}\n                  </div>\n                ))}\n                {feature.benefits.length > 4 && (\n                  <div className=\"text-sm text-gray-500\">\n                    +{feature.benefits.length - 4} more benefits\n                  </div>\n                )}\n              </div>\n            )}\n          </div>\n\n          {/* Action area */}\n          <div className=\"border-t pt-4\">\n            {hasAccess ? (\n              <button\n                onClick={onClick}\n                className=\"w-full bg-green-500 text-white py-3 px-4 rounded-lg font-medium hover:bg-green-600 transition-colors flex items-center justify-center gap-2\"\n              >\n                <Zap className=\"h-4 w-4\" />\n                Use Feature\n              </button>\n            ) : feature.comingSoon ? (\n              <button\n                disabled\n                className=\"w-full bg-gray-100 text-gray-500 py-3 px-4 rounded-lg font-medium cursor-not-allowed\"\n              >\n                Coming Soon\n              </button>\n            ) : (\n              <div className=\"space-y-2\">\n                {showPreview && (\n                  <button\n                    onClick={e => {\n                      e.stopPropagation();\n                      // Show preview functionality\n                      console.log(`Showing preview for ${feature.name}`);\n                    }}\n                    className=\"w-full bg-gray-100 text-gray-700 py-2 px-4 rounded-lg font-medium hover:bg-gray-200 transition-colors flex items-center justify-center gap-2 text-sm\"\n                  >\n                    <Eye className=\"h-4 w-4\" />\n                    Preview Feature\n                  </button>\n                )}\n                <button\n                  onClick={handleClick}\n                  className={`w-full bg-gradient-to-r ${colors.gradient} text-white py-3 px-4 rounded-lg font-medium hover:shadow-lg transition-all duration-200 flex items-center justify-center gap-2`}\n                >\n                  {feature.tier === 'ultimate' ? <Star className=\"h-4 w-4\" /> : <Crown className=\"h-4 w-4\" />}\n                  Unlock with {feature.tier === 'ultimate' ? 'Ultimate' : 'Premium'}\n                </button>\n              </div>\n            )}\n          </div>\n        </div>\n\n        {showUpgradeModal && (\n          <UpgradePrompt\n            feature={feature.id}\n            onUpgrade={handleUpgrade}\n            onDismiss={() => setShowUpgradeModal(false)}\n          />\n        )}\n      </>\n    );\n  }\n\n  // Default variant\n  return (\n    <>\n      <div\n        className={`relative bg-white border-2 rounded-xl p-6 transition-all duration-300 ${\n          hasAccess\n            ? 'border-green-200'\n            : `${colors.border} hover:shadow-lg cursor-pointer`\n        } ${isHovered && !hasAccess ? 'transform scale-105' : ''}`}\n        onClick={!hasAccess ? handleClick : undefined}\n        onMouseEnter={() => setIsHovered(true)}\n        onMouseLeave={() => setIsHovered(false)}\n      >\n        {/* Header */}\n        <div className=\"flex items-start justify-between mb-4\">\n          <div className={`w-12 h-12 rounded-full flex items-center justify-center ${\n            hasAccess ? 'bg-green-100 text-green-600' : `${colors.bg} ${colors.text}`\n          }`}>\n            <Icon className=\"h-6 w-6\" />\n          </div>\n\n          <div className=\"flex items-center gap-2\">\n            {feature.comingSoon && (\n              <div className=\"bg-blue-100 text-blue-600 px-2 py-1 rounded-full text-xs font-medium\">\n                Coming Soon\n              </div>\n            )}\n            {getTierBadge()}\n            {!hasAccess && <Lock className=\"h-4 w-4 text-gray-400\" />}\n            {hasAccess && <Check className=\"h-5 w-5 text-green-500\" />}\n          </div>\n        </div>\n\n        {/* Content */}\n        <div className=\"mb-4\">\n          <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">{feature.name}</h3>\n          <p className=\"text-gray-600 text-sm\">{feature.description}</p>\n        </div>\n\n        {/* Benefits preview */}\n        {feature.benefits && feature.benefits.length > 0 && (\n          <div className=\"space-y-1 mb-4\">\n            {feature.benefits.slice(0, 2).map((benefit, index) => (\n              <div key={index} className=\"flex items-center gap-2 text-xs text-gray-600\">\n                <div className=\"bg-green-100 text-green-600 p-0.5 rounded-full\">\n                  <Check className=\"h-2.5 w-2.5\" />\n                </div>\n                {benefit}\n              </div>\n            ))}\n            {feature.benefits.length > 2 && (\n              <div className=\"text-xs text-gray-500\">\n                +{feature.benefits.length - 2} more\n              </div>\n            )}\n          </div>\n        )}\n\n        {/* Action button */}\n        <div className=\"pt-4 border-t\">\n          {hasAccess ? (\n            <button\n              onClick={onClick}\n              className=\"w-full bg-green-500 text-white py-2 px-4 rounded-lg font-medium hover:bg-green-600 transition-colors flex items-center justify-center gap-2 text-sm\"\n            >\n              <Zap className=\"h-4 w-4\" />\n              Use Feature\n            </button>\n          ) : feature.comingSoon ? (\n            <div className=\"w-full text-center py-2 text-gray-500 text-sm\">\n              Coming Soon\n            </div>\n          ) : (\n            <button\n              onClick={handleClick}\n              className={`w-full bg-gradient-to-r ${colors.gradient} text-white py-2 px-4 rounded-lg font-medium hover:shadow-lg transition-all duration-200 flex items-center justify-center gap-2 text-sm`}\n            >\n              {feature.tier === 'ultimate' ? <Star className=\"h-4 w-4\" /> : <Crown className=\"h-4 w-4\" />}\n              Upgrade to Unlock\n            </button>\n          )}\n        </div>\n      </div>\n\n      {showUpgradeModal && (\n        <UpgradePrompt\n          feature={feature.id}\n          onUpgrade={handleUpgrade}\n          onDismiss={() => setShowUpgradeModal(false)}\n        />\n      )}\n    </>\n  );\n};\n\nexport default PremiumFeatureCard;\n\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/PremiumFeatureTest.tsx",
    "messages": [
      {
        "ruleId": null,
        "nodeType": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 600,
        "column": 0
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from './ui/card';\nimport { Button } from './ui/button';\nimport { Badge } from './ui/badge';\nimport { Alert, AlertDescription } from './ui/alert';\nimport { Tabs, TabsList, TabsTrigger, TabsContent } from './ui/tabs';\nimport {\n  Check,\n  X,\n  Crown,\n  Star,\n  Zap,\n  Volume2,\n  Target,\n  Mic,\n  AlertCircle,\n  TestTube,\n  RefreshCw,\n  Shield,\n  Lock,\n  Unlock,\n} from \"lucide-react\";\nimport { cn } from \"../lib/utils\";\nimport { PremiumService } from \"../services/premium\";\nimport { premiumVoiceService } from \"../services/premium-voice\";\nimport { nuclearModeService } from \"../services/nuclear-mode\";\nimport { UpgradePrompt } from \"./UpgradePrompt\";\nimport { PremiumFeatureCard } from \"./PremiumFeatureCard\";\nimport { SubscriptionStatus } from \"./SubscriptionStatus\";\nimport { FeatureLockOverlay } from \"./FeatureLockOverlay\";\nimport { VoiceSelector } from \"./VoiceSelector\";\nimport { VoiceCloning } from \"./VoiceCloning\";\n\ninterface PremiumFeatureTestProps {\n  user: User;\n  className?: string;\n}\n\ninterface TestResult {\n  name: string;\n  description: string;\n  status: 'pass' | 'fail' | 'pending';\n  details?: string;\n  error?: string;\n}\n\ninterface TestSuite {\n  name: string;\n  tests: TestResult[];\n}\n\nexport const PremiumFeatureTest: React.FC<PremiumFeatureTestProps> = ({ user, className }) => {\n  const [testResults, setTestResults] = useState<TestSuite[]>([]);\n  const [isRunning, setIsRunning] = useState(false);\n\n  useEffect(() => {\n    loadCurrentTier();\n  }, [user.id]);\n\n  const loadCurrentTier = async () => {\n    try {\n      const tier = await PremiumService.getUserTier(user.id);\n      setCurrentTier(tier);\n      setTestTier(tier);\n    } catch (error) {\n      console.error('Error loading current tier:', error);\n    }\n  };\n\n  const runTests = async () => {\n    setIsRunning(true);\n    const suites: TestSuite[] = [];\n\n    try {\n      // Test 1: Premium Service Core Functionality\n      const premiumServiceSuite: TestSuite = {\n        name: 'Premium Service Core',\n        tests: []\n      };\n\n      // Test getUserTier\n      try {\n        const tier = await PremiumService.getUserTier(user.id);\n        premiumServiceSuite.tests.push({\n          name: 'Get User Tier',\n          description: 'Verify premium service can retrieve user subscription tier',\n          status: ['free', 'premium', 'ultimate'].includes(tier) ? 'pass' : 'fail',\n          details: `Current tier: ${tier}`\n        });\n      } catch (error) {\n        premiumServiceSuite.tests.push({\n          name: 'Get User Tier',\n          description: 'Verify premium service can retrieve user subscription tier',\n          status: 'fail',\n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n\n      // Test feature access for each tier\n      const features = ['nuclear_mode', 'custom_voices', 'extra_personalities', 'voice_cloning'];\n      for (const feature of features) {\n        try {\n          const result = await PremiumService.checkFeatureAccess(user.id, feature as any);\n          premiumServiceSuite.tests.push({\n            name: `Feature Access: ${feature}`,\n            description: `Check if user has access to ${feature}`,\n            status: result.hasAccess !== undefined ? 'pass' : 'fail',\n            details: `Access: ${result.hasAccess}, Tier: ${result.userTier}, Required: ${result.requiredTier || 'N/A'}`\n          });\n        } catch (error) {\n          premiumServiceSuite.tests.push({\n            name: `Feature Access: ${feature}`,\n            description: `Check if user has access to ${feature}`,\n            status: 'fail',\n            error: error instanceof Error ? error.message : String(error)\n          });\n        }\n      }\n\n      // Test subscription status\n      try {\n        const status = await PremiumService.getSubscriptionStatus(user.id);\n        premiumServiceSuite.tests.push({\n          name: 'Subscription Status',\n          description: 'Retrieve detailed subscription information',\n          status: status && typeof status === 'object' ? 'pass' : 'fail',\n          details: status ? `Status: ${status.status || 'N/A'}` : 'No status data'\n        });\n      } catch (error) {\n        premiumServiceSuite.tests.push({\n          name: 'Subscription Status',\n          description: 'Retrieve detailed subscription information',\n          status: 'fail',\n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n\n      suites.push(premiumServiceSuite);\n\n      // Test 2: Nuclear Mode Integration\n      const nuclearModeSuite: TestSuite = {\n        name: 'Nuclear Mode Features',\n        tests: []\n      };\n\n      // Test nuclear mode access check\n      try {\n        const access = await nuclearModeService.canAccessNuclearMode(user.id);\n        nuclearModeSuite.tests.push({\n          name: 'Nuclear Mode Access Check',\n          description: 'Verify nuclear mode access validation',\n          status: access && typeof access.hasAccess === 'boolean' ? 'pass' : 'fail',\n          details: `Access: ${access.hasAccess}, Tier: ${access.userTier}`\n        });\n      } catch (error) {\n        nuclearModeSuite.tests.push({\n          name: 'Nuclear Mode Access Check',\n          description: 'Verify nuclear mode access validation',\n          status: 'fail',\n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n\n      // Test challenge types availability\n      try {\n        const challengeTypes = nuclearModeService.getChallengeTypes();\n        nuclearModeSuite.tests.push({\n          name: 'Challenge Types',\n          description: 'Verify nuclear mode challenge types are available',\n          status: Array.isArray(challengeTypes) && challengeTypes.length > 0 ? 'pass' : 'fail',\n          details: `Found ${challengeTypes.length} challenge types`\n        });\n      } catch (error) {\n        nuclearModeSuite.tests.push({\n          name: 'Challenge Types',\n          description: 'Verify nuclear mode challenge types are available',\n          status: 'fail',\n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n\n      suites.push(nuclearModeSuite);\n\n      // Test 3: Premium Voice System\n      const voiceSystemSuite: TestSuite = {\n        name: 'Premium Voice System',\n        tests: []\n      };\n\n      // Test voice personalities\n      try {\n        const personalities = premiumVoiceService.getAvailablePersonalities();\n        voiceSystemSuite.tests.push({\n          name: 'Voice Personalities',\n          description: 'Verify premium voice personalities are loaded',\n          status: Array.isArray(personalities) && personalities.length > 0 ? 'pass' : 'fail',\n          details: `Found ${personalities.length} personalities`\n        });\n      } catch (error) {\n        voiceSystemSuite.tests.push({\n          name: 'Voice Personalities',\n          description: 'Verify premium voice personalities are loaded',\n          status: 'fail',\n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n\n      // Test voice access for different tiers\n      const voiceIds = ['celebrity-chef', 'zen-master', 'robot-companion'];\n      for (const voiceId of voiceIds) {\n        try {\n          const hasAccess = await premiumVoiceService.hasVoiceAccess(user.id, voiceId);\n          voiceSystemSuite.tests.push({\n            name: `Voice Access: ${voiceId}`,\n            description: `Check access to premium voice ${voiceId}`,\n            status: typeof hasAccess === 'boolean' ? 'pass' : 'fail',\n            details: `Access: ${hasAccess}`\n          });\n        } catch (error) {\n          voiceSystemSuite.tests.push({\n            name: `Voice Access: ${voiceId}`,\n            description: `Check access to premium voice ${voiceId}`,\n            status: 'fail',\n            error: error instanceof Error ? error.message : String(error)\n          });\n        }\n      }\n\n      // Test voice cloning availability\n      try {\n        const canClone = await premiumVoiceService.canUseVoiceCloning(user.id);\n        voiceSystemSuite.tests.push({\n          name: 'Voice Cloning Access',\n          description: 'Check if user can access voice cloning (Ultimate tier)',\n          status: typeof canClone === 'boolean' ? 'pass' : 'fail',\n          details: `Can clone: ${canClone}`\n        });\n      } catch (error) {\n        voiceSystemSuite.tests.push({\n          name: 'Voice Cloning Access',\n          description: 'Check if user can access voice cloning (Ultimate tier)',\n          status: 'fail',\n          error: error instanceof Error ? error.message : String(error)\n        });\n      }\n\n      suites.push(voiceSystemSuite);\n\n      // Test 4: UI Components\n      const uiComponentsSuite: TestSuite = {\n        name: 'Premium UI Components',\n        tests: []\n      };\n\n      // Test component rendering (these will always pass if no errors thrown)\n      const componentTests = [\n        { name: 'UpgradePrompt', description: 'Verify upgrade prompt component renders' },\n        { name: 'PremiumFeatureCard', description: 'Verify premium feature card component renders' },\n        { name: 'SubscriptionStatus', description: 'Verify subscription status component renders' },\n        { name: 'FeatureLockOverlay', description: 'Verify feature lock overlay component renders' }\n      ];\n\n      componentTests.forEach(test => {\n        uiComponentsSuite.tests.push({\n          name: test.name,\n          description: test.description,\n          status: 'pass', // If we get here, components loaded successfully\n          details: 'Component imported and available'\n        });\n      });\n\n      suites.push(uiComponentsSuite);\n\n      setTestResults(suites);\n\n    } catch (error) {\n      console.error('Error running tests:', error);\n      setTestResults([{\n        name: 'Test Suite Error',\n        tests: [{\n          name: 'Test Execution',\n          description: 'Failed to execute test suite',\n          status: 'fail',\n          error: error instanceof Error ? error.message : String(error)\n        }]\n      }]);\n    } finally {\n      setIsRunning(false);\n    }\n  };\n\n    try {\n      await PremiumService.updateUserTier(user.id, tier);\n      setTestTier(tier);\n      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for update\n    } catch (error) {\n      console.error('Error changing tier:', error);\n    }\n  };\n\n  const resetToOriginalTier = async () => {\n    try {\n      await PremiumService.updateUserTier(user.id, currentTier);\n      setTestTier(currentTier);\n    } catch (error) {\n      console.error('Error resetting tier:', error);\n    }\n  };\n\n  const getTestSummary = () => {\n    const totalTests = testResults.reduce((sum, suite) => sum + suite.tests.length, 0);\n    const passedTests = testResults.reduce((sum, suite) =>\n      sum + suite.tests.filter(test => test.status === 'pass').length, 0\n    );\n    const failedTests = testResults.reduce((sum, suite) =>\n      sum + suite.tests.filter(test => test.status === 'fail').length, 0\n    );\n\n    return { totalTests, passedTests, failedTests };\n  };\n\n  const { totalTests, passedTests, failedTests } = getTestSummary();\n\n  return (\n    <div className={cn('max-w-6xl mx-auto p-6 space-y-6', className)}>\n      {/* Header */}\n      <div className=\"text-center space-y-4\">\n        <h1 className=\"text-3xl font-bold text-gray-900 flex items-center justify-center gap-3\">\n          <TestTube className=\"w-8 h-8 text-blue-600\" />\n          Premium Features Test Suite\n        </h1>\n        <p className=\"text-gray-600 max-w-2xl mx-auto\">\n          Comprehensive testing of premium subscription features, access controls, and user experience components.\n        </p>\n\n        {/* Current Status */}\n        <div className=\"flex items-center justify-center gap-6\">\n          <Badge variant=\"outline\" className=\"px-4 py-2\">\n            Original Tier: {currentTier.toUpperCase()}\n          </Badge>\n          <Badge variant=\"secondary\" className=\"px-4 py-2\">\n            Test Tier: {testTier.toUpperCase()}\n          </Badge>\n          {totalTests > 0 && (\n            <Badge\n              className={cn(\n                'px-4 py-2',\n                failedTests === 0 ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'\n              )}\n            >\n              {passedTests}/{totalTests} Tests Passed\n            </Badge>\n          )}\n        </div>\n      </div>\n\n      {/* Test Controls */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Shield className=\"w-5 h-5\" />\n            Test Controls\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"flex items-center gap-4\">\n            <Button\n              onClick={runTests}\n              disabled={isRunning}\n              className=\"flex items-center gap-2\"\n            >\n              {isRunning ? (\n                <>\n                  <RefreshCw className=\"w-4 h-4 animate-spin\" />\n                  Running Tests...\n                </>\n              ) : (\n                <>\n                  <TestTube className=\"w-4 h-4\" />\n                  Run All Tests\n                </>\n              )}\n            </Button>\n\n            <Button\n              onClick={resetToOriginalTier}\n              variant=\"outline\"\n              disabled={testTier === currentTier}\n            >\n              Reset to Original Tier\n            </Button>\n          </div>\n\n          {/* Tier Testing */}\n          <div className=\"space-y-2\">\n            <h4 className=\"font-medium text-sm\">Test Different Subscription Tiers:</h4>\n            <div className=\"flex gap-2\">\n              {[\"free\", \"premium\", \"ultimate\"].map((tier) => (\n                  <Button\n                    key={tier}\n                    onClick={() => changeTierForTesting(tier)}\n                    variant={testTier === tier ? \"default\" : \"outline\"}\n                    size=\"sm\"\n                    className=\"flex items-center gap-2\"\n                  >\n                    {tier === \"free\" && <Shield className=\"w-3 h-3\" />}\n                    {tier === \"premium\" && <Crown className=\"w-3 h-3\" />}\n                    {tier === \"ultimate\" && <Star className=\"w-3 h-3\" />}\n                    {tier.charAt(0).toUpperCase() + tier.slice(1)}\n                  </Button>\n                ),\n              )}\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Test Results */}\n      {testResults.length > 0 && (\n        <Tabs defaultValue=\"results\" className=\"w-full\">\n          <TabsList className=\"grid w-full grid-cols-3\">\n            <TabsTrigger value=\"results\">Test Results</TabsTrigger>\n            <TabsTrigger value=\"components\">Component Demo</TabsTrigger>\n            <TabsTrigger value=\"integration\">Integration Test</TabsTrigger>\n          </TabsList>\n\n          <TabsContent value=\"results\" className=\"space-y-4\">\n            {testResults.map((suite, suiteIndex) => (\n              <Card key={suiteIndex}>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center justify-between\">\n                    <span>{suite.name}</span>\n                    <Badge\n                      className={cn(\n                        suite.tests.every(t => t.status === 'pass')\n                          ? 'bg-green-100 text-green-800'\n                          : suite.tests.some(t => t.status === 'fail')\n                          ? 'bg-red-100 text-red-800'\n                          : 'bg-yellow-100 text-yellow-800'\n                      )}\n                    >\n                      {suite.tests.filter(t => t.status === 'pass').length}/{suite.tests.length}\n                    </Badge>\n                  </CardTitle>\n                </CardHeader>\n                <CardContent>\n                  <div className=\"space-y-3\">\n                    {suite.tests.map((test, testIndex) => (\n                      <div key={testIndex} className=\"flex items-start gap-3 p-3 rounded-lg border\">\n                        <div className=\"mt-0.5\">\n                          {test.status === 'pass' && <Check className=\"w-5 h-5 text-green-500\" />}\n                          {test.status === 'fail' && <X className=\"w-5 h-5 text-red-500\" />}\n                          {test.status === 'pending' && <AlertCircle className=\"w-5 h-5 text-yellow-500\" />}\n                        </div>\n                        <div className=\"flex-1 min-w-0\">\n                          <h4 className=\"font-medium text-sm\">{test.name}</h4>\n                          <p className=\"text-xs text-gray-600 mt-1\">{test.description}</p>\n                          {test.details && (\n                            <p className=\"text-xs text-blue-600 mt-1\">{test.details}</p>\n                          )}\n                          {test.error && (\n                            <p className=\"text-xs text-red-600 mt-1 font-mono\">{test.error}</p>\n                          )}\n                        </div>\n                      </div>\n                    ))}\n                  </div>\n                </CardContent>\n              </Card>\n            ))}\n          </TabsContent>\n\n          <TabsContent value=\"components\" className=\"space-y-6\">\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n              {/* Upgrade Prompt Demo */}\n              <div className=\"space-y-4\">\n                <h3 className=\"text-lg font-semibold\">Upgrade Prompt</h3>\n                <UpgradePrompt\n                  feature=\"nuclear_mode\"\n                  variant=\"modal\"\n                  requiredTier=\"premium\"\n                  onUpgrade={(tier) => console.log('Upgrade to:', tier)}\n                />\n              </div>\n\n              {/* Premium Feature Card Demo */}\n              <div className=\"space-y-4\">\n                <h3 className=\"text-lg font-semibold\">Premium Feature Card</h3>\n                <PremiumFeatureCard\n                  title=\"Nuclear Mode\"\n                  description=\"Extreme difficulty challenges\"\n                  requiredTier=\"premium\"\n                  currentTier={testTier}\n                  icon={<Zap className=\"w-6 h-6\" />}\n                  onUpgrade={() => console.log('Upgrade clicked')}\n                />\n              </div>\n\n              {/* Subscription Status Demo */}\n              <div className=\"space-y-4\">\n                <h3 className=\"text-lg font-semibold\">Subscription Status</h3>\n                <SubscriptionStatus\n                  subscription={{\n                    tier: testTier,\n                    status: 'active',\n                    renewsAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(),\n                    usage: {\n                      alarms: { used: 5, limit: testTier === 'free' ? 10 : -1 },\n                      voices: { used: 3, limit: testTier === 'free' ? 6 : -1 }\n                    }\n                  }}\n                  variant=\"card\"\n                />\n              </div>\n\n              {/* Feature Lock Overlay Demo */}\n              <div className=\"space-y-4\">\n                <h3 className=\"text-lg font-semibold\">Feature Lock Overlay</h3>\n                <FeatureLockOverlay\n                  feature=\"voice_cloning\"\n                  requiredTier=\"ultimate\"\n                  currentTier={testTier}\n                  variant=\"card\"\n                  onUpgrade={() => console.log('Upgrade from overlay')}\n                >\n                  <div className=\"p-6 bg-gray-100 rounded-lg\">\n                    <h4 className=\"font-medium\">Voice Cloning Feature</h4>\n                    <p className=\"text-sm text-gray-600\">This feature is locked for demo purposes</p>\n                  </div>\n                </FeatureLockOverlay>\n              </div>\n            </div>\n          </TabsContent>\n\n          <TabsContent value=\"integration\" className=\"space-y-6\">\n            <Alert>\n              <AlertCircle className=\"w-4 h-4\" />\n              <AlertDescription>\n                This tab demonstrates real integration of premium features with actual components.\n                Change the test tier above to see how features are locked/unlocked.\n              </AlertDescription>\n            </Alert>\n\n            {/* Voice Selector Integration */}\n            <Card>\n              <CardHeader>\n                <CardTitle>Voice Selector Integration</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <VoiceSelector\n                  currentVoice=\"gentle\"\n                  onVoiceChange={(voice) => console.log('Voice changed to:', voice)}\n                  userId={user.id}\n                  className=\"max-w-md\"\n                />\n              </CardContent>\n            </Card>\n\n            {/* Voice Cloning Integration (Ultimate only) */}\n            {testTier === 'ultimate' ? (\n              <Card>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2\">\n                    <Unlock className=\"w-5 h-5 text-green-500\" />\n                    Voice Cloning (Ultimate Feature)\n                  </CardTitle>\n                </CardHeader>\n                <CardContent>\n                  <VoiceCloning\n                    userId={user.id}\n                    onVoiceCreated={(voice) => console.log('Voice created:', voice)}\n                  />\n                </CardContent>\n              </Card>\n            ) : (\n              <Card>\n                <CardHeader>\n                  <CardTitle className=\"flex items-center gap-2\">\n                    <Lock className=\"w-5 h-5 text-red-500\" />\n                    Voice Cloning (Locked)\n                  </CardTitle>\n                </CardHeader>\n                <CardContent>\n                  <div className=\"text-center py-8\">\n                    <Crown className=\"w-12 h-12 text-purple-500 mx-auto mb-4\" />\n                    <h3 className=\"text-lg font-semibold mb-2\">Ultimate Feature Required</h3>\n                    <p className=\"text-gray-600 mb-4\">Voice cloning is available for Ultimate subscribers</p>\n                    <Button onClick={() => changeTierForTesting('ultimate')}>\n                      Test Ultimate Tier\n                    </Button>\n                  </div>\n                </CardContent>\n              </Card>\n            )}\n          </TabsContent>\n        </Tabs>\n      )}\n    </div>\n  );\n};\n\nexport default PremiumFeatureTest;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/PremiumGate.tsx",
    "messages": [
      {
        "ruleId": null,
        "nodeType": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 342,
        "column": 0
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect, ReactNode } from \"react\";\nimport { motion, AnimatePresence } from \"framer-motion\";\nimport { Lock, Crown, Sparkles, Star, ArrowUp } from \"lucide-react\";\nimport { SubscriptionService } from \"../services/subscription\";\nimport { SubscriptionModal } from \"./SubscriptionModal\";\n\ninterface PremiumGateProps {\n  feature: keyof PremiumFeatureAccess;\n  userId: string;\n  children: ReactNode;\n  fallback?: ReactNode;\n  showPreview?: boolean;\n  title?: string;\n  description?: string;\n  className?: string;\n  mode?: 'block' | 'overlay' | 'replace';\n}\n\ninterface PremiumGateState {\n  hasAccess: boolean;\n  loading: boolean;\n  isModalOpen: boolean;\n}\n\nexport const PremiumGate: React.FC<PremiumGateProps> = ({\n  feature,\n  userId,\n  children,\n  fallback,\n  showPreview = false,\n  title,\n  description,\n  className = '',\n  mode = 'block'\n}) => {\n  const [state, setState] = useState<PremiumGateState>({\n    hasAccess: false,\n    loading: true,\n    tier: 'free',\n    isModalOpen: false\n  });\n\n  useEffect(() => {\n    checkAccess();\n  }, [userId, feature]);\n\n  const checkAccess = async () => {\n    setState(prev => ({ ...prev, loading: true }));\n\n    try {\n      const [hasAccess, tier] = await Promise.all([\n        SubscriptionService.hasFeatureAccess(userId, feature),\n        SubscriptionService.getUserTier(userId)\n      ]);\n\n      setState(prev => ({\n        ...prev,\n        hasAccess,\n        tier,\n        loading: false\n      }));\n    } catch (error) {\n      console.error('Error checking premium access:', error);\n      setState(prev => ({ ...prev, loading: false }));\n    }\n  };\n\n  const handleUpgrade = () => {\n    setState(prev => ({ ...prev, isModalOpen: true }));\n  };\n\n  const handleModalClose = () => {\n    setState(prev => ({ ...prev, isModalOpen: false }));\n  };\n\n  if (state.loading) {\n    return (\n      <div className=\"flex items-center justify-center p-4\">\n        <div className=\"animate-pulse flex items-center space-x-2\">\n          <Crown className=\"w-4 h-4 text-amber-500\" />\n          <span className=\"text-sm text-gray-500\">Checking access...</span>\n        </div>\n      </div>\n    );\n  }\n\n  if (state.hasAccess) {\n    return <>{children}</>;\n  }\n\n  // User doesn't have access - show upgrade prompt\n  const getFeatureTitle = () => {\n    if (title) return title;\n\n    const featureTitles: Record<keyof PremiumFeatureAccess, string> = {\n      elevenlabsVoices: 'Premium Voices',\n      customVoiceMessages: 'Custom Voice Messages',\n      voiceCloning: 'Voice Cloning',\n      advancedAIInsights: 'Advanced AI Insights',\n      personalizedChallenges: 'Personalized Challenges',\n      smartRecommendations: 'Smart Recommendations',\n      behaviorAnalysis: 'Behavior Analysis',\n      premiumThemes: 'Premium Themes',\n      customSounds: 'Custom Sounds',\n      advancedPersonalization: 'Advanced Personalization',\n      unlimitedCustomization: 'Unlimited Customization',\n      advancedScheduling: 'Advanced Scheduling',\n      smartScheduling: 'Smart Scheduling',\n      locationBasedAlarms: 'Location-Based Alarms',\n      weatherIntegration: 'Weather Integration',\n      exclusiveBattleModes: 'Exclusive Battle Modes',\n      customBattleRules: 'Custom Battle Rules',\n      advancedStats: 'Advanced Statistics',\n      leaderboardFeatures: 'Leaderboard Features',\n      premiumSoundLibrary: 'Premium Sound Library',\n      exclusiveContent: 'Exclusive Content',\n      adFree: 'Ad-Free Experience',\n      prioritySupport: 'Priority Support',\n      nuclearMode: 'Nuclear Mode',\n      premiumPersonalities: 'Premium Voice Personalities'\n    };\n\n    return featureTitles[feature] || 'Premium Feature';\n  };\n\n  const getFeatureDescription = () => {\n    if (description) return description;\n\n    const featureDescriptions: Record<keyof PremiumFeatureAccess, string> = {\n      elevenlabsVoices: 'Get access to ultra-realistic AI voices powered by ElevenLabs',\n      customVoiceMessages: 'Create personalized voice messages for your alarms',\n      voiceCloning: 'Clone your own voice for ultimate personalization',\n      advancedAIInsights: 'Get deeper insights into your sleep patterns and habits',\n      personalizedChallenges: 'Receive AI-generated challenges tailored to your goals',\n      smartRecommendations: 'Get intelligent recommendations to improve your routine',\n      behaviorAnalysis: 'Analyze your behavior patterns with advanced AI',\n      premiumThemes: 'Access exclusive, beautifully designed themes',\n      customSounds: 'Upload and use your own custom alarm sounds',\n      advancedPersonalization: 'Unlock advanced customization options',\n      unlimitedCustomization: 'Remove all limits on customization features',\n      advancedScheduling: 'Set up complex alarm schedules with multiple conditions',\n      smartScheduling: 'Let AI optimize your alarm schedule automatically',\n      locationBasedAlarms: 'Set alarms that trigger based on your location',\n      weatherIntegration: 'Adjust alarms based on weather conditions',\n      exclusiveBattleModes: 'Access special battle modes and challenges',\n      customBattleRules: 'Create your own battle rules and challenges',\n      advancedStats: 'View detailed statistics and performance metrics',\n      leaderboardFeatures: 'Compete on exclusive premium leaderboards',\n      premiumSoundLibrary: 'Access hundreds of high-quality alarm sounds',\n      exclusiveContent: 'Get access to premium content and features',\n      adFree: 'Enjoy the app without any advertisements',\n      prioritySupport: 'Get priority customer support and faster responses',\n      nuclearMode: 'Access the ultimate extreme difficulty with nuclear-level challenges',\n      premiumPersonalities: 'Unlock 4 exclusive premium voice personalities including demon-lord, ai-robot, comedian, and philosopher'\n    };\n\n    return featureDescriptions[feature] || 'Unlock this premium feature to enhance your experience';\n  };\n\n    // Define which tier is required for each feature\n    const tierRequirements: Record<\n      keyof PremiumFeatureAccess,\n    > = {\n      elevenlabsVoices: \"premium\",\n      customVoiceMessages: \"premium\",\n      voiceCloning: \"pro\",\n      advancedAIInsights: \"premium\",\n      personalizedChallenges: \"premium\",\n      smartRecommendations: \"premium\",\n      behaviorAnalysis: \"premium\",\n      premiumThemes: \"premium\",\n      customSounds: \"premium\",\n      advancedPersonalization: \"premium\",\n      unlimitedCustomization: \"pro\",\n      advancedScheduling: \"premium\",\n      smartScheduling: \"pro\",\n      locationBasedAlarms: \"premium\",\n      weatherIntegration: \"premium\",\n      exclusiveBattleModes: \"premium\",\n      customBattleRules: \"pro\",\n      advancedStats: \"premium\",\n      leaderboardFeatures: \"premium\",\n      premiumSoundLibrary: \"premium\",\n      exclusiveContent: \"premium\",\n      adFree: \"premium\",\n      prioritySupport: \"pro\",\n      nuclearMode: \"pro\",\n      premiumPersonalities: \"pro\",\n    };\n\n    return tierRequirements[feature] || 'premium';\n  };\n\n  const renderUpgradePrompt = () => {\n    const requiredTier = getRequiredTier();\n    const featureTitle = getFeatureTitle();\n    const featureDesc = getFeatureDescription();\n\n    const tierColors = {\n      premium: 'from-amber-500 to-orange-500',\n      pro: 'from-purple-500 to-pink-500',\n      lifetime: 'from-emerald-500 to-teal-500'\n    };\n\n    const tierIcons = {\n      premium: Crown,\n      pro: Sparkles,\n      lifetime: Star\n    };\n\n    const TierIcon = tierIcons[requiredTier as keyof typeof tierIcons] || Crown;\n\n    return (\n      <motion.div\n        initial={{ opacity: 0, y: 20 }}\n        animate={{ opacity: 1, y: 0 }}\n        transition={{ duration: 0.3 }}\n        className={`relative overflow-hidden rounded-xl border border-gray-200 bg-gradient-to-br from-gray-50 to-white p-6 ${className}`}\n      >\n        {/* Background decoration */}\n        <div className=\"absolute -top-6 -right-6 w-24 h-24 opacity-5\">\n          <TierIcon className=\"w-full h-full\" />\n        </div>\n\n        <div className=\"relative\">\n          <div className=\"flex items-start space-x-4\">\n            <div className={`flex-shrink-0 w-12 h-12 rounded-xl bg-gradient-to-br ${tierColors[requiredTier]} flex items-center justify-center`}>\n              <TierIcon className=\"w-6 h-6 text-white\" />\n            </div>\n\n            <div className=\"flex-1 min-w-0\">\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-1\">\n                {featureTitle}\n              </h3>\n              <p className=\"text-sm text-gray-600 mb-4\">\n                {featureDesc}\n              </p>\n\n              <div className=\"flex items-center space-x-2 mb-4\">\n                <span className=\"text-xs font-medium text-gray-500 uppercase tracking-wide\">\n                  Requires {requiredTier}\n                </span>\n                <div className={`h-1 w-8 rounded-full bg-gradient-to-r ${tierColors[requiredTier]}`} />\n              </div>\n\n              <motion.button\n                whileHover={{ scale: 1.02 }}\n                whileTap={{ scale: 0.98 }}\n                onClick={handleUpgrade}\n                className={`inline-flex items-center space-x-2 px-4 py-2 rounded-lg bg-gradient-to-r ${tierColors[requiredTier]} text-white font-medium text-sm hover:shadow-lg transition-shadow`}\n              >\n                <ArrowUp className=\"w-4 h-4\" />\n                <span>Upgrade to {requiredTier}</span>\n              </motion.button>\n            </div>\n          </div>\n        </div>\n      </motion.div>\n    );\n  };\n\n  const renderOverlayMode = () => {\n    return (\n      <div className={`relative ${className}`}>\n        {showPreview && (\n          <div className=\"opacity-50 pointer-events-none blur-sm\">{children}</div>\n        )}\n        <div className=\"absolute inset-0 flex items-center justify-center bg-white/80 backdrop-blur-sm rounded-lg\">\n          <div className=\"text-center p-4\">\n            <Lock className=\"w-8 h-8 text-gray-400 mx-auto mb-2\" />\n            <h4 className=\"font-semibold text-gray-900 mb-1\">{getFeatureTitle()}</h4>\n            <p className=\"text-sm text-gray-600 mb-3\">\n              This feature requires a premium subscription\n            </p>\n            <motion.button\n              whileHover={{ scale: 1.05 }}\n              whileTap={{ scale: 0.95 }}\n              onClick={handleUpgrade}\n              className=\"px-4 py-2 bg-gradient-to-r from-amber-500 to-orange-500 text-white rounded-lg font-medium text-sm\"\n            >\n              Upgrade Now\n            </motion.button>\n          </div>\n        </div>\n      </div>\n    );\n  };\n\n  // Render based on mode\n  if (mode === 'overlay') {\n    return (\n      <>\n        {renderOverlayMode()}\n        <AnimatePresence>\n          {state.isModalOpen && (\n            <SubscriptionModal\n              isOpen={state.isModalOpen}\n              onClose={handleModalClose}\n              userId={userId}\n              highlightedFeature={feature}\n            />\n          )}\n        </AnimatePresence>\n      </>\n    );\n  }\n\n  if (mode === 'replace') {\n    return (\n      <>\n        {fallback || renderUpgradePrompt()}\n        <AnimatePresence>\n          {state.isModalOpen && (\n            <SubscriptionModal\n              isOpen={state.isModalOpen}\n              onClose={handleModalClose}\n              userId={userId}\n              highlightedFeature={feature}\n            />\n          )}\n        </AnimatePresence>\n      </>\n    );\n  }\n\n  // Default block mode\n  return (\n    <>\n      {renderUpgradePrompt()}\n      <AnimatePresence>\n        {state.isModalOpen && (\n          <SubscriptionModal\n            isOpen={state.isModalOpen}\n            onClose={handleModalClose}\n            userId={userId}\n            highlightedFeature={feature}\n          />\n        )}\n      </AnimatePresence>\n    </>\n  );\n};\n\nexport default PremiumGate;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/PricingPage.tsx",
    "messages": [
      {
        "ruleId": null,
        "nodeType": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 586,
        "column": 0
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from './ui/card';\nimport { Button } from './ui/button';\nimport { Badge } from './ui/badge';\nimport { Separator } from './ui/separator';\nimport { Alert, AlertDescription } from './ui/alert';\nimport {\n  Check,\n  Crown,\n  Star,\n  Zap,\n  Volume2,\n  Target,\n  Mic,\n  BarChart3,\n  Infinity,\n  AlertCircle,\n  CreditCard,\n  ArrowRight,\n  Users,\n  Shield,\n  TrendingUp,\n} from \"lucide-react\";\nimport { cn } from \"../lib/utils\";\nimport { PremiumService } from \"../services/premium\";\nimport { SubscriptionStatus } from \"./SubscriptionStatus\";\n\ninterface PricingPageProps {\n  user: User;\n  currentPlan?: SubscriptionPlan;\n  onUpgrade?: (plan: SubscriptionPlan) => void;\n  onManageSubscription?: () => void;\n  className?: string;\n}\n\ninterface PricingTier {\n  name: string;\n  price: number;\n  billingPeriod: 'month' | 'year';\n  yearlyPrice?: number;\n  icon: React.ReactNode;\n  badge?: string;\n  badgeColor?: string;\n  description: string;\n  features: Array<{\n    name: string;\n    included: boolean;\n    premium?: boolean;\n    ultimate?: boolean;\n    description?: string;\n  }>;\n  limits: {\n    alarms: number | 'unlimited';\n    voicePersonalities: number;\n    nuclearChallenges: boolean;\n    voiceCloning: boolean;\n    analytics: boolean;\n  };\n  cta: string;\n  popular?: boolean;\n}\n\nconst pricingTiers: PricingTier[] = [\n  {\n    id: 'free',\n    name: 'Free',\n    price: 0,\n    yearlyPrice: 0,\n    billingPeriod: 'month',\n    icon: <Shield className=\"w-6 h-6\" />,\n    description: 'Perfect for getting started with smart alarms',\n    features: [\n      { name: 'Basic voice alarms', included: true, description: 'Standard voice personalities' },\n      { name: 'Up to 10 alarms', included: true, description: 'Create multiple alarms' },\n      { name: 'Standard difficulty levels', included: true, description: 'Easy to hard challenges' },\n      { name: 'Basic voice recognition', included: true, description: 'Voice commands to dismiss' },\n      { name: 'Snooze controls', included: true, description: 'Customizable snooze settings' },\n      { name: 'Nuclear Mode', included: false, premium: true, description: 'Extreme difficulty challenges' },\n      { name: 'Custom voices', included: false, premium: true, description: '18+ premium voice personalities' },\n      { name: 'Voice cloning', included: false, ultimate: true, description: 'Create your own custom voice' },\n      { name: 'Advanced analytics', included: false, premium: true, description: 'Detailed sleep insights' },\n      { name: 'Unlimited alarms', included: false, premium: true, description: 'No limits on alarm creation' }\n    ],\n    limits: {\n      alarms: 10,\n      voicePersonalities: 6,\n      nuclearChallenges: false,\n      voiceCloning: false,\n      analytics: false\n    },\n    cta: 'Get Started Free'\n  },\n  {\n    id: 'premium',\n    name: 'Premium',\n    price: 9.99,\n    yearlyPrice: 99.99,\n    billingPeriod: 'month',\n    icon: <Crown className=\"w-6 h-6\" />,\n    badge: 'Most Popular',\n    badgeColor: 'bg-blue-500',\n    popular: true,\n    description: 'Unlock advanced features and nuclear mode',\n    features: [\n      { name: 'Everything in Free', included: true },\n      { name: 'Nuclear Mode', included: true, description: 'Extreme difficulty challenges' },\n      { name: 'Premium voices', included: true, description: '18+ celebrity and character voices' },\n      { name: 'Unlimited alarms', included: true, description: 'No limits on alarm creation' },\n      { name: 'Advanced analytics', included: true, description: 'Sleep patterns and performance tracking' },\n      { name: 'Priority support', included: true, description: 'Faster response times' },\n      { name: 'Custom challenge difficulty', included: true, description: 'Fine-tune your wake-up challenges' },\n      { name: 'Voice cloning', included: false, ultimate: true, description: 'Create custom voices' },\n      { name: 'Advanced integrations', included: false, ultimate: true, description: 'API access and webhooks' },\n      { name: 'Team management', included: false, ultimate: true, description: 'Manage multiple users' }\n    ],\n    limits: {\n      alarms: 'unlimited',\n      voicePersonalities: 18,\n      nuclearChallenges: true,\n      voiceCloning: false,\n      analytics: true\n    },\n    cta: 'Upgrade to Premium'\n  },\n  {\n    id: 'ultimate',\n    name: 'Ultimate',\n    price: 19.99,\n    yearlyPrice: 199.99,\n    billingPeriod: 'month',\n    icon: <Star className=\"w-6 h-6\" />,\n    badge: 'Ultimate Power',\n    badgeColor: 'bg-purple-500',\n    description: 'The complete alarm solution for power users',\n    features: [\n      { name: 'Everything in Premium', included: true },\n      { name: 'Voice cloning', included: true, description: 'Create unlimited custom voices' },\n      { name: 'Advanced integrations', included: true, description: 'API access, webhooks, IFTTT' },\n      { name: 'Team management', included: true, description: 'Manage up to 5 users' },\n      { name: 'White-label options', included: true, description: 'Custom branding' },\n      { name: 'Advanced nuclear modes', included: true, description: 'Custom challenge creation' },\n      { name: 'Export data', included: true, description: 'Full data export capabilities' },\n      { name: 'Premium support', included: true, description: '24/7 priority support' },\n      { name: 'Beta features', included: true, description: 'Early access to new features' },\n      { name: 'Custom integrations', included: true, description: 'Dedicated integration support' }\n    ],\n    limits: {\n      alarms: 'unlimited',\n      voicePersonalities: 'unlimited' as any,\n      nuclearChallenges: true,\n      voiceCloning: true,\n      analytics: true\n    },\n    cta: 'Go Ultimate'\n  }\n];\n\nexport const PricingPage: React.FC<PricingPageProps> = ({\n  user,\n  currentPlan,\n  onUpgrade,\n  onManageSubscription,\n  className\n}) => {\n  const [selectedBilling, setSelectedBilling] = useState<'monthly' | 'yearly'>('monthly');\n  const [isLoading, setIsLoading] = useState<string | null>(null);\n  const [subscriptionStatus, setSubscriptionStatus] = useState<any>(null);\n\n  useEffect(() => {\n    loadUserSubscription();\n  }, [user.id]);\n\n  const loadUserSubscription = async () => {\n    try {\n      const tier = await PremiumService.getUserTier(user.id);\n      const status = await PremiumService.getSubscriptionStatus(user.id);\n      setUserTier(tier);\n      setSubscriptionStatus(status);\n    } catch (error) {\n      console.error('Error loading subscription:', error);\n    }\n  };\n\n    if (tier === \"free\") return;\n\n    setIsLoading(tier);\n    try {\n      // In a real app, this would integrate with Stripe, PayPal, etc.\n      const success = await simulatePayment(tier, selectedBilling);\n\n      if (success) {\n        await PremiumService.updateUserTier(user.id, tier);\n        await loadUserSubscription();\n\n        if (onUpgrade) {\n          const plan = pricingTiers.find(t => t.id === tier);\n          if (plan) {\n            onUpgrade({\n              id: tier,\n              name: plan.name,\n              price: selectedBilling === 'yearly' ? plan.yearlyPrice || plan.price : plan.price,\n              billingPeriod: selectedBilling === 'yearly' ? 'year' : 'month',\n              features: plan.features.filter(f => f.included).map(f => f.name)\n            });\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error upgrading subscription:', error);\n    } finally {\n      setIsLoading(null);\n    }\n  };\n\n  const simulatePayment = async (\n    billing: \"monthly\" | \"yearly\",\n  ): Promise<boolean> => {\n    // Simulate payment processing\n    return new Promise(resolve => {\n      setTimeout(() => {\n        // In a real app, this would handle actual payment processing\n        resolve(true);\n      }, 2000);\n    });\n  };\n\n  const getPrice = (tier: PricingTier) => {\n    if (tier.price === 0) return 'Free';\n\n    const price = selectedBilling === 'yearly' && tier.yearlyPrice ? tier.yearlyPrice : tier.price;\n    const period = selectedBilling === 'yearly' ? 'year' : 'month';\n    const monthlyPrice = selectedBilling === 'yearly' && tier.yearlyPrice\n      ? tier.yearlyPrice / 12\n      : tier.price;\n\n    if (selectedBilling === 'yearly' && tier.yearlyPrice) {\n      return (\n        <div>\n          <span className=\"text-3xl font-bold\">${price}</span>\n          <span className=\"text-gray-600\">/{period}</span>\n          <div className=\"text-sm text-green-600\">${monthlyPrice.toFixed(2)}/month</div>\n        </div>\n      );\n    }\n\n    return (\n      <div>\n        <span className=\"text-3xl font-bold\">${price}</span>\n        <span className=\"text-gray-600\">/{period}</span>\n      </div>\n    );\n  };\n\n  const canUpgrade = (tier: string) => {\n    if (tier === \"free\") return false;\n    if (userTier === \"free\") return true;\n    if (userTier === \"premium\" && tier === \"ultimate\") return true;\n    return false;\n  };\n\n  const getTierIndex = (tier: string) => {\n    const order = ['free', 'basic', 'premium', 'pro', 'ultimate', 'lifetime'];\n    return order.indexOf(tier);\n  };\n\n  const isUpgrade = (tier: string) => {\n    return getTierIndex(tier) > getTierIndex(userTier);\n  };\n\n  return (\n    <div className={cn('max-w-7xl mx-auto p-6', className)}>\n      {/* Header */}\n      <div className=\"text-center mb-12\">\n        <h1 className=\"text-4xl font-bold text-gray-900 mb-4\">Choose Your Plan</h1>\n        <p className=\"text-xl text-gray-600 mb-8\">\n          Unlock powerful features to revolutionize how you wake up\n        </p>\n\n        {/* Current Subscription Status */}\n        {subscriptionStatus && (\n          <div className=\"mb-8\">\n            <SubscriptionStatus\n              subscription={subscriptionStatus}\n              variant=\"card\"\n              className=\"max-w-md mx-auto\"\n            />\n          </div>\n        )}\n\n        {/* Billing Toggle */}\n        <div className=\"flex items-center justify-center gap-4 mb-8\">\n          <span className={cn('text-sm', selectedBilling === 'monthly' ? 'font-semibold' : 'text-gray-600')}>\n            Monthly\n          </span>\n          <button\n            onClick={() => setSelectedBilling(selectedBilling === 'monthly' ? 'yearly' : 'monthly')}\n            className={cn(\n              'relative inline-flex h-6 w-11 items-center rounded-full transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2',\n              selectedBilling === 'yearly' ? 'bg-blue-600' : 'bg-gray-200'\n            )}\n          >\n            <span\n              className={cn(\n                'inline-block h-4 w-4 transform rounded-full bg-white transition-transform',\n                selectedBilling === 'yearly' ? 'translate-x-6' : 'translate-x-1'\n              )}\n            />\n          </button>\n          <span className={cn('text-sm', selectedBilling === 'yearly' ? 'font-semibold' : 'text-gray-600')}>\n            Yearly\n            {selectedBilling === 'yearly' && (\n              <Badge className=\"ml-2 bg-green-100 text-green-800\">Save 17%</Badge>\n            )}\n          </span>\n        </div>\n      </div>\n\n      {/* Pricing Cards */}\n      <div className=\"grid grid-cols-1 md:grid-cols-3 gap-8 mb-12\">\n        {pricingTiers.map(tier => (\n          <Card\n            key={tier.id}\n            className={cn(\n              'relative transition-all duration-200 hover:shadow-lg',\n              tier.popular && 'ring-2 ring-blue-500 shadow-lg scale-105',\n              isCurrentTier(tier.id) && 'ring-2 ring-green-500 bg-green-50'\n            )}\n          >\n            {tier.badge && (\n              <div className=\"absolute -top-3 left-1/2 transform -translate-x-1/2\">\n                <Badge className={cn('px-3 py-1', tier.badgeColor || 'bg-blue-500')}>\n                  {tier.badge}\n                </Badge>\n              </div>\n            )}\n\n            <CardHeader className=\"text-center pb-4\">\n              <div className=\"flex items-center justify-center gap-2 mb-2\">\n                <div className={cn(\n                  'p-2 rounded-lg',\n                  tier.id === 'free' ? 'bg-gray-100 text-gray-600' :\n                  tier.id === 'premium' ? 'bg-blue-100 text-blue-600' :\n                  'bg-purple-100 text-purple-600'\n                )}>\n                  {tier.icon}\n                </div>\n                <CardTitle className=\"text-2xl font-bold\">{tier.name}</CardTitle>\n              </div>\n\n              <div className=\"mb-4\">\n                {getPrice(tier)}\n              </div>\n\n              <p className=\"text-gray-600 text-sm\">{tier.description}</p>\n            </CardHeader>\n\n            <CardContent className=\"space-y-6\">\n              {/* Features List */}\n              <div className=\"space-y-3\">\n                {tier.features.map((feature, index) => (\n                  <div key={index} className=\"flex items-start gap-3\">\n                    {feature.included ? (\n                      <Check className=\"w-5 h-5 text-green-500 mt-0.5 flex-shrink-0\" />\n                    ) : (\n                      <div className=\"w-5 h-5 mt-0.5 flex-shrink-0 flex items-center justify-center\">\n                        {feature.premium && <Crown className=\"w-4 h-4 text-blue-500\" />}\n                        {feature.ultimate && (\n                          <Star className=\"w-4 h-4 text-purple-500\" />\n                        )}\n                      </div>\n                    )}\n                    <div>\n                      <span className={cn(\n                        'text-sm',\n                        feature.included ? 'text-gray-900' : 'text-gray-500'\n                      )}>\n                        {feature.name}\n                      </span>\n                      {feature.description && (\n                        <div className=\"text-xs text-gray-500 mt-1\">\n                          {feature.description}\n                        </div>\n                      )}\n                    </div>\n                  </div>\n                ))}\n              </div>\n\n              <Separator />\n\n              {/* Limits Summary */}\n              <div className=\"space-y-2 text-sm text-gray-600\">\n                <div className=\"flex justify-between\">\n                  <span>Alarms:</span>\n                  <span className=\"font-medium\">\n                    {tier.limits.alarms === 'unlimited' ? 'Unlimited' : tier.limits.alarms}\n                  </span>\n                </div>\n                <div className=\"flex justify-between\">\n                  <span>Voice Personalities:</span>\n                  <span className=\"font-medium\">\n                    {tier.limits.voicePersonalities === 'unlimited' ? 'Unlimited' : tier.limits.voicePersonalities}\n                  </span>\n                </div>\n              </div>\n\n              {/* Action Button */}\n              <div className=\"pt-4\">\n                {isCurrentTier(tier.id) ? (\n                  <div className=\"space-y-2\">\n                    <Button\n                      variant=\"outline\"\n                      className=\"w-full bg-green-50 border-green-200 text-green-700 hover:bg-green-100\"\n                      disabled\n                    >\n                      <Check className=\"w-4 h-4 mr-2\" />\n                      Current Plan\n                    </Button>\n                    {tier.id !== 'free' && (\n                      <Button\n                        variant=\"ghost\"\n                        size=\"sm\"\n                        onClick={onManageSubscription}\n                        className=\"w-full text-gray-600 hover:text-gray-900\"\n                      >\n                        <CreditCard className=\"w-4 h-4 mr-2\" />\n                        Manage Subscription\n                      </Button>\n                    )}\n                  </div>\n                ) : canUpgrade(tier.id) ? (\n                  <Button\n                    onClick={() => handleUpgrade(tier.id)}\n                    disabled={isLoading === tier.id}\n                    className={cn(\n                      'w-full',\n                      tier.popular && 'bg-blue-600 hover:bg-blue-700'\n                    )}\n                  >\n                    {isLoading === tier.id ? (\n                      <>\n                        <div className=\"animate-spin w-4 h-4 mr-2 border-2 border-white border-t-transparent rounded-full\" />\n                        Processing...\n                      </>\n                    ) : (\n                      <>\n                        <ArrowRight className=\"w-4 h-4 mr-2\" />\n                        {tier.cta}\n                      </>\n                    )}\n                  </Button>\n                ) : isDowngrade(tier.id) ? (\n                  <Button\n                    variant=\"outline\"\n                    onClick={() => handleUpgrade(tier.id)}\n                    className=\"w-full text-orange-600 border-orange-200 hover:bg-orange-50\"\n                  >\n                    Downgrade to {tier.name}\n                  </Button>\n                ) : (\n                  <Button\n                    variant=\"outline\"\n                    disabled\n                    className=\"w-full\"\n                  >\n                    Not Available\n                  </Button>\n                )}\n              </div>\n            </CardContent>\n          </Card>\n        ))}\n      </div>\n\n      {/* Feature Comparison */}\n      <div className=\"mb-12\">\n        <h2 className=\"text-2xl font-bold text-center mb-8\">Feature Comparison</h2>\n\n        <Alert className=\"mb-6\">\n          <AlertCircle className=\"w-4 h-4\" />\n          <AlertDescription>\n            All plans include our core alarm functionality. Premium features unlock advanced capabilities\n            to help you wake up more effectively and track your progress.\n          </AlertDescription>\n        </Alert>\n\n        <div className=\"overflow-x-auto\">\n          <table className=\"w-full border-collapse border border-gray-200 rounded-lg\">\n            <thead>\n              <tr className=\"bg-gray-50\">\n                <th className=\"border border-gray-200 px-4 py-3 text-left font-semibold\">Feature</th>\n                <th className=\"border border-gray-200 px-4 py-3 text-center font-semibold\">Free</th>\n                <th className=\"border border-gray-200 px-4 py-3 text-center font-semibold\">Premium</th>\n                <th className=\"border border-gray-200 px-4 py-3 text-center font-semibold\">Ultimate</th>\n              </tr>\n            </thead>\n            <tbody>\n              {[\n                { name: 'Basic Alarms', free: true, premium: true, ultimate: true },\n                { name: 'Voice Commands', free: true, premium: true, ultimate: true },\n                { name: 'Alarm Limit', free: '10', premium: 'Unlimited', ultimate: 'Unlimited' },\n                { name: 'Nuclear Mode', free: false, premium: true, ultimate: true },\n                { name: 'Premium Voices', free: false, premium: true, ultimate: true },\n                { name: 'Voice Cloning', free: false, premium: false, ultimate: true },\n                { name: 'Advanced Analytics', free: false, premium: true, ultimate: true },\n                { name: 'API Access', free: false, premium: false, ultimate: true },\n                { name: 'Team Management', free: false, premium: false, ultimate: true },\n              ].map((feature, index) => (\n                <tr key={index} className=\"hover:bg-gray-50\">\n                  <td className=\"border border-gray-200 px-4 py-3 font-medium\">\n                    {feature.name}\n                  </td>\n                  <td className=\"border border-gray-200 px-4 py-3 text-center\">\n                    {typeof feature.free === 'boolean' ? (\n                      feature.free ? (\n                        <Check className=\"w-5 h-5 text-green-500 mx-auto\" />\n                      ) : (\n                        <span className=\"text-gray-400\">‚Äî</span>\n                      )\n                    ) : (\n                      <span className=\"text-sm\">{feature.free}</span>\n                    )}\n                  </td>\n                  <td className=\"border border-gray-200 px-4 py-3 text-center\">\n                    {typeof feature.premium === 'boolean' ? (\n                      feature.premium ? (\n                        <Check className=\"w-5 h-5 text-green-500 mx-auto\" />\n                      ) : (\n                        <span className=\"text-gray-400\">‚Äî</span>\n                      )\n                    ) : (\n                      <span className=\"text-sm\">{feature.premium}</span>\n                    )}\n                  </td>\n                  <td className=\"border border-gray-200 px-4 py-3 text-center\">\n                    {typeof feature.ultimate === 'boolean' ? (\n                      feature.ultimate ? (\n                        <Check className=\"w-5 h-5 text-green-500 mx-auto\" />\n                      ) : (\n                        <span className=\"text-gray-400\">‚Äî</span>\n                      )\n                    ) : (\n                      <span className=\"text-sm\">{feature.ultimate}</span>\n                    )}\n                  </td>\n                </tr>\n              ))}\n            </tbody>\n          </table>\n        </div>\n      </div>\n\n      {/* FAQs */}\n      <div>\n        <h2 className=\"text-2xl font-bold text-center mb-8\">Frequently Asked Questions</h2>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n          {[\n            {\n              question: \"What is Nuclear Mode?\",\n              answer: \"Nuclear Mode is our most extreme alarm difficulty setting, featuring multi-step challenges, memory tests, and physical verification tasks that ensure you're truly awake before the alarm can be dismissed.\"\n            },\n            {\n              question: \"How does voice cloning work?\",\n              answer: \"With Ultimate tier, you can record voice samples to create custom AI voices that sound like you or your loved ones. Perfect for personalized wake-up messages.\"\n            },\n            {\n              question: \"Can I cancel anytime?\",\n              answer: \"Yes! You can cancel your subscription at any time. Your premium features will remain active until the end of your billing period.\"\n            },\n            {\n              question: \"What about data privacy?\",\n              answer: \"We take privacy seriously. Voice recordings for cloning are processed securely and can be deleted at any time. We never share personal data with third parties.\"\n            }\n          ].map((faq, index) => (\n            <Card key={index}>\n              <CardContent className=\"p-6\">\n                <h3 className=\"font-semibold mb-2\">{faq.question}</h3>\n                <p className=\"text-gray-600 text-sm\">{faq.answer}</p>\n              </CardContent>\n            </Card>\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default PricingPage;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/RTLContainer.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'RTLContainer' is not defined.",
        "line": 1,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 1,
        "endColumn": 28
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "export default RTLContainer;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/RTLFlex.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'RTLFlex' is not defined.",
        "line": 1,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 1,
        "endColumn": 23
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "export default RTLFlex;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/RTLForm.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'RTLForm' is not defined.",
        "line": 1,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 1,
        "endColumn": 23
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "export default RTLForm;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/RTLGrid.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'RTLGrid' is not defined.",
        "line": 1,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 1,
        "endColumn": 23
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "export default RTLGrid;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/RTLLayout/RTLContainer.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'JSX' is not defined.",
        "line": 16,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 16,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * RTL-aware Container component that automatically handles direction-based styling\n */\n\nimport React from 'react';\nimport { cn } from '../../lib/utils';\nimport { useRTL } from '../../hooks/useRTL';\n\ninterface RTLContainerProps {\n  children: React.ReactNode;\n  className?: string;\n  maxWidth?: 'sm' | 'md' | 'lg' | 'xl' | '2xl' | 'full' | 'none';\n  padding?: boolean | 'none' | 'sm' | 'md' | 'lg' | 'xl';\n  center?: boolean;\n  dir?: 'ltr' | 'rtl' | 'auto';\n  as?: keyof JSX.IntrinsicElements;\n}\n\nconst maxWidthClasses = {\n  sm: 'max-w-sm',\n  md: 'max-w-md',\n  lg: 'max-w-lg',\n  xl: 'max-w-xl',\n  '2xl': 'max-w-2xl',\n  full: 'max-w-full',\n  none: '',\n};\n\nconst paddingClasses = {\n  none: '',\n  sm: 'px-2 py-2',\n  md: 'px-4 py-4',\n  lg: 'px-6 py-6',\n  xl: 'px-8 py-8',\n};\n\nexport const RTLContainer: React.FC<RTLContainerProps> = ({\n  children,\n  className,\n  maxWidth = 'full',\n  padding = 'md',\n  center = true,\n  dir = 'auto',\n  as: Component = 'div',\n}) => {\n  const { direction, isRTL } = useRTL();\n\n  const containerDir = dir === 'auto' ? direction : dir;\n  const maxWidthClass = maxWidthClasses[maxWidth];\n  const paddingClass = typeof padding === 'boolean'\n    ? (padding ? paddingClasses.md : paddingClasses.none)\n    : paddingClasses[padding];\n\n  const containerClasses = cn(\n    'rtl-container',\n    maxWidthClass,\n    paddingClass,\n    center && 'mx-auto',\n    className\n  );\n\n  return (\n    <Component\n      className={containerClasses}\n      dir={containerDir}\n      data-rtl={isRTL}\n    >\n      {children}\n    </Component>\n  );\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/RTLLayout/RTLFlex.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'JSX' is not defined.",
        "line": 18,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 18,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * RTL-aware Flex component that automatically handles direction-based flexbox layouts\n */\n\nimport React from 'react';\nimport { cn } from '../../lib/utils';\nimport { useRTLFlex } from '../../hooks/useRTL';\n\ninterface RTLFlexProps {\n  children: React.ReactNode;\n  className?: string;\n  direction?: 'row' | 'column' | 'row-reverse' | 'column-reverse' | 'row-rtl';\n  justify?: 'start' | 'end' | 'center' | 'between' | 'around' | 'evenly';\n  align?: 'start' | 'end' | 'center' | 'stretch' | 'baseline';\n  wrap?: boolean | 'reverse';\n  gap?: number | string;\n  inline?: boolean;\n  as?: keyof JSX.IntrinsicElements;\n  style?: React.CSSProperties;\n}\n\nconst justifyClasses = {\n  start: 'justify-start',\n  end: 'justify-end',\n  center: 'justify-center',\n  between: 'justify-between',\n  around: 'justify-around',\n  evenly: 'justify-evenly',\n};\n\nconst alignClasses = {\n  start: 'items-start',\n  end: 'items-end',\n  center: 'items-center',\n  stretch: 'items-stretch',\n  baseline: 'items-baseline',\n};\n\nconst directionClasses = {\n  row: 'flex-row',\n  column: 'flex-col',\n  'row-reverse': 'flex-row-reverse',\n  'column-reverse': 'flex-col-reverse',\n};\n\nexport const RTLFlex: React.FC<RTLFlexProps> = ({\n  children,\n  className,\n  direction = 'row',\n  justify = 'start',\n  align = 'stretch',\n  wrap = false,\n  gap,\n  inline = false,\n  as: Component = 'div',\n  style,\n}) => {\n  const { flex, isRTL } = useRTLFlex();\n\n  // Handle RTL-aware row direction\n  const getFlexDirection = () => {\n    if (direction === 'row-rtl') {\n      return isRTL ? 'flex-row-reverse' : 'flex-row';\n    }\n\n    if (direction === 'row' && isRTL) {\n      return 'flex-row-reverse';\n    }\n\n    return directionClasses[direction as keyof typeof directionClasses] || 'flex-row';\n  };\n\n  // Handle RTL-aware justify content\n  const getJustifyClass = () => {\n    if (justify === 'start' || justify === 'end') {\n      return justifyClasses[flex.justifyContent[justify] as keyof typeof justifyClasses];\n    }\n    return justifyClasses[justify];\n  };\n\n  const flexClasses = cn(\n    inline ? 'inline-flex' : 'flex',\n    getFlexDirection(),\n    getJustifyClass(),\n    alignClasses[align],\n    wrap === true && 'flex-wrap',\n    wrap === 'reverse' && 'flex-wrap-reverse',\n    className\n  );\n\n  const flexStyle = {\n    ...(gap && { gap: typeof gap === 'number' ? `${gap}px` : gap }),\n    ...style,\n  };\n\n  return (\n    <Component\n      className={flexClasses}\n      style={flexStyle}\n      data-rtl={isRTL}\n      data-direction={direction}\n    >\n      {children}\n    </Component>\n  );\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/RTLLayout/RTLGrid.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'JSX' is not defined.",
        "line": 19,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 19,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * RTL-aware Grid component that automatically handles direction-based grid layouts\n */\n\nimport React from 'react';\nimport { cn } from '../../lib/utils';\nimport { useRTL } from '../../hooks/useRTL';\n\ninterface RTLGridProps {\n  children: React.ReactNode;\n  className?: string;\n  cols?: number | { sm?: number; md?: number; lg?: number; xl?: number; '2xl'?: number };\n  rows?: number | 'auto';\n  gap?: number | string | { x?: number | string; y?: number | string };\n  autoFlow?: 'row' | 'col' | 'row-dense' | 'col-dense' | 'rtl-row' | 'rtl-col';\n  justify?: 'start' | 'end' | 'center' | 'stretch';\n  align?: 'start' | 'end' | 'center' | 'stretch';\n  placeItems?: 'start' | 'end' | 'center' | 'stretch';\n  as?: keyof JSX.IntrinsicElements;\n  style?: React.CSSProperties;\n}\n\nconst colsClasses = {\n  1: 'grid-cols-1',\n  2: 'grid-cols-2',\n  3: 'grid-cols-3',\n  4: 'grid-cols-4',\n  5: 'grid-cols-5',\n  6: 'grid-cols-6',\n  7: 'grid-cols-7',\n  8: 'grid-cols-8',\n  9: 'grid-cols-9',\n  10: 'grid-cols-10',\n  11: 'grid-cols-11',\n  12: 'grid-cols-12',\n};\n\nconst responsiveColsClasses = {\n  sm: {\n    1: 'sm:grid-cols-1',\n    2: 'sm:grid-cols-2',\n    3: 'sm:grid-cols-3',\n    4: 'sm:grid-cols-4',\n    5: 'sm:grid-cols-5',\n    6: 'sm:grid-cols-6',\n    7: 'sm:grid-cols-7',\n    8: 'sm:grid-cols-8',\n    9: 'sm:grid-cols-9',\n    10: 'sm:grid-cols-10',\n    11: 'sm:grid-cols-11',\n    12: 'sm:grid-cols-12',\n  },\n  md: {\n    1: 'md:grid-cols-1',\n    2: 'md:grid-cols-2',\n    3: 'md:grid-cols-3',\n    4: 'md:grid-cols-4',\n    5: 'md:grid-cols-5',\n    6: 'md:grid-cols-6',\n    7: 'md:grid-cols-7',\n    8: 'md:grid-cols-8',\n    9: 'md:grid-cols-9',\n    10: 'md:grid-cols-10',\n    11: 'md:grid-cols-11',\n    12: 'md:grid-cols-12',\n  },\n  lg: {\n    1: 'lg:grid-cols-1',\n    2: 'lg:grid-cols-2',\n    3: 'lg:grid-cols-3',\n    4: 'lg:grid-cols-4',\n    5: 'lg:grid-cols-5',\n    6: 'lg:grid-cols-6',\n    7: 'lg:grid-cols-7',\n    8: 'lg:grid-cols-8',\n    9: 'lg:grid-cols-9',\n    10: 'lg:grid-cols-10',\n    11: 'lg:grid-cols-11',\n    12: 'lg:grid-cols-12',\n  },\n  xl: {\n    1: 'xl:grid-cols-1',\n    2: 'xl:grid-cols-2',\n    3: 'xl:grid-cols-3',\n    4: 'xl:grid-cols-4',\n    5: 'xl:grid-cols-5',\n    6: 'xl:grid-cols-6',\n    7: 'xl:grid-cols-7',\n    8: 'xl:grid-cols-8',\n    9: 'xl:grid-cols-9',\n    10: 'xl:grid-cols-10',\n    11: 'xl:grid-cols-11',\n    12: 'xl:grid-cols-12',\n  },\n  '2xl': {\n    1: '2xl:grid-cols-1',\n    2: '2xl:grid-cols-2',\n    3: '2xl:grid-cols-3',\n    4: '2xl:grid-cols-4',\n    5: '2xl:grid-cols-5',\n    6: '2xl:grid-cols-6',\n    7: '2xl:grid-cols-7',\n    8: '2xl:grid-cols-8',\n    9: '2xl:grid-cols-9',\n    10: '2xl:grid-cols-10',\n    11: '2xl:grid-cols-11',\n    12: '2xl:grid-cols-12',\n  },\n};\n\nconst autoFlowClasses = {\n  row: 'grid-flow-row',\n  col: 'grid-flow-col',\n  'row-dense': 'grid-flow-row-dense',\n  'col-dense': 'grid-flow-col-dense',\n};\n\nconst justifyClasses = {\n  start: 'justify-items-start',\n  end: 'justify-items-end',\n  center: 'justify-items-center',\n  stretch: 'justify-items-stretch',\n};\n\nconst alignClasses = {\n  start: 'items-start',\n  end: 'items-end',\n  center: 'items-center',\n  stretch: 'items-stretch',\n};\n\nconst placeItemsClasses = {\n  start: 'place-items-start',\n  end: 'place-items-end',\n  center: 'place-items-center',\n  stretch: 'place-items-stretch',\n};\n\nexport const RTLGrid: React.FC<RTLGridProps> = ({\n  children,\n  className,\n  cols = 1,\n  rows,\n  gap,\n  autoFlow = 'row',\n  justify,\n  align,\n  placeItems,\n  as: Component = 'div',\n  style,\n}) => {\n  const { isRTL } = useRTL();\n\n  // Generate column classes\n  const getColsClasses = () => {\n    if (typeof cols === 'number') {\n      return colsClasses[cols as keyof typeof colsClasses] || 'grid-cols-1';\n    }\n\n    const classes = [];\n\n    // Default mobile-first class\n    if (cols.sm) {\n      classes.push(colsClasses[cols.sm as keyof typeof colsClasses]);\n    }\n\n    // Responsive classes\n    Object.entries(cols).forEach(([breakpoint, value]) => {\n      if (breakpoint !== 'sm' && value && responsiveColsClasses[breakpoint as keyof typeof responsiveColsClasses]) {\n        classes.push(responsiveColsClasses[breakpoint as keyof typeof responsiveColsClasses][value as keyof typeof responsiveColsClasses.sm]);\n      }\n    });\n\n    return classes.join(' ');\n  };\n\n  // Handle RTL-aware auto flow\n  const getAutoFlowClass = () => {\n    if (autoFlow === 'rtl-row') {\n      return isRTL ? 'grid-flow-row-dense' : 'grid-flow-row';\n    }\n\n    if (autoFlow === 'rtl-col') {\n      return isRTL ? 'grid-flow-col-dense' : 'grid-flow-col';\n    }\n\n    return autoFlowClasses[autoFlow as keyof typeof autoFlowClasses] || 'grid-flow-row';\n  };\n\n  const gridClasses = cn(\n    'grid',\n    getColsClasses(),\n    rows && typeof rows === 'number' && `grid-rows-${rows}`,\n    rows === 'auto' && 'grid-rows-auto',\n    getAutoFlowClass(),\n    justify && justifyClasses[justify],\n    align && alignClasses[align],\n    placeItems && placeItemsClasses[placeItems],\n    className\n  );\n\n  const gridStyle = {\n    ...(gap && typeof gap === 'object' ? {\n      columnGap: typeof gap.x === 'number' ? `${gap.x}px` : gap.x,\n      rowGap: typeof gap.y === 'number' ? `${gap.y}px` : gap.y,\n    } : gap && {\n      gap: typeof gap === 'number' ? `${gap}px` : gap,\n    }),\n    ...style,\n  };\n\n  return (\n    <Component\n      className={gridClasses}\n      style={gridStyle}\n      data-rtl={isRTL}\n      data-auto-flow={autoFlow}\n    >\n      {children}\n    </Component>\n  );\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/RTLLayout/RTLText.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'JSX' is not defined.",
        "line": 13,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 13,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * RTL-aware Text component that handles direction-based text alignment and typography\n */\n\nimport React from 'react';\nimport { cn } from '../../lib/utils';\nimport { useRTLText } from '../../hooks/useRTL';\n\ninterface RTLTextProps {\n  children: React.ReactNode;\n  className?: string;\n  align?: 'start' | 'end' | 'center' | 'justify';\n  as?: keyof JSX.IntrinsicElements;\n  size?: 'xs' | 'sm' | 'base' | 'lg' | 'xl' | '2xl' | '3xl' | '4xl' | '5xl' | '6xl';\n  weight?: 'thin' | 'light' | 'normal' | 'medium' | 'semibold' | 'bold' | 'extrabold' | 'black';\n  color?: string;\n  leading?: 'none' | 'tight' | 'snug' | 'normal' | 'relaxed' | 'loose';\n  tracking?: 'tighter' | 'tight' | 'normal' | 'wide' | 'wider' | 'widest';\n  truncate?: boolean | number;\n  dir?: 'ltr' | 'rtl' | 'auto';\n  style?: React.CSSProperties;\n}\n\nconst sizeClasses = {\n  xs: 'text-xs',\n  sm: 'text-sm',\n  base: 'text-base',\n  lg: 'text-lg',\n  xl: 'text-xl',\n  '2xl': 'text-2xl',\n  '3xl': 'text-3xl',\n  '4xl': 'text-4xl',\n  '5xl': 'text-5xl',\n  '6xl': 'text-6xl',\n};\n\nconst weightClasses = {\n  thin: 'font-thin',\n  light: 'font-light',\n  normal: 'font-normal',\n  medium: 'font-medium',\n  semibold: 'font-semibold',\n  bold: 'font-bold',\n  extrabold: 'font-extrabold',\n  black: 'font-black',\n};\n\nconst leadingClasses = {\n  none: 'leading-none',\n  tight: 'leading-tight',\n  snug: 'leading-snug',\n  normal: 'leading-normal',\n  relaxed: 'leading-relaxed',\n  loose: 'leading-loose',\n};\n\nconst trackingClasses = {\n  tighter: 'tracking-tighter',\n  tight: 'tracking-tight',\n  normal: 'tracking-normal',\n  wide: 'tracking-wide',\n  wider: 'tracking-wider',\n  widest: 'tracking-widest',\n};\n\nexport const RTLText: React.FC<RTLTextProps> = ({\n  children,\n  className,\n  align = 'start',\n  as: Component = 'span',\n  size = 'base',\n  weight = 'normal',\n  color,\n  leading = 'normal',\n  tracking = 'normal',\n  truncate = false,\n  dir = 'auto',\n  style,\n}) => {\n  const { text, isRTL } = useRTLText();\n\n  const textDir = dir === 'auto' ? text.direction : dir;\n\n  // Get alignment class based on RTL direction\n  const getAlignClass = () => {\n    switch (align) {\n      case 'start':\n        return text.alignClass('start');\n      case 'end':\n        return text.alignClass('end');\n      case 'center':\n        return 'text-center';\n      case 'justify':\n        return 'text-justify';\n      default:\n        return text.alignClass('start');\n    }\n  };\n\n  // Handle truncation\n  const getTruncateClass = () => {\n    if (truncate === true) {\n      return 'truncate';\n    }\n    if (typeof truncate === 'number') {\n      return `line-clamp-${truncate}`;\n    }\n    return '';\n  };\n\n  const textClasses = cn(\n    'rtl-text',\n    sizeClasses[size],\n    weightClasses[weight],\n    leadingClasses[leading],\n    trackingClasses[tracking],\n    getAlignClass(),\n    getTruncateClass(),\n    color && `text-${color}`,\n    className\n  );\n\n  const textStyle = {\n    direction: textDir,\n    unicodeBidi: isRTL ? 'embed' : 'normal',\n    ...style,\n  };\n\n  return (\n    <Component\n      className={textClasses}\n      style={textStyle}\n      dir={textDir}\n      data-rtl={isRTL}\n      data-align={align}\n    >\n      {children}\n    </Component>\n  );\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/RTLText.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'RTLText' is not defined.",
        "line": 1,
        "column": 16,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 1,
        "endColumn": 23
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "export default RTLText;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/SoundPreviewSystem.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'Loader2' is not defined.",
        "line": 637,
        "column": 24,
        "nodeType": "JSXIdentifier",
        "messageId": "undef",
        "endLine": 637,
        "endColumn": 31
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference types=\"node\" />\n/// <reference lib=\"dom\" />\nimport React, { useState, useRef, useEffect } from \"react\";\nimport {\n  Play,\n  Pause,\n  Square,\n  Volume2,\n  VolumeX,\n  RotateCcw,\n  Settings,\n  TestTube,\n  Speaker,\n  Headphones,\n  Music,\n  Timer,\n  Waves,\n  Zap\n} from 'lucide-react';\nimport { Card, CardContent, CardHeader, CardTitle } from './ui/card';\nimport { Button } from './ui/button';\nimport { Badge } from './ui/badge';\nimport { Slider } from './ui/slider';\nimport { Progress } from './ui/progress';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';\nimport { Switch } from './ui/switch';\nimport { Label } from './ui/label';\nimport { Separator } from './ui/separator';\nimport { soundEffectsService, SoundEffectId } from '../services/sound-effects';\nimport type {\n  CustomSoundTheme,\n  CustomSoundAssignment,\n  DemoSequence,\n  PreviewSound\n} from '../types/custom-sound-themes';\n\ninterface SoundPreviewSystemProps {\n  theme?: CustomSoundTheme;\n  onThemeTest?: (results: ThemeTestResults) => void;\n  className?: string;\n}\n\ninterface PlaybackState {\n  isPlaying: boolean;\n  currentTime: number;\n  duration: number;\n  volume: number;\n  loop: boolean;\n  fadeIn: number;\n  fadeOut: number;\n}\n\ninterface ThemeTestResults {\n  overallScore: number;\n  categoryScores: Record<string, number>;\n  issues: Array<{\n    category: string;\n    sound: string;\n    issue: string;\n    severity: 'low' | 'medium' | 'high';\n  }>;\n  recommendations: string[];\n}\n\ninterface SoundTest {\n  id: string;\n  name: string;\n  category: string;\n  description: string;\n  soundId?: SoundEffectId;\n  customAssignment?: CustomSoundAssignment;\n}\n\nconst THEME_TESTS: SoundTest[] = [\n  // UI Tests\n  { id: 'ui.click', name: 'Button Click', category: 'UI', description: 'Primary interface interaction', soundId: 'ui.click' },\n  { id: 'ui.hover', name: 'Hover Effect', category: 'UI', description: 'Element hover feedback', soundId: 'ui.hover' },\n  { id: 'ui.success', name: 'Success Action', category: 'UI', description: 'Successful operation feedback', soundId: 'ui.success' },\n  { id: 'ui.error', name: 'Error Alert', category: 'UI', description: 'Error state notification', soundId: 'ui.error' },\n\n  // Notification Tests\n  { id: 'notification.default', name: 'Default Notification', category: 'Notification', description: 'Standard app notification', soundId: 'notification.default' },\n  { id: 'notification.alarm', name: 'Alarm Notification', category: 'Notification', description: 'Important alarm alert', soundId: 'notification.alarm' },\n  { id: 'notification.urgent', name: 'Urgent Alert', category: 'Notification', description: 'High priority notification', soundId: 'notification.urgent' },\n\n  // Alarm Tests\n  { id: 'alarm.gentle', name: 'Gentle Wake-up', category: 'Alarm', description: 'Soft morning alarm', soundId: 'alarm.gentle_bells' },\n  { id: 'alarm.energetic', name: 'Energetic Wake-up', category: 'Alarm', description: 'High-energy morning alarm', soundId: 'alarm.energetic_beep' },\n  { id: 'alarm.nature', name: 'Nature Wake-up', category: 'Alarm', description: 'Natural sound alarm', soundId: 'alarm.morning_birds' },\n\n  // Ambient Tests\n  { id: 'ambient.focus', name: 'Focus Ambience', category: 'Ambient', description: 'Background focus sound', soundId: 'ambient.white_noise' },\n  { id: 'ambient.relax', name: 'Relaxation Ambience', category: 'Ambient', description: 'Calming background sound', soundId: 'ambient.brown_noise' }\n];\n\nconst DEMO_SCENARIOS = [\n  {\n    id: 'morning-routine',\n    name: 'Morning Routine',\n    description: 'Simulates a typical morning wake-up sequence',\n    steps: [\n      { sound: 'alarm.gentle', delay: 0, duration: 5000, description: 'Alarm starts gently' },\n      { sound: 'ui.click', delay: 5000, duration: 200, description: 'User dismisses alarm' },\n      { sound: 'ui.success', delay: 5200, duration: 500, description: 'Successful dismissal' },\n      { sound: 'notification.default', delay: 6000, duration: 1000, description: 'Morning notification' }\n    ]\n  },\n  {\n    id: 'focused-work',\n    name: 'Focused Work Session',\n    description: 'Demonstrates ambient sounds and notifications during work',\n    steps: [\n      { sound: 'ambient.focus', delay: 0, duration: 10000, description: 'Background focus ambience' },\n      { sound: 'notification.default', delay: 3000, duration: 500, description: 'Incoming notification' },\n      { sound: 'ui.click', delay: 4000, duration: 200, description: 'User interaction' },\n      { sound: 'notification.default', delay: 7000, duration: 500, description: 'Another notification' }\n    ]\n  },\n  {\n    id: 'error-recovery',\n    name: 'Error & Recovery',\n    description: 'Shows error handling and recovery sounds',\n    steps: [\n      { sound: 'ui.click', delay: 0, duration: 200, description: 'User action' },\n      { sound: 'ui.error', delay: 1000, duration: 800, description: 'Error occurs' },\n      { sound: 'ui.click', delay: 2500, duration: 200, description: 'Retry action' },\n      { sound: 'ui.success', delay: 3000, duration: 500, description: 'Successful recovery' }\n    ]\n  }\n];\n\nexport const SoundPreviewSystem: React.FC<SoundPreviewSystemProps> = ({\n  theme,\n  onThemeTest,\n  className = ''\n}) => {\n  const [activeTab, setActiveTab] = useState('individual');\n  const [playbackStates, setPlaybackStates] = useState<Map<string, PlaybackState>>(new Map());\n  const [globalVolume, setGlobalVolume] = useState(0.7);\n  const [isGlobalMuted, setIsGlobalMuted] = useState(false);\n  const [runningDemo, setRunningDemo] = useState<string | null>(null);\n  const [demoProgress, setDemoProgress] = useState(0);\n  const [testResults, setTestResults] = useState<ThemeTestResults | null>(null);\n  const [isRunningTest, setIsRunningTest] = useState(false);\n\n  const audioRefs = useRef<Map<string, HTMLAudioElement>>(new Map());\n  const intervalRefs = useRef<Map<string, number>>(new Map());\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      audioRefs.current.forEach(audio => {\n        if (!audio.paused) {\n          audio.pause();\n        }\n      });\n      intervalRefs.current.forEach(interval => {\n        clearInterval(interval);\n      });\n    };\n  }, []);\n\n  // Initialize playback states\n  const getPlaybackState = (soundId: string): PlaybackState => {\n    return playbackStates.get(soundId) || {\n      isPlaying: false,\n      currentTime: 0,\n      duration: 0,\n      volume: 0.8,\n      loop: false,\n      fadeIn: 0,\n      fadeOut: 0\n    };\n  };\n\n  const updatePlaybackState = (soundId: string, updates: Partial<PlaybackState>) => {\n    const currentState = getPlaybackState(soundId);\n    const newState = { ...currentState, ...updates };\n    setPlaybackStates(new Map(playbackStates.set(soundId, newState)));\n  };\n\n  // Audio management functions\n  const createAudio = (soundId: string, soundUrl: string): HTMLAudioElement => {\n    let audio = audioRefs.current.get(soundId);\n    if (!audio) {\n      audio = new Audio(soundUrl);\n      audioRefs.current.set(soundId, audio);\n\n      audio.addEventListener('loadedmetadata', () => {\n        updatePlaybackState(soundId, { duration: audio!.duration });\n      });\n\n      audio.addEventListener('timeupdate', () => {\n        updatePlaybackState(soundId, { currentTime: audio!.currentTime });\n      });\n\n      audio.addEventListener('ended', () => {\n        updatePlaybackState(soundId, { isPlaying: false, currentTime: 0 });\n      });\n    }\n    return audio;\n  };\n\n  const playSound = async (test: SoundTest, options: { loop?: boolean; fadeIn?: number } = {}) => {\n    try {\n      const soundUrl = await getSoundUrl(test);\n      if (!soundUrl) return;\n\n      // Stop other sounds unless it's ambient\n      if (test.category !== 'Ambient') {\n        stopAllSounds();\n      }\n\n      const audio = createAudio(test.id, soundUrl);\n      const state = getPlaybackState(test.id);\n\n      audio.volume = (state.volume * globalVolume) * (isGlobalMuted ? 0 : 1);\n      audio.loop = options.loop || state.loop;\n\n      // Apply fade in effect\n      if (options.fadeIn || state.fadeIn) {\n        audio.volume = 0;\n        audio.play();\n        fadeInAudio(audio, (state.volume * globalVolume) * (isGlobalMuted ? 0 : 1), options.fadeIn || state.fadeIn);\n      } else {\n        await audio.play();\n      }\n\n      updatePlaybackState(test.id, { isPlaying: true });\n\n      // Set up progress tracking\n      const interval = setInterval(() => {\n        if (audio.ended || audio.paused) {\n          clearInterval(interval);\n          intervalRefs.current.delete(test.id);\n        }\n      }, 100);\n      intervalRefs.current.set(test.id, interval);\n\n    } catch (error) {\n      console.error('Error playing sound:', error);\n    }\n  };\n\n  const pauseSound = (soundId: string) => {\n    const audio = audioRefs.current.get(soundId);\n    if (audio && !audio.paused) {\n      audio.pause();\n      updatePlaybackState(soundId, { isPlaying: false });\n    }\n  };\n\n  const stopSound = (soundId: string) => {\n    const audio = audioRefs.current.get(soundId);\n    if (audio) {\n      audio.pause();\n      audio.currentTime = 0;\n      updatePlaybackState(soundId, { isPlaying: false, currentTime: 0 });\n    }\n\n    const interval = intervalRefs.current.get(soundId);\n    if (interval) {\n      clearInterval(interval);\n      intervalRefs.current.delete(soundId);\n    }\n  };\n\n  const stopAllSounds = () => {\n    audioRefs.current.forEach((audio, soundId) => {\n      if (!audio.paused) {\n        stopSound(soundId);\n      }\n    });\n  };\n\n  const fadeInAudio = (audio: HTMLAudioElement, targetVolume: number, duration: number) => {\n    const steps = 20;\n    const stepVolume = targetVolume / steps;\n    const stepDuration = (duration * 1000) / steps;\n\n    let currentStep = 0;\n    const fadeInterval = setInterval(() => {\n      currentStep++;\n      audio.volume = Math.min(stepVolume * currentStep, targetVolume);\n\n      if (currentStep >= steps) {\n        clearInterval(fadeInterval);\n      }\n    }, stepDuration);\n  };\n\n  const getSoundUrl = async (test: SoundTest): Promise<string | null> => {\n    if (theme && test.customAssignment) {\n      return test.customAssignment.source;\n    } else if (test.soundId) {\n      const soundConfig = soundEffectsService.getSoundEffect(test.soundId);\n      return soundConfig?.url || null;\n    }\n    return null;\n  };\n\n  // Demo sequence functions\n  const runDemoSequence = async (demoId: string) => {\n    const demo = DEMO_SCENARIOS.find(d => d.id === demoId);\n    if (!demo) return;\n\n    setRunningDemo(demoId);\n    setDemoProgress(0);\n\n    const totalDuration = demo.steps.reduce((sum, step) => Math.max(sum, step.delay + step.duration), 0);\n\n    for (const step of demo.steps) {\n      setTimeout(async () => {\n        const test = THEME_TESTS.find(t => t.id === step.sound);\n        if (test) {\n          await playSound(test, { loop: step.duration > 3000 });\n\n          // Stop the sound after its duration\n          setTimeout(() => {\n            stopSound(test.id);\n          }, step.duration);\n        }\n      }, step.delay);\n    }\n\n    // Track progress\n    const progressInterval = setInterval(() => {\n      setDemoProgress(prev => {\n        const newProgress = prev + (100 / (totalDuration / 100));\n        if (newProgress >= 100) {\n          clearInterval(progressInterval);\n          setRunningDemo(null);\n          setDemoProgress(0);\n          return 100;\n        }\n        return newProgress;\n      });\n    }, 100);\n  };\n\n  const stopDemo = () => {\n    stopAllSounds();\n    setRunningDemo(null);\n    setDemoProgress(0);\n  };\n\n  // Theme testing functions\n  const runThemeTest = async () => {\n    setIsRunningTest(true);\n\n    const results: ThemeTestResults = {\n      overallScore: 0,\n      categoryScores: {},\n      issues: [],\n      recommendations: []\n    };\n\n    // Test each category\n    const categories = ['UI', 'Notification', 'Alarm', 'Ambient'];\n\n    for (const category of categories) {\n      const categoryTests = THEME_TESTS.filter(t => t.category === category);\n      let categoryScore = 0;\n\n      for (const test of categoryTests) {\n        try {\n          const soundUrl = await getSoundUrl(test);\n          if (soundUrl) {\n            categoryScore += 25; // Each working sound adds to score\n          } else {\n            results.issues.push({\n              category,\n              sound: test.name,\n              issue: 'Sound not configured',\n              severity: 'medium'\n            });\n          }\n        } catch (error) {\n          results.issues.push({\n            category,\n            sound: test.name,\n            issue: 'Failed to load sound',\n            severity: 'high'\n          });\n        }\n      }\n\n      results.categoryScores[category] = Math.min(categoryScore, 100);\n    }\n\n    // Calculate overall score\n    const scores = Object.values(results.categoryScores);\n    results.overallScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;\n\n    // Generate recommendations\n    if (results.overallScore < 60) {\n      results.recommendations.push('Consider configuring more sounds for better user experience');\n    }\n    if (results.issues.filter(i => i.severity === 'high').length > 0) {\n      results.recommendations.push('Fix critical sound loading issues');\n    }\n    if (results.categoryScores['UI'] < 80) {\n      results.recommendations.push('Ensure all essential UI sounds are configured');\n    }\n\n    setTestResults(results);\n    onThemeTest?.(results);\n    setIsRunningTest(false);\n  };\n\n  const formatTime = (seconds: number): string => {\n    const mins = Math.floor(seconds / 60);\n    const secs = Math.floor(seconds % 60);\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  return (\n    <div className={`space-y-6 ${className}`}>\n      {/* Global Controls */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-2\">\n              <Speaker className=\"w-5 h-5\" />\n              Preview Controls\n            </div>\n            <div className=\"flex items-center gap-2\">\n              <Button\n                size=\"sm\"\n                variant=\"outline\"\n                onClick={stopAllSounds}\n              >\n                <Square className=\"w-4 h-4 mr-2\" />\n                Stop All\n              </Button>\n              <Button\n                size=\"sm\"\n                variant=\"outline\"\n                onClick={() => setIsGlobalMuted(!isGlobalMuted)}\n              >\n                {isGlobalMuted ? <VolumeX className=\"w-4 h-4\" /> : <Volume2 className=\"w-4 h-4\" />}\n              </Button>\n            </div>\n          </CardTitle>\n        </CardHeader>\n        <CardContent>\n          <div className=\"space-y-4\">\n            <div className=\"flex items-center gap-4\">\n              <Label className=\"w-20\">Volume:</Label>\n              <Slider\n                value={[globalVolume]}\n                onValueChange={([value]) => setGlobalVolume(value)}\n                max={1}\n                step={0.01}\n                className=\"flex-1\"\n              />\n              <span className=\"w-12 text-sm\">{Math.round(globalVolume * 100)}%</span>\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Main Preview Interface */}\n      <Card>\n        <CardContent className=\"p-0\">\n          <Tabs value={activeTab} onValueChange={setActiveTab}>\n            <div className=\"p-6 pb-0\">\n              <TabsList>\n                <TabsTrigger value=\"individual\">Individual Sounds</TabsTrigger>\n                <TabsTrigger value=\"sequences\">Demo Sequences</TabsTrigger>\n                <TabsTrigger value=\"testing\">Theme Testing</TabsTrigger>\n              </TabsList>\n            </div>\n\n            {/* Individual Sound Testing */}\n            <TabsContent value=\"individual\" className=\"p-6 space-y-4\">\n              <div className=\"grid gap-4\">\n                {['UI', 'Notification', 'Alarm', 'Ambient'].map(category => {\n                  const categoryTests = THEME_TESTS.filter(t => t.category === category);\n                  return (\n                    <Card key={category}>\n                      <CardHeader className=\"pb-4\">\n                        <CardTitle className=\"text-base\">{category} Sounds</CardTitle>\n                      </CardHeader>\n                      <CardContent className=\"space-y-3\">\n                        {categoryTests.map(test => {\n                          const state = getPlaybackState(test.id);\n                          return (\n                            <div key={test.id} className=\"flex items-center gap-3 p-3 border rounded-lg\">\n                              <Button\n                                size=\"sm\"\n                                variant=\"outline\"\n                                onClick={() => state.isPlaying ? pauseSound(test.id) : playSound(test)}\n                              >\n                                {state.isPlaying ? <Pause className=\"w-4 h-4\" /> : <Play className=\"w-4 h-4\" />}\n                              </Button>\n\n                              <div className=\"flex-1 min-w-0\">\n                                <div className=\"flex items-center gap-2 mb-1\">\n                                  <h4 className=\"font-medium\">{test.name}</h4>\n                                  <Badge variant=\"secondary\" className=\"text-xs\">\n                                    {test.category}\n                                  </Badge>\n                                </div>\n                                <p className=\"text-sm text-gray-600\">{test.description}</p>\n\n                                {state.duration > 0 && (\n                                  <div className=\"mt-2 space-y-1\">\n                                    <div className=\"flex justify-between text-xs text-gray-500\">\n                                      <span>{formatTime(state.currentTime)}</span>\n                                      <span>{formatTime(state.duration)}</span>\n                                    </div>\n                                    <Progress value={(state.currentTime / state.duration) * 100} className=\"h-1\" />\n                                  </div>\n                                )}\n                              </div>\n\n                              <div className=\"flex items-center gap-2\">\n                                <div className=\"w-20\">\n                                  <Slider\n                                    value={[state.volume]}\n                                    onValueChange={([value]) => {\n                                      updatePlaybackState(test.id, { volume: value });\n                                      const audio = audioRefs.current.get(test.id);\n                                      if (audio) {\n                                        audio.volume = value * globalVolume * (isGlobalMuted ? 0 : 1);\n                                      }\n                                    }}\n                                    max={1}\n                                    step={0.01}\n                                    className=\"w-full\"\n                                  />\n                                </div>\n\n                                <Button\n                                  size=\"sm\"\n                                  variant=\"outline\"\n                                  onClick={() => {\n                                    const newLoop = !state.loop;\n                                    updatePlaybackState(test.id, { loop: newLoop });\n                                    const audio = audioRefs.current.get(test.id);\n                                    if (audio) {\n                                      audio.loop = newLoop;\n                                    }\n                                  }}\n                                  className={state.loop ? 'bg-blue-50' : ''}\n                                >\n                                  <RotateCcw className=\"w-4 h-4\" />\n                                </Button>\n\n                                <Button\n                                  size=\"sm\"\n                                  variant=\"outline\"\n                                  onClick={() => stopSound(test.id)}\n                                  disabled={!state.isPlaying}\n                                >\n                                  <Square className=\"w-4 h-4\" />\n                                </Button>\n                              </div>\n                            </div>\n                          );\n                        })}\n                      </CardContent>\n                    </Card>\n                  );\n                })}\n              </div>\n            </TabsContent>\n\n            {/* Demo Sequences */}\n            <TabsContent value=\"sequences\" className=\"p-6 space-y-4\">\n              <div className=\"space-y-4\">\n                {DEMO_SCENARIOS.map(demo => (\n                  <Card key={demo.id}>\n                    <CardHeader>\n                      <div className=\"flex items-center justify-between\">\n                        <div>\n                          <CardTitle className=\"text-base\">{demo.name}</CardTitle>\n                          <p className=\"text-sm text-gray-600 mt-1\">{demo.description}</p>\n                        </div>\n                        <div className=\"flex items-center gap-2\">\n                          {runningDemo === demo.id ? (\n                            <>\n                              <div className=\"w-32\">\n                                <Progress value={demoProgress} className=\"h-2\" />\n                              </div>\n                              <Button size=\"sm\" variant=\"outline\" onClick={stopDemo}>\n                                <Square className=\"w-4 h-4 mr-2\" />\n                                Stop\n                              </Button>\n                            </>\n                          ) : (\n                            <Button\n                              size=\"sm\"\n                              onClick={() => runDemoSequence(demo.id)}\n                              disabled={runningDemo !== null}\n                            >\n                              <Play className=\"w-4 h-4 mr-2\" />\n                              Run Demo\n                            </Button>\n                          )}\n                        </div>\n                      </div>\n                    </CardHeader>\n                    <CardContent>\n                      <div className=\"space-y-2\">\n                        {demo.steps.map((step, index) => (\n                          <div key={index} className=\"flex items-center gap-3 text-sm\">\n                            <Badge variant=\"outline\" className=\"text-xs w-8 h-6 flex items-center justify-center\">\n                              {index + 1}\n                            </Badge>\n                            <span className=\"text-gray-500\">{step.delay / 1000}s</span>\n                            <span className=\"font-medium\">{step.description}</span>\n                            <span className=\"text-gray-500\">({step.duration / 1000}s)</span>\n                          </div>\n                        ))}\n                      </div>\n                    </CardContent>\n                  </Card>\n                ))}\n              </div>\n            </TabsContent>\n\n            {/* Theme Testing */}\n            <TabsContent value=\"testing\" className=\"p-6 space-y-6\">\n              <div className=\"text-center\">\n                <TestTube className=\"w-12 h-12 mx-auto mb-4 text-blue-500\" />\n                <h3 className=\"text-lg font-medium mb-2\">Theme Quality Testing</h3>\n                <p className=\"text-gray-600 mb-6\">\n                  Test your theme's completeness and functionality across all sound categories\n                </p>\n\n                <Button onClick={runThemeTest} disabled={isRunningTest} size=\"lg\">\n                  {isRunningTest ? (\n                    <>\n                      <Loader2 className=\"w-4 h-4 mr-2 animate-spin\" />\n                      Running Tests...\n                    </>\n                  ) : (\n                    <>\n                      <TestTube className=\"w-4 h-4 mr-2\" />\n                      Run Theme Test\n                    </>\n                  )}\n                </Button>\n              </div>\n\n              {testResults && (\n                <Card>\n                  <CardHeader>\n                    <CardTitle className=\"flex items-center justify-between\">\n                      Test Results\n                      <Badge\n                        variant={testResults.overallScore >= 80 ? 'default' :\n                                testResults.overallScore >= 60 ? 'secondary' : 'destructive'}\n                      >\n                        {Math.round(testResults.overallScore)}%\n                      </Badge>\n                    </CardTitle>\n                  </CardHeader>\n                  <CardContent className=\"space-y-6\">\n                    {/* Category Scores */}\n                    <div>\n                      <h4 className=\"font-medium mb-3\">Category Scores</h4>\n                      <div className=\"space-y-2\">\n                        {Object.entries(testResults.categoryScores).map(([category, score]) => (\n                          <div key={category} className=\"flex items-center gap-3\">\n                            <span className=\"w-20 text-sm\">{category}</span>\n                            <Progress value={score} className=\"flex-1\" />\n                            <span className=\"w-12 text-sm text-right\">{Math.round(score)}%</span>\n                          </div>\n                        ))}\n                      </div>\n                    </div>\n\n                    {/* Issues */}\n                    {testResults.issues.length > 0 && (\n                      <div>\n                        <h4 className=\"font-medium mb-3\">Issues Found</h4>\n                        <div className=\"space-y-2\">\n                          {testResults.issues.map((issue, index) => (\n                            <div\n                              key={index}\n                              className={`p-3 rounded-lg border ${\n                                issue.severity === 'high' ? 'bg-red-50 border-red-200' :\n                                issue.severity === 'medium' ? 'bg-yellow-50 border-yellow-200' :\n                                'bg-gray-50 border-gray-200'\n                              }`}\n                            >\n                              <div className=\"flex items-center gap-2 mb-1\">\n                                <Badge\n                                  variant={issue.severity === 'high' ? 'destructive' : 'secondary'}\n                                  className=\"text-xs\"\n                                >\n                                  {issue.severity}\n                                </Badge>\n                                <span className=\"font-medium text-sm\">{issue.category} - {issue.sound}</span>\n                              </div>\n                              <p className=\"text-sm text-gray-600\">{issue.issue}</p>\n                            </div>\n                          ))}\n                        </div>\n                      </div>\n                    )}\n\n                    {/* Recommendations */}\n                    {testResults.recommendations.length > 0 && (\n                      <div>\n                        <h4 className=\"font-medium mb-3\">Recommendations</h4>\n                        <ul className=\"space-y-1\">\n                          {testResults.recommendations.map((rec, index) => (\n                            <li key={index} className=\"text-sm text-gray-600 flex items-start gap-2\">\n                              <span className=\"text-blue-500 mt-1\">‚Ä¢</span>\n                              {rec}\n                            </li>\n                          ))}\n                        </ul>\n                      </div>\n                    )}\n                  </CardContent>\n                </Card>\n              )}\n            </TabsContent>\n          </Tabs>\n        </CardContent>\n      </Card>\n    </div>\n  );\n};\n\nexport default SoundPreviewSystem;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/SoundSettings.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'soundEffectsService' is not defined.",
        "line": 118,
        "column": 32,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 118,
        "endColumn": 51
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Sound Settings Component\n * Provides comprehensive controls for all sound effects in the app\n */\n\nimport React, { useState, useEffect } from 'react';\nimport { Volume2, VolumeX, Volume1, Settings as SettingsIcon, Play, Pause, TestTube, Check, X, Palette, Plus, Edit3, Music } from 'lucide-react';\nimport { Switch } from './ui/switch';\nimport { Button } from './ui/button';\nimport { Slider } from './ui/slider';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from './ui/card';\nimport { Badge } from './ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from './ui/tabs';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from './ui/dialog';\nimport useSoundEffects, { useUISound, useNotificationSounds, useAlarmSounds } from '../hooks/useSoundEffects';\nimport type { SoundEffectId, SoundTheme } from '../services/sound-effects';\nimport CustomSoundThemeCreator from './CustomSoundThemeCreator';\nimport CustomThemeManager from './CustomThemeManager';\n\ninterface SoundSettingsProps {\n  className?: string;\n  userId?: string;\n}\n\nconst SoundSettings: React.FC<SoundSettingsProps> = ({ className, userId }) => {\n  const {\n    settings,\n    updateSettings,\n    testSound,\n    isInitialized,\n    stopAllSounds,\n    setSoundTheme,\n    getSoundTheme,\n    getAvailableThemes,\n    previewTheme,\n  } = useSoundEffects();\n\n  const { soundsEnabled: uiSoundsEnabled } = useUISound();\n  const { soundsEnabled: notificationSoundsEnabled } = useNotificationSounds();\n  const { soundsEnabled: alarmSoundsEnabled } = useAlarmSounds();\n\n  const [testResults, setTestResults] = useState<{ [key: string]: boolean | null }>({});\n  const [isTestingAll, setIsTestingAll] = useState(false);\n  const [availableThemes, setAvailableThemes] = useState(getAvailableThemes());\n  const [customThemes, setCustomThemes] = useState<any[]>([]);\n  const [allThemes, setAllThemes] = useState(getAvailableThemes());\n  const [showCustomThemeCreator, setShowCustomThemeCreator] = useState(false);\n  const [showCustomThemeManager, setShowCustomThemeManager] = useState(false);\n\n  // Volume change handlers\n  const handleVolumeChange = async (category: string, value: number[]) => {\n    const volume = value[0] / 100;\n\n    switch (category) {\n      case 'master':\n        await updateSettings({ masterVolume: volume });\n        break;\n      case 'ui':\n        await updateSettings({ uiVolume: volume });\n        break;\n      case 'notification':\n        await updateSettings({ notificationVolume: volume });\n        break;\n      case 'alarm':\n        await updateSettings({ alarmVolume: volume });\n        break;\n      case 'ambient':\n        await updateSettings({ ambientVolume: volume });\n        break;\n    }\n  };\n\n  // Toggle handlers\n  const handleToggleCategory = async (category: string, enabled: boolean) => {\n    switch (category) {\n      case 'ui':\n        await updateSettings({ uiSoundsEnabled: enabled });\n        break;\n      case 'notification':\n        await updateSettings({ notificationSoundsEnabled: enabled });\n        break;\n      case 'alarm':\n        await updateSettings({ alarmSoundsEnabled: enabled });\n        break;\n      case 'ambient':\n        await updateSettings({ ambientSoundsEnabled: enabled });\n        break;\n    }\n  };\n\n  // Theme selection handler\n  const handleThemeChange = async (theme: SoundTheme) => {\n    try {\n      await setSoundTheme(theme);\n    } catch (error) {\n      console.error('Error changing theme:', error);\n    }\n  };\n\n  // Preview theme handler\n  const handleThemePreview = async (theme: SoundTheme) => {\n    try {\n      await previewTheme(theme);\n    } catch (error) {\n      console.error('Error previewing theme:', error);\n    }\n  };\n\n  // Load custom themes\n  const loadCustomThemes = async () => {\n    if (!userId) {\n      setCustomThemes([]);\n      return;\n    }\n\n    try {\n      const userCustomThemes = soundEffectsService.getCustomThemesByUser(userId);\n      // Transform custom themes to match built-in theme format\n      const transformedThemes = userCustomThemes.map(theme => ({\n        id: theme.id,\n        name: theme.displayName || theme.name,\n        description: theme.description || 'Custom theme',\n        category: 'custom',\n        isCustom: true\n      }));\n      setCustomThemes(transformedThemes);\n    } catch (error) {\n      console.error('Error loading custom themes:', error);\n      setCustomThemes([]);\n    }\n  };\n\n  const refreshThemes = () => {\n    setAvailableThemes(getAvailableThemes());\n    loadCustomThemes();\n  };\n\n  // Load custom themes on component mount\n  useEffect(() => {\n    loadCustomThemes();\n  }, [userId]);\n\n  // Combine built-in themes with custom themes\n  useEffect(() => {\n    const combined = [...availableThemes, ...customThemes];\n    setAllThemes(combined);\n  }, [availableThemes, customThemes]);\n\n  // Test individual sound\n  const handleTestSound = async (soundId: SoundEffectId) => {\n    setTestResults(prev => ({ ...prev, [soundId]: null }));\n\n    try {\n      const result = await testSound(soundId);\n      setTestResults(prev => ({ ...prev, [soundId]: result }));\n\n      // Clear result after 3 seconds\n      setTimeout(() => {\n        setTestResults(prev => ({ ...prev, [soundId]: null }));\n      }, 3000);\n    } catch (error) {\n      setTestResults(prev => ({ ...prev, [soundId]: false }));\n    }\n  };\n\n  // Test all sounds\n  const handleTestAllSounds = async () => {\n    setIsTestingAll(true);\n    const allSounds: SoundEffectId[] = [\n      'ui.click', 'ui.hover', 'ui.success', 'ui.error',\n      'notification.default', 'notification.alarm', 'notification.beep',\n      'alarm.gentle_bells', 'alarm.morning_birds', 'alarm.classic_beep',\n      'alarm.ocean_waves', 'alarm.energetic_beep'\n    ];\n\n    for (const soundId of allSounds) {\n      await handleTestSound(soundId);\n      await new Promise(resolve => setTimeout(resolve, 800)); // Delay between tests\n    }\n\n    setIsTestingAll(false);\n  };\n\n  const VolumeIcon = ({ volume }: { volume: number }) => {\n    if (volume === 0) return <VolumeX className=\"w-4 h-4\" />;\n    if (volume < 0.5) return <Volume1 className=\"w-4 h-4\" />;\n    return <Volume2 className=\"w-4 h-4\" />;\n  };\n\n  const TestButton = ({ soundId, label }: { soundId: SoundEffectId; label: string }) => {\n    const result = testResults[soundId];\n\n    return (\n      <Button\n        variant=\"outline\"\n        size=\"sm\"\n        onClick={() => handleTestSound(soundId)}\n        disabled={isTestingAll}\n        className=\"min-w-[80px]\"\n      >\n        <Play className=\"w-3 h-3 mr-1\" />\n        Test\n        {result === true && <Check className=\"w-3 h-3 ml-1 text-green-500\" />}\n        {result === false && <X className=\"w-3 h-3 ml-1 text-red-500\" />}\n      </Button>\n    );\n  };\n\n  if (!isInitialized) {\n    return (\n      <Card className={className}>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Volume2 className=\"w-5 h-5\" />\n            Sound Effects\n          </CardTitle>\n          <CardDescription>Loading sound system...</CardDescription>\n        </CardHeader>\n      </Card>\n    );\n  }\n\n  return (\n    <Card className={className}>\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2\">\n          <Volume2 className=\"w-5 h-5\" />\n          Sound Effects\n          <Badge variant={settings.masterVolume > 0 ? 'default' : 'secondary'}>\n            {settings.masterVolume > 0 ? 'Enabled' : 'Muted'}\n          </Badge>\n        </CardTitle>\n        <CardDescription>\n          Configure sound effects for different parts of the app\n        </CardDescription>\n      </CardHeader>\n\n      <CardContent className=\"space-y-6\">\n        {/* Master Volume Control */}\n        <div className=\"space-y-4\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-2\">\n              <VolumeIcon volume={settings.masterVolume} />\n              <span className=\"text-sm font-medium\">Master Volume</span>\n            </div>\n            <span className=\"text-xs text-muted-foreground\">\n              {Math.round(settings.masterVolume * 100)}%\n            </span>\n          </div>\n          <Slider\n            value={[settings.masterVolume * 100]}\n            onValueChange={(value) => handleVolumeChange('master', value)}\n            max={100}\n            step={5}\n            className=\"w-full\"\n          />\n        </div>\n\n        {/* Theme Selector */}\n        <div className=\"space-y-4\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-2\">\n              <Palette className=\"w-4 h-4\" />\n              <span className=\"text-sm font-medium\">Sound Theme</span>\n            </div>\n            <Badge variant=\"outline\">\n              {allThemes.find(theme => theme.id === settings.soundTheme)?.name || 'Default'}\n            </Badge>\n          </div>\n          <div className=\"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-2\">\n            {allThemes.map(theme => (\n              <Card\n                key={theme.id}\n                className={`cursor-pointer transition-colors ${\n                  settings.soundTheme === theme.id\n                    ? 'border-primary bg-primary/10'\n                    : 'hover:border-primary/50'\n                }`}\n                onClick={() => handleThemeChange(theme.id)}\n              >\n                <CardContent className=\"p-3\">\n                  <div className=\"flex items-center justify-between\">\n                    <div>\n                      <div className=\"flex items-center gap-2\">\n                        <h4 className=\"text-sm font-medium\">{theme.name}</h4>\n                        {theme.isCustom && (\n                          <Badge variant=\"secondary\" className=\"text-xs\">Custom</Badge>\n                        )}\n                      </div>\n                      <p className=\"text-xs text-muted-foreground\">{theme.description}</p>\n                    </div>\n                    {settings.soundTheme !== theme.id && (\n                      <Button\n                        variant=\"ghost\"\n                        size=\"sm\"\n                        onClick={e => {\n                          e.stopPropagation();\n                          handleThemePreview(theme.id);\n                        }}\n                        className=\"p-1 h-6 w-6\"\n                      >\n                        <Play className=\"w-3 h-3\" />\n                      </Button>\n                    )}\n                  </div>\n                </CardContent>\n              </Card>\n            ))}\n          </div>\n          <div className=\"flex items-center justify-between\">\n            <p className=\"text-xs text-muted-foreground\">\n              Click on a theme to apply it, or use the play button to preview.\n            </p>\n            <div className=\"flex gap-2\">\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => setShowCustomThemeManager(true)}\n                className=\"text-xs\"\n              >\n                <Music className=\"w-3 h-3 mr-1\" />\n                My Themes\n              </Button>\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={() => setShowCustomThemeCreator(true)}\n                className=\"text-xs\"\n              >\n                <Plus className=\"w-3 h-3 mr-1\" />\n                Create Custom\n              </Button>\n            </div>\n          </div>\n        </div>\n\n        <Tabs defaultValue=\"categories\" className=\"w-full\">\n          <TabsList className=\"grid w-full grid-cols-4\">\n            <TabsTrigger value=\"categories\">Categories</TabsTrigger>\n            <TabsTrigger value=\"sounds\">Individual Sounds</TabsTrigger>\n            <TabsTrigger value=\"custom\">Custom Themes</TabsTrigger>\n            <TabsTrigger value=\"test\">Testing</TabsTrigger>\n          </TabsList>\n\n          {/* Sound Categories Tab */}\n          <TabsContent value=\"categories\" className=\"space-y-4\">\n            {/* UI Sounds */}\n            <Card>\n              <CardHeader>\n                <div className=\"flex items-center justify-between\">\n                  <div>\n                    <CardTitle className=\"text-base\">UI Sounds</CardTitle>\n                    <CardDescription className=\"text-xs\">\n                      Button clicks, hover effects, success/error feedback\n                    </CardDescription>\n                  </div>\n                  <Switch\n                    checked={settings.uiSoundsEnabled}\n                    onCheckedChange={(enabled) => handleToggleCategory('ui', enabled)}\n                  />\n                </div>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-3\">\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Volume</span>\n                    <span className=\"text-xs text-muted-foreground\">\n                      {Math.round(settings.uiVolume * 100)}%\n                    </span>\n                  </div>\n                  <Slider\n                    value={[settings.uiVolume * 100]}\n                    onValueChange={(value) => handleVolumeChange('ui', value)}\n                    max={100}\n                    step={5}\n                    disabled={!settings.uiSoundsEnabled}\n                  />\n                </div>\n              </CardContent>\n            </Card>\n\n            {/* Notification Sounds */}\n            <Card>\n              <CardHeader>\n                <div className=\"flex items-center justify-between\">\n                  <div>\n                    <CardTitle className=\"text-base\">Notifications</CardTitle>\n                    <CardDescription className=\"text-xs\">\n                      Push notifications, system alerts\n                    </CardDescription>\n                  </div>\n                  <Switch\n                    checked={settings.notificationSoundsEnabled}\n                    onCheckedChange={(enabled) => handleToggleCategory('notification', enabled)}\n                  />\n                </div>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-3\">\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Volume</span>\n                    <span className=\"text-xs text-muted-foreground\">\n                      {Math.round(settings.notificationVolume * 100)}%\n                    </span>\n                  </div>\n                  <Slider\n                    value={[settings.notificationVolume * 100]}\n                    onValueChange={(value) => handleVolumeChange('notification', value)}\n                    max={100}\n                    step={5}\n                    disabled={!settings.notificationSoundsEnabled}\n                  />\n                </div>\n              </CardContent>\n            </Card>\n\n            {/* Alarm Sounds */}\n            <Card>\n              <CardHeader>\n                <div className=\"flex items-center justify-between\">\n                  <div>\n                    <CardTitle className=\"text-base\">Alarms</CardTitle>\n                    <CardDescription className=\"text-xs\">\n                      Alarm tones and wake-up sounds\n                    </CardDescription>\n                  </div>\n                  <Switch\n                    checked={settings.alarmSoundsEnabled}\n                    onCheckedChange={(enabled) => handleToggleCategory('alarm', enabled)}\n                  />\n                </div>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-3\">\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Volume</span>\n                    <span className=\"text-xs text-muted-foreground\">\n                      {Math.round(settings.alarmVolume * 100)}%\n                    </span>\n                  </div>\n                  <Slider\n                    value={[settings.alarmVolume * 100]}\n                    onValueChange={(value) => handleVolumeChange('alarm', value)}\n                    max={100}\n                    step={5}\n                    disabled={!settings.alarmSoundsEnabled}\n                  />\n                </div>\n              </CardContent>\n            </Card>\n\n            {/* Ambient Sounds */}\n            <Card>\n              <CardHeader>\n                <div className=\"flex items-center justify-between\">\n                  <div>\n                    <CardTitle className=\"text-base\">Ambient Sounds</CardTitle>\n                    <CardDescription className=\"text-xs\">\n                      Background sounds and environmental audio\n                    </CardDescription>\n                  </div>\n                  <Switch\n                    checked={settings.ambientSoundsEnabled}\n                    onCheckedChange={(enabled) => handleToggleCategory('ambient', enabled)}\n                  />\n                </div>\n              </CardHeader>\n              <CardContent>\n                <div className=\"space-y-3\">\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Volume</span>\n                    <span className=\"text-xs text-muted-foreground\">\n                      {Math.round(settings.ambientVolume * 100)}%\n                    </span>\n                  </div>\n                  <Slider\n                    value={[settings.ambientVolume * 100]}\n                    onValueChange={(value) => handleVolumeChange('ambient', value)}\n                    max={100}\n                    step={5}\n                    disabled={!settings.ambientSoundsEnabled}\n                  />\n                </div>\n              </CardContent>\n            </Card>\n          </TabsContent>\n\n          {/* Individual Sounds Tab */}\n          <TabsContent value=\"sounds\" className=\"space-y-4\">\n            {/* UI Sounds */}\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"text-base\">UI Sound Effects</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"grid grid-cols-1 gap-3\">\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Click Sound</span>\n                    <TestButton soundId=\"ui.click\" label=\"Click\" />\n                  </div>\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Hover Sound</span>\n                    <TestButton soundId=\"ui.hover\" label=\"Hover\" />\n                  </div>\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Success Sound</span>\n                    <TestButton soundId=\"ui.success\" label=\"Success\" />\n                  </div>\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Error Sound</span>\n                    <TestButton soundId=\"ui.error\" label=\"Error\" />\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n\n            {/* Notification Sounds */}\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"text-base\">Notification Sounds</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"grid grid-cols-1 gap-3\">\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Default Notification</span>\n                    <TestButton soundId=\"notification.default\" label=\"Notification\" />\n                  </div>\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Alarm Notification</span>\n                    <TestButton soundId=\"notification.alarm\" label=\"Alarm\" />\n                  </div>\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Beep</span>\n                    <TestButton soundId=\"notification.beep\" label=\"Beep\" />\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n\n            {/* Alarm Sounds */}\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"text-base\">Alarm Sounds</CardTitle>\n              </CardHeader>\n              <CardContent>\n                <div className=\"grid grid-cols-1 gap-3\">\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Gentle Bells</span>\n                    <TestButton soundId=\"alarm.gentle_bells\" label=\"Bells\" />\n                  </div>\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Morning Birds</span>\n                    <TestButton soundId=\"alarm.morning_birds\" label=\"Birds\" />\n                  </div>\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Classic Beep</span>\n                    <TestButton soundId=\"alarm.classic_beep\" label=\"Classic\" />\n                  </div>\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Ocean Waves</span>\n                    <TestButton soundId=\"alarm.ocean_waves\" label=\"Ocean\" />\n                  </div>\n                  <div className=\"flex items-center justify-between\">\n                    <span className=\"text-sm\">Energetic Beep</span>\n                    <TestButton soundId=\"alarm.energetic_beep\" label=\"Energetic\" />\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n          </TabsContent>\n\n          {/* Custom Themes Tab */}\n          <TabsContent value=\"custom\" className=\"space-y-4\">\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"text-base flex items-center gap-2\">\n                  <Palette className=\"w-4 h-4\" />\n                  Custom Sound Themes\n                </CardTitle>\n                <CardDescription>\n                  Create and manage your own personalized sound themes\n                </CardDescription>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <div className=\"grid grid-cols-1 sm:grid-cols-2 gap-4\">\n                  <Card className=\"cursor-pointer hover:border-primary/50 transition-colors\" onClick={() => setShowCustomThemeCreator(true)}>\n                    <CardContent className=\"p-4 text-center\">\n                      <Plus className=\"w-8 h-8 mx-auto mb-2 text-muted-foreground\" />\n                      <h4 className=\"font-medium\">Create New Theme</h4>\n                      <p className=\"text-xs text-muted-foreground mt-1\">Design your own custom sound experience</p>\n                    </CardContent>\n                  </Card>\n\n                  <Card className=\"cursor-pointer hover:border-primary/50 transition-colors\" onClick={() => setShowCustomThemeManager(true)}>\n                    <CardContent className=\"p-4 text-center\">\n                      <Music className=\"w-8 h-8 mx-auto mb-2 text-muted-foreground\" />\n                      <h4 className=\"font-medium\">Manage Themes</h4>\n                      <p className=\"text-xs text-muted-foreground mt-1\">Edit, share, and organize your themes</p>\n                    </CardContent>\n                  </Card>\n                </div>\n\n                <div className=\"p-4 bg-muted rounded-lg\">\n                  <h4 className=\"font-medium mb-2 flex items-center gap-2\">\n                    <Edit3 className=\"w-4 h-4\" />\n                    Custom Theme Features\n                  </h4>\n                  <ul className=\"text-sm text-muted-foreground space-y-1\">\n                    <li>‚Ä¢ Upload your own sound files (MP3, WAV, OGG)</li>\n                    <li>‚Ä¢ Mix and match sounds from different sources</li>\n                    <li>‚Ä¢ Preview themes before applying them</li>\n                    <li>‚Ä¢ Share themes with the community</li>\n                    <li>‚Ä¢ Import themes from other users</li>\n                    <li>‚Ä¢ Sync themes across all your devices</li>\n                  </ul>\n                </div>\n              </CardContent>\n            </Card>\n          </TabsContent>\n\n          {/* Testing Tab */}\n          <TabsContent value=\"test\" className=\"space-y-4\">\n            <Card>\n              <CardHeader>\n                <CardTitle className=\"text-base\">Sound System Testing</CardTitle>\n                <CardDescription>\n                  Test all sound effects to ensure they're working properly\n                </CardDescription>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <div className=\"flex gap-2\">\n                  <Button\n                    onClick={handleTestAllSounds}\n                    disabled={isTestingAll}\n                    className=\"flex-1\"\n                  >\n                    <TestTube className=\"w-4 h-4 mr-2\" />\n                    {isTestingAll ? 'Testing All Sounds...' : 'Test All Sounds'}\n                  </Button>\n                  <Button\n                    variant=\"outline\"\n                    onClick={stopAllSounds}\n                  >\n                    <Pause className=\"w-4 h-4 mr-2\" />\n                    Stop All\n                  </Button>\n                </div>\n\n                {Object.keys(testResults).length > 0 && (\n                  <div className=\"p-3 bg-muted rounded-lg\">\n                    <h4 className=\"text-sm font-medium mb-2\">Test Results</h4>\n                    <div className=\"grid grid-cols-2 gap-1 text-xs\">\n                      {Object.entries(testResults).map(([soundId, result]) => (\n                        <div key={soundId} className=\"flex items-center justify-between\">\n                          <span className=\"truncate\">{soundId.replace(/^(ui|notification|alarm)\\./, '')}</span>\n                          {result === true && <Check className=\"w-3 h-3 text-green-500\" />}\n                          {result === false && <X className=\"w-3 h-3 text-red-500\" />}\n                          {result === null && <div className=\"w-3 h-3 bg-muted-foreground rounded-full animate-pulse\" />}\n                        </div>\n                      ))}\n                    </div>\n                  </div>\n                )}\n              </CardContent>\n            </Card>\n          </TabsContent>\n        </Tabs>\n\n        {/* Custom Sound Theme Creator Modal */}\n        <Dialog open={showCustomThemeCreator} onOpenChange={setShowCustomThemeCreator}>\n          <DialogContent className=\"max-w-6xl max-h-[90vh] overflow-hidden\">\n            <DialogHeader>\n              <DialogTitle className=\"flex items-center gap-2\">\n                <Palette className=\"w-5 h-5\" />\n                Create Custom Sound Theme\n              </DialogTitle>\n            </DialogHeader>\n            <div className=\"overflow-y-auto\">\n              <CustomSoundThemeCreator\n                userId={userId}\n                onClose={() => setShowCustomThemeCreator(false)}\n                onThemeCreated={theme => {\n                  // Refresh available themes\n                  refreshThemes();\n                  setShowCustomThemeCreator(false);\n                }}\n              />\n            </div>\n          </DialogContent>\n        </Dialog>\n\n        {/* Custom Theme Manager Modal */}\n        <Dialog open={showCustomThemeManager} onOpenChange={setShowCustomThemeManager}>\n          <DialogContent className=\"max-w-5xl max-h-[90vh] overflow-hidden\">\n            <DialogHeader>\n              <DialogTitle className=\"flex items-center gap-2\">\n                <Music className=\"w-5 h-5\" />\n                My Custom Sound Themes\n              </DialogTitle>\n            </DialogHeader>\n            <div className=\"overflow-y-auto\">\n              <CustomThemeManager\n                userId={userId}\n                onClose={() => setShowCustomThemeManager(false)}\n                onThemeUpdated={theme => {\n                  // Refresh available themes\n                  refreshThemes();\n                }}\n              />\n            </div>\n          </DialogContent>\n        </Dialog>\n      </CardContent>\n    </Card>\n  );\n};\n\nexport default SoundSettings;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/SubscriptionModal.tsx",
    "messages": [
      {
        "ruleId": null,
        "nodeType": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 345,
        "column": 0
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport {\n  X,\n  Crown,\n  Sparkles,\n  Star,\n  Check,\n  Loader2,\n  CreditCard,\n  Shield,\n  Zap,\n} from \"lucide-react\";\nimport {\n  SUBSCRIPTION_PLANS,\n  type SubscriptionPlan,\n  type PremiumFeatureAccess,\n} from \"../types\";\nimport { SubscriptionService } from \"../services/subscription\";\n\ninterface SubscriptionModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  userId: string;\n  highlightedFeature?: keyof PremiumFeatureAccess;\n}\n\ninterface ModalState {\n  selectedPlan: SubscriptionPlan | null;\n  isProcessing: boolean;\n  error: string | null;\n  trialDaysRemaining: number;\n}\n\nconst SubscriptionModal: React.FC<SubscriptionModalProps> = ({\n  isOpen,\n  onClose,\n  userId,\n  highlightedFeature\n}) => {\n  const [state, setState] = useState<ModalState>({\n    selectedPlan: null,\n    isProcessing: false,\n    error: null,\n    currentTier: 'free',\n    trialDaysRemaining: 0\n  });\n\n  useEffect(() => {\n    if (isOpen) {\n      loadUserData();\n    }\n  }, [isOpen, userId]);\n\n  const loadUserData = async () => {\n    try {\n      const [tier, trialDays] = await Promise.all([\n        SubscriptionService.getUserTier(userId),\n        SubscriptionService.getTrialDaysRemaining(userId)\n      ]);\n\n      setState(prev => ({\n        ...prev,\n        currentTier: tier,\n        trialDaysRemaining: trialDays\n      }));\n    } catch (error) {\n      console.error('Error loading user data:', error);\n    }\n  };\n\n  const handlePlanSelect = (plan: SubscriptionPlan) => {\n    setState(prev => ({ ...prev, selectedPlan: plan }));\n  };\n\n  const handleSubscribe = async () => {\n    if (!state.selectedPlan) return;\n\n    setState(prev => ({ ...prev, isProcessing: true, error: null }));\n\n    try {\n      // TODO: Integrate with Stripe or other payment processor\n      // For now, we'll simulate the subscription flow\n      console.log('Subscribing to plan:', state.selectedPlan);\n\n      // Simulate API call delay\n      await new Promise(resolve => setTimeout(resolve, 2000));\n\n      // Close modal and show success\n      onClose();\n\n      // TODO: Refresh user data in parent component\n    } catch (error) {\n      setState(prev => ({\n        ...prev,\n        error: error instanceof Error ? error.message : 'Failed to process subscription'\n      }));\n    } finally {\n      setState(prev => ({ ...prev, isProcessing: false }));\n    }\n  };\n\n    switch (tier) {\n      case 'premium': return Crown;\n      case 'pro': return Sparkles;\n      case 'lifetime': return Star;\n      default: return Shield;\n    }\n  };\n\n\n  const getTierGradient = (tier: SubscriptionTier) => {\n    switch (tier) {\n      case 'premium': return 'from-amber-500 to-orange-500';\n      case 'pro': return 'from-purple-500 to-pink-500';\n      case 'lifetime': return 'from-emerald-500 to-teal-500';\n      default: return 'from-gray-500 to-gray-600';\n    }\n  };\n\n  const isFeatureHighlighted = (plan: SubscriptionPlan): boolean => {\n    if (!highlightedFeature) return false;\n    return plan.featureAccess[highlightedFeature];\n  };\n\n  const renderPlanCard = (plan: SubscriptionPlan) => {\n    const TierIcon = getTierIcon(plan.tier);\n    const isSelected = state.selectedPlan?.id === plan.id;\n    const isCurrentTier = state.currentTier === plan.tier;\n    const isHighlighted = isFeatureHighlighted(plan);\n\n    return (\n      <motion.div\n        key={plan.id}\n        layout\n        whileHover={{ scale: 1.02 }}\n        whileTap={{ scale: 0.98 }}\n        onClick={() => handlePlanSelect(plan)}\n        className={`relative p-6 rounded-xl border-2 cursor-pointer transition-all ${\n          isSelected\n            ? 'border-blue-500 shadow-lg bg-blue-50'\n            : isHighlighted\n            ? 'border-amber-300 shadow-md bg-amber-50'\n            : 'border-gray-200 hover:border-gray-300'\n        } ${isCurrentTier ? 'opacity-60 cursor-not-allowed' : ''}`}\n      >\n        {plan.popular && (\n          <div className=\"absolute -top-3 left-1/2 transform -translate-x-1/2\">\n            <span className=\"bg-gradient-to-r from-amber-500 to-orange-500 text-white px-3 py-1 rounded-full text-xs font-semibold\">\n              Most Popular\n            </span>\n          </div>\n        )}\n\n        {isHighlighted && (\n          <div className=\"absolute -top-3 right-4\">\n            <span className=\"bg-gradient-to-r from-amber-500 to-orange-500 text-white px-2 py-1 rounded-full text-xs font-semibold\">\n              Includes This Feature\n            </span>\n          </div>\n        )}\n\n        {isCurrentTier && (\n          <div className=\"absolute -top-3 left-4\">\n            <span className=\"bg-green-500 text-white px-2 py-1 rounded-full text-xs font-semibold\">\n              Current Plan\n            </span>\n          </div>\n        )}\n\n        <div className=\"flex items-center justify-between mb-4\">\n          <div className=\"flex items-center space-x-3\">\n            <div className={`w-10 h-10 rounded-lg bg-gradient-to-br ${getTierColor(plan.tier)} flex items-center justify-center`}>\n              <TierIcon className=\"w-5 h-5 text-white\" />\n            </div>\n            <div>\n              <h3 className=\"text-lg font-semibold text-gray-900\">{plan.name}</h3>\n              <p className=\"text-sm text-gray-500\">{plan.description}</p>\n            </div>\n          </div>\n\n          {isSelected && (\n            <div className=\"w-6 h-6 bg-blue-500 rounded-full flex items-center justify-center\">\n              <Check className=\"w-4 h-4 text-white\" />\n            </div>\n          )}\n        </div>\n\n        <div className=\"mb-4\">\n          {plan.tier === 'free' ? (\n            <div className=\"text-2xl font-bold text-gray-900\">Free</div>\n          ) : (\n            <div className=\"flex items-baseline space-x-1\">\n              <span className=\"text-2xl font-bold text-gray-900\">${plan.price}</span>\n              {plan.interval !== 'lifetime' && (\n                <span className=\"text-sm text-gray-500\">/{plan.interval}</span>\n              )}\n            </div>\n          )}\n        </div>\n\n        <ul className=\"space-y-2\">\n          {plan.features.map((feature, index) => (\n            <li key={index} className=\"flex items-start space-x-2\">\n              <Check className=\"w-4 h-4 text-green-500 mt-0.5 flex-shrink-0\" />\n              <span className=\"text-sm text-gray-700\">{feature}</span>\n            </li>\n          ))}\n        </ul>\n\n        {!isCurrentTier && plan.tier !== 'free' && (\n          <motion.button\n            whileHover={{ scale: 1.02 }}\n            whileTap={{ scale: 0.98 }}\n            onClick={e => {\n              e.stopPropagation();\n              handlePlanSelect(plan);\n            }}\n            className={`w-full mt-4 py-2 px-4 rounded-lg font-medium transition-colors ${\n              isSelected\n                ? 'bg-blue-500 text-white'\n                : `bg-gradient-to-r ${getTierColor(plan.tier)} text-white hover:shadow-lg`\n            }`}\n          >\n            Select {plan.name}\n          </motion.button>\n        )}\n      </motion.div>\n    );\n  };\n\n  if (!isOpen) return null;\n\n  return (\n    <AnimatePresence>\n      <motion.div\n        initial={{ opacity: 0 }}\n        animate={{ opacity: 1 }}\n        exit={{ opacity: 0 }}\n        className=\"fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4\"\n        onClick={onClose}\n      >\n        <motion.div\n          initial={{ scale: 0.9, opacity: 0 }}\n          animate={{ scale: 1, opacity: 1 }}\n          exit={{ scale: 0.9, opacity: 0 }}\n          className=\"bg-white rounded-2xl shadow-2xl max-w-6xl w-full max-h-[90vh] overflow-hidden\"\n          onClick={e => e.stopPropagation()}\n        >\n          <div className=\"flex items-center justify-between p-6 border-b border-gray-200\">\n            <div>\n              <h2 className=\"text-2xl font-bold text-gray-900\">Choose Your Plan</h2>\n              <p className=\"text-gray-600 mt-1\">\n                Unlock premium features to enhance your alarm experience\n              </p>\n              {state.trialDaysRemaining > 0 && (\n                <div className=\"mt-2 inline-flex items-center space-x-2 bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm\">\n                  <Zap className=\"w-4 h-4\" />\n                  <span>{state.trialDaysRemaining} days left in trial</span>\n                </div>\n              )}\n            </div>\n            <button\n              onClick={onClose}\n              className=\"p-2 hover:bg-gray-100 rounded-lg transition-colors\"\n            >\n              <X className=\"w-6 h-6 text-gray-500\" />\n            </button>\n          </div>\n\n          <div className=\"p-6 overflow-y-auto max-h-[calc(90vh-200px)]\">\n            <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6\">\n              {SUBSCRIPTION_PLANS.map(plan => renderPlanCard(plan))}\n            </div>\n\n            {state.selectedPlan && state.selectedPlan.tier !== 'free' && (\n              <motion.div\n                initial={{ opacity: 0, y: 20 }}\n                animate={{ opacity: 1, y: 0 }}\n                className=\"mt-8 p-6 bg-gray-50 rounded-xl\"\n              >\n                <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">\n                  Complete Your Subscription\n                </h3>\n\n                <div className=\"flex items-center justify-between mb-4\">\n                  <div>\n                    <p className=\"text-gray-700\">{state.selectedPlan.name} Plan</p>\n                    <p className=\"text-sm text-gray-500\">\n                      Billed {state.selectedPlan.interval === 'lifetime' ? 'once' : state.selectedPlan.interval + 'ly'}\n                    </p>\n                  </div>\n                  <div className=\"text-right\">\n                    <p className=\"text-2xl font-bold text-gray-900\">\n                      ${state.selectedPlan.price}\n                    </p>\n                    {state.selectedPlan.interval !== 'lifetime' && (\n                      <p className=\"text-sm text-gray-500\">\n                        per {state.selectedPlan.interval}\n                      </p>\n                    )}\n                  </div>\n                </div>\n\n                {state.error && (\n                  <div className=\"mb-4 p-3 bg-red-100 border border-red-300 text-red-700 rounded-lg text-sm\">\n                    {state.error}\n                  </div>\n                )}\n\n                <motion.button\n                  whileHover={{ scale: 1.02 }}\n                  whileTap={{ scale: 0.98 }}\n                  onClick={handleSubscribe}\n                  disabled={state.isProcessing}\n                  className={`w-full py-3 px-4 rounded-lg font-medium text-white transition-all ${\n                    state.isProcessing\n                      ? 'bg-gray-400 cursor-not-allowed'\n                      : `bg-gradient-to-r ${getTierColor(state.selectedPlan.tier)} hover:shadow-lg`\n                  }`}\n                >\n                  {state.isProcessing ? (\n                    <div className=\"flex items-center justify-center space-x-2\">\n                      <Loader2 className=\"w-4 h-4 animate-spin\" />\n                      <span>Processing...</span>\n                    </div>\n                  ) : (\n                    <div className=\"flex items-center justify-center space-x-2\">\n                      <CreditCard className=\"w-4 h-4\" />\n                      <span>Subscribe to {state.selectedPlan.name}</span>\n                    </div>\n                  )}\n                </motion.button>\n\n                <p className=\"text-xs text-gray-500 text-center mt-3\">\n                  Secure payment processing. Cancel anytime.\n                </p>\n              </motion.div>\n            )}\n          </div>\n        </motion.div>\n      </motion.div>\n    </AnimatePresence>\n  );\n};\n\nexport default SubscriptionModal;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/UpgradePrompt.tsx",
    "messages": [
      {
        "ruleId": "no-shadow-restricted-names",
        "severity": 2,
        "message": "Shadowing of global property 'Infinity'.",
        "line": 10,
        "column": 3,
        "nodeType": "Identifier",
        "messageId": "shadowingRestrictedName",
        "endLine": 10,
        "endColumn": 11
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'PremiumFeature' is not defined.",
        "line": 19,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 19,
        "endColumn": 26
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React from 'react';\nimport {\n  Crown,\n  Star,\n  Zap,\n  X,\n  Check,\n  Mic,\n  Target,\n  Infinity,\n  Shield,\n  BarChart3,\n  Palette,\n  Headphones,\n} from \"lucide-react\";\n\ninterface UpgradePromptProps {\n  /** The feature that triggered the upgrade prompt */\n  feature: PremiumFeature | string;\n  /** Whether to show as modal or inline */\n  variant?: 'modal' | 'inline' | 'banner';\n  /** Callback when user clicks upgrade */\n  /** Callback when user dismisses prompt */\n  onDismiss?: () => void;\n  /** Custom title override */\n  title?: string;\n  /** Custom description override */\n  description?: string;\n  /** Whether to show pricing */\n  showPricing?: boolean;\n  /** Current user tier for comparison */\n}\n\nconst UpgradePrompt: React.FC<UpgradePromptProps> = ({\n  feature,\n  variant = 'modal',\n  onUpgrade,\n  onDismiss,\n  title,\n  description,\n  showPricing = true,\n  currentTier = 'free'\n}) => {\n  const getFeatureInfo = (featureId: string) => {\n    const featureMap: Record<\n      string,\n      {\n        title: string;\n        description: string;\n        icon: React.ComponentType<any>;\n        benefits: string[];\n      }\n    > = {\n      nuclear_mode: {\n        title: \"Nuclear Mode\",\n        description: \"Extreme difficulty challenges that guarantee you wake up\",\n        icon: Target,\n        benefits: [\n          'Mathematical gauntlets',\n          'Memory challenges',\n          'Physical movement detection',\n          'Photo proof requirements',\n          'Voice recognition tasks'\n        ]\n      },\n      'custom_voices': {\n        title: 'Premium Voices',\n        description: '20+ unique AI personalities to wake you up',\n        icon: Mic,\n        benefits: [\n          'Celebrity chef motivation',\n          'Zen master mindfulness',\n          'Robot companion efficiency',\n          'Pirate captain adventure',\n          'And 16+ more personalities'\n        ]\n      },\n      'voice_cloning': {\n        title: 'Voice Cloning',\n        description: 'Create a custom AI voice clone of yourself or loved ones',\n        icon: Headphones,\n        benefits: [\n          'Upload voice samples',\n          'AI generates your voice',\n          'Personalized wake-up calls',\n          'Share with family members',\n          'High-quality speech synthesis'\n        ]\n      },\n      'unlimited_alarms': {\n        title: 'Unlimited Alarms',\n        description: 'Create as many alarms as you need without limits',\n        icon: Infinity,\n        benefits: [\n          'No 10-alarm limit',\n          'Complex schedules',\n          'Multiple time zones',\n          'Backup alarms',\n          'Event-specific alarms'\n        ]\n      },\n      'advanced_analytics': {\n        title: 'Advanced Analytics',\n        description: 'Detailed insights into your sleep and wake patterns',\n        icon: BarChart3,\n        benefits: [\n          'Sleep quality tracking',\n          'Wake time optimization',\n          'Performance trends',\n          'Personalized insights',\n          'Export data reports'\n        ]\n      },\n      'priority_support': {\n        title: 'Priority Support',\n        description: 'Get help faster with dedicated premium support',\n        icon: Shield,\n        benefits: [\n          'Faster response times',\n          'Dedicated support team',\n          'Phone support option',\n          'Feature request priority',\n          '24/7 availability'\n        ]\n      },\n      'theme_store': {\n        title: 'Premium Themes',\n        description: 'Beautiful themes and customization options',\n        icon: Palette,\n        benefits: [\n          'Exclusive themes',\n          'Custom color schemes',\n          'Animated backgrounds',\n          'Dark mode variants',\n          'Seasonal themes'\n        ]\n      }\n    };\n\n    return (\n      featureMap[featureId] || {\n        title: \"Premium Feature\",\n        description: \"This feature requires a premium subscription\",\n        icon: Crown,\n        benefits: [\n          \"Enhanced functionality\",\n          \"Premium experience\",\n          \"Advanced features\",\n        ],\n      }\n    );\n  };\n\n  const featureInfo =\n    typeof feature === \"string\"\n      ? getFeatureInfo(feature)\n      : {\n          title: \"Premium Feature\",\n          description: \"This feature requires a premium subscription\",\n          icon: Crown,\n          benefits: [\"Enhanced functionality\"],\n        };\n\n  const Icon = featureInfo.icon;\n\n  const plans = [\n    {\n      name: \"Premium\",\n      price: \"$9.99/month\",\n      icon: Crown,\n      color: 'from-orange-500 to-red-500',\n      textColor: 'text-orange-600',\n      bgColor: 'bg-orange-50',\n      features: [\n        'Nuclear Mode challenges',\n        '20+ Premium voices',\n        'Unlimited alarms',\n        'Advanced analytics',\n        'Priority support',\n        'Premium themes'\n      ]\n    },\n    {\n      name: \"Ultimate\",\n      price: \"$19.99/month\",\n      icon: Star,\n      color: 'from-purple-500 to-pink-500',\n      textColor: 'text-purple-600',\n      bgColor: 'bg-purple-50',\n      features: [\n        'Everything in Premium',\n        'Voice cloning',\n        'White label options',\n        'API access',\n        'Custom integrations',\n        'Dedicated support'\n      ]\n    }\n  ];\n\n  const getRequiredPlan = () => {\n    return plans.find(plan => plan.tier === featureInfo.tier) || plans[0];\n  };\n\n  const requiredPlan = getRequiredPlan();\n\n  if (variant === 'banner') {\n    return (\n      <div className=\"bg-gradient-to-r from-orange-500 to-red-500 text-white p-4\">\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center gap-3\">\n            <div className=\"bg-white bg-opacity-20 p-2 rounded-lg\">\n              <Icon className=\"h-5 w-5\" />\n            </div>\n            <div>\n              <h3 className=\"font-semibold\">{title || featureInfo.title}</h3>\n              <p className=\"text-orange-100 text-sm\">{description || featureInfo.description}</p>\n            </div>\n          </div>\n          <div className=\"flex items-center gap-2\">\n            <button\n              onClick={() => onUpgrade(featureInfo.tier)}\n              className=\"bg-white text-orange-600 px-4 py-2 rounded-lg font-medium hover:bg-orange-50 transition-colors text-sm\"\n            >\n              Upgrade Now\n            </button>\n            {onDismiss && (\n              <button\n                onClick={onDismiss}\n                className=\"text-white hover:text-orange-200 transition-colors p-1\"\n              >\n                <X className=\"h-4 w-4\" />\n              </button>\n            )}\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  if (variant === 'inline') {\n    return (\n      <div className=\"bg-white border-2 border-gray-200 rounded-xl p-6\">\n        <div className=\"text-center\">\n          <div className={`w-16 h-16 mx-auto mb-4 rounded-full flex items-center justify-center bg-gradient-to-br ${requiredPlan.color}`}>\n            <Icon className=\"h-8 w-8 text-white\" />\n          </div>\n          <h3 className=\"text-xl font-bold text-gray-900 mb-2\">\n            {title || `Unlock ${featureInfo.title}`}\n          </h3>\n          <p className=\"text-gray-600 mb-4\">{description || featureInfo.description}</p>\n          <div className=\"mb-6\">\n            <div className=\"text-sm text-gray-500 mb-2\">What you'll get:</div>\n            <div className=\"space-y-1\">\n              {featureInfo.benefits.slice(0, 3).map((benefit, index) => (\n                <div key={index} className=\"flex items-center gap-2 text-sm text-gray-700\">\n                  <Check className=\"h-4 w-4 text-green-500\" />\n                  {benefit}\n                </div>\n              ))}\n            </div>\n          </div>\n          <button\n            onClick={() => onUpgrade(featureInfo.tier)}\n            className={`bg-gradient-to-r ${requiredPlan.color} text-white px-6 py-3 rounded-lg font-medium hover:shadow-lg transition-all duration-200 flex items-center justify-center gap-2 w-full`}\n          >\n            <requiredPlan.icon className=\"h-4 w-4\" />\n            Upgrade to {requiredPlan.name}\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  // Modal variant\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4\">\n      <div className=\"bg-white rounded-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto\">\n        {/* Header */}\n        <div className={`bg-gradient-to-r ${requiredPlan.color} text-white p-6 rounded-t-xl relative`}>\n          {onDismiss && (\n            <button\n              onClick={onDismiss}\n              className=\"absolute top-4 right-4 text-white hover:text-gray-200 transition-colors\"\n            >\n              <X className=\"h-6 w-6\" />\n            </button>\n          )}\n          <div className=\"flex items-center gap-4\">\n            <div className=\"bg-white bg-opacity-20 p-3 rounded-lg\">\n              <Icon className=\"h-8 w-8\" />\n            </div>\n            <div>\n              <h2 className=\"text-2xl font-bold mb-1\">\n                {title || `Unlock ${featureInfo.title}`}\n              </h2>\n              <p className=\"text-white text-opacity-90\">\n                {description || featureInfo.description}\n              </p>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"p-6\">\n          {/* Feature benefits */}\n          <div className=\"mb-8\">\n            <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">\n              What you'll get with {featureInfo.title}:\n            </h3>\n            <div className=\"grid gap-3\">\n              {featureInfo.benefits.map((benefit, index) => (\n                <div key={index} className=\"flex items-center gap-3\">\n                  <div className=\"bg-green-100 text-green-600 p-1 rounded-full\">\n                    <Check className=\"h-4 w-4\" />\n                  </div>\n                  <span className=\"text-gray-700\">{benefit}</span>\n                </div>\n              ))}\n            </div>\n          </div>\n\n          {/* Pricing plans */}\n          {showPricing && (\n            <div>\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">Choose Your Plan:</h3>\n              <div className=\"grid gap-4 md:grid-cols-2\">\n                {plans.map(plan => {\n                  const isRequired = plan.tier === featureInfo.tier;\n                  const isHigherTier = plan.tier === 'ultimate' && featureInfo.tier === 'premium';\n                  const showPlan = isRequired || isHigherTier;\n\n                  if (!showPlan) return null;\n\n                  return (\n                    <div\n                      key={plan.tier}\n                      className={`border-2 rounded-xl p-6 relative ${\n                        isRequired ? 'border-blue-500 bg-blue-50' : 'border-gray-200'\n                      }`}\n                    >\n                      {isRequired && (\n                        <div className=\"absolute -top-3 left-1/2 transform -translate-x-1/2\">\n                          <div className=\"bg-blue-500 text-white px-3 py-1 rounded-full text-sm font-medium\">\n                            Required\n                          </div>\n                        </div>\n                      )}\n\n                      <div className=\"text-center\">\n                        <div className={`w-12 h-12 mx-auto mb-3 rounded-full flex items-center justify-center bg-gradient-to-br ${plan.color}`}>\n                          <plan.icon className=\"h-6 w-6 text-white\" />\n                        </div>\n                        <h4 className=\"text-xl font-bold text-gray-900 mb-1\">{plan.name}</h4>\n                        <div className=\"text-2xl font-bold mb-4\">\n                          <span className={plan.textColor}>{plan.price}</span>\n                        </div>\n\n                        <div className=\"space-y-2 mb-6\">\n                          {plan.features.map((feature, index) => (\n                            <div key={index} className=\"flex items-center gap-2 text-sm text-gray-600\">\n                              <Check className=\"h-4 w-4 text-green-500 flex-shrink-0\" />\n                              <span>{feature}</span>\n                            </div>\n                          ))}\n                        </div>\n\n                        <button\n                          onClick={() => onUpgrade(plan.tier)}\n                          className={`w-full py-3 px-4 rounded-lg font-medium transition-all duration-200 ${\n                            isRequired\n                              ? `bg-gradient-to-r ${plan.color} text-white hover:shadow-lg`\n                              : `border-2 ${plan.textColor} border-current hover:bg-opacity-10 ${plan.bgColor}`\n                          }`}\n                        >\n                          {isRequired ? `Unlock with ${plan.name}` : `Upgrade to ${plan.name}`}\n                        </button>\n                      </div>\n                    </div>\n                  );\n                })}\n              </div>\n            </div>\n          )}\n\n          {/* Simple upgrade button for non-pricing version */}\n          {!showPricing && (\n            <div className=\"text-center\">\n              <button\n                onClick={() => onUpgrade(featureInfo.tier)}\n                className={`bg-gradient-to-r ${requiredPlan.color} text-white px-8 py-3 rounded-lg font-medium hover:shadow-lg transition-all duration-200 flex items-center justify-center gap-2 mx-auto`}\n              >\n                <requiredPlan.icon className=\"h-5 w-5\" />\n                Upgrade to {requiredPlan.name}\n              </button>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default UpgradePrompt;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/VoiceCloning.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'BlobPart' is not defined.",
        "line": 66,
        "column": 21,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 66,
        "endColumn": 29
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference types=\"node\" />\nimport React, { useState, useRef, useCallback } from \"react\";\nimport {\n  Mic,\n  Upload,\n  Play,\n  Pause,\n  Trash2,\n  Crown,\n  CheckCircle,\n  AlertCircle,\n  Clock,\n  Info,\n  Star\n} from 'lucide-react';\nimport type { User, VoiceCloneRequest } from '../types';\nimport { PremiumVoiceService } from '../services/premium-voice';\nimport { PremiumService } from '../services/premium';\n\ninterface VoiceCloningProps {\n  user: User;\n  onClose: () => void;\n}\n\ninterface AudioSample {\n  id: string;\n  blob: Blob;\n  duration: number;\n  name: string;\n  url: string;\n}\n\nconst VoiceCloning: React.FC<VoiceCloningProps> = ({ user, onClose }) => {\n  const [samples, setSamples] = useState<AudioSample[]>([]);\n  const [isRecording, setIsRecording] = useState(false);\n  const [recordingTime, setRecordingTime] = useState(0);\n  const [playingId, setPlayingId] = useState<string | null>(null);\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [cloneRequest, setCloneRequest] = useState<VoiceCloneRequest | null>(null);\n  const [hasAccess, setHasAccess] = useState<boolean | null>(null);\n\n  const mediaRecorderRef = useRef<MediaRecorder | null>(null);\n  const recordingTimerRef = useRef<number | null>(null);\n  const audioRefs = useRef<Map<string, HTMLAudioElement>>(new Map());\n\n  // Check access on mount\n  React.useEffect(() => {\n    checkAccess();\n  }, [user.id]);\n\n  const checkAccess = async () => {\n    try {\n      const access = await PremiumService.getInstance().hasFeatureAccess(user.id, 'voice_cloning');\n      setHasAccess(access);\n    } catch (error) {\n      console.error('Error checking voice cloning access:', error);\n      setHasAccess(false);\n    }\n  };\n\n  const startRecording = async () => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      const mediaRecorder = new MediaRecorder(stream);\n\n      const chunks: BlobPart[] = [];\n      mediaRecorder.ondataavailable = event => {\n        chunks.push(event.data);\n      };\n\n      mediaRecorder.onstop = () => {\n        const blob = new Blob(chunks, { type: 'audio/wav' });\n        const sampleId = `sample_${Date.now()}`;\n        const url = URL.createObjectURL(blob);\n\n        const newSample: AudioSample = {\n          id: sampleId,\n          blob,\n          duration: recordingTime,\n          name: `Recording ${samples.length + 1}`,\n          url\n        };\n\n        setSamples(prev => [...prev, newSample]);\n        stream.getTracks().forEach(track => track.stop());\n      };\n\n      mediaRecorderRef.current = mediaRecorder;\n      mediaRecorder.start();\n      setIsRecording(true);\n      setRecordingTime(0);\n\n      // Start timer\n      recordingTimerRef.current = setInterval(() => {\n        setRecordingTime(prev => prev + 1);\n      }, 1000);\n\n    } catch (error) {\n      console.error('Error starting recording:', error);\n      alert('Could not access microphone. Please check permissions.');\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorderRef.current && isRecording) {\n      mediaRecorderRef.current.stop();\n      setIsRecording(false);\n\n      if (recordingTimerRef.current) {\n        clearInterval(recordingTimerRef.current);\n        recordingTimerRef.current = null;\n      }\n    }\n  };\n\n  const handleFileUpload = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {\n    const files = event.target.files;\n    if (!files) return;\n\n    Array.from(files).forEach((file) => {\n      if (file.type.startsWith('audio/')) {\n        const sampleId = `upload_${Date.now()}_${Math.random()}`;\n        const url = URL.createObjectURL(file);\n\n        const newSample: AudioSample = {\n          id: sampleId,\n          blob: file,\n          duration: 0, // Would need to calculate from audio\n          name: file.name,\n          url\n        };\n\n        setSamples(prev => [...prev, newSample]);\n      }\n    });\n\n    // Reset input\n    event.target.value = '';\n  }, []);\n\n  const playAudio = (sampleId: string) => {\n    const sample = samples.find(s => s.id === sampleId);\n    if (!sample) return;\n\n    // Stop any currently playing audio\n    if (playingId) {\n      const currentAudio = audioRefs.current.get(playingId);\n      if (currentAudio) {\n        currentAudio.pause();\n        currentAudio.currentTime = 0;\n      }\n    }\n\n    // Create or get audio element\n    let audio = audioRefs.current.get(sampleId);\n    if (!audio) {\n      audio = new Audio(sample.url);\n      audioRefs.current.set(sampleId, audio);\n    }\n\n    audio.onended = () => setPlayingId(null);\n    audio.onpause = () => setPlayingId(null);\n\n    setPlayingId(sampleId);\n    audio.play().catch(console.error);\n  };\n\n  const stopAudio = (sampleId: string) => {\n    const audio = audioRefs.current.get(sampleId);\n    if (audio) {\n      audio.pause();\n      audio.currentTime = 0;\n    }\n    setPlayingId(null);\n  };\n\n  const removeSample = (sampleId: string) => {\n    setSamples(prev => prev.filter(s => s.id !== sampleId));\n\n    // Clean up audio and URL\n    const audio = audioRefs.current.get(sampleId);\n    if (audio) {\n      audio.pause();\n      audioRefs.current.delete(sampleId);\n    }\n\n    const sample = samples.find(s => s.id === sampleId);\n    if (sample) {\n      URL.revokeObjectURL(sample.url);\n    }\n\n    if (playingId === sampleId) {\n      setPlayingId(null);\n    }\n  };\n\n  const createVoiceClone = async () => {\n    if (samples.length < 3) {\n      alert('Please provide at least 3 voice samples for better quality.');\n      return;\n    }\n\n    try {\n      setIsProcessing(true);\n      const audioBlobs = samples.map(sample => sample.blob);\n      const request = await PremiumVoiceService.createVoiceClone(user.id, audioBlobs);\n      setCloneRequest(request);\n    } catch (error) {\n      console.error('Error creating voice clone:', error);\n      alert('Failed to create voice clone. Please try again.');\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  const formatTime = (seconds: number): string => {\n    const mins = Math.floor(seconds / 60);\n    const secs = seconds % 60;\n    return `${mins}:${secs.toString().padStart(2, '0')}`;\n  };\n\n  if (hasAccess === false) {\n    return (\n      <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n        <div className=\"bg-white rounded-xl max-w-md mx-4 p-6\">\n          <div className=\"text-center\">\n            <div className=\"bg-gradient-to-br from-purple-500 to-pink-500 text-white w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4\">\n              <Crown className=\"h-8 w-8\" />\n            </div>\n            <h2 className=\"text-2xl font-bold text-gray-900 mb-2\">Ultimate Required</h2>\n            <p className=\"text-gray-600 mb-6\">\n              Voice cloning is an exclusive feature for Ultimate subscribers. Upgrade to create your personalized AI voice.\n            </p>\n            <div className=\"flex gap-3\">\n              <button\n                onClick={onClose}\n                className=\"flex-1 bg-gray-100 text-gray-700 py-2 px-4 rounded-lg font-medium hover:bg-gray-200 transition-colors\"\n              >\n                Cancel\n              </button>\n              <button\n                onClick={() => {\n                  // In a real app, this would open the upgrade flow\n                  alert('Redirecting to upgrade page...');\n                }}\n                className=\"flex-1 bg-gradient-to-r from-purple-500 to-pink-500 text-white py-2 px-4 rounded-lg font-medium hover:from-purple-600 hover:to-pink-600 transition-all duration-200 flex items-center justify-center gap-2\"\n              >\n                <Star className=\"h-4 w-4\" />\n                Upgrade\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  if (cloneRequest) {\n    return (\n      <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n        <div className=\"bg-white rounded-xl max-w-lg mx-4 p-6\">\n          <div className=\"text-center\">\n            {cloneRequest.status === 'processing' && (\n              <>\n                <div className=\"bg-blue-100 text-blue-600 w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4\">\n                  <Clock className=\"h-8 w-8 animate-spin\" />\n                </div>\n                <h2 className=\"text-2xl font-bold text-gray-900 mb-2\">Creating Your Voice Clone</h2>\n                <p className=\"text-gray-600 mb-4\">\n                  Our AI is analyzing your voice samples and training your custom model.\n                  This typically takes 12-24 hours.\n                </p>\n                <div className=\"bg-gray-100 rounded-lg p-4 mb-6\">\n                  <div className=\"flex items-center justify-between text-sm\">\n                    <span className=\"text-gray-600\">Estimated completion:</span>\n                    <span className=\"font-medium text-gray-900\">\n                      {cloneRequest.estimatedCompletion?.toLocaleDateString()} at {cloneRequest.estimatedCompletion?.toLocaleTimeString()}\n                    </span>\n                  </div>\n                </div>\n              </>\n            )}\n\n            {cloneRequest.status === 'completed' && (\n              <>\n                <div className=\"bg-green-100 text-green-600 w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4\">\n                  <CheckCircle className=\"h-8 w-8\" />\n                </div>\n                <h2 className=\"text-2xl font-bold text-gray-900 mb-2\">Voice Clone Ready!</h2>\n                <p className=\"text-gray-600 mb-6\">\n                  Your custom voice has been successfully created. You can now select \"Custom Voice\" in your alarm settings.\n                </p>\n              </>\n            )}\n\n            {cloneRequest.status === 'failed' && (\n              <>\n                <div className=\"bg-red-100 text-red-600 w-16 h-16 rounded-full flex items-center justify-center mx-auto mb-4\">\n                  <AlertCircle className=\"h-8 w-8\" />\n                </div>\n                <h2 className=\"text-2xl font-bold text-gray-900 mb-2\">Voice Clone Failed</h2>\n                <p className=\"text-gray-600 mb-6\">\n                  We couldn't create your voice clone. This might be due to audio quality issues. Please try again with clearer recordings.\n                </p>\n              </>\n            )}\n\n            <button\n              onClick={onClose}\n              className=\"w-full bg-blue-500 text-white py-3 px-6 rounded-lg font-medium hover:bg-blue-600 transition-colors\"\n            >\n              {cloneRequest.status === 'completed' ? 'Done' : 'Close'}\n            </button>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4\">\n      <div className=\"bg-white rounded-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto\">\n        {/* Header */}\n        <div className=\"bg-gradient-to-r from-purple-500 to-pink-500 text-white p-6 rounded-t-xl\">\n          <div className=\"flex items-center gap-3 mb-2\">\n            <div className=\"bg-white bg-opacity-20 p-2 rounded-lg\">\n              <Mic className=\"h-6 w-6\" />\n            </div>\n            <div>\n              <h2 className=\"text-2xl font-bold\">Voice Cloning</h2>\n              <p className=\"text-purple-100\">Create your personalized AI voice</p>\n            </div>\n          </div>\n        </div>\n\n        <div className=\"p-6\">\n          {/* Instructions */}\n          <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6\">\n            <div className=\"flex gap-3\">\n              <Info className=\"h-5 w-5 text-blue-600 flex-shrink-0 mt-0.5\" />\n              <div className=\"text-sm\">\n                <h3 className=\"font-semibold text-blue-900 mb-1\">Voice Cloning Tips:</h3>\n                <ul className=\"text-blue-800 space-y-1\">\n                  <li>‚Ä¢ Provide 3-10 voice samples for best results</li>\n                  <li>‚Ä¢ Each sample should be 10-30 seconds long</li>\n                  <li>‚Ä¢ Speak clearly in a quiet environment</li>\n                  <li>‚Ä¢ Use varied sentences and emotions</li>\n                  <li>‚Ä¢ Processing takes 12-24 hours</li>\n                </ul>\n              </div>\n            </div>\n          </div>\n\n          {/* Recording controls */}\n          <div className=\"mb-6\">\n            <div className=\"flex items-center justify-between mb-4\">\n              <h3 className=\"text-lg font-semibold text-gray-900\">Record Voice Samples</h3>\n              <div className=\"text-sm text-gray-600\">\n                {samples.length}/10 samples\n              </div>\n            </div>\n\n            <div className=\"flex gap-3 mb-4\">\n              {!isRecording ? (\n                <button\n                  onClick={startRecording}\n                  className=\"flex-1 bg-red-500 text-white py-3 px-4 rounded-lg font-medium hover:bg-red-600 transition-colors flex items-center justify-center gap-2\"\n                >\n                  <Mic className=\"h-5 w-5\" />\n                  Start Recording\n                </button>\n              ) : (\n                <button\n                  onClick={stopRecording}\n                  className=\"flex-1 bg-red-600 text-white py-3 px-4 rounded-lg font-medium hover:bg-red-700 transition-colors flex items-center justify-center gap-2 animate-pulse\"\n                >\n                  <Pause className=\"h-5 w-5\" />\n                  Stop Recording ({formatTime(recordingTime)})\n                </button>\n              )}\n\n              <label className=\"flex-1 bg-blue-500 text-white py-3 px-4 rounded-lg font-medium hover:bg-blue-600 transition-colors flex items-center justify-center gap-2 cursor-pointer\">\n                <Upload className=\"h-5 w-5\" />\n                Upload Audio\n                <input\n                  type=\"file\"\n                  accept=\"audio/*\"\n                  multiple\n                  onChange={handleFileUpload}\n                  className=\"hidden\"\n                />\n              </label>\n            </div>\n          </div>\n\n          {/* Voice samples list */}\n          {samples.length > 0 && (\n            <div className=\"mb-6\">\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">Voice Samples</h3>\n              <div className=\"space-y-3\">\n                {samples.map((sample) => (\n                  <div key={sample.id} className=\"bg-gray-50 rounded-lg p-4 flex items-center gap-3\">\n                    <button\n                      onClick={() =>\n                        playingId === sample.id\n                          ? stopAudio(sample.id)\n                          : playAudio(sample.id)\n                      }\n                      className=\"bg-green-500 text-white p-2 rounded-full hover:bg-green-600 transition-colors\"\n                    >\n                      {playingId === sample.id ? (\n                        <Pause className=\"h-4 w-4\" />\n                      ) : (\n                        <Play className=\"h-4 w-4\" />\n                      )}\n                    </button>\n\n                    <div className=\"flex-1\">\n                      <div className=\"font-medium text-gray-900\">{sample.name}</div>\n                      <div className=\"text-sm text-gray-600\">\n                        Duration: {formatTime(sample.duration)}\n                      </div>\n                    </div>\n\n                    <button\n                      onClick={() => removeSample(sample.id)}\n                      className=\"text-red-500 hover:text-red-700 transition-colors p-1\"\n                    >\n                      <Trash2 className=\"h-4 w-4\" />\n                    </button>\n                  </div>\n                ))}\n              </div>\n            </div>\n          )}\n\n          {/* Progress requirements */}\n          <div className=\"mb-6\">\n            <h3 className=\"text-lg font-semibold text-gray-900 mb-3\">Requirements</h3>\n            <div className=\"space-y-2\">\n              <div className={`flex items-center gap-2 ${samples.length >= 3 ? 'text-green-600' : 'text-gray-400'}`}>\n                <CheckCircle className=\"h-4 w-4\" />\n                <span className=\"text-sm\">At least 3 voice samples (recommended: 5-10)</span>\n              </div>\n              <div className={`flex items-center gap-2 ${samples.some(s => s.duration >= 10) ? 'text-green-600' : 'text-gray-400'}`}>\n                <CheckCircle className=\"h-4 w-4\" />\n                <span className=\"text-sm\">Samples should be 10+ seconds each</span>\n              </div>\n            </div>\n          </div>\n\n          {/* Action buttons */}\n          <div className=\"flex gap-3\">\n            <button\n              onClick={onClose}\n              className=\"flex-1 bg-gray-100 text-gray-700 py-3 px-6 rounded-lg font-medium hover:bg-gray-200 transition-colors\"\n            >\n              Cancel\n            </button>\n            <button\n              onClick={createVoiceClone}\n              disabled={samples.length < 3 || isProcessing}\n              className=\"flex-1 bg-gradient-to-r from-purple-500 to-pink-500 text-white py-3 px-6 rounded-lg font-medium hover:from-purple-600 hover:to-pink-600 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2\"\n            >\n              {isProcessing ? (\n                <>\n                  <Clock className=\"h-4 w-4 animate-spin\" />\n                  Creating...\n                </>\n              ) : (\n                <>\n                  <Star className=\"h-4 w-4\" />\n                  Create Voice Clone\n                </>\n              )}\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default VoiceCloning;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/__tests__/AlarmRinging.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 318,
        "column": 27,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 318,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 327,
        "column": 32,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 327,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 338,
        "column": 32,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 338,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 451,
        "column": 32,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 451,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 499,
        "column": 32,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 499,
        "endColumn": 67
      }
    ],
    "suppressedMessages": [],
    "errorCount": 5,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Vitest globals are available globally, no need to import\n/// <reference lib=\"dom\" />\nimport React from 'react';\nimport { render, screen, waitFor, fireEvent } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport AlarmRinging from '../AlarmRinging';\nimport { testUtils } from '../../test-setup';\nimport { vibrate } from '../../services/capacitor';\nimport { VoiceService } from '../../services/voice-pro';\n\n// Mock services\njest.mock('../../services/voice-pro', () => ({\n  VoiceService: {\n    speak: jest.fn(() => Promise.resolve()),\n    stop: jest.fn(),\n    isSupported: jest.fn(() => true),\n  },\n}));\n\njest.mock('../../services/voice-recognition', () => ({\n  VoiceRecognitionService: {\n    startListening: jest.fn(),\n    stopListening: jest.fn(),\n    isListening: false,\n    onCommand: jest.fn(),\n    isSupported: jest.fn(() => true),\n  },\n}));\n\njest.mock('../../services/capacitor', () => ({\n  vibrate: jest.fn(() => Promise.resolve()),\n}));\n\n// Mock Web Speech API\nconst mockSpeechRecognition = {\n  start: jest.fn(),\n  stop: jest.fn(),\n  addEventListener: jest.fn(),\n  removeEventListener: jest.fn(),\n  continuous: true,\n  interimResults: true,\n  lang: 'en-US',\n};\n\nObject.defineProperty(window, 'SpeechRecognition', {\n  value: jest.fn(() => mockSpeechRecognition),\n  writable: true,\n});\n\nObject.defineProperty(window, 'webkitSpeechRecognition', {\n  value: jest.fn(() => mockSpeechRecognition),\n  writable: true,\n});\n\ndescribe('AlarmRinging', () => {\n  const mockProps = {\n    alarm: testUtils.mockAlarm,\n    onDismiss: jest.fn(),\n    onSnooze: jest.fn(),\n  };\n\n  beforeEach(() => {\n    testUtils.clearAllMocks();\n    jest.clearAllMocks();\n\n    // Reset speech recognition mock\n    mockSpeechRecognition.start.mockClear();\n    mockSpeechRecognition.stop.mockClear();\n  });\n\n  describe('rendering', () => {\n    test('renders alarm information', () => {\n      render(<AlarmRinging {...mockProps} />);\n\n      expect(screen.getByText(testUtils.mockAlarm.label)).toBeInTheDocument();\n      expect(screen.getByText(testUtils.mockAlarm.time)).toBeInTheDocument();\n      expect(screen.getByText(/wake up/i)).toBeInTheDocument();\n    });\n\n    test('renders dismiss and snooze buttons', () => {\n      render(<AlarmRinging {...mockProps} />);\n\n      expect(screen.getByRole('button', { name: /dismiss/i })).toBeInTheDocument();\n      expect(screen.getByRole('button', { name: /snooze/i })).toBeInTheDocument();\n    });\n\n    test('renders voice recognition controls', () => {\n      render(<AlarmRinging {...mockProps} />);\n\n      expect(\n        screen.getByRole('button', { name: /start voice recognition/i })\n      ).toBeInTheDocument();\n      expect(screen.getByText(/say \"stop\" to dismiss/i)).toBeInTheDocument();\n    });\n\n    test('shows current time', () => {\n      const mockDate = new Date('2023-12-25T07:30:00');\n      jest.spyOn(global, 'Date').mockImplementation(() => mockDate);\n\n      render(<AlarmRinging {...mockProps} />);\n\n      expect(screen.getByText('07:30')).toBeInTheDocument();\n\n      jest.restoreAllMocks();\n    });\n\n    test('displays motivational message based on voice mood', () => {\n      const motivationalAlarm = {\n        ...testUtils.mockAlarm,\n        voiceMood: 'motivational' as const,\n      };\n      render(<AlarmRinging {...mockProps} alarm={motivationalAlarm} />);\n\n      expect(screen.getByText(/time to conquer/i)).toBeInTheDocument();\n    });\n  });\n\n  describe('voice recognition', () => {\n    test('starts voice recognition when button is clicked', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      const voiceButton = screen.getByRole('button', {\n        name: /start voice recognition/i,\n      });\n      await user.click(voiceButton);\n\n      expect(mockSpeechRecognition.start).toHaveBeenCalled();\n    });\n\n    test('stops voice recognition when listening', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      // Start listening\n      const voiceButton = screen.getByRole('button', {\n        name: /start voice recognition/i,\n      });\n      await user.click(voiceButton);\n\n      // Should now show stop button\n      const stopButton = screen.getByRole('button', {\n        name: /stop voice recognition/i,\n      });\n      await user.click(stopButton);\n\n      expect(mockSpeechRecognition.stop).toHaveBeenCalled();\n    });\n\n    test('shows listening indicator when voice recognition is active', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      const voiceButton = screen.getByRole('button', {\n        name: /start voice recognition/i,\n      });\n      await user.click(voiceButton);\n\n      expect(screen.getByText(/listening/i)).toBeInTheDocument();\n      expect(screen.getByTestId('voice-indicator')).toHaveClass('animate-pulse');\n    });\n\n    test('handles voice commands correctly', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      const voiceButton = screen.getByRole('button', {\n        name: /start voice recognition/i,\n      });\n      await user.click(voiceButton);\n\n      // Simulate speech recognition result\n      const mockEvent = {\n        results: [\n          {\n            0: { transcript: 'stop', confidence: 0.9 },\n            isFinal: true,\n          },\n        ],\n        resultIndex: 0,\n      };\n\n      // Find the result event handler and call it\n      const resultHandler = mockSpeechRecognition.addEventListener.mock.calls.find(\n        call => call[0] === 'result'\n      )?.[1];\n\n      if (resultHandler) {\n        resultHandler(mockEvent);\n\n        await waitFor(() => {\n          expect(mockProps.onDismiss).toHaveBeenCalled();\n        });\n      }\n    });\n\n    test('handles snooze voice command', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      const voiceButton = screen.getByRole('button', {\n        name: /start voice recognition/i,\n      });\n      await user.click(voiceButton);\n\n      const mockEvent = {\n        results: [\n          {\n            0: { transcript: 'snooze', confidence: 0.85 },\n            isFinal: true,\n          },\n        ],\n        resultIndex: 0,\n      };\n\n      const resultHandler = mockSpeechRecognition.addEventListener.mock.calls.find(\n        call => call[0] === 'result'\n      )?.[1];\n\n      if (resultHandler) {\n        resultHandler(mockEvent);\n\n        await waitFor(() => {\n          expect(mockProps.onSnooze).toHaveBeenCalled();\n        });\n      }\n    });\n\n    test('shows voice command feedback', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      const voiceButton = screen.getByRole('button', {\n        name: /start voice recognition/i,\n      });\n      await user.click(voiceButton);\n\n      const mockEvent = {\n        results: [\n          {\n            0: { transcript: 'stop alarm', confidence: 0.7 },\n            isFinal: false,\n          },\n        ],\n        resultIndex: 0,\n      };\n\n      const resultHandler = mockSpeechRecognition.addEventListener.mock.calls.find(\n        call => call[0] === 'result'\n      )?.[1];\n\n      if (resultHandler) {\n        resultHandler(mockEvent);\n\n        expect(screen.getByText('stop alarm')).toBeInTheDocument();\n      }\n    });\n  });\n\n  describe('interactions', () => {\n    test('calls onDismiss when dismiss button is clicked', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      const dismissButton = screen.getByRole('button', { name: /dismiss/i });\n      await user.click(dismissButton);\n\n      expect(mockProps.onDismiss).toHaveBeenCalled();\n    });\n\n    test('calls onSnooze when snooze button is clicked', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      const snoozeButton = screen.getByRole('button', { name: /snooze/i });\n      await user.click(snoozeButton);\n\n      expect(mockProps.onSnooze).toHaveBeenCalled();\n    });\n\n    test('handles double-tap dismiss', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      const dismissButton = screen.getByRole('button', { name: /dismiss/i });\n\n      // First click\n      await user.click(dismissButton);\n      expect(screen.getByText(/tap again to dismiss/i)).toBeInTheDocument();\n\n      // Second click within time window\n      await user.click(dismissButton);\n      expect(mockProps.onDismiss).toHaveBeenCalled();\n    });\n\n    test('resets double-tap after timeout', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      const dismissButton = screen.getByRole('button', { name: /dismiss/i });\n\n      // First click\n      await user.click(dismissButton);\n      expect(screen.getByText(/tap again to dismiss/i)).toBeInTheDocument();\n\n      // Wait for timeout\n      await waitFor(\n        () => {\n          expect(screen.queryByText(/tap again to dismiss/i)).not.toBeInTheDocument();\n        },\n        { timeout: 4000 }\n      );\n    });\n  });\n\n  describe('audio and vibration', () => {\n    test('triggers device vibration on mount', async () => {\n      const { vibrate } = require('../../services/capacitor');\n      render(<AlarmRinging {...mockProps} />);\n\n      await waitFor(() => {\n        expect(vibrate).toHaveBeenCalled();\n      });\n    });\n\n    test('speaks alarm message using voice service', async () => {\n      const { VoiceService } = require('../../services/voice-pro');\n      render(<AlarmRinging {...mockProps} />);\n\n      await waitFor(() => {\n        expect(VoiceService.speak).toHaveBeenCalledWith(\n          expect.stringContaining(testUtils.mockAlarm.label)\n        );\n      });\n    });\n\n    test('stops speech when component unmounts', () => {\n      const { VoiceService } = require('../../services/voice-pro');\n      const { unmount } = render(<AlarmRinging {...mockProps} />);\n\n      unmount();\n\n      expect(VoiceService.stop).toHaveBeenCalled();\n    });\n  });\n\n  describe('accessibility', () => {\n    test('has proper heading structure', () => {\n      render(<AlarmRinging {...mockProps} />);\n\n      expect(screen.getByRole('heading', { level: 1 })).toBeInTheDocument();\n      expect(screen.getByRole('heading', { level: 2 })).toBeInTheDocument();\n    });\n\n    test('has proper ARIA labels', () => {\n      render(<AlarmRinging {...mockProps} />);\n\n      expect(screen.getByLabelText('Alarm notification')).toBeInTheDocument();\n      expect(screen.getByLabelText(/dismiss alarm/i)).toBeInTheDocument();\n      expect(screen.getByLabelText(/snooze alarm/i)).toBeInTheDocument();\n    });\n\n    test('supports keyboard navigation', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      const dismissButton = screen.getByRole('button', { name: /dismiss/i });\n      const snoozeButton = screen.getByRole('button', { name: /snooze/i });\n\n      // Tab navigation\n      await user.tab();\n      expect(dismissButton).toHaveFocus();\n\n      await user.tab();\n      expect(snoozeButton).toHaveFocus();\n    });\n\n    test('handles Enter key for dismiss', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      const dismissButton = screen.getByRole('button', { name: /dismiss/i });\n      dismissButton.focus();\n\n      await user.keyboard('{Enter}');\n\n      expect(screen.getByText(/tap again to dismiss/i)).toBeInTheDocument();\n    });\n\n    test('handles Space key for snooze', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      const snoozeButton = screen.getByRole('button', { name: /snooze/i });\n      snoozeButton.focus();\n\n      await user.keyboard(' ');\n\n      expect(mockProps.onSnooze).toHaveBeenCalled();\n    });\n\n    test('announces voice recognition status', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      const voiceButton = screen.getByRole('button', {\n        name: /start voice recognition/i,\n      });\n      await user.click(voiceButton);\n\n      expect(screen.getByLabelText('Voice recognition active')).toBeInTheDocument();\n    });\n  });\n\n  describe('error handling', () => {\n    test('handles voice recognition errors gracefully', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      const voiceButton = screen.getByRole('button', {\n        name: /start voice recognition/i,\n      });\n      await user.click(voiceButton);\n\n      // Simulate speech recognition error\n      const errorHandler = mockSpeechRecognition.addEventListener.mock.calls.find(\n        call => call[0] === 'error'\n      )?.[1];\n\n      if (errorHandler) {\n        errorHandler({ error: 'network', message: 'Network error' });\n\n        expect(screen.getByText(/voice recognition unavailable/i)).toBeInTheDocument();\n      }\n    });\n\n    test('handles missing Web Speech API', () => {\n      // Mock unsupported browser\n      delete (window as any).SpeechRecognition;\n      delete (window as any).webkitSpeechRecognition;\n\n      render(<AlarmRinging {...mockProps} />);\n\n      expect(\n        screen.queryByRole('button', { name: /start voice recognition/i })\n      ).not.toBeInTheDocument();\n      expect(screen.getByText(/voice commands not supported/i)).toBeInTheDocument();\n    });\n\n    test('handles voice service errors', async () => {\n      const { VoiceService } = require('../../services/voice-pro');\n      VoiceService.speak.mockRejectedValueOnce(new Error('Speech synthesis failed'));\n\n      const consoleError = jest.spyOn(console, 'error').mockImplementation();\n\n      render(<AlarmRinging {...mockProps} />);\n\n      await waitFor(() => {\n        expect(consoleError).toHaveBeenCalledWith(\n          expect.stringContaining('Speech synthesis failed')\n        );\n      });\n\n      consoleError.mockRestore();\n    });\n  });\n\n  describe('snooze functionality', () => {\n    test('shows snooze count when alarm has been snoozed', () => {\n      const snoozedAlarm = { ...testUtils.mockAlarm, snoozeCount: 2 };\n      render(<AlarmRinging {...mockProps} alarm={snoozedAlarm} />);\n\n      expect(screen.getByText(/snoozed 2 times/i)).toBeInTheDocument();\n    });\n\n    test('disables snooze when max snoozes reached', () => {\n      const maxSnoozedAlarm = {\n        ...testUtils.mockAlarm,\n        snoozeCount: 3,\n        maxSnoozes: 3,\n      };\n      render(<AlarmRinging {...mockProps} alarm={maxSnoozedAlarm} />);\n\n      const snoozeButton = screen.getByRole('button', { name: /snooze/i });\n      expect(snoozeButton).toBeDisabled();\n      expect(screen.getByText(/max snoozes reached/i)).toBeInTheDocument();\n    });\n\n    test('shows snooze interval information', () => {\n      const customSnoozeAlarm = { ...testUtils.mockAlarm, snoozeInterval: 10 };\n      render(<AlarmRinging {...mockProps} alarm={customSnoozeAlarm} />);\n\n      expect(screen.getByText(/snooze for 10 minutes/i)).toBeInTheDocument();\n    });\n  });\n\n  describe('performance', () => {\n    test('cleans up resources on unmount', () => {\n      const { VoiceService } = require('../../services/voice-pro');\n      const { unmount } = render(<AlarmRinging {...mockProps} />);\n\n      unmount();\n\n      expect(VoiceService.stop).toHaveBeenCalled();\n      expect(mockSpeechRecognition.stop).toHaveBeenCalled();\n    });\n\n    test('handles rapid button clicks gracefully', async () => {\n      const user = userEvent.setup();\n      render(<AlarmRinging {...mockProps} />);\n\n      const dismissButton = screen.getByRole('button', { name: /dismiss/i });\n\n      // Click rapidly multiple times\n      await user.click(dismissButton);\n      await user.click(dismissButton);\n      await user.click(dismissButton);\n\n      // Should only register as one double-tap dismiss\n      expect(mockProps.onDismiss).toHaveBeenCalledTimes(1);\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/__tests__/Dashboard.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 160,
        "column": 38,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 160,
        "endColumn": 83
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 167,
        "column": 38,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 167,
        "endColumn": 83
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 182,
        "column": 39,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 182,
        "endColumn": 78
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 189,
        "column": 39,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 189,
        "endColumn": 78
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Vitest globals are available globally, no need to import\nimport React from 'react';\nimport { render, screen, waitFor, fireEvent } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport Dashboard from '../Dashboard';\nimport { testUtils } from '../../test-setup';\nimport { PerformanceMonitor } from '../../services/performance-monitor';\nimport { AppAnalyticsService } from '../../services/app-analytics';\n\n// Mock the services and hooks\njest.mock('../../services/performance-monitor', () => ({\n  PerformanceMonitor: {\n    startTracking: jest.fn(),\n    endTracking: jest.fn(),\n    trackUserAction: jest.fn(),\n  },\n}));\n\njest.mock('../../services/app-analytics', () => ({\n  AppAnalyticsService: {\n    trackPageView: jest.fn(),\n    trackUserInteraction: jest.fn(),\n  },\n}));\n\njest.mock('../../hooks/useAuth', () => ({\n  __esModule: true,\n  default: () => ({\n    user: testUtils.mockUser,\n    isAuthenticated: true,\n    loading: false,\n  }),\n}));\n\ndescribe('Dashboard', () => {\n  const mockProps = {\n    user: testUtils.mockUser,\n    alarms: [testUtils.mockAlarm],\n    onAddAlarm: jest.fn(),\n    onEditAlarm: jest.fn(),\n    onDeleteAlarm: jest.fn(),\n    onToggleAlarm: jest.fn(),\n    activeAlarm: null,\n    onQuickSetup: jest.fn(),\n  };\n\n  beforeEach(() => {\n    testUtils.clearAllMocks();\n    jest.clearAllMocks();\n  });\n\n  describe('rendering', () => {\n    test('renders dashboard with user greeting', () => {\n      render(<Dashboard {...mockProps} />);\n\n      expect(screen.getByText(/good/i)).toBeInTheDocument();\n      expect(screen.getByText(testUtils.mockUser.name)).toBeInTheDocument();\n    });\n\n    test('renders correct greeting based on time of day', () => {\n      // Mock different times\n      jest.spyOn(Date.prototype, 'getHours').mockReturnValueOnce(7); // Morning\n\n      render(<Dashboard {...mockProps} />);\n      expect(screen.getByText(/good morning/i)).toBeInTheDocument();\n    });\n\n    test('renders alarm statistics', () => {\n      render(<Dashboard {...mockProps} />);\n\n      expect(screen.getByText('Active Alarms')).toBeInTheDocument();\n      expect(screen.getByText('1')).toBeInTheDocument(); // Count of alarms\n    });\n\n    test('renders quick setup buttons', () => {\n      render(<Dashboard {...mockProps} />);\n\n      expect(screen.getByText('Quick Setup')).toBeInTheDocument();\n      expect(\n        screen.getByRole('button', { name: /morning routine/i })\n      ).toBeInTheDocument();\n      expect(screen.getByRole('button', { name: /work alarm/i })).toBeInTheDocument();\n      expect(screen.getByRole('button', { name: /custom/i })).toBeInTheDocument();\n    });\n\n    test('renders recent alarms section', () => {\n      render(<Dashboard {...mockProps} />);\n\n      expect(screen.getByText('Recent Alarms')).toBeInTheDocument();\n      expect(screen.getByText(testUtils.mockAlarm.label)).toBeInTheDocument();\n      expect(screen.getByText(testUtils.mockAlarm.time)).toBeInTheDocument();\n    });\n\n    test('shows empty state when no alarms', () => {\n      render(<Dashboard {...mockProps} alarms={[]} />);\n\n      expect(screen.getByText(/no alarms yet/i)).toBeInTheDocument();\n      expect(screen.getByText(/create your first alarm/i)).toBeInTheDocument();\n    });\n  });\n\n  describe('interactions', () => {\n    test('calls onAddAlarm when add button is clicked', async () => {\n      const user = userEvent.setup();\n      render(<Dashboard {...mockProps} />);\n\n      const addButton = screen.getByRole('button', { name: /add alarm/i });\n      await user.click(addButton);\n\n      expect(mockProps.onAddAlarm).toHaveBeenCalled();\n    });\n\n    test('calls onQuickSetup with correct preset', async () => {\n      const user = userEvent.setup();\n      render(<Dashboard {...mockProps} />);\n\n      const morningButton = screen.getByRole('button', { name: /morning routine/i });\n      await user.click(morningButton);\n\n      expect(mockProps.onQuickSetup).toHaveBeenCalledWith('morning');\n    });\n\n    test('calls onEditAlarm when alarm edit is clicked', async () => {\n      const user = userEvent.setup();\n      render(<Dashboard {...mockProps} />);\n\n      const editButton = screen.getByRole('button', { name: /edit alarm/i });\n      await user.click(editButton);\n\n      expect(mockProps.onEditAlarm).toHaveBeenCalledWith(testUtils.mockAlarm);\n    });\n\n    test('calls onToggleAlarm when alarm switch is clicked', async () => {\n      const user = userEvent.setup();\n      render(<Dashboard {...mockProps} />);\n\n      const toggleSwitch = screen.getByRole('switch');\n      await user.click(toggleSwitch);\n\n      expect(mockProps.onToggleAlarm).toHaveBeenCalledWith(testUtils.mockAlarm.id);\n    });\n\n    test('calls onDeleteAlarm when delete is confirmed', async () => {\n      const user = userEvent.setup();\n      render(<Dashboard {...mockProps} />);\n\n      const deleteButton = screen.getByRole('button', { name: /delete alarm/i });\n      await user.click(deleteButton);\n\n      // Confirm deletion in modal\n      const confirmButton = screen.getByRole('button', { name: /delete/i });\n      await user.click(confirmButton);\n\n      expect(mockProps.onDeleteAlarm).toHaveBeenCalledWith(testUtils.mockAlarm.id);\n    });\n  });\n\n  describe('performance tracking', () => {\n    test('tracks dashboard view on mount', () => {\n      const { PerformanceMonitor } = require('../../services/performance-monitor');\n      render(<Dashboard {...mockProps} />);\n\n      expect(PerformanceMonitor.startTracking).toHaveBeenCalledWith('dashboard-view');\n    });\n\n    test('tracks user interactions', async () => {\n      const { PerformanceMonitor } = require('../../services/performance-monitor');\n      const user = userEvent.setup();\n      render(<Dashboard {...mockProps} />);\n\n      const addButton = screen.getByRole('button', { name: /add alarm/i });\n      await user.click(addButton);\n\n      expect(PerformanceMonitor.trackUserAction).toHaveBeenCalledWith(\n        'add-alarm-clicked'\n      );\n    });\n  });\n\n  describe('analytics tracking', () => {\n    test('tracks page view on mount', () => {\n      const { AppAnalyticsService } = require('../../services/app-analytics');\n      render(<Dashboard {...mockProps} />);\n\n      expect(AppAnalyticsService.trackPageView).toHaveBeenCalledWith('dashboard');\n    });\n\n    test('tracks quick setup interactions', async () => {\n      const { AppAnalyticsService } = require('../../services/app-analytics');\n      const user = userEvent.setup();\n      render(<Dashboard {...mockProps} />);\n\n      const workButton = screen.getByRole('button', { name: /work alarm/i });\n      await user.click(workButton);\n\n      expect(AppAnalyticsService.trackUserInteraction).toHaveBeenCalledWith(\n        'quick-setup-used',\n        { preset: 'work' }\n      );\n    });\n  });\n\n  describe('responsive behavior', () => {\n    test('adapts layout for mobile screens', () => {\n      // Mock mobile viewport\n      Object.defineProperty(window, 'innerWidth', { value: 375 });\n      Object.defineProperty(window, 'innerHeight', { value: 667 });\n\n      render(<Dashboard {...mockProps} />);\n\n      const container = screen.getByTestId('dashboard-container');\n      expect(container).toHaveClass('mobile-layout');\n    });\n\n    test('shows desktop layout for large screens', () => {\n      Object.defineProperty(window, 'innerWidth', { value: 1024 });\n      Object.defineProperty(window, 'innerHeight', { value: 768 });\n\n      render(<Dashboard {...mockProps} />);\n\n      const container = screen.getByTestId('dashboard-container');\n      expect(container).toHaveClass('desktop-layout');\n    });\n  });\n\n  describe('loading states', () => {\n    test('shows loading spinner while data loads', () => {\n      render(<Dashboard {...mockProps} alarms={undefined} />);\n\n      expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();\n    });\n\n    test('shows skeleton placeholders during load', () => {\n      render(<Dashboard {...mockProps} alarms={undefined} />);\n\n      expect(screen.getAllByTestId('alarm-skeleton')).toHaveLength(3);\n    });\n  });\n\n  describe('accessibility', () => {\n    test('has proper heading structure', () => {\n      render(<Dashboard {...mockProps} />);\n\n      expect(screen.getByRole('heading', { level: 1 })).toBeInTheDocument();\n      expect(\n        screen.getByRole('heading', { level: 2, name: /quick setup/i })\n      ).toBeInTheDocument();\n      expect(\n        screen.getByRole('heading', { level: 2, name: /recent alarms/i })\n      ).toBeInTheDocument();\n    });\n\n    test('has proper ARIA labels', () => {\n      render(<Dashboard {...mockProps} />);\n\n      expect(screen.getByLabelText('Dashboard main content')).toBeInTheDocument();\n      expect(screen.getByLabelText('Alarm statistics')).toBeInTheDocument();\n    });\n\n    test('supports keyboard navigation', async () => {\n      const user = userEvent.setup();\n      render(<Dashboard {...mockProps} />);\n\n      const addButton = screen.getByRole('button', { name: /add alarm/i });\n      const quickSetupButton = screen.getByRole('button', { name: /morning routine/i });\n\n      // Tab navigation\n      await user.tab();\n      expect(addButton).toHaveFocus();\n\n      await user.tab();\n      expect(quickSetupButton).toHaveFocus();\n    });\n\n    test('announces important changes to screen readers', async () => {\n      const user = userEvent.setup();\n      render(<Dashboard {...mockProps} />);\n\n      const toggleSwitch = screen.getByRole('switch');\n      await user.click(toggleSwitch);\n\n      // Check for ARIA live region updates\n      expect(screen.getByLabelText('Alarm status updated')).toBeInTheDocument();\n    });\n  });\n\n  describe('error handling', () => {\n    test('handles missing user gracefully', () => {\n      render(<Dashboard {...mockProps} user={null} />);\n\n      expect(screen.getByText(/welcome/i)).toBeInTheDocument();\n    });\n\n    test('handles API errors gracefully', async () => {\n      const consoleError = jest.spyOn(console, 'error').mockImplementation();\n\n      // Mock a failing onAddAlarm\n      const failingOnAddAlarm = jest.fn().mockRejectedValue(new Error('API Error'));\n\n      const user = userEvent.setup();\n      render(<Dashboard {...mockProps} onAddAlarm={failingOnAddAlarm} />);\n\n      const addButton = screen.getByRole('button', { name: /add alarm/i });\n      await user.click(addButton);\n\n      await waitFor(() => {\n        expect(screen.getByText(/error creating alarm/i)).toBeInTheDocument();\n      });\n\n      consoleError.mockRestore();\n    });\n  });\n\n  describe('real-time updates', () => {\n    test('updates alarm status in real-time', async () => {\n      const { rerender } = render(<Dashboard {...mockProps} />);\n\n      const updatedAlarm = { ...testUtils.mockAlarm, enabled: false };\n      rerender(<Dashboard {...mockProps} alarms={[updatedAlarm]} />);\n\n      const toggleSwitch = screen.getByRole('switch');\n      expect(toggleSwitch).not.toBeChecked();\n    });\n\n    test('handles active alarm display', () => {\n      const activeAlarm = { ...testUtils.mockAlarm, isActive: true };\n      render(<Dashboard {...mockProps} activeAlarm={activeAlarm} />);\n\n      expect(screen.getByText(/alarm ringing/i)).toBeInTheDocument();\n      expect(screen.getByText(activeAlarm.label)).toBeInTheDocument();\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/__tests__/RootErrorBoundary.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 109,
        "column": 32,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 109,
        "endColumn": 71
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 311,
        "column": 30,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 311,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 530,
        "column": 30,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 530,
        "endColumn": 69
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\nimport React from \"react\";\nimport { render, screen, fireEvent } from \"@testing-library/react\";\nimport userEvent from \"@testing-library/user-event\";\nimport RootErrorBoundary from \"../RootErrorBoundary\";\nimport {\n  AnalyticsErrorBoundary,\n  MediaErrorBoundary,\n  AIErrorBoundary,\n  APIErrorBoundary,\n  DataErrorBoundary,\n  FormErrorBoundary\n} from '../SpecializedErrorBoundaries';\n\n\nimport { testUtils } from '../../test-setup';\n\n// Mock ErrorHandler service\njest.mock('../../services/error-handler', () => ({\n  ErrorHandler: {\n    handleError: jest.fn(() => 'test-error-id-123'),\n  }\n}));\n\n// Test component that throws errors\nconst ThrowError: React.FC<{\n  shouldThrow?: boolean;\n  errorMessage?: string;\n  errorType?: string;\n}> = ({\n  shouldThrow = false,\n  errorMessage = 'Test error',\n  errorType = 'generic'\n}) => {\n  if (shouldThrow) {\n    const error = new Error(errorMessage);\n    (error as any).type = errorType;\n    throw error;\n  }\n  return <div data-testid=\"working-component\">Component rendered successfully</div>;\n};\n\ndescribe('RootErrorBoundary', () => {\n  beforeEach(() => {\n    testUtils.clearAllMocks();\n    jest.spyOn(console, 'error').mockImplementation(() => {});\n  });\n\n  afterEach(() => {\n    jest.restoreAllMocks();\n  });\n\n  describe('normal operation', () => {\n    test('renders children when no error occurs', () => {\n      render(\n        <RootErrorBoundary>\n          <ThrowError shouldThrow={false} />\n        </RootErrorBoundary>\n      );\n\n      expect(screen.getByTestId('working-component')).toBeInTheDocument();\n    });\n\n    test('renders complex component tree without errors', () => {\n      render(\n        <RootErrorBoundary>\n          <div>\n            <h1>App Header</h1>\n            <main>\n              <ThrowError shouldThrow={false} />\n            </main>\n            <footer>App Footer</footer>\n          </div>\n        </RootErrorBoundary>\n      );\n\n      expect(screen.getByText('App Header')).toBeInTheDocument();\n      expect(screen.getByTestId('working-component')).toBeInTheDocument();\n      expect(screen.getByText('App Footer')).toBeInTheDocument();\n    });\n  });\n\n  describe('error handling', () => {\n    test('catches errors and shows root fallback UI', () => {\n      render(\n        <RootErrorBoundary>\n          <ThrowError shouldThrow={true} errorMessage=\"Critical app error\" />\n        </RootErrorBoundary>\n      );\n\n      expect(screen.getByText('Something went wrong')).toBeInTheDocument();\n      expect(screen.getByText(/critical app error occurred/i)).toBeInTheDocument();\n      expect(screen.getByRole('button', { name: /try again/i })).toBeInTheDocument();\n      expect(screen.getByRole('button', { name: /reload app/i })).toBeInTheDocument();\n      expect(screen.getByRole('button', { name: /fresh start/i })).toBeInTheDocument();\n    });\n\n    test('shows error ID for support', () => {\n      render(\n        <RootErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </RootErrorBoundary>\n      );\n\n      expect(screen.getByText(/error id: test-error-id-123/i)).toBeInTheDocument();\n    });\n\n    test('calls ErrorHandler with correct parameters', () => {\n      const { ErrorHandler } = require('../../services/error-handler');\n\n      render(\n        <RootErrorBoundary>\n          <ThrowError shouldThrow={true} errorMessage=\"Test error for handler\" />\n        </RootErrorBoundary>\n      );\n\n      expect(ErrorHandler.handleError).toHaveBeenCalledWith(\n        expect.any(Error),\n        expect.objectContaining({\n          context: 'RootErrorBoundary',\n          severity: 'high',\n          componentStack: expect.any(String)\n        })\n      );\n    });\n\n    test('shows retry attempts counter', () => {\n      const { rerender } = render(\n        <RootErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </RootErrorBoundary>\n      );\n\n      const retryButton = screen.getByRole('button', { name: /try again/i });\n\n      // First retry\n      fireEvent.click(retryButton);\n      rerender(\n        <RootErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </RootErrorBoundary>\n      );\n\n      expect(screen.getByText(/attempt 2 of 3/i)).toBeInTheDocument();\n    });\n\n    test('disables retry after maximum attempts', () => {\n      const { rerender } = render(\n        <RootErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </RootErrorBoundary>\n      );\n\n      const retryButton = screen.getByRole('button', { name: /try again/i });\n\n      // Exhaust retry attempts\n      for (let i = 0; i < 3; i++) {\n        fireEvent.click(retryButton);\n        rerender(\n          <RootErrorBoundary>\n            <ThrowError shouldThrow={true} />\n          </RootErrorBoundary>\n        );\n      }\n\n      expect(retryButton).toBeDisabled();\n      expect(screen.getByText(/maximum retry attempts reached/i)).toBeInTheDocument();\n    });\n  });\n\n  describe('recovery actions', () => {\n    test('reload app button reloads the page', () => {\n      // Mock window.location.reload\n      const mockReload = jest.fn();\n      Object.defineProperty(window, 'location', {\n        value: { reload: mockReload },\n        writable: true,\n      });\n\n      render(\n        <RootErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </RootErrorBoundary>\n      );\n\n      const reloadButton = screen.getByRole('button', { name: /reload app/i });\n      fireEvent.click(reloadButton);\n\n      expect(mockReload).toHaveBeenCalled();\n    });\n\n    test('fresh start clears storage and reloads', () => {\n      const mockReload = jest.fn();\n      Object.defineProperty(window, 'location', {\n        value: { reload: mockReload },\n        writable: true,\n      });\n\n      render(\n        <RootErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </RootErrorBoundary>\n      );\n\n      const freshStartButton = screen.getByRole('button', { name: /fresh start/i });\n      fireEvent.click(freshStartButton);\n\n      expect(testUtils.mockStorage.clear).toHaveBeenCalled();\n      expect(mockReload).toHaveBeenCalled();\n    });\n\n    test('report error opens email client', () => {\n      // Mock window.open\n      const mockOpen = jest.fn();\n      Object.defineProperty(window, 'open', {\n        value: mockOpen,\n        writable: true,\n      });\n\n      render(\n        <RootErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </RootErrorBoundary>\n      );\n\n      const reportButton = screen.getByRole('button', { name: /report error/i });\n      fireEvent.click(reportButton);\n\n      expect(mockOpen).toHaveBeenCalledWith(\n        expect.stringContaining('mailto:support@'),\n        '_blank'\n      );\n    });\n  });\n\n  describe('accessibility', () => {\n    test('has proper ARIA roles and labels', () => {\n      render(\n        <RootErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </RootErrorBoundary>\n      );\n\n      expect(screen.getByRole('alert')).toBeInTheDocument();\n      expect(screen.getByLabelText('Error information')).toBeInTheDocument();\n    });\n\n    test('supports keyboard navigation', async () => {\n      const user = userEvent.setup();\n      render(\n        <RootErrorBoundary>\n          <ThrowError shouldThrow={true} />\n        </RootErrorBoundary>\n      );\n\n      const retryButton = screen.getByRole('button', { name: /try again/i });\n      const reloadButton = screen.getByRole('button', { name: /reload app/i });\n\n      await user.tab();\n      expect(retryButton).toHaveFocus();\n\n      await user.tab();\n      expect(reloadButton).toHaveFocus();\n    });\n  });\n});\n\ndescribe('AnalyticsErrorBoundary', () => {\n  beforeEach(() => {\n    testUtils.clearAllMocks();\n    jest.spyOn(console, 'error').mockImplementation(() => {});\n  });\n\n  afterEach(() => {\n    jest.restoreAllMocks();\n  });\n\n  test('renders children normally', () => {\n    render(\n      <AnalyticsErrorBoundary>\n        <ThrowError shouldThrow={false} />\n      </AnalyticsErrorBoundary>\n    );\n\n    expect(screen.getByTestId('working-component')).toBeInTheDocument();\n  });\n\n  test('shows analytics-specific error message', () => {\n    render(\n      <AnalyticsErrorBoundary>\n        <ThrowError shouldThrow={true} errorMessage=\"Analytics service failed\" />\n      </AnalyticsErrorBoundary>\n    );\n\n    expect(screen.getByText('Analytics Temporarily Unavailable')).toBeInTheDocument();\n    expect(screen.getByText(/analytics and performance tracking/i)).toBeInTheDocument();\n    expect(screen.getByText(/core alarm features/i)).toBeInTheDocument();\n  });\n\n  test('provides continue without analytics option', () => {\n    render(\n      <AnalyticsErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </AnalyticsErrorBoundary>\n    );\n\n    expect(screen.getByRole('button', { name: /continue without analytics/i })).toBeInTheDocument();\n  });\n\n  test('reports error with analytics context', () => {\n    const { ErrorHandler } = require('../../services/error-handler');\n\n    render(\n      <AnalyticsErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </AnalyticsErrorBoundary>\n    );\n\n    expect(ErrorHandler.handleError).toHaveBeenCalledWith(\n      expect.any(Error),\n      expect.objectContaining({\n        context: 'Analytics',\n        severity: 'low',\n        category: 'analytics'\n      })\n    );\n  });\n});\n\ndescribe('MediaErrorBoundary', () => {\n  beforeEach(() => {\n    testUtils.clearAllMocks();\n    jest.spyOn(console, 'error').mockImplementation(() => {});\n  });\n\n  test('shows media-specific error message', () => {\n    render(\n      <MediaErrorBoundary>\n        <ThrowError shouldThrow={true} errorMessage=\"Audio playback failed\" />\n      </MediaErrorBoundary>\n    );\n\n    expect(screen.getByText('Media Content Issue')).toBeInTheDocument();\n    expect(screen.getByText(/audio or media content/i)).toBeInTheDocument();\n    expect(screen.getByText(/alarms will still work/i)).toBeInTheDocument();\n  });\n\n  test('provides fallback audio option', () => {\n    render(\n      <MediaErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </MediaErrorBoundary>\n    );\n\n    expect(screen.getByRole('button', { name: /use default audio/i })).toBeInTheDocument();\n  });\n});\n\ndescribe('AIErrorBoundary', () => {\n  beforeEach(() => {\n    testUtils.clearAllMocks();\n    jest.spyOn(console, 'error').mockImplementation(() => {});\n  });\n\n  test('shows AI-specific error message', () => {\n    render(\n      <AIErrorBoundary>\n        <ThrowError shouldThrow={true} errorMessage=\"AI service unavailable\" />\n      </AIErrorBoundary>\n    );\n\n    expect(screen.getByText('AI Features Temporarily Unavailable')).toBeInTheDocument();\n    expect(screen.getByText(/smart features are currently unavailable/i)).toBeInTheDocument();\n    expect(screen.getByText(/basic alarm functionality/i)).toBeInTheDocument();\n  });\n\n  test('provides manual mode option', () => {\n    render(\n      <AIErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </AIErrorBoundary>\n    );\n\n    expect(screen.getByRole('button', { name: /continue in manual mode/i })).toBeInTheDocument();\n  });\n});\n\ndescribe('APIErrorBoundary', () => {\n  beforeEach(() => {\n    testUtils.clearAllMocks();\n    jest.spyOn(console, 'error').mockImplementation(() => {});\n  });\n\n  test('shows network-specific error message', () => {\n    render(\n      <APIErrorBoundary>\n        <ThrowError shouldThrow={true} errorMessage=\"Network request failed\" />\n      </APIErrorBoundary>\n    );\n\n    expect(screen.getByText('Connection Issue')).toBeInTheDocument();\n    expect(screen.getByText(/unable to connect/i)).toBeInTheDocument();\n    expect(screen.getByText(/offline features/i)).toBeInTheDocument();\n  });\n\n  test('provides offline mode option', () => {\n    render(\n      <APIErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </APIErrorBoundary>\n    );\n\n    expect(screen.getByRole('button', { name: /continue offline/i })).toBeInTheDocument();\n  });\n\n  test('shows retry connection option', () => {\n    render(\n      <APIErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </APIErrorBoundary>\n    );\n\n    expect(screen.getByRole('button', { name: /retry connection/i })).toBeInTheDocument();\n  });\n});\n\ndescribe('DataErrorBoundary', () => {\n  beforeEach(() => {\n    testUtils.clearAllMocks();\n    jest.spyOn(console, 'error').mockImplementation(() => {});\n  });\n\n  test('shows data-specific error message', () => {\n    render(\n      <DataErrorBoundary>\n        <ThrowError shouldThrow={true} errorMessage=\"Database error\" />\n      </DataErrorBoundary>\n    );\n\n    expect(screen.getByText('Data Storage Issue')).toBeInTheDocument();\n    expect(screen.getByText(/problem accessing your data/i)).toBeInTheDocument();\n    expect(screen.getByText(/data integrity/i)).toBeInTheDocument();\n  });\n\n  test('provides data recovery options', () => {\n    render(\n      <DataErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </DataErrorBoundary>\n    );\n\n    expect(screen.getByRole('button', { name: /reload data/i })).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: /restore backup/i })).toBeInTheDocument();\n  });\n});\n\ndescribe('FormErrorBoundary', () => {\n  beforeEach(() => {\n    testUtils.clearAllMocks();\n    jest.spyOn(console, 'error').mockImplementation(() => {});\n  });\n\n  test('shows form-specific error message', () => {\n    render(\n      <FormErrorBoundary>\n        <ThrowError shouldThrow={true} errorMessage=\"Form validation failed\" />\n      </FormErrorBoundary>\n    );\n\n    expect(screen.getByText('Form Error')).toBeInTheDocument();\n    expect(screen.getByText(/problem with the form/i)).toBeInTheDocument();\n    expect(screen.getByText(/data has been preserved/i)).toBeInTheDocument();\n  });\n\n  test('provides form recovery options', () => {\n    render(\n      <FormErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </FormErrorBoundary>\n    );\n\n    expect(screen.getByRole('button', { name: /try again/i })).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: /refresh form/i })).toBeInTheDocument();\n  });\n\n  test('preserves form data message', () => {\n    render(\n      <FormErrorBoundary>\n        <ThrowError shouldThrow={true} />\n      </FormErrorBoundary>\n    );\n\n    expect(screen.getByText(/your form data has been preserved/i)).toBeInTheDocument();\n  });\n});\n\ndescribe('Error Boundary Integration', () => {\n  test('nested error boundaries work correctly', () => {\n    render(\n      <RootErrorBoundary>\n        <div>\n          <h1>App</h1>\n          <AnalyticsErrorBoundary>\n            <div>\n              <h2>Analytics Section</h2>\n              <ThrowError shouldThrow={true} errorMessage=\"Analytics error\" />\n            </div>\n          </AnalyticsErrorBoundary>\n          <div>\n            <h2>Other Section</h2>\n            <p>This should still render</p>\n          </div>\n        </div>\n      </RootErrorBoundary>\n    );\n\n    // Root content should be visible\n    expect(screen.getByText('App')).toBeInTheDocument();\n    expect(screen.getByText('Other Section')).toBeInTheDocument();\n    expect(screen.getByText('This should still render')).toBeInTheDocument();\n\n    // Analytics error boundary should catch the error\n    expect(screen.getByText('Analytics Temporarily Unavailable')).toBeInTheDocument();\n\n    // Root error boundary should not activate\n    expect(screen.queryByText('Something went wrong')).not.toBeInTheDocument();\n  });\n\n  test('error boundaries report to different contexts', () => {\n    const { ErrorHandler } = require('../../services/error-handler');\n\n    render(\n      <div>\n        <MediaErrorBoundary>\n          <ThrowError shouldThrow={true} errorMessage=\"Media error\" />\n        </MediaErrorBoundary>\n        <APIErrorBoundary>\n          <ThrowError shouldThrow={true} errorMessage=\"API error\" />\n        </APIErrorBoundary>\n      </div>\n    );\n\n    expect(ErrorHandler.handleError).toHaveBeenCalledWith(\n      expect.any(Error),\n      expect.objectContaining({ context: 'Media' })\n    );\n\n    expect(ErrorHandler.handleError).toHaveBeenCalledWith(\n      expect.any(Error),\n      expect.objectContaining({ context: 'API' })\n    );\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/premium/EnhancedUpgradePrompt.tsx",
    "messages": [
      {
        "ruleId": "no-shadow-restricted-names",
        "severity": 2,
        "message": "Shadowing of global property 'Infinity'.",
        "line": 10,
        "column": 3,
        "nodeType": "Identifier",
        "messageId": "shadowingRestrictedName",
        "endLine": 10,
        "endColumn": 11
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'tier' is not defined.",
        "line": 213,
        "column": 17,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 213,
        "endColumn": 21
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import React, { useState, useEffect } from 'react';\nimport {\n  Crown,\n  Star,\n  Zap,\n  X,\n  Check,\n  Mic,\n  Target,\n  Infinity,\n  Shield,\n  BarChart3,\n  Palette,\n  Headphones,\n  Flame,\n  Brain,\n  Laugh,\n  Robot,\n  Clock,\n  Users,\n  TrendingUp,\n  ArrowRight,\n  Sparkles,\n  Lock,\n} from \"lucide-react\";\n\ninterface EnhancedUpgradePromptProps {\n  /** The feature that triggered the upgrade prompt */\n  feature: string;\n  /** Whether to show as modal or inline */\n  variant?: 'modal' | 'inline' | 'banner' | 'fullscreen';\n  /** Callback when user clicks upgrade */\n  /** Callback when user dismisses prompt */\n  onDismiss?: () => void;\n  /** Custom title override */\n  title?: string;\n  /** Custom description override */\n  description?: string;\n  /** Whether to show pricing */\n  showPricing?: boolean;\n  /** Current user tier for comparison */\n  /** Show social proof */\n  showSocialProof?: boolean;\n  /** Show urgency messaging */\n  showUrgency?: boolean;\n  /** Custom CTA text */\n  ctaText?: string;\n}\n\nconst EnhancedUpgradePrompt: React.FC<EnhancedUpgradePromptProps> = ({\n  feature,\n  variant = 'modal',\n  onUpgrade,\n  onDismiss,\n  title,\n  description,\n  showPricing = true,\n  currentTier = 'free',\n  showSocialProof = true,\n  showUrgency = true,\n  ctaText\n}) => {\n  const [isAnimating, setIsAnimating] = useState(false);\n  const [currentTestimonial, setCurrentTestimonial] = useState(0);\n\n  useEffect(() => {\n    setIsAnimating(true);\n    const timer = setTimeout(() => setIsAnimating(false), 500);\n    return () => clearTimeout(timer);\n  }, []);\n\n  // Rotate testimonials every 4 seconds\n  useEffect(() => {\n    if (!showSocialProof) return;\n    const interval = setInterval(() => {\n      setCurrentTestimonial(prev => (prev + 1) % testimonials.length);\n    }, 4000);\n    return () => clearInterval(interval);\n  }, [showSocialProof]);\n\n  const getFeatureInfo = (featureId: string) => {\n    const featureMap: Record<\n      string,\n      {\n        title: string;\n        description: string;\n        icon: React.ReactNode;\n        benefits: string[];\n        color: string;\n        gradient: string;\n      }\n    > = {\n      nuclearMode: {\n        title: 'Nuclear Mode',\n        description: 'The ultimate wake-up challenge for unstoppable mornings',\n        icon: <Flame className=\"w-8 h-8\" />,\n        benefits: [\n          '5x score multiplier for ultimate rewards',\n          'Nuclear-themed extreme challenges',\n          'Meltdown consequences for failure',\n          'Exclusive achievement system',\n          'Dramatic visual effects'\n        ],\n        tier: 'pro',\n        color: 'from-red-500 to-orange-600',\n        gradient: 'bg-gradient-to-br from-red-50 to-orange-50'\n      },\n      premiumPersonalities: {\n        title: 'Premium Voice Personalities',\n        description: 'Unlock exclusive AI personalities for personalized wake-ups',\n        icon: <Brain className=\"w-8 h-8\" />,\n        benefits: [\n          'üî• Demon Lord: Dark, intimidating commands',\n          'ü§ñ AI Robot: Systematic wake protocols',\n          'üé≠ Comedian: Hilarious entertainment',\n          'üß† Philosopher: Contemplative wisdom',\n          'Never get bored with variety'\n        ],\n        tier: 'pro',\n        color: 'from-purple-500 to-pink-600',\n        gradient: 'bg-gradient-to-br from-purple-50 to-pink-50'\n      },\n      customVoices: {\n        title: 'Custom Voice Messages',\n        description: 'Create personalized wake-up messages with premium TTS',\n        icon: <Mic className=\"w-8 h-8\" />,\n        benefits: [\n          'High-quality ElevenLabs voices',\n          'Unlimited custom messages',\n          'Voice cloning technology',\n          'Emotional voice variations',\n          'Celebrity-style voices'\n        ],\n        tier: 'premium',\n        color: 'from-blue-500 to-cyan-600',\n        gradient: 'bg-gradient-to-br from-blue-50 to-cyan-50'\n      },\n      analytics: {\n        title: 'Advanced Analytics',\n        description: 'Deep insights into your sleep and wake patterns',\n        icon: <BarChart3 className=\"w-8 h-8\" />,\n        benefits: [\n          'Sleep quality analysis',\n          'Productivity correlations',\n          'Habit tracking insights',\n          'Performance optimization',\n          'Exportable reports'\n        ],\n        tier: 'premium',\n        color: 'from-green-500 to-emerald-600',\n        gradient: 'bg-gradient-to-br from-green-50 to-emerald-50'\n      }\n    };\n\n    return (\n      featureMap[featureId] || {\n        title: \"Premium Feature\",\n        description: \"Unlock advanced functionality\",\n        icon: <Star className=\"w-8 h-8\" />,\n        benefits: [\"Enhanced functionality\", \"Priority support\"],\n        color: \"from-gray-500 to-gray-600\",\n        gradient: \"bg-gradient-to-br from-gray-50 to-gray-100\",\n      }\n    );\n  };\n\n  const testimonials = [\n    {\n      text: \"Nuclear Mode completely changed my morning routine. I actually look forward to waking up now!\",\n      author: \"Sarah M.\",\n      title: \"Pro User\",\n      rating: 5\n    },\n    {\n      text: \"The Demon Lord personality is hilarious but surprisingly effective. Best $9.99 I've spent.\",\n      author: \"Mike R.\",\n      title: \"Pro User\",\n      rating: 5\n    },\n    {\n      text: \"Finally an alarm app that understands psychology. The premium features are game-changing.\",\n      author: \"Dr. Lisa K.\",\n      title: \"Sleep Specialist\",\n      rating: 5\n    }\n  ];\n\n  const featureInfo = getFeatureInfo(feature);\n  const displayTitle = title || `Unlock ${featureInfo.title}`;\n  const displayDescription = description || featureInfo.description;\n\n  const getPricingInfo = () => {\n    if (featureInfo.tier === 'pro') {\n      return {\n        monthly: { price: 9.99, savings: null },\n        yearly: { price: 99.99, savings: 17 }\n      };\n    }\n    return {\n      monthly: { price: 4.99, savings: null },\n      yearly: { price: 49.99, savings: 17 }\n    };\n  };\n\n  const pricing = getPricingInfo();\n\n  const handleUpgrade = (\n    interval: \"monthly\" | \"yearly\" = \"monthly\",\n  ) => {\n    // Add smooth transition effect\n    setIsAnimating(true);\n    setTimeout(() => {\n      onUpgrade(tier);\n    }, 200);\n  };\n\n  if (variant === 'banner') {\n    return (\n      <div className={`\n        relative overflow-hidden rounded-xl border border-yellow-200\n        bg-gradient-to-r from-yellow-50 via-orange-50 to-red-50\n        p-4 shadow-sm transition-all duration-300 hover:shadow-md\n        ${isAnimating ? 'animate-pulse' : ''}\n      `}>\n        <div className=\"flex items-center justify-between\">\n          <div className=\"flex items-center space-x-3\">\n            <div className={`p-2 rounded-lg bg-gradient-to-br ${featureInfo.color} text-white`}>\n              {featureInfo.icon}\n            </div>\n            <div>\n              <h3 className=\"font-semibold text-gray-900\">{displayTitle}</h3>\n              <p className=\"text-sm text-gray-600\">{displayDescription}</p>\n            </div>\n          </div>\n          <div className=\"flex items-center space-x-2\">\n            {showUrgency && (\n              <span className=\"inline-flex items-center px-2 py-1 text-xs font-medium text-orange-700 bg-orange-100 rounded-full\">\n                <Zap className=\"w-3 h-3 mr-1\" />\n                Limited Time\n              </span>\n            )}\n            <button\n              onClick={() => handleUpgrade(featureInfo.tier)}\n              className=\"inline-flex items-center px-4 py-2 bg-gradient-to-r from-blue-600 to-purple-600 text-white text-sm font-medium rounded-lg hover:from-blue-700 hover:to-purple-700 transition-all duration-200 transform hover:scale-105\"\n            >\n              {ctaText || 'Upgrade Now'}\n              <ArrowRight className=\"w-4 h-4 ml-1\" />\n            </button>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  if (variant === 'inline') {\n    return (\n      <div className={`\n        relative rounded-2xl border-2 border-dashed border-gray-200\n        p-6 text-center transition-all duration-300 hover:border-gray-300\n        ${featureInfo.gradient}\n        ${isAnimating ? 'animate-bounce' : ''}\n      `}>\n        <div className=\"mx-auto mb-4\">\n          <div className={`inline-flex p-4 rounded-full bg-gradient-to-br ${featureInfo.color} text-white shadow-lg`}>\n            {featureInfo.icon}\n          </div>\n        </div>\n        <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">{displayTitle}</h3>\n        <p className=\"text-gray-600 mb-4\">{displayDescription}</p>\n\n        <div className=\"space-y-2 mb-6\">\n          {featureInfo.benefits.slice(0, 3).map((benefit, index) => (\n            <div key={index} className=\"flex items-center justify-center text-sm text-gray-700\">\n              <Check className=\"w-4 h-4 text-green-500 mr-2 flex-shrink-0\" />\n              {benefit}\n            </div>\n          ))}\n        </div>\n\n        <button\n          onClick={() => handleUpgrade(featureInfo.tier)}\n          className=\"w-full bg-gradient-to-r from-blue-600 to-purple-600 text-white py-3 px-6 rounded-xl font-medium hover:from-blue-700 hover:to-purple-700 transition-all duration-200 transform hover:scale-105 shadow-lg hover:shadow-xl\"\n        >\n          {ctaText || `Upgrade to ${featureInfo.tier.charAt(0).toUpperCase() + featureInfo.tier.slice(1)}`}\n        </button>\n      </div>\n    );\n  }\n\n  // Modal and Fullscreen variants\n  const isFullscreen = variant === 'fullscreen';\n\n  return (\n    <div className=\"fixed inset-0 z-50 flex items-center justify-center p-4 bg-black bg-opacity-50 backdrop-blur-sm\">\n      <div className={`\n        relative w-full max-w-2xl mx-auto bg-white rounded-3xl shadow-2xl overflow-hidden\n        transform transition-all duration-300\n        ${isAnimating ? 'scale-95 opacity-0' : 'scale-100 opacity-100'}\n        ${isFullscreen ? 'max-w-4xl max-h-screen' : 'max-h-[90vh]'}\n      `}>\n        {/* Header */}\n        <div className={`relative px-8 pt-8 pb-6 bg-gradient-to-br ${featureInfo.color} text-white overflow-hidden`}>\n          {/* Background decoration */}\n          <div className=\"absolute inset-0 opacity-10\">\n            <div className=\"absolute top-0 right-0 w-64 h-64 rounded-full bg-white transform translate-x-32 -translate-y-32\"></div>\n            <div className=\"absolute bottom-0 left-0 w-48 h-48 rounded-full bg-white transform -translate-x-24 translate-y-24\"></div>\n          </div>\n\n          {/* Close button */}\n          {onDismiss && (\n            <button\n              onClick={onDismiss}\n              className=\"absolute top-4 right-4 p-2 rounded-full bg-white bg-opacity-20 hover:bg-opacity-30 transition-colors\"\n            >\n              <X className=\"w-5 h-5\" />\n            </button>\n          )}\n\n          <div className=\"relative z-10\">\n            <div className=\"flex items-center space-x-4 mb-4\">\n              <div className=\"p-3 bg-white bg-opacity-20 rounded-2xl\">\n                {featureInfo.icon}\n              </div>\n              <div>\n                <h2 className=\"text-3xl font-bold\">{displayTitle}</h2>\n                {showUrgency && (\n                  <div className=\"flex items-center mt-2\">\n                    <Sparkles className=\"w-4 h-4 mr-1\" />\n                    <span className=\"text-sm font-medium opacity-90\">Limited time offer</span>\n                  </div>\n                )}\n              </div>\n            </div>\n            <p className=\"text-xl text-white text-opacity-90\">{displayDescription}</p>\n          </div>\n        </div>\n\n        {/* Content */}\n        <div className=\"px-8 py-6\">\n          {/* Benefits */}\n          <div className=\"mb-8\">\n            <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">What you'll get:</h3>\n            <div className=\"grid grid-cols-1 gap-3\">\n              {featureInfo.benefits.map((benefit, index) => (\n                <div\n                  key={index}\n                  className=\"flex items-start space-x-3 p-3 rounded-xl bg-gray-50 hover:bg-gray-100 transition-colors\"\n                >\n                  <div className=\"flex-shrink-0 w-6 h-6 bg-green-100 rounded-full flex items-center justify-center mt-0.5\">\n                    <Check className=\"w-4 h-4 text-green-600\" />\n                  </div>\n                  <span className=\"text-gray-700 font-medium\">{benefit}</span>\n                </div>\n              ))}\n            </div>\n          </div>\n\n          {/* Social Proof */}\n          {showSocialProof && (\n            <div className=\"mb-8 p-6 bg-gradient-to-r from-blue-50 to-purple-50 rounded-2xl border border-blue-100\">\n              <div className=\"flex items-center justify-between mb-4\">\n                <h3 className=\"font-semibold text-gray-900\">What users are saying</h3>\n                <div className=\"flex items-center space-x-1\">\n                  {[...Array(5)].map((_, i) => (\n                    <Star key={i} className=\"w-4 h-4 text-yellow-400 fill-current\" />\n                  ))}\n                  <span className=\"text-sm text-gray-600 ml-2\">(4.9/5 from 2,847 users)</span>\n                </div>\n              </div>\n              <div className=\"transition-all duration-500\">\n                <blockquote className=\"text-gray-700 italic mb-3\">\n                  \"{testimonials[currentTestimonial].text}\"\n                </blockquote>\n                <div className=\"flex items-center justify-between\">\n                  <cite className=\"text-sm font-medium text-gray-900\">\n                    ‚Äî {testimonials[currentTestimonial].author}, {testimonials[currentTestimonial].title}\n                  </cite>\n                  <div className=\"flex space-x-1\">\n                    {testimonials.map((_, index) => (\n                      <div\n                        key={index}\n                        className={`w-2 h-2 rounded-full transition-colors ${\n                          index === currentTestimonial ? 'bg-blue-600' : 'bg-gray-300'\n                        }`}\n                      />\n                    ))}\n                  </div>\n                </div>\n              </div>\n            </div>\n          )}\n\n          {/* Pricing */}\n          {showPricing && (\n            <div className=\"mb-8\">\n              <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">Choose your plan:</h3>\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n                {/* Monthly */}\n                <div className=\"relative p-6 border-2 border-gray-200 rounded-2xl hover:border-blue-300 transition-colors\">\n                  <div className=\"text-center\">\n                    <h4 className=\"font-semibold text-gray-900 mb-2\">Monthly</h4>\n                    <div className=\"mb-4\">\n                      <span className=\"text-3xl font-bold text-gray-900\">${pricing.monthly.price}</span>\n                      <span className=\"text-gray-600\">/month</span>\n                    </div>\n                    <button\n                      onClick={() => handleUpgrade(featureInfo.tier, 'monthly')}\n                      className=\"w-full bg-gray-900 text-white py-3 px-6 rounded-xl font-medium hover:bg-gray-800 transition-colors\"\n                    >\n                      Start Monthly Plan\n                    </button>\n                  </div>\n                </div>\n\n                {/* Yearly */}\n                <div className=\"relative p-6 border-2 border-blue-500 rounded-2xl bg-gradient-to-br from-blue-50 to-purple-50\">\n                  {pricing.yearly.savings && (\n                    <div className=\"absolute -top-3 left-1/2 transform -translate-x-1/2\">\n                      <span className=\"bg-gradient-to-r from-blue-600 to-purple-600 text-white px-4 py-1 rounded-full text-sm font-medium\">\n                        Save {pricing.yearly.savings}%\n                      </span>\n                    </div>\n                  )}\n                  <div className=\"text-center\">\n                    <h4 className=\"font-semibold text-gray-900 mb-2\">Yearly</h4>\n                    <div className=\"mb-2\">\n                      <span className=\"text-3xl font-bold text-gray-900\">${pricing.yearly.price}</span>\n                      <span className=\"text-gray-600\">/year</span>\n                    </div>\n                    <div className=\"text-sm text-gray-600 mb-4\">\n                      <span className=\"line-through\">${(pricing.monthly.price * 12).toFixed(2)}</span>\n                      <span className=\"text-green-600 font-medium ml-2\">\n                        Save ${((pricing.monthly.price * 12) - pricing.yearly.price).toFixed(2)}\n                      </span>\n                    </div>\n                    <button\n                      onClick={() => handleUpgrade(featureInfo.tier, 'yearly')}\n                      className=\"w-full bg-gradient-to-r from-blue-600 to-purple-600 text-white py-3 px-6 rounded-xl font-medium hover:from-blue-700 hover:to-purple-700 transition-all duration-200 transform hover:scale-105\"\n                    >\n                      Start Yearly Plan\n                    </button>\n                  </div>\n                </div>\n              </div>\n            </div>\n          )}\n\n          {/* Trust signals */}\n          <div className=\"flex flex-wrap items-center justify-center gap-6 text-sm text-gray-600 border-t pt-6\">\n            <div className=\"flex items-center space-x-2\">\n              <Shield className=\"w-4 h-4 text-green-500\" />\n              <span>30-day money-back guarantee</span>\n            </div>\n            <div className=\"flex items-center space-x-2\">\n              <Zap className=\"w-4 h-4 text-blue-500\" />\n              <span>Instant activation</span>\n            </div>\n            <div className=\"flex items-center space-x-2\">\n              <Users className=\"w-4 h-4 text-purple-500\" />\n              <span>Join 10,000+ happy users</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default EnhancedUpgradePrompt;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/premium/FeatureGate.tsx",
    "messages": [
      {
        "ruleId": null,
        "nodeType": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 207,
        "column": 0
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Feature Gate Components for Relife Alarm App\n// Provides UI components for premium feature access control\n\nimport React, { ReactNode } from \"react\";\nimport { Lock, Crown, Zap, Sparkles } from \"lucide-react\";\nimport useFeatureGate from \"../../hooks/useFeatureGate\";\n\ninterface FeatureGateProps {\n  children: ReactNode;\n  feature: string;\n  userId: string;\n  fallback?: ReactNode;\n  showUpgradePrompt?: boolean;\n  softGate?: boolean;\n  customMessage?: string;\n  className?: string;\n}\n\nfunction FeatureGate({\n  children,\n  feature,\n  userId,\n  fallback,\n  showUpgradePrompt = true,\n  softGate = false,\n  customMessage,\n  className = \"\",\n  onUpgradeClick\n}: FeatureGateProps) {\n  const featureGate = useFeatureGate({\n    userId,\n    feature,\n    config: { softGate },\n    onUpgradeRequired: onUpgradeClick\n  });\n\n  // Track when gate is encountered\n  React.useEffect(() => {\n    if (featureGate.isGated) {\n      featureGate.trackFeatureAttempt();\n    }\n  }, [featureGate.isGated]);\n\n  if (featureGate.hasAccess) {\n    return <>{children}</>;\n  }\n\n  if (fallback) {\n    return <>{fallback}</>;\n  }\n\n  if (showUpgradePrompt) {\n    return (\n      <UpgradePrompt\n        feature={feature}\n        requiredTier={featureGate.requiredTier}\n        message={customMessage || featureGate.upgradeMessage}\n        usageRemaining={featureGate.usageRemaining}\n        usageLimit={featureGate.usageLimit}\n        canBypass={featureGate.canBypass}\n        onUpgradeClick={() => {\n          featureGate.showUpgradeModal();\n          if (onUpgradeClick && featureGate.requiredTier) {\n            onUpgradeClick(featureGate.requiredTier);\n          }\n        }}\n        onBypass={softGate ? () => featureGate.requestAccess() : undefined}\n        className={className}\n      />\n    );\n  }\n\n  return null;\n}\n\ninterface UpgradePromptProps {\n  feature: string;\n  message: string;\n  usageRemaining?: number;\n  usageLimit?: number;\n  canBypass: boolean;\n  onUpgradeClick: () => void;\n  onBypass?: () => void;\n  className?: string;\n}\n\nfunction UpgradePrompt({\n  feature,\n  requiredTier,\n  message,\n  usageRemaining,\n  usageLimit,\n  canBypass,\n  onUpgradeClick,\n  onBypass,\n  className = \"\"\n}: UpgradePromptProps) {\n    switch (tier) {\n      case 'basic':\n        return <Zap className=\"w-5 h-5 text-blue-500\" />;\n      case 'premium':\n        return <Sparkles className=\"w-5 h-5 text-purple-500\" />;\n      case 'pro':\n        return <Crown className=\"w-5 h-5 text-yellow-500\" />;\n      default:\n        return <Lock className=\"w-5 h-5 text-gray-500\" />;\n    }\n  };\n\n  const getTierColor = (tier: SubscriptionTier) => {\n    switch (tier) {\n      case 'basic':\n        return 'border-blue-200 bg-blue-50';\n      case 'premium':\n        return 'border-purple-200 bg-purple-50';\n      case 'pro':\n        return 'border-yellow-200 bg-yellow-50';\n      default:\n        return 'border-gray-200 bg-gray-50';\n    }\n  };\n\n  const getTierIcon = (tier: SubscriptionTier) => {\n    switch (tier) {\n      case 'basic':\n        return <Zap className=\"w-5 h-5 text-blue-500\" />;\n      case 'premium':\n        return <Sparkles className=\"w-5 h-5 text-purple-500\" />;\n      case 'pro':\n        return <Crown className=\"w-5 h-5 text-yellow-500\" />;\n      default:\n        return <Lock className=\"w-5 h-5 text-gray-500\" />;\n    }\n  };\n\n  const getTierDisplayName = (tier: SubscriptionTier) => {\n    switch (tier) {\n      case 'basic':\n        return 'Basic';\n      case 'premium':\n        return 'Premium';\n      case 'pro':\n        return 'Pro';\n      default:\n        return 'Premium';\n    }\n  };\n\n  return (\n    <div className={`rounded-lg border-2 ${getTierColor(requiredTier)} p-6 text-center ${className}`}>\n      <div className=\"flex justify-center mb-4\">\n        {getTierIcon(requiredTier)}\n      </div>\n\n      <h3 className=\"text-lg font-semibold text-gray-900 mb-2\">\n        {requiredTier ? `${getTierDisplayName(requiredTier)} Feature` : 'Premium Feature'}\n      </h3>\n\n      <p className=\"text-gray-600 mb-4\">\n        {message}\n      </p>\n\n      {usageLimit && usageRemaining !== undefined && (\n        <div className=\"mb-4\">\n          <div className=\"flex justify-between text-sm text-gray-500 mb-1\">\n            <span>Usage this month</span>\n            <span>{usageLimit - usageRemaining} / {usageLimit}</span>\n          </div>\n          <div className=\"w-full bg-gray-200 rounded-full h-2\">\n            <div\n              className=\"bg-gradient-to-r from-blue-500 to-purple-500 h-2 rounded-full transition-all duration-300\"\n              style={{\n                width: `${Math.min(100, ((usageLimit - usageRemaining) / usageLimit) * 100)}%`\n              }}\n            />\n          </div>\n        </div>\n      )}\n\n      <div className=\"flex flex-col sm:flex-row gap-2 justify-center\">\n        <button\n          onClick={onUpgradeClick}\n          className={`px-6 py-2 rounded-lg font-medium transition-colors ${\n            requiredTier === 'basic'\n              ? 'bg-blue-600 hover:bg-blue-700 text-white'\n              : requiredTier === 'premium'\n              ? 'bg-purple-600 hover:bg-purple-700 text-white'\n              : requiredTier === 'pro'\n              ? 'bg-yellow-600 hover:bg-yellow-700 text-white'\n              : 'bg-gray-600 hover:bg-gray-700 text-white'\n          }`}\n        >\n          Upgrade to {getTierDisplayName(requiredTier)}\n        </button>\n\n        {canBypass && onBypass && (\n          <button\n            onClick={onBypass}\n            className=\"px-6 py-2 rounded-lg font-medium border border-gray-300 text-gray-700 hover:bg-gray-50 transition-colors\"\n          >\n            Try It Once\n          </button>\n        )}\n      </div>\n    </div>\n  );\n}\n\n// Higher Order Component for feature gating\nexport function withFeatureGate<P extends object>(\n  WrappedComponent: React.ComponentType<P>,\n  feature: string,\n  config?: {\n    fallback?: ReactNode;\n    showUpgradePrompt?: boolean;\n    softGate?: boolean;\n  }\n) {\n  return function FeatureGatedComponent(props: P & { userId: string }) {\n    const { userId, ...restProps } = props;\n\n    return (\n      <FeatureGate\n        feature={feature}\n        userId={userId}\n        fallback={config?.fallback}\n        showUpgradePrompt={config?.showUpgradePrompt}\n        softGate={config?.softGate}\n      >\n        <WrappedComponent {...(restProps as P)} />\n      </FeatureGate>\n    );\n  };\n}\n\n// Inline feature access check component\ninterface FeatureAccessProps {\n  children: (hasAccess: boolean, upgrade: () => void) => ReactNode;\n  feature: string;\n  userId: string;\n}\n\nexport function FeatureAccess({ children, feature, userId }: FeatureAccessProps) {\n  const featureGate = useFeatureGate({ userId, feature });\n\n  return (\n    <>\n      {children(featureGate.hasAccess, featureGate.showUpgradeModal)}\n    </>\n  );\n}\n\n// Usage limit indicator component\ninterface UsageLimitIndicatorProps {\n  feature: string;\n  userId: string;\n  showOnlyWhenNearLimit?: boolean;\n  warningThreshold?: number; // percentage (0-100)\n  className?: string;\n}\n\nexport function UsageLimitIndicator({\n  feature,\n  userId,\n  showOnlyWhenNearLimit = true,\n  warningThreshold = 80,\n  className = \"\"\n}: UsageLimitIndicatorProps) {\n  const featureGate = useFeatureGate({ userId, feature });\n\n  if (!featureGate.usageLimit || featureGate.usageRemaining === undefined) {\n    return null;\n  }\n\n  const usagePercentage = ((featureGate.usageLimit - featureGate.usageRemaining) / featureGate.usageLimit) * 100;\n\n  if (showOnlyWhenNearLimit && usagePercentage < warningThreshold) {\n    return null;\n  }\n\n  const isNearLimit = usagePercentage >= warningThreshold;\n  const isAtLimit = featureGate.usageRemaining === 0;\n\n  return (\n    <div className={`rounded-lg p-3 ${isAtLimit ? 'bg-red-50 border border-red-200' : isNearLimit ? 'bg-yellow-50 border border-yellow-200' : 'bg-gray-50 border border-gray-200'} ${className}`}>\n      <div className=\"flex items-center justify-between mb-2\">\n        <span className={`text-sm font-medium ${isAtLimit ? 'text-red-700' : isNearLimit ? 'text-yellow-700' : 'text-gray-700'}`}>\n          {feature.replace('_', ' ')} Usage\n        </span>\n        <span className={`text-sm ${isAtLimit ? 'text-red-600' : isNearLimit ? 'text-yellow-600' : 'text-gray-600'}`}>\n          {featureGate.usageLimit - featureGate.usageRemaining} / {featureGate.usageLimit}\n        </span>\n      </div>\n\n      <div className=\"w-full bg-gray-200 rounded-full h-2 mb-2\">\n        <div\n          className={`h-2 rounded-full transition-all duration-300 ${\n            isAtLimit\n              ? 'bg-red-500'\n              : isNearLimit\n              ? 'bg-yellow-500'\n              : 'bg-green-500'\n          }`}\n          style={{ width: `${Math.min(100, usagePercentage)}%` }}\n        />\n      </div>\n\n      {isAtLimit && (\n        <p className=\"text-xs text-red-600\">\n          You've reached your limit. Upgrade for unlimited access!\n        </p>\n      )}\n\n      {isNearLimit && !isAtLimit && (\n        <p className=\"text-xs text-yellow-600\">\n          {featureGate.usageRemaining} uses remaining this month\n        </p>\n      )}\n    </div>\n  );\n}\n\nexport default FeatureGate;\n\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/premium/PricingTable.tsx",
    "messages": [
      {
        "ruleId": null,
        "nodeType": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 248,
        "column": 0
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Pricing Table Component for Relife Alarm App\n// Displays subscription plans with upgrade/downgrade functionality\n\nimport React, { useState } from \"react\";\nimport { Check, Zap, Star, Crown, ArrowRight } from \"lucide-react\";\nimport { FeatureBadge } from \"./FeatureUtils\";\nimport type {\n  SubscriptionPlan,\n  BillingInterval,\n} from \"../../types/premium\";\n\ninterface PricingTableProps {\n  plans: SubscriptionPlan[];\n  billingInterval?: BillingInterval;\n  onPlanSelect: (plan: SubscriptionPlan, billingInterval: BillingInterval) => void;\n  onBillingIntervalChange?: (interval: BillingInterval) => void;\n  loading?: boolean;\n  className?: string;\n}\n\nexport function PricingTable({\n  plans,\n  currentTier = 'free',\n  billingInterval = 'month',\n  onPlanSelect,\n  onBillingIntervalChange,\n  loading = false,\n  className = ''\n}: PricingTableProps) {\n  const [selectedInterval, setSelectedInterval] = useState<BillingInterval>(billingInterval);\n\n  const handleIntervalChange = (interval: BillingInterval) => {\n    setSelectedInterval(interval);\n    if (onBillingIntervalChange) {\n      onBillingIntervalChange(interval);\n    }\n  };\n\n  const getPlanPrice = (plan: SubscriptionPlan, interval: BillingInterval) => {\n    if (plan.tier === 'free') return { amount: 0, currency: 'usd' };\n\n    const pricing = plan.pricing;\n    if (interval === 'year') {\n      return pricing.yearly || pricing.monthly;\n    }\n    return pricing.monthly;\n  };\n\n  const formatPrice = (amount: number, currency: string, interval: BillingInterval) => {\n    const price = (amount / 100).toFixed(2);\n    const symbol = currency === 'usd' ? '$' : currency.toUpperCase();\n    const period = interval === 'year' ? 'year' : 'month';\n\n    return amount === 0 ? 'Free' : `${symbol}${price}/${period}`;\n  };\n\n  const getDiscountPercentage = (plan: SubscriptionPlan) => {\n    if (!plan.pricing.yearly?.discountPercentage) return null;\n    return plan.pricing.yearly.discountPercentage;\n  };\n\n    switch (tier) {\n      case 'basic':\n        return <Zap className=\"w-6 h-6 text-blue-600\" />;\n      case 'premium':\n        return <Star className=\"w-6 h-6 text-purple-600\" />;\n      case 'pro':\n        return <Crown className=\"w-6 h-6 text-yellow-600\" />;\n      default:\n        return null;\n    }\n  };\n\n  const isUpgrade = (tier: SubscriptionTier) => {\n    const hierarchy = [\n      \"free\",\n      \"basic\",\n      \"premium\",\n      \"pro\",\n      \"enterprise\",\n    ];\n    return hierarchy.indexOf(tier) > hierarchy.indexOf(currentTier);\n  };\n\n  const getButtonText = (tier: SubscriptionTier) => {\n    if (isCurrentPlan(tier)) return \"Current Plan\";\n    if (isUpgrade(tier)) return \"Upgrade\";\n    return \"Downgrade\";\n  };\n\n  return (\n    <div className={`w-full ${className}`}>\n      {/* Billing Interval Toggle */}\n      <div className=\"flex justify-center mb-8\">\n        <div className=\"bg-gray-100 rounded-lg p-1 flex\">\n          <button\n            onClick={() => handleIntervalChange('month')}\n            className={`px-6 py-2 rounded-md text-sm font-medium transition-colors ${\n              selectedInterval === 'month'\n                ? 'bg-white text-gray-900 shadow-sm'\n                : 'text-gray-600 hover:text-gray-900'\n            }`}\n          >\n            Monthly\n          </button>\n          <button\n            onClick={() => handleIntervalChange('year')}\n            className={`px-6 py-2 rounded-md text-sm font-medium transition-colors relative ${\n              selectedInterval === 'year'\n                ? 'bg-white text-gray-900 shadow-sm'\n                : 'text-gray-600 hover:text-gray-900'\n            }`}\n          >\n            Annual\n            <span className=\"absolute -top-2 -right-2 bg-green-500 text-white text-xs px-2 py-1 rounded-full\">\n              Save 20%\n            </span>\n          </button>\n        </div>\n      </div>\n\n      {/* Pricing Grid */}\n      <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6\">\n        {plans.map(plan => {\n          const price = getPlanPrice(plan, selectedInterval);\n          const discount = selectedInterval === 'year' ? getDiscountPercentage(plan) : null;\n          const isCurrent = isCurrentPlan(plan.tier);\n          const isPopular = plan.isPopular;\n\n          return (\n            <div\n              key={plan.id}\n              className={`relative bg-white rounded-2xl border-2 p-6 transition-all duration-200 hover:shadow-lg ${\n                isPopular\n                  ? 'border-purple-500 shadow-lg scale-105'\n                  : isCurrent\n                  ? 'border-green-500'\n                  : 'border-gray-200'\n              }`}\n            >\n              {/* Popular Badge */}\n              {isPopular && (\n                <div className=\"absolute -top-3 left-1/2 transform -translate-x-1/2\">\n                  <span className=\"bg-purple-500 text-white px-4 py-1 rounded-full text-sm font-medium\">\n                    Most Popular\n                  </span>\n                </div>\n              )}\n\n              {/* Current Plan Badge */}\n              {isCurrent && (\n                <div className=\"absolute top-4 right-4\">\n                  <FeatureBadge tier={plan.tier} size=\"sm\" variant=\"prominent\" />\n                </div>\n              )}\n\n              {/* Plan Header */}\n              <div className=\"text-center mb-6\">\n                {getPlanIcon(plan.tier) && (\n                  <div className=\"flex justify-center mb-3\">\n                    {getPlanIcon(plan.tier)}\n                  </div>\n                )}\n\n                <h3 className=\"text-xl font-bold text-gray-900 mb-2\">\n                  {plan.displayName}\n                </h3>\n\n                <div className=\"mb-2\">\n                  <span className=\"text-3xl font-bold text-gray-900\">\n                    {formatPrice(price.amount, price.currency, selectedInterval)}\n                  </span>\n                  {discount && (\n                    <div className=\"text-sm text-green-600 font-medium\">\n                      Save {discount}% annually\n                    </div>\n                  )}\n                </div>\n\n                <p className=\"text-gray-600 text-sm\">\n                  {plan.description}\n                </p>\n              </div>\n\n              {/* Features List */}\n              <div className=\"mb-6\">\n                <ul className=\"space-y-3\">\n                  {plan.features.slice(0, 6).map((feature, index) => (\n                    <li key={index} className=\"flex items-start gap-3\">\n                      <Check className=\"w-5 h-5 text-green-500 flex-shrink-0 mt-0.5\" />\n                      <span className=\"text-sm text-gray-700\">{feature.name}</span>\n                    </li>\n                  ))}\n\n                  {plan.features.length > 6 && (\n                    <li className=\"text-sm text-gray-500 font-medium\">\n                      + {plan.features.length - 6} more features\n                    </li>\n                  )}\n                </ul>\n              </div>\n\n              {/* Action Button */}\n              <button\n                onClick={() => onPlanSelect(plan, selectedInterval)}\n                disabled={loading || isCurrent}\n                className={`w-full py-3 px-4 rounded-lg font-medium transition-colors flex items-center justify-center gap-2 ${\n                  isCurrent\n                    ? 'bg-gray-100 text-gray-500 cursor-not-allowed'\n                    : isPopular\n                    ? 'bg-purple-600 text-white hover:bg-purple-700'\n                    : plan.tier === 'basic'\n                    ? 'bg-blue-600 text-white hover:bg-blue-700'\n                    : plan.tier === 'pro'\n                    ? 'bg-yellow-600 text-white hover:bg-yellow-700'\n                    : 'bg-gray-600 text-white hover:bg-gray-700'\n                }`}\n              >\n                {loading ? (\n                  <div className=\"w-5 h-5 border-2 border-current border-t-transparent rounded-full animate-spin\" />\n                ) : (\n                  <>\n                    {getButtonText(plan.tier)}\n                    {!isCurrent && <ArrowRight className=\"w-4 h-4\" />}\n                  </>\n                )}\n              </button>\n\n              {/* Free Trial */}\n              {plan.trialDays && plan.trialDays > 0 && !isCurrent && (\n                <p className=\"text-center text-sm text-gray-500 mt-3\">\n                  {plan.trialDays}-day free trial\n                </p>\n              )}\n            </div>\n          );\n        })}\n      </div>\n\n      {/* Feature Comparison Link */}\n      <div className=\"text-center mt-8\">\n        <button className=\"text-blue-600 hover:text-blue-700 font-medium text-sm\">\n          Compare all features ‚Üí\n        </button>\n      </div>\n    </div>\n  );\n}\n\nexport default PricingTable;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/premium/SubscriptionDashboard.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SubscriptionTier' is not defined.",
        "line": 68,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 68,
        "endColumn": 46
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Subscription Dashboard Component for Relife Alarm App\n// Comprehensive view of subscription status, billing, and feature usage\n\nimport React, { useState } from 'react';\nimport { Calendar, CreditCard, TrendingUp, AlertTriangle, Gift, Settings, Crown, Zap } from 'lucide-react';\nimport { Card, CardContent, CardHeader, CardTitle } from '../ui/card';\nimport { Button } from '../ui/button';\nimport { Progress } from '../ui/progress';\nimport { Badge } from '../ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '../ui/tabs';\nimport { Alert, AlertDescription } from '../ui/alert';\nimport PaymentMethodManager from './PaymentMethodManager';\nimport BillingHistory from './BillingHistory';\nimport PricingTable from './PricingTable';\nimport type {\n  SubscriptionDashboardData,\n  SubscriptionStatus,\n  BillingInterval\n} from '../../types/premium';\n\ninterface SubscriptionDashboardProps {\n  data: SubscriptionDashboardData;\n  isLoading?: boolean;\n  onUpgrade: (planId: string, billingInterval: BillingInterval) => Promise<void>;\n  onDowngrade: (planId: string, billingInterval: BillingInterval) => Promise<void>;\n  onCancelSubscription: (reason?: string) => Promise<void>;\n  onReactivateSubscription: () => Promise<void>;\n  onAddPaymentMethod: () => Promise<void>;\n  onRemovePaymentMethod: (paymentMethodId: string) => Promise<void>;\n  onSetDefaultPaymentMethod: (paymentMethodId: string) => Promise<void>;\n  onUpdateBillingDetails: (paymentMethodId: string, billingDetails: any) => Promise<void>;\n  className?: string;\n}\n\nexport function SubscriptionDashboard({\n  data,\n  isLoading = false,\n  onUpgrade,\n  onDowngrade,\n  onCancelSubscription,\n  onReactivateSubscription,\n  onAddPaymentMethod,\n  onRemovePaymentMethod,\n  onSetDefaultPaymentMethod,\n  onUpdateBillingDetails,\n  className = ''\n}: SubscriptionDashboardProps) {\n  const [actionLoading, setActionLoading] = useState<string | null>(null);\n  const [showUpgradeModal, setShowUpgradeModal] = useState(false);\n  const [activeTab, setActiveTab] = useState('overview');\n\n  const formatDate = (date: Date) => {\n    return new Intl.DateTimeFormat('en-US', {\n      month: 'long',\n      day: 'numeric',\n      year: 'numeric'\n    }).format(new Date(date));\n  };\n\n  const formatCurrency = (amount: number, currency: string = 'usd') => {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency: currency.toUpperCase()\n    }).format(amount / 100);\n  };\n\n\n  const getTierIcon = (tier: SubscriptionTier) => {\n    switch (tier) {\n      case 'basic':\n        return <Zap className=\"w-5 h-5 text-blue-600\" />;\n      case 'premium':\n        return <Crown className=\"w-5 h-5 text-purple-600\" />;\n      case 'pro':\n        return <Crown className=\"w-5 h-5 text-yellow-600\" />;\n      default:\n        return null;\n    }\n  };\n\n  const getStatusBadge = (status: SubscriptionStatus) => {\n    switch (status) {\n      case 'active':\n        return <Badge className=\"bg-green-100 text-green-800\">Active</Badge>;\n      case 'trialing':\n        return <Badge className=\"bg-blue-100 text-blue-800\">Trial</Badge>;\n      case 'past_due':\n        return <Badge className=\"bg-orange-100 text-orange-800\">Past Due</Badge>;\n      case 'canceled':\n        return <Badge className=\"bg-red-100 text-red-800\">Canceled</Badge>;\n      case 'unpaid':\n        return <Badge className=\"bg-red-100 text-red-800\">Unpaid</Badge>;\n      default:\n        return <Badge variant=\"outline\">{status}</Badge>;\n    }\n  };\n\n  const getUsageColor = (used: number, limit: number) => {\n    const percentage = (used / limit) * 100;\n    if (percentage >= 90) return 'bg-red-500';\n    if (percentage >= 75) return 'bg-yellow-500';\n    return 'bg-blue-500';\n  };\n\n  const handlePlanSelect = async (plan: any, billingInterval: BillingInterval) => {\n    try {\n      setActionLoading('plan-change');\n\n      const currentTierIndex = ['free', 'basic', 'premium', 'pro', 'enterprise'].indexOf(data.subscription?.tier || 'free');\n      const newTierIndex = ['free', 'basic', 'premium', 'pro', 'enterprise'].indexOf(plan.tier);\n\n      if (newTierIndex > currentTierIndex) {\n        await onUpgrade(plan.id, billingInterval);\n      } else {\n        await onDowngrade(plan.id, billingInterval);\n      }\n\n      setShowUpgradeModal(false);\n    } catch (error) {\n      console.error('Failed to change plan:', error);\n    } finally {\n      setActionLoading(null);\n    }\n  };\n\n  const handleCancelSubscription = async () => {\n    try {\n      setActionLoading('cancel');\n      await onCancelSubscription('User initiated cancellation');\n    } catch (error) {\n      console.error('Failed to cancel subscription:', error);\n    } finally {\n      setActionLoading(null);\n    }\n  };\n\n  const handleReactivateSubscription = async () => {\n    try {\n      setActionLoading('reactivate');\n      await onReactivateSubscription();\n    } catch (error) {\n      console.error('Failed to reactivate subscription:', error);\n    } finally {\n      setActionLoading(null);\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div className={`space-y-6 ${className}`}>\n        <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\n          {[1, 2, 3].map(i => (\n            <Card key={i} className=\"p-6\">\n              <div className=\"animate-pulse space-y-4\">\n                <div className=\"h-4 bg-gray-200 rounded w-1/2\"></div>\n                <div className=\"h-8 bg-gray-200 rounded w-3/4\"></div>\n                <div className=\"h-3 bg-gray-200 rounded w-full\"></div>\n              </div>\n            </Card>\n          ))}\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={`space-y-6 ${className}`}>\n      {/* Alert for subscription issues */}\n      {data.subscription?.status === 'past_due' && (\n        <Alert className=\"border-orange-200 bg-orange-50\">\n          <AlertTriangle className=\"h-4 w-4 text-orange-600\" />\n          <AlertDescription className=\"text-orange-600\">\n            Your subscription payment is past due. Please update your payment method to continue using premium features.\n          </AlertDescription>\n        </Alert>\n      )}\n\n      {data.subscription?.cancelAtPeriodEnd && (\n        <Alert className=\"border-blue-200 bg-blue-50\">\n          <AlertTriangle className=\"h-4 w-4 text-blue-600\" />\n          <AlertDescription className=\"text-blue-600 flex items-center justify-between\">\n            <span>Your subscription will end on {formatDate(data.subscription.currentPeriodEnd)}.</span>\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={handleReactivateSubscription}\n              disabled={actionLoading === 'reactivate'}\n            >\n              {actionLoading === 'reactivate' ? 'Processing...' : 'Reactivate'}\n            </Button>\n          </AlertDescription>\n        </Alert>\n      )}\n\n      <Tabs value={activeTab} onValueChange={setActiveTab} className=\"w-full\">\n        <TabsList className=\"grid w-full grid-cols-4\">\n          <TabsTrigger value=\"overview\">Overview</TabsTrigger>\n          <TabsTrigger value=\"usage\">Usage</TabsTrigger>\n          <TabsTrigger value=\"billing\">Billing</TabsTrigger>\n          <TabsTrigger value=\"plans\">Plans</TabsTrigger>\n        </TabsList>\n\n        {/* Overview Tab */}\n        <TabsContent value=\"overview\" className=\"space-y-6\">\n          <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6\">\n            {/* Current Subscription */}\n            <Card>\n              <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n                <CardTitle className=\"text-sm font-medium\">Current Plan</CardTitle>\n                {getTierIcon(data.subscription?.tier || 'free')}\n              </CardHeader>\n              <CardContent>\n                <div className=\"text-2xl font-bold capitalize mb-2\">\n                  {data.currentPlan?.displayName || 'Free'}\n                </div>\n                {data.subscription && (\n                  <>\n                    {getStatusBadge(data.subscription.status)}\n                    <p className=\"text-xs text-gray-600 mt-2\">\n                      {data.subscription.billingInterval === 'year' ? 'Yearly' : 'Monthly'} billing\n                    </p>\n                  </>\n                )}\n              </CardContent>\n            </Card>\n\n            {/* Next Billing */}\n            <Card>\n              <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n                <CardTitle className=\"text-sm font-medium\">Next Billing</CardTitle>\n                <Calendar className=\"h-4 w-4 text-muted-foreground\" />\n              </CardHeader>\n              <CardContent>\n                {data.subscription && data.subscription.tier !== 'free' ? (\n                  <>\n                    <div className=\"text-2xl font-bold\">\n                      {formatCurrency(data.subscription.amount, data.subscription.currency)}\n                    </div>\n                    <p className=\"text-xs text-gray-600\">\n                      Due {formatDate(data.subscription.currentPeriodEnd)}\n                    </p>\n                  </>\n                ) : (\n                  <div className=\"text-2xl font-bold text-gray-400\">‚Äî</div>\n                )}\n              </CardContent>\n            </Card>\n\n            {/* Features Used */}\n            <Card>\n              <CardHeader className=\"flex flex-row items-center justify-between space-y-0 pb-2\">\n                <CardTitle className=\"text-sm font-medium\">Features Used</CardTitle>\n                <TrendingUp className=\"h-4 w-4 text-muted-foreground\" />\n              </CardHeader>\n              <CardContent>\n                {data.usage ? (\n                  <>\n                    <div className=\"text-2xl font-bold\">\n                      {Object.values(data.usage.features).reduce((sum, feature) => sum + feature.used, 0)}\n                    </div>\n                    <p className=\"text-xs text-gray-600\">\n                      This month\n                    </p>\n                  </>\n                ) : (\n                  <div className=\"text-2xl font-bold text-gray-400\">‚Äî</div>\n                )}\n              </CardContent>\n            </Card>\n          </div>\n\n          {/* Trial Information */}\n          {data.activeTrial && (\n            <Card className=\"border-blue-200 bg-blue-50\">\n              <CardHeader>\n                <CardTitle className=\"flex items-center gap-2 text-blue-900\">\n                  <Gift className=\"w-5 h-5\" />\n                  Free Trial Active\n                </CardTitle>\n              </CardHeader>\n              <CardContent className=\"text-blue-800\">\n                <p className=\"mb-2\">\n                  Your free trial ends on {formatDate(data.activeTrial.endDate)}.\n                </p>\n                <p className=\"text-sm\">\n                  Days remaining: {Math.ceil((new Date(data.activeTrial.endDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24))}\n                </p>\n                <Button className=\"mt-4\" onClick={() => setShowUpgradeModal(true)}>\n                  Choose a Plan\n                </Button>\n              </CardContent>\n            </Card>\n          )}\n\n          {/* Quick Actions */}\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"flex items-center gap-2\">\n                <Settings className=\"w-5 h-5\" />\n                Quick Actions\n              </CardTitle>\n            </CardHeader>\n            <CardContent>\n              <div className=\"flex flex-wrap gap-3\">\n                <Button variant=\"outline\" onClick={() => setShowUpgradeModal(true)}>\n                  Change Plan\n                </Button>\n\n                {data.subscription && data.subscription.tier !== 'free' && !data.subscription.cancelAtPeriodEnd && (\n                  <Button\n                    variant=\"outline\"\n                    onClick={handleCancelSubscription}\n                    disabled={actionLoading === 'cancel'}\n                    className=\"text-red-600 border-red-200 hover:bg-red-50\"\n                  >\n                    {actionLoading === 'cancel' ? 'Processing...' : 'Cancel Subscription'}\n                  </Button>\n                )}\n              </div>\n            </CardContent>\n          </Card>\n        </TabsContent>\n\n        {/* Usage Tab */}\n        <TabsContent value=\"usage\" className=\"space-y-6\">\n          {data.usage && data.currentPlan ? (\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n              {Object.entries(data.usage.features).map(([featureKey, featureUsage]) => {\n                const limit = data.currentPlan?.limits?.[featureKey as keyof typeof data.currentPlan.limits] || 0;\n                const usedPercentage = typeof limit === 'number' ? Math.min((featureUsage.used / limit) * 100, 100) : 0;\n\n                return (\n                  <Card key={featureKey}>\n                    <CardHeader>\n                      <CardTitle className=\"text-sm capitalize\">\n                        {featureKey.replace(/([A-Z])/g, ' $1').toLowerCase()}\n                      </CardTitle>\n                    </CardHeader>\n                    <CardContent>\n                      <div className=\"space-y-2\">\n                        <div className=\"flex justify-between text-sm\">\n                          <span>{featureUsage.used} used</span>\n                          <span>{typeof limit === 'number' ? limit : '‚àû'} limit</span>\n                        </div>\n                        {typeof limit === 'number' && (\n                          <Progress value={usedPercentage} className=\"h-2\" />\n                        )}\n                        {featureUsage.resetDate && (\n                          <p className=\"text-xs text-gray-600\">\n                            Resets {formatDate(featureUsage.resetDate)}\n                          </p>\n                        )}\n                      </div>\n                    </CardContent>\n                  </Card>\n                );\n              })}\n            </div>\n          ) : (\n            <Card className=\"p-8 text-center\">\n              <TrendingUp className=\"w-12 h-12 text-gray-400 mx-auto mb-4\" />\n              <h4 className=\"font-semibold text-gray-900 mb-2\">No usage data</h4>\n              <p className=\"text-gray-600\">\n                Usage statistics will appear here once you start using premium features.\n              </p>\n            </Card>\n          )}\n        </TabsContent>\n\n        {/* Billing Tab */}\n        <TabsContent value=\"billing\" className=\"space-y-6\">\n          <PaymentMethodManager\n            paymentMethods={data.paymentMethods || []}\n            defaultPaymentMethodId={data.paymentMethods?.[0]?.id}\n            onAddPaymentMethod={onAddPaymentMethod}\n            onRemovePaymentMethod={onRemovePaymentMethod}\n            onSetDefaultPaymentMethod={onSetDefaultPaymentMethod}\n            onUpdateBillingDetails={onUpdateBillingDetails}\n          />\n\n          <BillingHistory\n            invoices={data.invoiceHistory || []}\n            upcomingInvoice={data.upcomingInvoice}\n          />\n        </TabsContent>\n\n        {/* Plans Tab */}\n        <TabsContent value=\"plans\">\n          <PricingTable\n            plans={data.availablePlans || []}\n            currentTier={data.subscription?.tier || 'free'}\n            onPlanSelect={handlePlanSelect}\n            loading={actionLoading === 'plan-change'}\n          />\n        </TabsContent>\n      </Tabs>\n    </div>\n  );\n};\n\nexport default SubscriptionDashboard;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/premium/SubscriptionManagement.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SubscriptionTier' is not defined.",
        "line": 83,
        "column": 28,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 83,
        "endColumn": 44
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SubscriptionTier' is not defined.",
        "line": 88,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 88,
        "endColumn": 46
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Subscription Management Component for Relife Alarm App\n// Handles subscription cancellation, upgrades, downgrades, and plan changes\n\nimport React, { useState } from 'react';\nimport { AlertTriangle, ArrowUpCircle, ArrowDownCircle, Calendar, Gift, Settings, X } from 'lucide-react';\nimport { Card, CardContent, CardHeader, CardTitle } from '../ui/card';\nimport { Button } from '../ui/button';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger, DialogFooter } from '../ui/dialog';\nimport { Alert, AlertDescription } from '../ui/alert';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../ui/select';\nimport { Textarea } from '../ui/textarea';\nimport { Label } from '../ui/label';\nimport { Checkbox } from '../ui/checkbox';\nimport PricingTable from './PricingTable';\nimport type {\n  Subscription,\n  SubscriptionPlan,\n  BillingInterval,\n  CancelSubscriptionRequest\n} from '../../types/premium';\n\ninterface SubscriptionManagementProps {\n  subscription: Subscription;\n  currentPlan: SubscriptionPlan;\n  availablePlans: SubscriptionPlan[];\n  isLoading?: boolean;\n  onUpgrade: (planId: string, billingInterval: BillingInterval) => Promise<void>;\n  onDowngrade: (planId: string, billingInterval: BillingInterval) => Promise<void>;\n  onCancelSubscription: (request: CancelSubscriptionRequest) => Promise<void>;\n  onReactivateSubscription: () => Promise<void>;\n  onPauseSubscription?: (pauseDuration: number) => Promise<void>;\n  className?: string;\n}\n\ninterface CancellationData {\n  reason: string;\n  feedback: string;\n  effectiveDate: 'immediate' | 'period_end';\n  retentionOfferAccepted?: boolean;\n}\n\nexport function SubscriptionManagement({\n  subscription,\n  currentPlan,\n  availablePlans,\n  isLoading = false,\n  onUpgrade,\n  onDowngrade,\n  onCancelSubscription,\n  onReactivateSubscription,\n  onPauseSubscription,\n  className = ''\n}: SubscriptionManagementProps) {\n  const [actionLoading, setActionLoading] = useState<string | null>(null);\n  const [showCancelDialog, setShowCancelDialog] = useState(false);\n  const [showUpgradeDialog, setShowUpgradeDialog] = useState(false);\n  const [showRetentionOffer, setShowRetentionOffer] = useState(false);\n  const [cancellationData, setCancellationData] = useState<CancellationData>({\n    reason: '',\n    feedback: '',\n    effectiveDate: 'period_end'\n  });\n\n  const formatDate = (date: Date) => {\n    return new Intl.DateTimeFormat('en-US', {\n      month: 'long',\n      day: 'numeric',\n      year: 'numeric'\n    }).format(new Date(date));\n  };\n\n  const formatCurrency = (amount: number, currency: string = 'usd') => {\n    return new Intl.NumberFormat('en-US', {\n      style: 'currency',\n      currency: currency.toUpperCase()\n    }).format(amount / 100);\n  };\n\n  const getTierHierarchy = () => {\n    return [\"free\", \"basic\", \"premium\", \"pro\", \"enterprise\"];\n  };\n\n  const isUpgrade = (tier: SubscriptionTier) => {\n    const hierarchy = getTierHierarchy();\n    return hierarchy.indexOf(tier) > hierarchy.indexOf(subscription.tier);\n  };\n\n  const isDowngrade = (tier: SubscriptionTier) => {\n    const hierarchy = getTierHierarchy();\n    return hierarchy.indexOf(tier) < hierarchy.indexOf(subscription.tier);\n  };\n\n  const getUpgradeOptions = () => {\n    return availablePlans.filter(plan => isUpgrade(plan.tier));\n  };\n\n  const getDowngradeOptions = () => {\n    return availablePlans.filter(plan => isDowngrade(plan.tier));\n  };\n\n  const cancellationReasons = [\n    'Too expensive',\n    'Not using enough features',\n    'Found a better alternative',\n    'Technical issues',\n    'Poor customer support',\n    'Missing features I need',\n    'Temporary financial constraints',\n    'Other'\n  ];\n\n  const retentionOffers = [\n    {\n      id: 'discount_50',\n      title: '50% Off Next 3 Months',\n      description: 'Save 50% on your current plan for the next 3 months',\n      savings: Math.floor(subscription.amount * 0.5 * 3),\n      duration: '3 months'\n    },\n    {\n      id: 'discount_25_6m',\n      title: '25% Off Next 6 Months',\n      description: 'Save 25% on your current plan for the next 6 months',\n      savings: Math.floor(subscription.amount * 0.25 * 6),\n      duration: '6 months'\n    },\n    {\n      id: 'pause_subscription',\n      title: 'Pause Subscription',\n      description: 'Pause your subscription for up to 3 months, then resume when ready',\n      savings: subscription.amount * 3,\n      duration: 'Up to 3 months'\n    }\n  ];\n\n  const handlePlanChange = async (plan: SubscriptionPlan, billingInterval: BillingInterval) => {\n    try {\n      setActionLoading('plan-change');\n\n      if (isUpgrade(plan.tier)) {\n        await onUpgrade(plan.id, billingInterval);\n      } else if (isDowngrade(plan.tier)) {\n        await onDowngrade(plan.id, billingInterval);\n      }\n\n      setShowUpgradeDialog(false);\n    } catch (error) {\n      console.error('Failed to change plan:', error);\n    } finally {\n      setActionLoading(null);\n    }\n  };\n\n  const handleCancelClick = () => {\n    setShowCancelDialog(true);\n    // Simulate showing retention offer based on cancellation reason\n    setTimeout(() => {\n      if (cancellationData.reason && !showRetentionOffer) {\n        setShowRetentionOffer(true);\n      }\n    }, 500);\n  };\n\n  const handleCancelConfirm = async () => {\n    try {\n      setActionLoading('cancel');\n\n      const request: CancelSubscriptionRequest = {\n        reason: cancellationData.reason,\n        feedback: cancellationData.feedback,\n        cancelAtPeriodEnd: cancellationData.effectiveDate === 'period_end',\n        retentionOfferAccepted: cancellationData.retentionOfferAccepted\n      };\n\n      await onCancelSubscription(request);\n      setShowCancelDialog(false);\n      setShowRetentionOffer(false);\n    } catch (error) {\n      console.error('Failed to cancel subscription:', error);\n    } finally {\n      setActionLoading(null);\n    }\n  };\n\n  const handleReactivate = async () => {\n    try {\n      setActionLoading('reactivate');\n      await onReactivateSubscription();\n    } catch (error) {\n      console.error('Failed to reactivate subscription:', error);\n    } finally {\n      setActionLoading(null);\n    }\n  };\n\n  const handleAcceptRetentionOffer = (offerId: string) => {\n    setCancellationData(prev => ({\n      ...prev,\n      retentionOfferAccepted: true\n    }));\n    // In a real implementation, you would apply the retention offer here\n    setShowRetentionOffer(false);\n    setShowCancelDialog(false);\n  };\n\n  if (isLoading) {\n    return (\n      <div className={`space-y-6 ${className}`}>\n        <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n          {[1, 2].map(i => (\n            <Card key={i} className=\"p-6\">\n              <div className=\"animate-pulse space-y-4\">\n                <div className=\"h-4 bg-gray-200 rounded w-1/2\"></div>\n                <div className=\"h-8 bg-gray-200 rounded w-3/4\"></div>\n                <div className=\"h-10 bg-gray-200 rounded w-full\"></div>\n              </div>\n            </Card>\n          ))}\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={`space-y-6 ${className}`}>\n      {/* Subscription Status Card */}\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Settings className=\"w-5 h-5\" />\n            Subscription Management\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-4\">\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\n            <div>\n              <h4 className=\"font-semibold text-gray-900 mb-2\">Current Plan</h4>\n              <p className=\"text-2xl font-bold\">{currentPlan.displayName}</p>\n              <p className=\"text-gray-600\">{currentPlan.description}</p>\n              <p className=\"text-sm text-gray-500 mt-1\">\n                {formatCurrency(subscription.amount, subscription.currency)} per {subscription.billingInterval}\n              </p>\n            </div>\n\n            <div>\n              <h4 className=\"font-semibold text-gray-900 mb-2\">Next Billing</h4>\n              <p className=\"text-lg font-semibold\">\n                {formatDate(subscription.currentPeriodEnd)}\n              </p>\n              <p className=\"text-gray-600\">\n                {subscription.cancelAtPeriodEnd ? 'Subscription will end' : 'Auto-renewal'}\n              </p>\n            </div>\n          </div>\n\n          {/* Cancellation Notice */}\n          {subscription.cancelAtPeriodEnd && (\n            <Alert className=\"border-orange-200 bg-orange-50\">\n              <AlertTriangle className=\"h-4 w-4 text-orange-600\" />\n              <AlertDescription className=\"text-orange-600\">\n                Your subscription will end on {formatDate(subscription.currentPeriodEnd)}.\n                You can reactivate anytime before this date.\n              </AlertDescription>\n            </Alert>\n          )}\n\n          <div className=\"flex flex-wrap gap-3 pt-4\">\n            <Dialog open={showUpgradeDialog} onOpenChange={setShowUpgradeDialog}>\n              <DialogTrigger asChild>\n                <Button variant=\"outline\" className=\"flex items-center gap-2\">\n                  <ArrowUpCircle className=\"w-4 h-4\" />\n                  Change Plan\n                </Button>\n              </DialogTrigger>\n              <DialogContent className=\"max-w-4xl max-h-[80vh] overflow-auto\">\n                <DialogHeader>\n                  <DialogTitle>Choose a New Plan</DialogTitle>\n                </DialogHeader>\n                <PricingTable\n                  plans={availablePlans}\n                  currentTier={subscription.tier}\n                  onPlanSelect={handlePlanChange}\n                  loading={actionLoading === 'plan-change'}\n                />\n              </DialogContent>\n            </Dialog>\n\n            {subscription.cancelAtPeriodEnd ? (\n              <Button\n                onClick={handleReactivate}\n                disabled={actionLoading === 'reactivate'}\n                className=\"flex items-center gap-2\"\n              >\n                {actionLoading === 'reactivate' && (\n                  <div className=\"w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin\" />\n                )}\n                Reactivate Subscription\n              </Button>\n            ) : (\n              <Dialog open={showCancelDialog} onOpenChange={setShowCancelDialog}>\n                <DialogTrigger asChild>\n                  <Button\n                    variant=\"outline\"\n                    className=\"text-red-600 border-red-200 hover:bg-red-50\"\n                  >\n                    Cancel Subscription\n                  </Button>\n                </DialogTrigger>\n                <DialogContent className=\"max-w-md\">\n                  <DialogHeader>\n                    <DialogTitle className=\"flex items-center gap-2\">\n                      <AlertTriangle className=\"w-5 h-5 text-red-600\" />\n                      Cancel Subscription\n                    </DialogTitle>\n                  </DialogHeader>\n\n                  {!showRetentionOffer ? (\n                    <div className=\"space-y-4\">\n                      <p className=\"text-gray-600\">\n                        We're sorry to see you go! Help us improve by sharing why you're canceling.\n                      </p>\n\n                      <div>\n                        <Label htmlFor=\"reason\">Reason for canceling</Label>\n                        <Select\n                          value={cancellationData.reason}\n                          onValueChange={(value) => setCancellationData(prev => ({ ...prev, reason: value }))}\n                        >\n                          <SelectTrigger>\n                            <SelectValue placeholder=\"Select a reason...\" />\n                          </SelectTrigger>\n                          <SelectContent>\n                            {cancellationReasons.map(reason => (\n                              <SelectItem key={reason} value={reason}>\n                                {reason}\n                              </SelectItem>\n                            ))}\n                          </SelectContent>\n                        </Select>\n                      </div>\n\n                      <div>\n                        <Label htmlFor=\"feedback\">Additional feedback (optional)</Label>\n                        <Textarea\n                          id=\"feedback\"\n                          value={cancellationData.feedback}\n                          onChange={(e) => setCancellationData(prev => ({ ...prev, feedback: e.target.value }))}\n                          placeholder=\"Tell us more about your experience...\"\n                          rows={3}\n                        />\n                      </div>\n\n                      <div className=\"space-y-3\">\n                        <Label>When should the cancellation take effect?</Label>\n                        <div className=\"space-y-2\">\n                          <div className=\"flex items-center space-x-2\">\n                            <input\n                              type=\"radio\"\n                              id=\"period_end\"\n                              name=\"effectiveDate\"\n                              checked={cancellationData.effectiveDate === 'period_end'}\n                              onChange={() => setCancellationData(prev => ({ ...prev, effectiveDate: 'period_end' }))}\n                            />\n                            <Label htmlFor=\"period_end\" className=\"text-sm\">\n                              At the end of current billing period ({formatDate(subscription.currentPeriodEnd)})\n                            </Label>\n                          </div>\n                          <div className=\"flex items-center space-x-2\">\n                            <input\n                              type=\"radio\"\n                              id=\"immediate\"\n                              name=\"effectiveDate\"\n                              checked={cancellationData.effectiveDate === 'immediate'}\n                              onChange={() => setCancellationData(prev => ({ ...prev, effectiveDate: 'immediate' }))}\n                            />\n                            <Label htmlFor=\"immediate\" className=\"text-sm\">\n                              Immediately (no refund for unused time)\n                            </Label>\n                          </div>\n                        </div>\n                      </div>\n                    </div>\n                  ) : (\n                    <div className=\"space-y-4\">\n                      <div className=\"text-center\">\n                        <Gift className=\"w-12 h-12 text-blue-600 mx-auto mb-3\" />\n                        <h3 className=\"text-lg font-semibold\">Wait! We have a special offer</h3>\n                        <p className=\"text-gray-600\">\n                          Before you go, here are some exclusive offers just for you:\n                        </p>\n                      </div>\n\n                      <div className=\"space-y-3\">\n                        {retentionOffers.map(offer => (\n                          <Card\n                            key={offer.id}\n                            className=\"border-blue-200 bg-blue-50 cursor-pointer hover:bg-blue-100 transition-colors\"\n                            onClick={() => handleAcceptRetentionOffer(offer.id)}\n                          >\n                            <CardContent className=\"p-4\">\n                              <div className=\"flex justify-between items-start\">\n                                <div className=\"flex-1\">\n                                  <h4 className=\"font-semibold text-blue-900\">{offer.title}</h4>\n                                  <p className=\"text-sm text-blue-700 mt-1\">{offer.description}</p>\n                                  <p className=\"text-xs text-blue-600 mt-2\">Duration: {offer.duration}</p>\n                                </div>\n                                <div className=\"text-right text-blue-900\">\n                                  <p className=\"font-bold\">Save</p>\n                                  <p className=\"text-lg font-bold\">\n                                    {formatCurrency(offer.savings)}\n                                  </p>\n                                </div>\n                              </div>\n                            </CardContent>\n                          </Card>\n                        ))}\n                      </div>\n\n                      <div className=\"text-center\">\n                        <Button\n                          variant=\"outline\"\n                          onClick={() => setShowRetentionOffer(false)}\n                          className=\"text-gray-600\"\n                        >\n                          No thanks, continue with cancellation\n                        </Button>\n                      </div>\n                    </div>\n                  )}\n\n                  {!showRetentionOffer && (\n                    <DialogFooter>\n                      <Button\n                        variant=\"outline\"\n                        onClick={() => setShowCancelDialog(false)}\n                      >\n                        Keep Subscription\n                      </Button>\n                      <Button\n                        onClick={handleCancelConfirm}\n                        disabled={!cancellationData.reason || actionLoading === 'cancel'}\n                        className=\"bg-red-600 hover:bg-red-700\"\n                      >\n                        {actionLoading === 'cancel' ? (\n                          <div className=\"w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin mr-2\" />\n                        ) : null}\n                        Confirm Cancellation\n                      </Button>\n                    </DialogFooter>\n                  )}\n                </DialogContent>\n              </Dialog>\n            )}\n\n            {onPauseSubscription && !subscription.cancelAtPeriodEnd && (\n              <Button\n                variant=\"outline\"\n                onClick={() => onPauseSubscription(90)} // 90 days pause\n                disabled={actionLoading === 'pause'}\n                className=\"flex items-center gap-2\"\n              >\n                {actionLoading === 'pause' && (\n                  <div className=\"w-4 h-4 border-2 border-gray-600 border-t-transparent rounded-full animate-spin\" />\n                )}\n                <Calendar className=\"w-4 h-4\" />\n                Pause Subscription\n              </Button>\n            )}\n          </div>\n        </CardContent>\n      </Card>\n\n      {/* Plan Recommendations */}\n      {(getUpgradeOptions().length > 0 || getDowngradeOptions().length > 0) && (\n        <Card>\n          <CardHeader>\n            <CardTitle>Recommended Plans</CardTitle>\n          </CardHeader>\n          <CardContent>\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n              {/* Upgrade Options */}\n              {getUpgradeOptions().slice(0, 1).map((plan) => (\n                <Card key={plan.id} className=\"border-green-200 bg-green-50\">\n                  <CardContent className=\"p-4\">\n                    <div className=\"flex items-center justify-between mb-3\">\n                      <div>\n                        <h4 className=\"font-semibold text-green-900\">{plan.displayName}</h4>\n                        <p className=\"text-sm text-green-700\">{plan.description}</p>\n                      </div>\n                      <ArrowUpCircle className=\"w-6 h-6 text-green-600\" />\n                    </div>\n                    <div className=\"flex items-center justify-between\">\n                      <span className=\"text-lg font-bold text-green-900\">\n                        {formatCurrency(plan.pricing.monthly.amount, plan.pricing.monthly.currency)}/month\n                      </span>\n                      <Button\n                        size=\"sm\"\n                        onClick={() => handlePlanChange(plan, 'month')}\n                        disabled={actionLoading === 'plan-change'}\n                        className=\"bg-green-600 hover:bg-green-700\"\n                      >\n                        Upgrade\n                      </Button>\n                    </div>\n                  </CardContent>\n                </Card>\n              ))}\n\n              {/* Downgrade Options */}\n              {getDowngradeOptions().slice(-1).map((plan) => (\n                <Card key={plan.id} className=\"border-blue-200 bg-blue-50\">\n                  <CardContent className=\"p-4\">\n                    <div className=\"flex items-center justify-between mb-3\">\n                      <div>\n                        <h4 className=\"font-semibold text-blue-900\">{plan.displayName}</h4>\n                        <p className=\"text-sm text-blue-700\">{plan.description}</p>\n                      </div>\n                      <ArrowDownCircle className=\"w-6 h-6 text-blue-600\" />\n                    </div>\n                    <div className=\"flex items-center justify-between\">\n                      <span className=\"text-lg font-bold text-blue-900\">\n                        {formatCurrency(plan.pricing.monthly.amount, plan.pricing.monthly.currency)}/month\n                      </span>\n                      <Button\n                        variant=\"outline\"\n                        size=\"sm\"\n                        onClick={() => handlePlanChange(plan, 'month')}\n                        disabled={actionLoading === 'plan-change'}\n                        className=\"border-blue-300 text-blue-700 hover:bg-blue-100\"\n                      >\n                        Downgrade\n                      </Button>\n                    </div>\n                  </CardContent>\n                </Card>\n              ))}\n            </div>\n          </CardContent>\n        </Card>\n      )}\n    </div>\n  );\n}\n\nexport default SubscriptionManagement;\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/ui/alert.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'VariantProps' is not defined.",
        "line": 26,
        "column": 34,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 26,
        "endColumn": 46
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\"\nimport { cva } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst alertVariants = cva(\n  'relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current',\n  {\n    variants: {\n      variant: {\n        default: 'bg-card text-card-foreground',\n        destructive:\n          'text-destructive bg-card [&>svg]:text-current *:data-[slot=alert-description]:text-destructive/90',\n      },\n    },\n    defaultVariants: {\n      variant: 'default',\n    },\n  }\n)\n\nfunction Alert({\n  className,\n  variant,\n  ...props\n}: React.ComponentProps<'div'> & VariantProps<typeof alertVariants>) {\n  return (\n    <div\n      data-slot=\"alert\"\n      role=\"alert\"\n      className={cn(alertVariants({ variant }), className)}\n      {...props}\n    />\n  )\n}\n\nfunction AlertTitle({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"alert-title\"\n      className={cn(\n        \"col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nfunction AlertDescription({ className, ...props }: React.ComponentProps<'div'>) {\n  return (\n    <div\n      data-slot=\"alert-description\"\n      className={cn(\n        \"text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed\",\n        className\n      )}\n      {...props}\n    />\n  )\n}\n\nexport { Alert, AlertTitle, AlertDescription }\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/ui/badge.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'VariantProps' is not defined.",
        "line": 34,
        "column": 3,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 34,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst badgeVariants = cva(\n  'inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden',\n  {\n    variants: {\n      variant: {\n        default:\n          'border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90',\n        secondary:\n          'border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90',\n        destructive:\n          'border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',\n        outline:\n          'text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground',\n      },\n    },\n    defaultVariants: {\n      variant: 'default',\n    },\n  }\n)\n\nfunction Badge({\n  className,\n  variant,\n  asChild = false,\n  ...props\n}: React.ComponentProps<'span'> &\n  VariantProps<typeof badgeVariants> & { asChild?: boolean }) {\n  const Comp = asChild ? Slot : \"span\"\n\n  return (\n    <Comp\n      data-slot=\"badge\"\n      className={cn(badgeVariants({ variant }), className)}\n      {...props}\n    />\n  )\n}\n\nexport { Badge, badgeVariants }\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/ui/button.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'VariantProps' is not defined.",
        "line": 45,
        "column": 3,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 45,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\"\nimport { Slot } from \"@radix-ui/react-slot\"\nimport { cva } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\nimport { useRTL } from \"../RTLLayout\"\n\nconst buttonVariants = cva(\n  \"inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive ltr:flex-row rtl:flex-row-reverse\",\n  {\n    variants: {\n      variant: {\n        default: 'bg-primary text-primary-foreground shadow-xs hover:bg-primary/90',\n        destructive:\n          'bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60',\n        outline:\n          'border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50',\n        secondary:\n          'bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80',\n        ghost: 'hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50',\n        link: 'text-primary underline-offset-4 hover:underline',\n      },\n      size: {\n        default: 'h-9 px-4 py-2 has-[>svg]:px-3',\n        sm: 'h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5',\n        lg: 'h-10 rounded-md px-6 has-[>svg]:px-4',\n        icon: 'size-9',\n      },\n    },\n    defaultVariants: {\n      variant: 'default',\n      size: 'default',\n    },\n  }\n)\n\nfunction Button({\n  className,\n  variant,\n  size,\n  asChild = false,\n  dir,\n  ...props\n}: React.ComponentProps<'button'> &\n  VariantProps<typeof buttonVariants> & {\n    asChild?: boolean\n    dir?: 'ltr' | 'rtl' | 'auto'\n  }) {\n  const Comp = asChild ? Slot : \"button\"\n  const { direction, isRTL } = useRTL()\n\n  const buttonDir = dir === 'auto' || !dir ? direction : dir\n\n  return (\n    <Comp\n      data-slot=\"button\"\n      className={cn(buttonVariants({ variant, size, className }))}\n      dir={buttonDir}\n      data-rtl={isRTL}\n      {...props}\n    />\n  )\n}\n\nexport { Button, buttonVariants }\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/components/ui/toggle.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'VariantProps' is not defined.",
        "line": 35,
        "column": 3,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 35,
        "endColumn": 15
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import * as React from \"react\"\nimport * as TogglePrimitive from \"@radix-ui/react-toggle\"\nimport { cva } from \"class-variance-authority\"\n\nimport { cn } from \"@/lib/utils\"\n\nconst toggleVariants = cva(\n  \"inline-flex items-center justify-center gap-2 rounded-md text-sm font-medium hover:bg-muted hover:text-muted-foreground disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 [&_svg]:shrink-0 focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] outline-none transition-[color,box-shadow] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive whitespace-nowrap\",\n  {\n    variants: {\n      variant: {\n        default: 'bg-transparent',\n        outline:\n          'border border-input bg-transparent shadow-xs hover:bg-accent hover:text-accent-foreground',\n      },\n      size: {\n        default: 'h-9 px-2 min-w-9',\n        sm: 'h-8 px-1.5 min-w-8',\n        lg: 'h-10 px-2.5 min-w-10',\n      },\n    },\n    defaultVariants: {\n      variant: 'default',\n      size: 'default',\n    },\n  }\n)\n\nfunction Toggle({\n  className,\n  variant,\n  size,\n  ...props\n}: React.ComponentProps<typeof TogglePrimitive.Root> &\n  VariantProps<typeof toggleVariants>) {\n  return (\n    <TogglePrimitive.Root\n      data-slot=\"toggle\"\n      className={cn(toggleVariants({ variant, size, className }))}\n      {...props}\n    />\n  )\n}\n\nexport { Toggle, toggleVariants }\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/contexts/FeatureAccessContext.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'FeatureAccess' is not defined.",
        "line": 18,
        "column": 18,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 18,
        "endColumn": 31
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'FeatureAccess' is not defined.",
        "line": 65,
        "column": 54,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 65,
        "endColumn": 67
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'setUserTier' is not defined.",
        "line": 88,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 88,
        "endColumn": 18
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'userTier' is not defined.",
        "line": 195,
        "column": 5,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 195,
        "endColumn": 13
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Feature Access Context for Relife Alarm App\n// Provides feature access state and controls throughout the React component tree\n\nimport React, {\n  createContext,\n  useContext,\n  useEffect,\n  useState,\n  ReactNode,\n  useCallback,\n} from \"react\";\nimport FeatureGateService from \"../services/feature-gate-service\";\nimport SubscriptionService from \"../services/subscription-service\";\nimport { ErrorHandler } from \"../services/error-handler\";\n\ninterface FeatureAccessContextValue {\n  // State\n  featureAccess: FeatureAccess | null;\n  isLoading: boolean;\n  error: string | null;\n\n  // Feature checking\n  hasFeatureAccess: (featureId: string) => boolean;\n  getFeatureUsage: (\n    featureId: string,\n  ) => { used: number; limit: number; remaining: number } | null;\n\n  // Actions\n  trackFeatureAttempt: (featureId: string, context?: Record<string, any>) => void;\n  refreshFeatureAccess: () => Promise<void>;\n  grantTemporaryAccess: (featureId: string, durationMinutes: number, reason: string) => void;\n\n  // Callbacks\n  onFeatureBlocked?: (\n    featureId: string,\n  ) => void;\n  onUpgradeRequired?: (\n    featureId: string,\n  ) => void;\n}\n\nconst FeatureAccessContext = createContext<FeatureAccessContextValue | null>(null);\n\ninterface FeatureAccessProviderProps {\n  children: ReactNode;\n  userId: string;\n  onFeatureBlocked?: (\n    featureId: string,\n  ) => void;\n  onUpgradeRequired?: (\n    featureId: string,\n  ) => void;\n  autoRefresh?: boolean;\n  refreshInterval?: number;\n}\n\nexport function FeatureAccessProvider({\n  children,\n  userId,\n  onFeatureBlocked,\n  onUpgradeRequired,\n  autoRefresh = true,\n  refreshInterval = 300000 // 5 minutes\n}: FeatureAccessProviderProps) {\n  const [featureAccess, setFeatureAccess] = useState<FeatureAccess | null>(\n    null,\n  );\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const featureGateService = FeatureGateService.getInstance();\n  const subscriptionService = SubscriptionService.getInstance();\n\n  // Load initial feature access data\n  const loadFeatureAccess = useCallback(async () => {\n    if (!userId) return;\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const [accessData, tier] = await Promise.all([\n        subscriptionService.getFeatureAccess(userId),\n        subscriptionService.getUserTier(userId)\n      ]);\n\n      setFeatureAccess(accessData);\n      setUserTier(tier);\n    } catch (error) {\n      const errorMessage = 'Failed to load feature access data';\n      setError(errorMessage);\n\n      ErrorHandler.handleError(\n        error instanceof Error ? error : new Error(String(error)),\n        errorMessage,\n        { context: 'FeatureAccessProvider', metadata: { userId } }\n      );\n    } finally {\n      setIsLoading(false);\n    }\n  }, [userId, subscriptionService]);\n\n  // Initialize on mount\n  useEffect(() => {\n    loadFeatureAccess();\n  }, [loadFeatureAccess]);\n\n  // Auto-refresh feature access\n  useEffect(() => {\n    if (!autoRefresh || !userId) return;\n\n    const interval = setInterval(() => {\n      loadFeatureAccess();\n    }, refreshInterval);\n\n    return () => clearInterval(interval);\n  }, [autoRefresh, refreshInterval, loadFeatureAccess]);\n\n  // Feature access checking functions\n  const hasFeatureAccess = useCallback((featureId: string): boolean => {\n    if (!featureAccess) return false;\n\n    const feature = featureAccess.features[featureId];\n    if (!feature) return false;\n\n    // Check if user has access\n    if (!feature.hasAccess) return false;\n\n    // Check usage limits\n    if (feature.usageLimit && feature.usageCount !== undefined) {\n      return feature.usageCount < feature.usageLimit;\n    }\n\n    return true;\n  }, [featureAccess]);\n\n  const getFeatureUsage = useCallback((featureId: string) => {\n    if (!featureAccess) return null;\n\n    const feature = featureAccess.features[featureId];\n    if (!feature || !feature.usageLimit || feature.usageCount === undefined) {\n      return null;\n    }\n\n    return {\n      used: feature.usageCount,\n      limit: feature.usageLimit,\n      remaining: Math.max(0, feature.usageLimit - feature.usageCount)\n    };\n  }, [featureAccess]);\n\n  const getUpgradeRequirement = useCallback((featureId: string) => {\n      if (!featureAccess) return null;\n\n    const feature = featureAccess.features[featureId];\n    return feature?.upgradeRequired || null;\n  }, [featureAccess]);\n\n  // Actions\n  const trackFeatureAttempt = useCallback(async (featureId: string, context?: Record<string, any>) => {\n    const hasAccess = hasFeatureAccess(featureId);\n\n    await featureGateService.trackFeatureAttempt(userId, featureId, hasAccess, context);\n\n    // Trigger callbacks if access is denied\n    if (!hasAccess) {\n      const requiredTier = getUpgradeRequirement(featureId);\n\n      if (onFeatureBlocked) {\n        onFeatureBlocked(featureId, requiredTier || 'basic');\n      }\n\n      if (requiredTier && onUpgradeRequired) {\n        onUpgradeRequired(featureId, requiredTier);\n      }\n    }\n  }, [userId, hasFeatureAccess, getUpgradeRequirement, onFeatureBlocked, onUpgradeRequired]);\n\n  const refreshFeatureAccess = useCallback(async () => {\n    await loadFeatureAccess();\n  }, [loadFeatureAccess]);\n\n  const grantTemporaryAccess = useCallback((featureId: string, durationMinutes: number, reason: string) => {\n    featureGateService.grantTemporaryAccess(userId, featureId, durationMinutes, reason);\n\n    // Refresh feature access to reflect the temporary grant\n    setTimeout(() => {\n      loadFeatureAccess();\n    }, 1000);\n  }, [userId, loadFeatureAccess]);\n\n  const contextValue: FeatureAccessContextValue = {\n    // State\n    featureAccess,\n    userTier,\n    isLoading,\n    error,\n\n    // Feature checking\n    hasFeatureAccess,\n    getFeatureUsage,\n    getUpgradeRequirement,\n\n    // Actions\n    trackFeatureAttempt,\n    refreshFeatureAccess,\n    grantTemporaryAccess,\n\n    // Callbacks\n    onFeatureBlocked,\n    onUpgradeRequired\n  };\n\n  return (\n    <FeatureAccessContext.Provider value={contextValue}>\n      {children}\n    </FeatureAccessContext.Provider>\n  );\n}\n\n// Hook to use feature access context\nexport function useFeatureAccessContext(): FeatureAccessContextValue {\n  const context = useContext(FeatureAccessContext);\n\n  if (!context) {\n    throw new Error('useFeatureAccessContext must be used within a FeatureAccessProvider');\n  }\n\n  return context;\n}\n\n// Higher-order component to provide feature access context\nexport function withFeatureAccess<P extends object>(\n  WrappedComponent: React.ComponentType<P>,\n  userId: string,\n  options?: {\n    onFeatureBlocked?: (\n      featureId: string,\n    ) => void;\n    onUpgradeRequired?: (\n      featureId: string,\n    ) => void;\n  },\n) {\n  return function FeatureAccessWrappedComponent(props: P) {\n    return (\n      <FeatureAccessProvider\n        userId={userId}\n        onFeatureBlocked={options?.onFeatureBlocked}\n        onUpgradeRequired={options?.onUpgradeRequired}\n      >\n        <WrappedComponent {...props} />\n      </FeatureAccessProvider>\n    );\n  };\n}\n\n// Component to conditionally render based on feature access\ninterface ConditionalFeatureProps {\n  feature: string;\n  children: ReactNode;\n  fallback?: ReactNode;\n  onBlocked?: () => void;\n}\n\nexport function ConditionalFeature({\n  feature,\n  children,\n  fallback = null,\n  onBlocked\n}: ConditionalFeatureProps) {\n  const { hasFeatureAccess: checkAccess, trackFeatureAttempt } = useFeatureAccessContext();\n\n  const hasAccess = checkAccess(feature);\n\n  // Track the attempt when component mounts or feature changes\n  useEffect(() => {\n    trackFeatureAttempt(feature);\n\n    if (!hasAccess && onBlocked) {\n      onBlocked();\n    }\n  }, [feature, hasAccess, onBlocked, trackFeatureAttempt]);\n\n  return hasAccess ? <>{children}</> : <>{fallback}</>;\n}\n\n// Hook for easier feature access checking\nexport function useFeatureAccess(feature: string) {\n  const context = useFeatureAccessContext();\n\n  return {\n    hasAccess: context.hasFeatureAccess(feature),\n    usage: context.getFeatureUsage(feature),\n    requiredTier: context.getUpgradeRequirement(feature),\n    trackAttempt: (contextData?: Record<string, any>) => context.trackFeatureAttempt(feature, contextData)\n  };\n}\n\nexport default FeatureAccessContext;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/__tests__/edge-cases/useAdvancedAlarms.edge.test.ts",
    "messages": [
      {
        "ruleId": null,
        "nodeType": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Expression expected.",
        "line": 503,
        "column": 6
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\nimport { renderHook, act } from \"@testing-library/react\";\n\n// Mock dependencies\njest.mock('../../../services/alarm-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      getAllAlarms: jest.fn(),\n      createAlarm: jest.fn(),\n      updateAlarm: jest.fn(),\n      deleteAlarm: jest.fn(),\n      duplicateAlarm: jest.fn(),\n      exportAlarms: jest.fn(),\n      importAlarms: jest.fn(),\n      getAlarmStatistics: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/advanced-alarm-scheduler', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      scheduleAlarm: jest.fn(),\n      cancelAlarm: jest.fn(),\n      updateScheduledAlarm: jest.fn(),\n      getNextOccurrence: jest.fn(),\n      optimizeSchedule: jest.fn(),\n      handleLocationTrigger: jest.fn(),\n      checkConditionalRules: jest.fn(),\n      bulkScheduleAlarms: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/error-handler', () => ({\n  ErrorHandler: {\n    handleError: jest.fn()\n  }\n}));\n\njest.mock('../../useAnalytics', () => ({\n  useAnalytics: () => ({\n    track: jest.fn(),\n    trackPageView: jest.fn(),\n    trackFeatureUsage: jest.fn()\n  }),\n  ANALYTICS_EVENTS: {\n    ALARM_CREATED: 'alarm_created',\n    ALARM_DELETED: 'alarm_deleted',\n    BULK_OPERATION: 'bulk_operation'\n  }\n}));\n\n// Mock geolocation\nconst mockGeolocation = {\n  getCurrentPosition: jest.fn(),\n  watchPosition: jest.fn(),\n  clearWatch: jest.fn()\n};\n\nObject.defineProperty(global.navigator, 'geolocation', {\n  value: mockGeolocation,\n  writable: true\n});\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    localStorage.clear();\n    jest.useFakeTimers();\n\n    // Reset geolocation mocks\n    mockGeolocation.getCurrentPosition.mockClear();\n    mockGeolocation.watchPosition.mockClear();\n    mockGeolocation.clearWatch.mockClear();\n  });\n\n  afterEach(() => {\n    jest.runOnlyPendingTimers();\n    jest.useRealTimers();\n  });\n\n  describe('Data Corruption and Invalid States', () => {\n    it('should handle corrupted alarm data from storage', async () => {\n      const AlarmService = require('../../../services/alarm-service').default;\n      const mockAlarmService = AlarmService.getInstance();\n\n      // Return mixed valid and corrupted alarm data\n      mockAlarmService.getAllAlarms.mockResolvedValue([\n        { id: 'alarm-1', name: 'Valid Alarm', time: '07:00', enabled: true },\n        { id: null, name: undefined, time: 'invalid-time' }, // Corrupted\n        'invalid-alarm-format', // Wrong format\n        { id: 'alarm-3', name: 'Another Valid', time: '08:00', enabled: true },\n        { id: 'alarm-4', time: '09:00' } // Missing required fields\n      ]);\n\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // Should filter out corrupted alarms and keep valid ones\n      const validAlarms = result.current.alarms.filter(alarm =>\n        alarm && typeof alarm === 'object' && alarm.id && alarm.time\n      );\n      expect(validAlarms).toHaveLength(2);\n      expect(result.current.error).not.toContain('TypeError');\n    });\n\n    it('should handle invalid time formats', async () => {\n      const AlarmService = require('../../../services/alarm-service').default;\n      const mockAlarmService = AlarmService.getInstance();\n\n      mockAlarmService.createAlarm.mockResolvedValue({\n        id: 'alarm-123',\n        name: 'Test Alarm',\n        time: '25:70', // Invalid time\n        enabled: true\n      });\n\n\n      await act(async () => {\n        await result.current.createAlarm({\n          name: 'Test Alarm',\n          time: '25:70',\n          enabled: true,\n          repeatDays: []\n        });\n      });\n\n      expect(result.current.error).toContain('Invalid time format');\n    });\n\n    it('should handle extremely large alarm collections', async () => {\n      const AlarmService = require('../../../services/alarm-service').default;\n      const mockAlarmService = AlarmService.getInstance();\n\n      // Generate 10,000 alarms\n      const largeAlarmCollection = Array(10000).fill(null).map((_, index) => ({\n        id: `alarm-${index}`,\n        name: `Alarm ${index}`,\n        time: `${(index % 24).toString().padStart(2, '0')}:${(index % 60).toString().padStart(2, '0')}`,\n        enabled: index % 2 === 0,\n        repeatDays: index % 7 === 0 ? [1, 2, 3, 4, 5] : [],\n        metadata: {\n          large_data: 'x'.repeat(1000) // 1KB per alarm\n        }\n      }));\n\n      mockAlarmService.getAllAlarms.mockResolvedValue(largeAlarmCollection);\n\n      const startTime = Date.now();\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n      const endTime = Date.now();\n\n      // Should handle large collections efficiently\n      expect(endTime - startTime).toBeLessThan(2000); // Less than 2 seconds\n      expect(result.current.alarms).toHaveLength(10000);\n      expect(result.current.isLoading).toBe(false);\n    });\n  });\n\n  describe('Concurrency and Race Conditions', () => {\n    it('should handle concurrent alarm creations', async () => {\n      const AlarmService = require('../../../services/alarm-service').default;\n      const mockAlarmService = AlarmService.getInstance();\n\n      let creationCount = 0;\n      mockAlarmService.createAlarm.mockImplementation(alarm => {\n        creationCount++;\n        return new Promise(resolve => {\n          setTimeout(() => resolve({\n            id: `alarm-${creationCount}`,\n            ...alarm,\n            created_at: new Date().toISOString()\n          }), 100 + Math.random() * 200);\n        });\n      });\n\n\n      await act(async () => {\n        // Create 20 alarms simultaneously\n        const promises = Array(20).fill(null).map((_, index) =>\n          result.current.createAlarm({\n            name: `Concurrent Alarm ${index}`,\n            time: `${(7 + index % 3).toString().padStart(2, '0')}:${(index * 5 % 60).toString().padStart(2, '0')}`,\n            enabled: true,\n            repeatDays: []\n          })\n        );\n\n        await Promise.allSettled(promises);\n      });\n\n      expect(creationCount).toBe(20);\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    it('should handle alarm deletion during update', async () => {\n      const AlarmService = require('../../../services/alarm-service').default;\n      const mockAlarmService = AlarmService.getInstance();\n\n      mockAlarmService.updateAlarm.mockImplementation(() =>\n        new Promise(resolve => setTimeout(() => resolve({\n          id: 'alarm-123',\n          name: 'Updated Alarm',\n          time: '08:00'\n        }), 200))\n      );\n\n      mockAlarmService.deleteAlarm.mockResolvedValue({ success: true });\n\n\n      await act(async () => {\n        // Start update\n        const updatePromise = result.current.updateAlarm('alarm-123', {\n          name: 'Updated Name'\n        });\n\n        // Delete before update completes\n        setTimeout(() => {\n          result.current.deleteAlarm('alarm-123');\n        }, 50);\n\n        await Promise.allSettled([updatePromise]);\n      });\n\n      // Should handle conflicting operations gracefully\n      expect(result.current.error).not.toContain('conflict');\n    });\n\n    it(\"should handle rapid alarm scheduling operations\", async () => {\n      // Service is now imported at the top\n\n      let scheduleCount = 0;\n      mockScheduler.scheduleAlarm.mockImplementation(alarm => {\n        scheduleCount++;\n        return Promise.resolve({\n          scheduled: true,\n          next_occurrence: new Date(Date.now() + 24 * 60 * 60 * 1000)\n        });\n      });\n\n\n      await act(async () => {\n        // Schedule 100 alarms rapidly\n        const alarms = Array(100).fill(null).map((_, index) => ({\n          id: `alarm-${index}`,\n          name: `Rapid Alarm ${index}`,\n          time: '07:00',\n          enabled: true\n        }));\n\n        await result.current.bulkScheduleAlarms(alarms);\n      });\n\n      expect(scheduleCount).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Geolocation Edge Cases', () => {\n    it('should handle geolocation permission denied', async () => {\n      mockGeolocation.getCurrentPosition.mockImplementation((success, error) => {\n        error({ code: 1, message: 'User denied Geolocation' });\n      });\n\n\n      await act(async () => {\n        await result.current.createAlarm({\n          name: 'Location Alarm',\n          time: '08:00',\n          enabled: true,\n          repeatDays: [],\n          locationTrigger: {\n            latitude: 37.7749,\n            longitude: -122.4194,\n            radius: 100\n          }\n        });\n      });\n\n      expect(result.current.error).toContain('location permission');\n    });\n\n    it('should handle geolocation timeout', async () => {\n      mockGeolocation.getCurrentPosition.mockImplementation((success, error) => {\n        setTimeout(() => {\n          error({ code: 3, message: 'Timeout' });\n        }, 10000);\n      });\n\n\n      await act(async () => {\n        // Try to create location-based alarm\n        const promise = result.current.createAlarm({\n          name: 'Location Alarm',\n          time: '08:00',\n          enabled: true,\n          repeatDays: [],\n          locationTrigger: {\n            latitude: 37.7749,\n            longitude: -122.4194,\n            radius: 100\n          }\n        });\n\n        // Fast forward to timeout\n        jest.advanceTimersByTime(10000);\n        await promise;\n      });\n\n      expect(result.current.error).toContain('timeout');\n    });\n\n    it('should handle invalid GPS coordinates', async () => {\n      mockGeolocation.getCurrentPosition.mockImplementation((success) => {\n        success({\n          coords: {\n            latitude: 999, // Invalid latitude\n            longitude: -999, // Invalid longitude\n            accuracy: 10\n          }\n        });\n      });\n\n\n      await act(async () => {\n        await result.current.createAlarm({\n          name: 'Location Alarm',\n          time: '08:00',\n          enabled: true,\n          repeatDays: [],\n          locationTrigger: {\n            latitude: 999,\n            longitude: -999,\n            radius: 100\n          }\n        });\n      });\n\n      expect(result.current.error).toContain('Invalid coordinates');\n    });\n  });\n\n  describe('Import/Export Edge Cases', () => {\n    it('should handle corrupted import files', async () => {\n      const AlarmService = require('../../../services/alarm-service').default;\n      const mockAlarmService = AlarmService.getInstance();\n\n      mockAlarmService.importAlarms.mockRejectedValue(\n        new Error('Invalid file format')\n      );\n\n\n      const corruptedFile = new File(['corrupted-data-{{{'], 'alarms.json', {\n        type: 'application/json'\n      });\n\n      await act(async () => {\n        await result.current.importAlarms(corruptedFile);\n      });\n\n      expect(result.current.error).toContain('Invalid file format');\n    });\n\n    it('should handle extremely large import files', async () => {\n      const AlarmService = require('../../../services/alarm-service').default;\n      const mockAlarmService = AlarmService.getInstance();\n\n      // Mock successful import of large file\n      mockAlarmService.importAlarms.mockImplementation(file => {\n        // Simulate processing delay based on file size\n        const delay = Math.min(file.size / 1000, 5000); // Max 5 seconds\n        return new Promise(resolve => {\n          setTimeout(() => resolve({\n            imported: Math.floor(file.size / 100), // Mock alarm count\n            skipped: 0,\n            errors: []\n          }), delay);\n        });\n      });\n\n\n      // Create a 10MB file\n      const largeContent = JSON.stringify(Array(10000).fill({\n        name: 'Large Import Alarm',\n        time: '07:00',\n        enabled: true\n      }));\n\n      const largeFile = new File([largeContent], 'large-alarms.json', {\n        type: 'application/json'\n      });\n\n      const startTime = Date.now();\n      await act(async () => {\n        await result.current.importAlarms(largeFile);\n      });\n      const endTime = Date.now();\n\n      // Should handle large files efficiently\n      expect(endTime - startTime).toBeLessThan(10000); // Less than 10 seconds\n      expect(result.current.importResult?.imported).toBeGreaterThan(0);\n    });\n\n    it('should handle network failures during export', async () => {\n      const AlarmService = require('../../../services/alarm-service').default;\n      const mockAlarmService = AlarmService.getInstance();\n\n      mockAlarmService.exportAlarms.mockRejectedValue(\n        new Error('Network error during export')\n      );\n\n\n      await act(async () => {\n        await result.current.exportAlarms('json');\n      });\n\n      expect(result.current.error).toContain('Network error');\n\n      // Should provide retry mechanism\n      mockAlarmService.exportAlarms.mockResolvedValue({\n        data: JSON.stringify([]),\n        filename: 'alarms.json'\n      });\n\n      await act(async () => {\n        await result.current.retryLastOperation();\n      });\n\n      expect(result.current.exportResult).toBeTruthy();\n    });\n  });\n\n  describe(\"Conditional Rules Edge Cases\", () => {\n    it(\"should handle invalid weather API responses\", async () => {\n      // Service is now imported at the top\n\n      mockScheduler.checkConditionalRules.mockRejectedValue(\n        new Error('Weather API unavailable')\n      );\n\n\n      await act(async () => {\n        await result.current.createAlarm({\n          name: 'Weather Alarm',\n          time: '07:00',\n          enabled: true,\n          repeatDays: [],\n          conditionalRules: {\n            weather: {\n              condition: 'sunny',\n              temperature: { min: 15, max: 25 }\n            }\n          }\n        });\n      });\n\n      // Should create alarm but disable weather rules\n      expect(result.current.error).toContain('Weather conditions unavailable');\n    });\n\n    it(\"should handle conflicting conditional rules\", async () => {\n\n      await act(async () => {\n        await result.current.createAlarm({\n          name: 'Conflicting Rules Alarm',\n          time: '07:00',\n          enabled: true,\n          repeatDays: [],\n          conditionalRules: {\n            weather: { condition: 'sunny' },\n            calendar: { hasEvents: false },\n            location: { withinRadius: 100 },\n            // These rules might conflict with each other\n            timeOffset: {\n              earlier: 30, // 30 minutes earlier\n              later: 15    // 15 minutes later - conflict!\n            }\n          }\n        });\n      });\n\n      expect(result.current.error).toContain('Conflicting rules');\n    });\n  });\n\n  describe(\"Performance and Memory Stress Tests\", () => {\n    it(\"should handle intensive alarm scheduling without memory leaks\", async () => {\n      // Service is now imported at the top\n\n      let scheduleCallCount = 0;\n      mockScheduler.scheduleAlarm.mockImplementation(() => {\n        scheduleCallCount++;\n        return Promise.resolve({ scheduled: true });\n      });\n\n      const { result, unmount } = renderHook(() =>\n      );\n\n      await act(async () => {\n        // Create and schedule many alarms\n        for (let batch = 0; batch < 10; batch++) {\n          const alarms = Array(100).fill(null).map((_, index) => ({\n            name: `Stress Test Alarm ${batch}-${index}`,\n            time: `${((batch + index) % 24).toString().padStart(2, '0')}:00`,\n            enabled: true,\n            repeatDays: [1, 2, 3, 4, 5]\n          }));\n\n          for (const alarm of alarms) {\n            await result.current.createAlarm(alarm);\n          }\n        }\n      });\n\n      // Should handle without excessive memory usage\n      expect(scheduleCallCount).toBe(1000);\n      expect(result.current.isLoading).toBe(false);\n\n      unmount();\n    });\n\n    it('should handle rapid alarm state changes', async () => {\n      const AlarmService = require('../../../services/alarm-service').default;\n      const mockAlarmService = AlarmService.getInstance();\n\n      let operationCount = 0;\n      const mockOperation = (operation: string) => {\n        operationCount++;\n        return Promise.resolve({\n          id: 'alarm-123',\n          operation: operation,\n          count: operationCount\n        });\n      };\n\n      mockAlarmService.updateAlarm.mockImplementation(() => mockOperation('update'));\n      mockAlarmService.createAlarm.mockImplementation(() => mockOperation('create'));\n      mockAlarmService.deleteAlarm.mockImplementation(() => mockOperation('delete'));\n\n\n      await act(async () => {\n        // Rapid state changes\n        for (let i = 0; i < 200; i++) {\n          const operation = i % 3;\n          switch (operation) {\n            case 0:\n              await result.current.createAlarm({\n                name: `Rapid ${i}`,\n                time: '07:00',\n                enabled: true,\n                repeatDays: []\n              });\n              break;\n            case 1:\n              await result.current.updateAlarm('alarm-123', {\n                name: `Updated ${i}`\n              });\n              break;\n            case 2:\n              await result.current.deleteAlarm('alarm-123');\n              break;\n          }\n        }\n      });\n\n      expect(operationCount).toBe(200);\n      expect(result.current.isLoading).toBe(false);\n    });\n  });\n\n  describe(\"Timezone and Time Edge Cases\", () => {\n    it(\"should handle timezone changes\", async () => {\n      // Service is now imported at the top\n\n      // Mock timezone-aware scheduling\n      mockScheduler.getNextOccurrence.mockImplementation(alarm => {\n        const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n        return new Date(Date.now() + 24 * 60 * 60 * 1000); // Next day\n      });\n\n\n      // Mock timezone change\n      Object.defineProperty(Intl.DateTimeFormat.prototype, 'resolvedOptions', {\n        value: () => ({ timeZone: 'America/Los_Angeles' })\n      });\n\n      await act(async () => {\n        await result.current.createAlarm({\n          name: 'Timezone Test',\n          time: '07:00',\n          enabled: true,\n          repeatDays: [1, 2, 3, 4, 5]\n        });\n      });\n\n      expect(result.current.error).not.toContain('timezone');\n    });\n\n    it(\"should handle daylight saving time transitions\", async () => {\n      // Service is now imported at the top\n\n      // Mock DST transition\n      const dstTransitionDate = new Date('2024-03-10T07:00:00'); // Spring forward\n      mockScheduler.getNextOccurrence.mockReturnValue(dstTransitionDate);\n\n\n      await act(async () => {\n        await result.current.createAlarm({\n          name: 'DST Alarm',\n          time: '02:30', // Time that doesn't exist during spring forward\n          enabled: true,\n          repeatDays: [0] // Sunday\n        });\n      });\n\n      // Should handle DST transition gracefully\n      expect(result.current.error).not.toContain('DST');\n    });\n  });\n\n  describe('Regression Tests', () => {\n    it('should preserve alarm order after bulk operations', async () => {\n      const AlarmService = require('../../../services/alarm-service').default;\n      const mockAlarmService = AlarmService.getInstance();\n\n      const orderedAlarms = [\n        { id: 'alarm-1', name: 'First', time: '06:00', enabled: true },\n        { id: 'alarm-2', name: 'Second', time: '07:00', enabled: true },\n        { id: 'alarm-3', name: 'Third', time: '08:00', enabled: true }\n      ];\n\n      mockAlarmService.getAllAlarms.mockResolvedValue(orderedAlarms);\n\n\n      await act(async () => {\n        await result.current.refreshAlarms();\n      });\n\n      // Verify order is preserved\n      expect(result.current.alarms[0].name).toBe('First');\n      expect(result.current.alarms[1].name).toBe('Second');\n      expect(result.current.alarms[2].name).toBe('Third');\n    });\n\n    it('should handle alarm duplication with conflicting names', async () => {\n      const AlarmService = require('../../../services/alarm-service').default;\n      const mockAlarmService = AlarmService.getInstance();\n\n      mockAlarmService.duplicateAlarm.mockResolvedValue({\n        id: 'alarm-duplicate',\n        name: 'Morning Alarm (Copy)',\n        time: '07:00',\n        enabled: true\n      });\n\n\n      await act(async () => {\n        await result.current.duplicateAlarm('alarm-1');\n      });\n\n      expect(result.current.error).toBeNull();\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/__tests__/edge-cases/useAuth.edge.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 137,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 137,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 170,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 170,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 201,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 201,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 234,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 234,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 250,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 250,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 275,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 275,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 297,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 297,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 320,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 320,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 344,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 344,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 370,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 370,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 395,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 395,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 428,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 428,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 445,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 445,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 473,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 473,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 496,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 496,
        "endColumn": 76
      }
    ],
    "suppressedMessages": [],
    "errorCount": 15,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\nimport { renderHook, act } from \"@testing-library/react\";\nimport { useAuth } from \"../../useAuth\";\n\n// Mock dependencies\njest.mock('../../../services/supabase-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      signIn: jest.fn(),\n      signUp: jest.fn(),\n      signOut: jest.fn(),\n      resetPassword: jest.fn(),\n      updateProfile: jest.fn(),\n      getCurrentUser: jest.fn(),\n      getSession: jest.fn(),\n      onAuthStateChange: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/security-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      generateCSRFToken: jest.fn(),\n      validateCSRFToken: jest.fn(),\n      isRateLimited: jest.fn(),\n      resetRateLimit: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/error-handler', () => ({\n  ErrorHandler: {\n    handleError: jest.fn()\n  }\n}));\n\njest.mock('../../useAnalytics', () => ({\n  useAnalytics: () => ({\n    track: jest.fn(),\n    trackPageView: jest.fn(),\n    trackFeatureUsage: jest.fn()\n  }),\n  ANALYTICS_EVENTS: {\n    USER_SIGNED_IN: 'user_signed_in',\n    USER_SIGNED_OUT: 'user_signed_out',\n    ERROR_OCCURRED: 'error_occurred'\n  }\n}));\n\ndescribe('useAuth Edge Cases and Stress Tests', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    localStorage.clear();\n\n    // Clear any existing timers\n    jest.clearAllTimers();\n    jest.useFakeTimers();\n  });\n\n  afterEach(() => {\n    jest.runOnlyPendingTimers();\n    jest.useRealTimers();\n  });\n\n  describe('Corrupted LocalStorage Data', () => {\n    it('should handle corrupted user data in localStorage', async () => {\n      // Insert corrupted data\n      localStorage.setItem('auth_user', 'invalid-json-{{{');\n      localStorage.setItem('auth_session', 'corrupted-data');\n\n      const { result } = renderHook(() => useAuth());\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // Should not crash and provide fallback behavior\n      expect(result.current.user).toBeNull();\n      expect(result.current.session).toBeNull();\n      expect(result.current.error).toBeNull(); // Should handle gracefully\n    });\n\n    it('should handle missing localStorage support', async () => {\n      // Mock localStorage failure\n      const originalLocalStorage = window.localStorage;\n      Object.defineProperty(window, 'localStorage', {\n        value: {\n          getItem: () => { throw new Error('Storage unavailable'); },\n          setItem: () => { throw new Error('Storage unavailable'); },\n          removeItem: () => { throw new Error('Storage unavailable'); },\n          clear: () => { throw new Error('Storage unavailable'); }\n        }\n      });\n\n      const { result } = renderHook(() => useAuth());\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'password');\n      });\n\n      // Should continue to function without localStorage\n      expect(result.current.error).not.toContain('Storage unavailable');\n\n      // Restore localStorage\n      Object.defineProperty(window, 'localStorage', { value: originalLocalStorage });\n    });\n\n    it('should handle extremely large localStorage data', async () => {\n      // Create large user object\n      const largeUser = {\n        id: 'user-123',\n        email: 'test@example.com',\n        metadata: {\n          largeData: 'x'.repeat(100000), // 100KB of data\n          moreData: Array(1000).fill('large string data').join(' ')\n        }\n      };\n\n      localStorage.setItem('auth_user', JSON.stringify(largeUser));\n\n      const { result } = renderHook(() => useAuth());\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // Should handle large data gracefully\n      expect(result.current.isLoading).toBe(false);\n    });\n  });\n\n  describe('Race Conditions', () => {\n    it('should handle concurrent sign-in attempts', async () => {\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n\n      let callCount = 0;\n      mockService.signIn.mockImplementation(() => {\n        callCount++;\n        return new Promise(resolve => {\n          setTimeout(() => resolve({\n            user: { id: `user-${callCount}`, email: 'test@example.com' },\n            session: { access_token: `token-${callCount}` }\n          }), 100 + Math.random() * 100);\n        });\n      });\n\n      const { result } = renderHook(() => useAuth());\n\n      // Fire multiple concurrent sign-in attempts\n      await act(async () => {\n        const promises = [\n          result.current.signIn('test@example.com', 'password1'),\n          result.current.signIn('test@example.com', 'password2'),\n          result.current.signIn('test@example.com', 'password3')\n        ];\n\n        await Promise.allSettled(promises);\n      });\n\n      // Should handle gracefully without conflicting state\n      expect(result.current.user).toBeDefined();\n      expect(callCount).toBeGreaterThan(0);\n    });\n\n    it('should handle sign-out during sign-in process', async () => {\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n\n      mockService.signIn.mockImplementation(() =>\n        new Promise(resolve => setTimeout(() => resolve({\n          user: { id: 'user-123', email: 'test@example.com' },\n          session: { access_token: 'token' }\n        }), 200))\n      );\n\n      mockService.signOut.mockResolvedValue({ error: null });\n\n      const { result } = renderHook(() => useAuth());\n\n      await act(async () => {\n        // Start sign-in\n        const signInPromise = result.current.signIn('test@example.com', 'password');\n\n        // Immediately try to sign out\n        setTimeout(() => {\n          result.current.signOut();\n        }, 50);\n\n        await signInPromise;\n      });\n\n      // Should handle conflicting operations gracefully\n      expect(result.current.error).not.toContain('conflict');\n    });\n\n    it('should handle rapid auth state changes', async () => {\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n\n      const authCallbacks: Array<(event: string, session: any) => void> = [];\n      mockService.onAuthStateChange.mockImplementation(callback => {\n        authCallbacks.push(callback);\n        return { data: { subscription: { unsubscribe: jest.fn() } } };\n      });\n\n      const { result } = renderHook(() => useAuth());\n\n      await act(async () => {\n        // Simulate rapid auth state changes\n        authCallbacks.forEach((callback, index) => {\n          setTimeout(() => {\n            callback('SIGNED_IN', { user: { id: `user-${index}` }, access_token: `token-${index}` });\n          }, index * 10);\n\n          setTimeout(() => {\n            callback('SIGNED_OUT', null);\n          }, index * 10 + 5);\n        });\n\n        await new Promise(resolve => setTimeout(resolve, 200));\n      });\n\n      // Should handle rapid state changes without crashing\n      expect(result.current.isLoading).toBe(false);\n    });\n  });\n\n  describe('Memory Leaks and Resource Management', () => {\n    it('should clean up listeners on unmount', async () => {\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n      const mockUnsubscribe = jest.fn();\n\n      mockService.onAuthStateChange.mockReturnValue({\n        data: { subscription: { unsubscribe: mockUnsubscribe } }\n      });\n\n      const { unmount } = renderHook(() => useAuth());\n\n      unmount();\n\n      expect(mockUnsubscribe).toHaveBeenCalled();\n    });\n\n    it('should handle multiple mount/unmount cycles', async () => {\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n      let subscriptionCount = 0;\n\n      mockService.onAuthStateChange.mockImplementation(() => {\n        subscriptionCount++;\n        return { data: { subscription: { unsubscribe: () => subscriptionCount-- } } };\n      });\n\n      // Mount and unmount multiple times\n      for (let i = 0; i < 10; i++) {\n        const { unmount } = renderHook(() => useAuth());\n        await act(async () => {\n          await new Promise(resolve => setTimeout(resolve, 10));\n        });\n        unmount();\n      }\n\n      // Should not accumulate subscriptions\n      expect(subscriptionCount).toBeLessThanOrEqual(1);\n    });\n  });\n\n  describe('Error Boundaries and Invalid States', () => {\n    it('should handle invalid user objects from service', async () => {\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n\n      // Return invalid user object\n      mockService.getCurrentUser.mockResolvedValue({\n        // Missing required fields\n        email: null,\n        id: undefined,\n        metadata: 'invalid-type'\n      });\n\n      const { result } = renderHook(() => useAuth());\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // Should handle invalid data gracefully\n      expect(result.current.error).not.toContain('TypeError');\n    });\n\n    it('should handle session timeout edge cases', async () => {\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n\n      // Session that expires in the past\n      const expiredSession = {\n        access_token: 'token',\n        expires_at: Date.now() - 10000, // 10 seconds ago\n        user: { id: 'user-123' }\n      };\n\n      mockService.getSession.mockResolvedValue(expiredSession);\n\n      const { result } = renderHook(() => useAuth());\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // Should detect expired session\n      expect(result.current.sessionTimeoutWarning).toBe(true);\n    });\n\n    it('should handle network disconnection during authentication', async () => {\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n\n      mockService.signIn.mockRejectedValue(new Error('Network Error'));\n\n      // Mock navigator.onLine\n      Object.defineProperty(navigator, 'onLine', {\n        writable: true,\n        value: false\n      });\n\n      const { result } = renderHook(() => useAuth());\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'password');\n      });\n\n      // Should provide offline-specific error handling\n      expect(result.current.error).toContain('offline');\n    });\n  });\n\n  describe('Stress Testing', () => {\n    it('should handle rapid consecutive API calls', async () => {\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n\n      let callCount = 0;\n      mockService.updateProfile.mockImplementation(() => {\n        callCount++;\n        return Promise.resolve({ user: { id: 'user-123', name: `Update ${callCount}` } });\n      });\n\n      const { result } = renderHook(() => useAuth());\n\n      await act(async () => {\n        // Fire 50 rapid updates\n        const promises = Array(50).fill(null).map((_, index) =>\n          result.current.updateProfile({ name: `Name ${index}` })\n        );\n\n        await Promise.allSettled(promises);\n      });\n\n      // Should handle without crashing\n      expect(result.current.isLoading).toBe(false);\n      expect(callCount).toBe(50);\n    });\n\n    it('should handle extremely long running operations', async () => {\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n\n      mockService.signIn.mockImplementation(() =>\n        new Promise(resolve => setTimeout(() => resolve({\n          user: { id: 'user-123' },\n          session: { access_token: 'token' }\n        }), 10000)) // 10 second delay\n      );\n\n      const { result } = renderHook(() => useAuth());\n\n      await act(async () => {\n        const signInPromise = result.current.signIn('test@example.com', 'password');\n\n        // Fast forward time\n        jest.advanceTimersByTime(10000);\n\n        await signInPromise;\n      });\n\n      expect(result.current.user).toBeTruthy();\n    });\n\n    it('should handle component re-renders during async operations', async () => {\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n\n      mockService.signIn.mockImplementation(() =>\n        new Promise(resolve => setTimeout(() => resolve({\n          user: { id: 'user-123' },\n          session: { access_token: 'token' }\n        }), 100))\n      );\n\n      const { result, rerender } = renderHook(() => useAuth());\n\n      await act(async () => {\n        // Start async operation\n        const signInPromise = result.current.signIn('test@example.com', 'password');\n\n        // Force multiple re-renders during operation\n        for (let i = 0; i < 10; i++) {\n          rerender();\n          await new Promise(resolve => setTimeout(resolve, 10));\n        }\n\n        await signInPromise;\n      });\n\n      // Should complete successfully despite re-renders\n      expect(result.current.user).toBeTruthy();\n      expect(result.current.error).toBeNull();\n    });\n  });\n\n  describe('Security Edge Cases', () => {\n    it('should handle CSRF token corruption', async () => {\n      const SecurityService = require('../../../services/security-service').default;\n      const mockSecurityService = SecurityService.getInstance();\n\n      mockSecurityService.generateCSRFToken.mockReturnValue('valid-token');\n      mockSecurityService.validateCSRFToken.mockReturnValue(false); // Always invalid\n\n      const { result } = renderHook(() => useAuth());\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'password');\n      });\n\n      // Should handle CSRF validation failure\n      expect(result.current.error).toContain('security');\n    });\n\n    it('should handle rate limiting edge cases', async () => {\n      const SecurityService = require('../../../services/security-service').default;\n      const mockSecurityService = SecurityService.getInstance();\n\n      // Simulate immediate rate limiting\n      mockSecurityService.isRateLimited.mockReturnValue(true);\n\n      const { result } = renderHook(() => useAuth());\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'password');\n      });\n\n      expect(result.current.rateLimitInfo.isLimited).toBe(true);\n\n      // Test rate limit reset\n      mockSecurityService.isRateLimited.mockReturnValue(false);\n      mockSecurityService.resetRateLimit.mockResolvedValue(undefined);\n\n      await act(async () => {\n        await result.current.resetRateLimit();\n      });\n\n      expect(result.current.rateLimitInfo.isLimited).toBe(false);\n    });\n  });\n\n  describe('Regression Tests', () => {\n    it('should handle auth state persistence after page reload', async () => {\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n\n      const persistedUser = { id: 'user-123', email: 'test@example.com' };\n      localStorage.setItem('auth_user', JSON.stringify(persistedUser));\n\n      mockService.getCurrentUser.mockResolvedValue(persistedUser);\n      mockService.getSession.mockResolvedValue({\n        access_token: 'token',\n        user: persistedUser\n      });\n\n      const { result } = renderHook(() => useAuth());\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // Should restore persisted state\n      expect(result.current.user).toEqual(persistedUser);\n    });\n\n    it('should handle sign-out with pending operations', async () => {\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n\n      mockService.updateProfile.mockImplementation(() =>\n        new Promise(resolve => setTimeout(() => resolve({ user: { id: 'user-123' } }), 200))\n      );\n      mockService.signOut.mockResolvedValue({ error: null });\n\n      const { result } = renderHook(() => useAuth());\n\n      await act(async () => {\n        // Start profile update\n        const updatePromise = result.current.updateProfile({ name: 'New Name' });\n\n        // Sign out before update completes\n        setTimeout(() => {\n          result.current.signOut();\n        }, 50);\n\n        await Promise.allSettled([updatePromise]);\n      });\n\n      // Should handle gracefully without state corruption\n      expect(result.current.user).toBeNull();\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/__tests__/edge-cases/usePWA.edge.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 33,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 33,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 47,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 47,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 101,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 101,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 187,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 187,
        "endColumn": 66
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\nimport { renderHook, act } from \"@testing-library/react\";\nimport { usePWA, useInstallPrompt, useServiceWorkerUpdate } from \"../../usePWA\";\n\n// Mock PWA Manager Service\njest.mock('../../../services/pwa-manager', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      isPWASupported: jest.fn().mockReturnValue(true),\n      isInstalled: jest.fn().mockReturnValue(false),\n      install: jest.fn(),\n      checkForUpdates: jest.fn(),\n      updateServiceWorker: jest.fn(),\n      on: jest.fn(),\n      off: jest.fn()\n    })\n  }\n}));\n\ndescribe('PWA Hooks Edge Cases and Stress Tests', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    jest.useFakeTimers();\n  });\n\n  afterEach(() => {\n    jest.useRealTimers();\n  });\n\n  describe('Installation Edge Cases', () => {\n    it('should handle installation failures gracefully', async () => {\n      const PWAManager = require('../../../services/pwa-manager').default;\n      const mockPWAManager = PWAManager.getInstance();\n      mockPWAManager.install.mockRejectedValue(new Error('Installation failed'));\n\n      const { result } = renderHook(() => usePWA());\n\n      await act(async () => {\n        await result.current.install();\n      });\n\n      expect(result.current.error).toContain('Installation failed');\n    });\n\n    it('should handle multiple concurrent install attempts', async () => {\n      const PWAManager = require('../../../services/pwa-manager').default;\n      const mockPWAManager = PWAManager.getInstance();\n\n      let installCount = 0;\n      mockPWAManager.install.mockImplementation(() => {\n        installCount++;\n        return new Promise(resolve =>\n          setTimeout(() => resolve(true), 100 + Math.random() * 100)\n        );\n      });\n\n      const { result } = renderHook(() => usePWA());\n\n      await act(async () => {\n        // Fire multiple concurrent installs\n        const promises = [\n          result.current.install(),\n          result.current.install(),\n          result.current.install()\n        ];\n\n        await Promise.allSettled(promises);\n      });\n\n      // Should handle gracefully\n      expect(installCount).toBeGreaterThanOrEqual(1);\n      expect(result.current.isLoading).toBe(false);\n    });\n  });\n\n  describe('Service Worker Edge Cases', () => {\n    it('should handle service worker registration failures', async () => {\n      const originalServiceWorker = navigator.serviceWorker;\n\n      // Mock service worker registration failure\n      Object.defineProperty(navigator, 'serviceWorker', {\n        value: {\n          register: jest.fn().mockRejectedValue(new Error('Registration failed'))\n        }\n      });\n\n      const { result } = renderHook(() => useServiceWorkerUpdate());\n\n      await act(async () => {\n        await result.current.checkForUpdates();\n      });\n\n      expect(result.current.error).toContain('failed');\n\n      // Restore\n      Object.defineProperty(navigator, 'serviceWorker', { value: originalServiceWorker });\n    });\n\n    it('should handle rapid service worker update checks', async () => {\n      const PWAManager = require('../../../services/pwa-manager').default;\n      const mockPWAManager = PWAManager.getInstance();\n\n      let checkCount = 0;\n      mockPWAManager.checkForUpdates.mockImplementation(() => {\n        checkCount++;\n        return Promise.resolve({ updateAvailable: checkCount % 2 === 0 });\n      });\n\n      const { result } = renderHook(() => useServiceWorkerUpdate());\n\n      await act(async () => {\n        // Fire 50 rapid update checks\n        const promises = Array(50).fill(null).map(() =>\n          result.current.checkForUpdates()\n        );\n\n        await Promise.allSettled(promises);\n      });\n\n      expect(checkCount).toBe(50);\n      expect(result.current.isLoading).toBe(false);\n    });\n  });\n\n  describe('Offline/Online Edge Cases', () => {\n    it('should handle rapid network state changes', async () => {\n      const { result } = renderHook(() => usePWA());\n\n      await act(async () => {\n        // Simulate rapid network changes\n        for (let i = 0; i < 100; i++) {\n          const event = i % 2 === 0 ? new Event('offline') : new Event('online');\n          window.dispatchEvent(event);\n          await new Promise(resolve => setTimeout(resolve, 1));\n        }\n      });\n\n      // Should handle without crashing\n      expect(result.current.isOnline).toBeDefined();\n    });\n\n    it('should handle corrupted cache data', async () => {\n      // Mock corrupted cache\n      const originalCaches = global.caches;\n      Object.defineProperty(global, 'caches', {\n        value: {\n          open: jest.fn().mockRejectedValue(new Error('Cache corrupted')),\n          delete: jest.fn().mockResolvedValue(true)\n        }\n      });\n\n      const { result } = renderHook(() => usePWA());\n\n      await act(async () => {\n        await result.current.clearCache();\n      });\n\n      // Should handle gracefully\n      expect(result.current.error).not.toContain('TypeError');\n\n      // Restore\n      Object.defineProperty(global, 'caches', { value: originalCaches });\n    });\n  });\n\n  describe('Memory and Performance Stress Tests', () => {\n    it('should handle intensive PWA operations without memory leaks', async () => {\n      const { result, unmount } = renderHook(() => usePWA());\n\n      await act(async () => {\n        // Perform many operations\n        for (let i = 0; i < 1000; i++) {\n          result.current.checkSupport();\n          result.current.checkInstallability();\n        }\n      });\n\n      expect(result.current.isLoading).toBe(false);\n      unmount();\n    });\n  });\n\n  describe('Browser Compatibility Edge Cases', () => {\n    it('should handle unsupported browsers gracefully', async () => {\n      // Mock unsupported browser\n      const PWAManager = require('../../../services/pwa-manager').default;\n      const mockPWAManager = PWAManager.getInstance();\n      mockPWAManager.isPWASupported.mockReturnValue(false);\n\n      const { result } = renderHook(() => usePWA());\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 50));\n      });\n\n      expect(result.current.isSupported).toBe(false);\n      expect(result.current.canInstall).toBe(false);\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/__tests__/edge-cases/useSubscription.edge.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 97,
        "column": 29,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 97,
        "endColumn": 72
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\nimport { renderHook, act } from \"@testing-library/react\";\nimport { useSubscription } from \"../../useSubscription\";\nimport SubscriptionService from '../../../services/subscription-service';\n\n// Mock dependencies\njest.mock('../../../services/subscription-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      getSubscription: jest.fn(),\n      createSubscription: jest.fn(),\n      updateSubscription: jest.fn(),\n      cancelSubscription: jest.fn(),\n      getPaymentMethods: jest.fn(),\n      addPaymentMethod: jest.fn(),\n      removePaymentMethod: jest.fn(),\n      setDefaultPaymentMethod: jest.fn(),\n      validatePromoCode: jest.fn(),\n      applyPromoCode: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/stripe-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      createPaymentIntent: jest.fn(),\n      confirmPayment: jest.fn(),\n      createSetupIntent: jest.fn(),\n      updatePaymentMethod: jest.fn(),\n      handle3DSecureAuthentication: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/error-handler', () => ({\n  ErrorHandler: {\n    handleError: jest.fn()\n  }\n}));\n\njest.mock('../../useAnalytics', () => ({\n  useAnalytics: () => ({\n    track: jest.fn(),\n    trackPageView: jest.fn(),\n    trackFeatureUsage: jest.fn()\n  }),\n  ANALYTICS_EVENTS: {\n    SUBSCRIPTION_CREATED: 'subscription_created',\n    SUBSCRIPTION_CANCELLED: 'subscription_cancelled',\n    PAYMENT_FAILED: 'payment_failed'\n  }\n}));\n\ndescribe('useSubscription Edge Cases and Stress Tests', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    localStorage.clear();\n    jest.useFakeTimers();\n  });\n\n  afterEach(() => {\n    jest.runOnlyPendingTimers();\n    jest.useRealTimers();\n  });\n\n  describe('Payment Processing Edge Cases', () => {\n    it('should handle payment failure with retry mechanism', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      let attemptCount = 0;\n      mockSubscriptionService.createSubscription.mockImplementation(() => {\n        attemptCount++;\n        if (attemptCount < 3) {\n          return Promise.reject(new Error('Payment failed'));\n        }\n        return Promise.resolve({\n          id: 'sub-123',\n          status: 'active',\n          tier: 'pro'\n        });\n      });\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        await result.current.createSubscription('pro', 'pm_test_card');\n      });\n\n      expect(attemptCount).toBe(3);\n      expect(result.current.subscription?.status).toBe('active');\n    });\n\n    it('should handle 3D Secure authentication flow', async () => {\n      const StripeService = require('../../../services/stripe-service').default;\n      const mockStripeService = StripeService.getInstance();\n\n      mockStripeService.createPaymentIntent.mockResolvedValue({\n        id: 'pi_test',\n        status: 'requires_action',\n        next_action: {\n          type: 'use_stripe_sdk',\n          use_stripe_sdk: {\n            type: 'three_d_secure_redirect'\n          }\n        }\n      });\n\n      mockStripeService.handle3DSecureAuthentication.mockResolvedValue({\n        id: 'pi_test',\n        status: 'succeeded'\n      });\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        await result.current.processPayment({\n          amount: 999,\n          currency: 'usd',\n          paymentMethodId: 'pm_test_card'\n        });\n      });\n\n      expect(mockStripeService.handle3DSecureAuthentication).toHaveBeenCalled();\n    });\n\n    it('should handle corrupted payment method data', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      // Return corrupted payment methods\n      mockSubscriptionService.getPaymentMethods.mockResolvedValue([\n        { id: null, type: undefined, last4: 'invalid' }, // Invalid data\n        { id: 'pm_valid', type: 'card', last4: '4242' }, // Valid data\n        'invalid-payment-method-format' // Wrong format\n      ]);\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        await result.current.loadPaymentMethods();\n      });\n\n      // Should filter out invalid payment methods\n      const validMethods = result.current.paymentMethods.filter(method =>\n        method && typeof method === 'object' && method.id\n      );\n      expect(validMethods).toHaveLength(1);\n      expect(validMethods[0].id).toBe('pm_valid');\n    });\n  });\n\n  describe('Subscription State Race Conditions', () => {\n    it('should handle concurrent subscription operations', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      let operationCount = 0;\n      mockSubscriptionService.updateSubscription.mockImplementation((id, updates) => {\n        operationCount++;\n        return new Promise(resolve => {\n          setTimeout(() => resolve({\n            id,\n            ...updates,\n            updated_at: new Date().toISOString()\n          }), 100 + Math.random() * 100);\n        });\n      });\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        // Fire multiple concurrent updates\n        const promises = [\n          result.current.updateSubscription('sub-123', { tier: 'pro' }),\n          result.current.updateSubscription('sub-123', { tier: 'basic' }),\n          result.current.updateSubscription('sub-123', { tier: 'pro' })\n        ];\n\n        await Promise.allSettled(promises);\n      });\n\n      expect(operationCount).toBe(3);\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    it('should handle subscription cancellation during upgrade', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      mockSubscriptionService.updateSubscription.mockImplementation(() =>\n        new Promise(resolve => setTimeout(() => resolve({\n          id: 'sub-123',\n          tier: 'pro',\n          status: 'active'\n        }), 200))\n      );\n\n      mockSubscriptionService.cancelSubscription.mockResolvedValue({\n        id: 'sub-123',\n        status: 'cancelled'\n      });\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        // Start upgrade\n        const upgradePromise = result.current.updateSubscription('sub-123', { tier: 'pro' });\n\n        // Cancel before upgrade completes\n        setTimeout(() => {\n          result.current.cancelSubscription('sub-123');\n        }, 50);\n\n        await Promise.allSettled([upgradePromise]);\n      });\n\n      // Should handle conflicting operations gracefully\n      expect(result.current.error).not.toContain('conflict');\n    });\n  });\n\n  describe('Network and API Failures', () => {\n    it('should handle intermittent network failures', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      let failureCount = 0;\n      mockSubscriptionService.getSubscription.mockImplementation(() => {\n        failureCount++;\n        if (failureCount <= 2) {\n          return Promise.reject(new Error('Network timeout'));\n        }\n        return Promise.resolve({\n          id: 'sub-123',\n          status: 'active',\n          tier: 'pro'\n        });\n      });\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        // Should retry automatically\n        await result.current.refreshSubscription();\n      });\n\n      expect(failureCount).toBe(3);\n      expect(result.current.subscription?.status).toBe('active');\n    });\n\n    it('should handle API rate limiting', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      mockSubscriptionService.createSubscription.mockRejectedValue(\n        new Error('Rate limit exceeded')\n      );\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        await result.current.createSubscription('pro', 'pm_test_card');\n      });\n\n      expect(result.current.error).toContain('rate limit');\n\n      // Should provide retry mechanism\n      await act(async () => {\n        jest.advanceTimersByTime(60000); // Advance 1 minute\n        mockSubscriptionService.createSubscription.mockResolvedValue({\n          id: 'sub-123',\n          status: 'active'\n        });\n\n        await result.current.retryLastOperation();\n      });\n\n      expect(result.current.subscription?.status).toBe('active');\n    });\n\n    it('should handle Stripe webhook delays', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      // Initial payment intent creation\n      mockSubscriptionService.createSubscription.mockResolvedValue({\n        id: 'sub-123',\n        status: 'incomplete',\n        payment_intent: {\n          id: 'pi_test',\n          status: 'processing'\n        }\n      });\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        await result.current.createSubscription('pro', 'pm_test_card');\n      });\n\n      expect(result.current.subscription?.status).toBe('incomplete');\n\n      // Simulate webhook processing delay\n      await act(async () => {\n        jest.advanceTimersByTime(30000); // 30 seconds\n\n        // Mock webhook update\n        mockSubscriptionService.getSubscription.mockResolvedValue({\n          id: 'sub-123',\n          status: 'active',\n          tier: 'pro'\n        });\n\n        await result.current.pollSubscriptionStatus('sub-123');\n      });\n\n      expect(result.current.subscription?.status).toBe('active');\n    });\n  });\n\n  describe('Data Corruption and Invalid States', () => {\n    it('should handle corrupted subscription data', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      // Return corrupted subscription data\n      mockSubscriptionService.getSubscription.mockResolvedValue({\n        id: undefined,\n        status: 'invalid_status',\n        tier: null,\n        expires_at: 'invalid-date',\n        metadata: 'not-an-object'\n      });\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        await result.current.refreshSubscription();\n      });\n\n      // Should handle corrupted data gracefully\n      expect(result.current.error).not.toContain('TypeError');\n      expect(result.current.subscription).toBeNull(); // Should fallback to null\n    });\n\n    it('should handle missing required fields', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      // Return subscription missing critical fields\n      mockSubscriptionService.getSubscription.mockResolvedValue({\n        // Missing id, status, tier\n        created_at: '2023-01-01T00:00:00Z'\n      });\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        await result.current.refreshSubscription();\n      });\n\n      // Should validate data structure\n      expect(result.current.subscription).toBeNull();\n    });\n  });\n\n  describe('Memory Leaks and Performance', () => {\n    it('should handle rapid subscription polling without memory leaks', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      let callCount = 0;\n      mockSubscriptionService.getSubscription.mockImplementation(() => {\n        callCount++;\n        return Promise.resolve({\n          id: 'sub-123',\n          status: 'active',\n          tier: 'pro',\n          call_count: callCount\n        });\n      });\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        // Enable aggressive polling\n        result.current.enableAutoRefresh(1000); // 1 second intervals\n\n        // Fast forward through many polling cycles\n        for (let i = 0; i < 100; i++) {\n          jest.advanceTimersByTime(1000);\n          await new Promise(resolve => setTimeout(resolve, 0));\n        }\n\n        result.current.disableAutoRefresh();\n      });\n\n      expect(callCount).toBeGreaterThan(90);\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    it('should cleanup polling on unmount', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      let callCount = 0;\n      mockSubscriptionService.getSubscription.mockImplementation(() => {\n        callCount++;\n        return Promise.resolve({ id: 'sub-123', status: 'active' });\n      });\n\n      const { result, unmount } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        result.current.enableAutoRefresh(500);\n        jest.advanceTimersByTime(1000);\n      });\n\n      const callCountBeforeUnmount = callCount;\n\n      unmount();\n\n      await act(async () => {\n        jest.advanceTimersByTime(2000); // Should not trigger more calls\n      });\n\n      expect(callCount).toBe(callCountBeforeUnmount);\n    });\n  });\n\n  describe('Promo Code Edge Cases', () => {\n    it('should handle expired promo codes', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      mockSubscriptionService.validatePromoCode.mockResolvedValue({\n        valid: false,\n        error: 'expired',\n        expires_at: '2023-01-01T00:00:00Z'\n      });\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        await result.current.validatePromoCode('EXPIRED2023');\n      });\n\n      expect(result.current.promoCodeError).toContain('expired');\n    });\n\n    it('should handle promo code usage limits', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      mockSubscriptionService.applyPromoCode.mockRejectedValue(\n        new Error('Promo code usage limit exceeded')\n      );\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        await result.current.applyPromoCode('LIMITREACHED');\n      });\n\n      expect(result.current.error).toContain('usage limit');\n    });\n\n    it('should handle concurrent promo code applications', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      let applicationCount = 0;\n      mockSubscriptionService.applyPromoCode.mockImplementation(code => {\n        applicationCount++;\n        return Promise.resolve({\n          discount: { percent: 50 },\n          code: code,\n          applied_at: new Date().toISOString()\n        });\n      });\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        // Try to apply multiple codes simultaneously\n        const promises = [\n          result.current.applyPromoCode('FIRST50'),\n          result.current.applyPromoCode('SECOND25'),\n          result.current.applyPromoCode('THIRD10')\n        ];\n\n        await Promise.allSettled(promises);\n      });\n\n      // Should handle gracefully (typically only one would succeed)\n      expect(applicationCount).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Stress Testing', () => {\n    it('should handle high frequency subscription updates', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      let updateCount = 0;\n      mockSubscriptionService.updateSubscription.mockImplementation((id, updates) => {\n        updateCount++;\n        return Promise.resolve({\n          id,\n          ...updates,\n          update_number: updateCount\n        });\n      });\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        // Fire 100 rapid updates\n        const promises = Array(100).fill(null).map((_, index) =>\n          result.current.updateSubscription('sub-123', {\n            metadata: { update: index }\n          })\n        );\n\n        await Promise.allSettled(promises);\n      });\n\n      expect(updateCount).toBe(100);\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    it('should handle large payment method collections', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      // Generate 1000 payment methods\n      const largePaymentMethodCollection = Array(1000).fill(null).map((_, index) => ({\n        id: `pm_${index}`,\n        type: 'card',\n        last4: `${index}`.padStart(4, '0'),\n        exp_month: (index % 12) + 1,\n        exp_year: 2025 + (index % 10)\n      }));\n\n      mockSubscriptionService.getPaymentMethods.mockResolvedValue(\n        largePaymentMethodCollection\n      );\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      const startTime = Date.now();\n      await act(async () => {\n        await result.current.loadPaymentMethods();\n      });\n      const endTime = Date.now();\n\n      // Should handle large collections efficiently\n      expect(endTime - startTime).toBeLessThan(1000); // Less than 1 second\n      expect(result.current.paymentMethods).toHaveLength(1000);\n    });\n  });\n\n  describe('Regression Tests', () => {\n    it('should maintain trial period tracking accuracy', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      const trialEndDate = new Date();\n      trialEndDate.setDate(trialEndDate.getDate() + 7); // 7 days from now\n\n      mockSubscriptionService.getSubscription.mockResolvedValue({\n        id: 'sub-123',\n        status: 'trialing',\n        tier: 'pro',\n        trial_end: trialEndDate.toISOString()\n      });\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        await result.current.refreshSubscription();\n      });\n\n      expect(result.current.subscription?.status).toBe('trialing');\n      expect(result.current.trialDaysRemaining).toBeCloseTo(7, 0);\n    });\n\n    it('should handle subscription renewal edge cases', async () => {\n      const mockSubscriptionService = SubscriptionService.getInstance();\n\n      // Subscription that renews in the next minute\n      const renewalDate = new Date();\n      renewalDate.setMinutes(renewalDate.getMinutes() + 1);\n\n      mockSubscriptionService.getSubscription.mockResolvedValue({\n        id: 'sub-123',\n        status: 'active',\n        tier: 'pro',\n        current_period_end: renewalDate.toISOString()\n      });\n\n      const { result } = renderHook(() => useSubscription('user-123'));\n\n      await act(async () => {\n        await result.current.refreshSubscription();\n\n        // Fast forward past renewal\n        jest.advanceTimersByTime(120000); // 2 minutes\n      });\n\n      // Should handle renewal timing correctly\n      expect(result.current.subscription?.status).toBe('active');\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/__tests__/integration/cross-hook.integration.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 152,
        "column": 29,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 152,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 188,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 188,
        "endColumn": 68
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 337,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 337,
        "endColumn": 84
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 351,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 351,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 377,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 377,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 392,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 392,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 440,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 440,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 465,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 465,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 469,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 469,
        "endColumn": 84
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 491,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 491,
        "endColumn": 84
      }
    ],
    "suppressedMessages": [],
    "errorCount": 10,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\nimport { renderHook, act } from \"@testing-library/react\";\nimport React from \"react\";\nimport { useAuth } from \"../../useAuth\";\nimport { useFeatureGate } from \"../../useFeatureGate\";\nimport { useSubscription } from \"../../useSubscription\";\nimport { AnalyticsProvider } from \"../../../components/AnalyticsProvider\";\nimport { FeatureAccessProvider } from \"../../../contexts/FeatureAccessContext\";\nimport { LanguageProvider } from \"../../../contexts/LanguageContext\";\nimport { StrugglingSamProvider } from \"../../../contexts/StrugglingsamContext\";\nimport SubscriptionService from '../../../services/subscription-service';\n\n// Mock all services\njest.mock('../../../services/supabase-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      signIn: jest.fn(),\n      signOut: jest.fn(),\n      getCurrentUser: jest.fn(),\n      getSession: jest.fn(),\n      onAuthStateChange: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/subscription-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      getSubscription: jest.fn(),\n      getFeatureAccess: jest.fn(),\n      getUserTier: jest.fn(),\n      createSubscription: jest.fn(),\n      cancelSubscription: jest.fn(),\n      updateSubscription: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/stripe-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      createPaymentIntent: jest.fn(),\n      confirmPayment: jest.fn(),\n      createSetupIntent: jest.fn(),\n      updatePaymentMethod: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/alarm-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      getAllAlarms: jest.fn(),\n      createAlarm: jest.fn(),\n      updateAlarm: jest.fn(),\n      deleteAlarm: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/feature-gate-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      trackFeatureAttempt: jest.fn(),\n      grantTemporaryAccess: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/error-handler', () => ({\n  ErrorHandler: {\n    handleError: jest.fn()\n  }\n}));\n\n// Mock analytics hooks\njest.mock('../../useAnalytics', () => ({\n  useAnalytics: () => ({\n    track: jest.fn(),\n    trackPageView: jest.fn(),\n    trackFeatureUsage: jest.fn()\n  }),\n  useEngagementAnalytics: () => ({\n    trackFeatureDiscovery: jest.fn()\n  }),\n  usePerformanceAnalytics: () => ({\n    trackComponentRenderTime: jest.fn()\n  }),\n  ANALYTICS_EVENTS: {\n    SESSION_ENDED: 'session_ended',\n    ERROR_OCCURRED: 'error_occurred',\n    USER_SIGNED_IN: 'user_signed_in',\n    SUBSCRIPTION_CREATED: 'subscription_created',\n    FEATURE_GATE_BYPASSED: 'feature_gate_bypassed'\n  }\n}));\n\n// Mock i18n\njest.mock('react-i18next', () => ({\n  useTranslation: () => ({\n    t: (key: string) => key,\n    i18n: {\n      language: 'en',\n      exists: jest.fn().mockReturnValue(true)\n    }\n  })\n}));\n\njest.mock('@capacitor/device', () => ({\n  Device: {\n    getLanguageCode: jest.fn().mockResolvedValue({ value: 'en' })\n  }\n}));\n\njest.mock('../../../config/i18n', () => ({\n  SUPPORTED_LANGUAGES: {\n    en: { nativeName: 'English', rtl: false },\n    es: { nativeName: 'Espa√±ol', rtl: false }\n  },\n  getCurrentLanguage: () => 'en',\n  getLanguageInfo: () => ({ nativeName: 'English', rtl: false }),\n  isRTL: () => false,\n  formatTime: (time: string) => time,\n  formatRelativeTime: (date: Date) => date.toLocaleDateString(),\n  changeLanguage: jest.fn()\n}));\n\n// Comprehensive test wrapper with all providers\ninterface FullTestWrapperProps {\n  children: React.ReactNode;\n  initialUser?: any;\n  userTier?: 'free' | 'basic' | 'pro';\n  subscription?: any;\n}\n\nconst FullTestWrapper: React.FC<FullTestWrapperProps> = ({\n  children,\n  initialUser = null,\n  userTier = 'free',\n  subscription = null\n}) => {\n  const [user, setUser] = React.useState(initialUser);\n\n  // Mock all service responses\n  React.useEffect(() => {\n    // Mock Supabase Service\n    const SupabaseService = require('../../../services/supabase-service').default;\n    const mockSupabaseService = SupabaseService.getInstance();\n    mockSupabaseService.getCurrentUser.mockResolvedValue(user);\n    mockSupabaseService.getSession.mockResolvedValue(\n      user ? { access_token: 'token', user } : null\n    );\n    mockSupabaseService.onAuthStateChange.mockImplementation((callback) => {\n      setTimeout(() => callback(user ? 'SIGNED_IN' : 'SIGNED_OUT',\n        user ? { access_token: 'token', user } : null), 10);\n      return { data: { subscription: { unsubscribe: jest.fn() } } };\n    });\n\n    // Mock Subscription Service\n    const mockSubscriptionService = SubscriptionService.getInstance();\n    mockSubscriptionService.getSubscription.mockResolvedValue(subscription);\n    mockSubscriptionService.getUserTier.mockResolvedValue(userTier);\n    mockSubscriptionService.getFeatureAccess.mockResolvedValue({\n      features: {\n        advanced_alarms: {\n          hasAccess: userTier !== 'free',\n          usageLimit: userTier === 'basic' ? 10 : null,\n          usageCount: 0,\n          upgradeRequired: userTier === 'free' ? 'basic' : null\n        },\n        premium_themes: {\n          hasAccess: userTier === 'pro',\n          upgradeRequired: userTier !== 'pro' ? 'pro' : null\n        },\n        export_data: {\n          hasAccess: userTier === 'pro',\n          upgradeRequired: userTier !== 'pro' ? 'pro' : null\n        }\n      }\n    });\n\n    // Mock Alarm Service\n    const AlarmService = require('../../../services/alarm-service').default;\n    const mockAlarmService = AlarmService.getInstance();\n    mockAlarmService.getAllAlarms.mockResolvedValue([]);\n  }, [user, userTier, subscription]);\n\n  return (\n    <AnalyticsProvider>\n      <LanguageProvider>\n        <FeatureAccessProvider userId={user?.id || ''}>\n          <StrugglingSamProvider userId={user?.id || ''}>\n            {children}\n          </StrugglingSamProvider>\n        </FeatureAccessProvider>\n      </LanguageProvider>\n    </AnalyticsProvider>\n  );\n};\n\ndescribe('Cross-Hook Integration Tests with Full Provider Stack', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    localStorage.clear();\n  });\n\n  describe('Authentication ‚Üí Feature Access ‚Üí Alarms Flow', () => {\n    it('should cascade authentication state through all providers and hooks', async () => {\n      const mockUser = {\n        id: 'user-123',\n        email: 'test@example.com',\n        user_metadata: { subscription_tier: 'basic' }\n      };\n\n      const { result } = renderHook(\n        () => ({\n          auth: useAuth(),\n          featureGate: useFeatureGate(\"advanced_alarms\"),\n        }),\n        {\n          wrapper: (props) => <FullTestWrapper {...props} initialUser={mockUser} userTier=\"basic\" />\n        }\n      );\n\n      // Wait for all hooks to initialize\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 200));\n      });\n\n      // All hooks should reflect authenticated state\n      expect(result.current.auth.user).toEqual(mockUser);\n      expect(result.current.featureGate.hasAccess).toBe(true);\n      expect(result.current.alarms.canUseAdvancedFeatures).toBe(true);\n    });\n\n    it('should handle authentication changes affecting downstream features', async () => {\n      const { result, rerender } = renderHook(\n        () => ({\n          auth: useAuth(),\n          featureGate: useFeatureGate(\"advanced_alarms\"),\n        }),\n        {\n          wrapper: (props) => <FullTestWrapper {...props} userTier=\"free\" />\n        }\n      );\n\n      // Initially unauthenticated/free user\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(result.current.featureGate.hasAccess).toBe(false);\n\n      // Sign in and upgrade\n      const mockUser = { id: 'user-123', email: 'test@example.com' };\n      rerender();\n\n      // Use new wrapper with authenticated user\n      const { result: newResult } = renderHook(\n        () => ({\n          auth: useAuth(),\n          featureGate: useFeatureGate(\"advanced_alarms\"),\n        }),\n        {\n          wrapper: (props) => <FullTestWrapper {...props} initialUser={mockUser} userTier=\"basic\" />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(newResult.current.auth.user).toEqual(mockUser);\n      expect(newResult.current.featureGate.hasAccess).toBe(true);\n    });\n  });\n\n  describe('Subscription ‚Üí Feature Gates ‚Üí Usage Integration', () => {\n    it('should coordinate subscription status across feature gates and usage tracking', async () => {\n      const mockUser = { id: 'user-123', email: 'test@example.com' };\n      const mockSubscription = {\n        id: 'sub-123',\n        status: 'active',\n        tier: 'pro',\n        features: ['advanced_alarms', 'premium_themes', 'export_data']\n      };\n\n      const { result } = renderHook(\n        () => ({\n          auth: useAuth(),\n          subscription: useSubscription(\"user-123\"),\n          advancedAlarmsGate: useFeatureGate(\"advanced_alarms\"),\n          premiumThemesGate: useFeatureGate(\"premium_themes\"),\n        }),\n        {\n          wrapper: props => (\n            <FullTestWrapper\n              {...props}\n              initialUser={mockUser}\n              userTier=\"pro\"\n              subscription={mockSubscription}\n            />\n          )\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 200));\n      });\n\n      // All pro features should be accessible\n      expect(result.current.subscription.tier).toBe('pro');\n      expect(result.current.advancedAlarmsGate.hasAccess).toBe(true);\n      expect(result.current.premiumThemesGate.hasAccess).toBe(true);\n      expect(result.current.alarms.canUseConditionalRules).toBe(true);\n    });\n\n    it('should handle subscription cancellation affecting all gated features', async () => {\n      const mockUser = { id: 'user-123', email: 'test@example.com' };\n\n      const { result } = renderHook(\n        () => ({\n          subscription: useSubscription(\"user-123\"),\n          featureGate: useFeatureGate(\"premium_themes\"),\n        }),\n        {\n          wrapper: (props) => <FullTestWrapper {...props} initialUser={mockUser} userTier=\"pro\" />\n        }\n      );\n\n      // Mock subscription service to simulate cancellation\n      const SubscriptionService = require('../../../services/subscription-service').default;\n      const mockSubscriptionService = SubscriptionService.getInstance();\n      mockSubscriptionService.cancelSubscription.mockResolvedValue({\n        id: 'sub-123',\n        status: 'canceled'\n      });\n\n      await act(async () => {\n        await result.current.subscription.cancelSubscription('sub-123');\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // Should track cancellation through analytics\n      const mockTrack = jest.fn();\n      const useAnalytics = require('../../useAnalytics').useAnalytics;\n      useAnalytics.mockReturnValue({\n        track: mockTrack,\n        trackPageView: jest.fn(),\n        trackFeatureUsage: jest.fn()\n      });\n\n      expect(mockTrack).toHaveBeenCalled();\n    });\n  });\n\n  describe('Language ‚Üí Analytics ‚Üí Feature Access Integration', () => {\n    it('should coordinate language settings across all providers and hooks', async () => {\n      const mockUser = { id: 'user-123', email: 'test@example.com' };\n\n      const { result } = renderHook(\n        () => ({\n          auth: useAuth(),\n          featureGate: useFeatureGate(\"advanced_alarms\"),\n        }),\n        {\n          wrapper: (props) => <FullTestWrapper {...props} initialUser={mockUser} userTier=\"basic\" />\n        }\n      );\n\n      // Mock language change\n      const i18nConfig = require('../../../config/i18n');\n      i18nConfig.getCurrentLanguage.mockReturnValue('es');\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // All hooks should be aware of language context\n      expect(result.current.auth.isLoading).toBeDefined();\n      expect(result.current.featureGate.hasAccess).toBeDefined();\n      expect(result.current.alarms.isLoading).toBeDefined();\n    });\n\n    it('should track multilingual feature usage through analytics', async () => {\n      const mockTrack = jest.fn();\n      const useAnalytics = require('../../useAnalytics').useAnalytics;\n      useAnalytics.mockReturnValue({\n        track: mockTrack,\n        trackPageView: jest.fn(),\n        trackFeatureUsage: jest.fn()\n      });\n\n      const mockUser = { id: 'user-123', email: 'test@example.com' };\n\n      const { result } = renderHook(\n        () => ({\n          featureGate: useFeatureGate(\"advanced_alarms\"),\n        }),\n        {\n          wrapper: (props) => <FullTestWrapper {...props} initialUser={mockUser} userTier=\"basic\" />\n        }\n      );\n\n      await act(async () => {\n        await result.current.featureGate.requestAccess();\n        await new Promise(resolve => setTimeout(resolve, 50));\n      });\n\n      expect(mockTrack).toHaveBeenCalledWith(\n        expect.any(String),\n        expect.objectContaining({\n          metadata: expect.objectContaining({\n            user_language: expect.any(String)\n          })\n        })\n      );\n    });\n  });\n\n  describe('Achievement ‚Üí Streak ‚Üí Analytics Integration', () => {\n    it('should coordinate achievements across alarm usage and streak tracking', async () => {\n      const mockUser = { id: 'user-123', email: 'test@example.com' };\n\n      const { result } = renderHook(\n        () => ({\n          auth: useAuth(),\n        }),\n        {\n          wrapper: (props) => <FullTestWrapper {...props} initialUser={mockUser} userTier=\"basic\" />\n        }\n      );\n\n      // Mock successful alarm creation\n      const AlarmService = require('../../../services/alarm-service').default;\n      const mockAlarmService = AlarmService.getInstance();\n      mockAlarmService.createAlarm.mockResolvedValue({\n        id: 'alarm-123',\n        name: 'Test Alarm',\n        time: '07:00'\n      });\n\n      await act(async () => {\n        await result.current.alarms.createAlarm({\n          name: 'Test Alarm',\n          time: '07:00',\n          enabled: true,\n          repeatDays: []\n        });\n      });\n\n      // Should track achievement through StrugglingSam context\n      expect(result.current.alarms.error).toBeNull();\n    });\n  });\n\n  describe('Error Propagation Across Provider Chain', () => {\n    it('should handle cascading errors across all providers gracefully', async () => {\n      const mockHandleError = jest.fn();\n      const ErrorHandler = require('../../../services/error-handler').ErrorHandler;\n      ErrorHandler.handleError = mockHandleError;\n\n      // Mock service failures\n      const SubscriptionService = require('../../../services/subscription-service').default;\n      const mockSubscriptionService = SubscriptionService.getInstance();\n      mockSubscriptionService.getFeatureAccess.mockRejectedValue(new Error('Service unavailable'));\n\n      const { result } = renderHook(\n        () => ({\n          featureGate: useFeatureGate(\"advanced_alarms\"),\n        }),\n        { wrapper: FullTestWrapper }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // Hooks should handle provider errors gracefully\n      expect(result.current.featureGate.hasAccess).toBe(false);\n      expect(result.current.alarms.error).toBeNull(); // Should not propagate provider errors\n    });\n\n    it('should maintain hook functionality despite provider chain failures', async () => {\n      // Mock multiple provider failures\n      const SubscriptionService = require('../../../services/subscription-service').default;\n      const mockSubscriptionService = SubscriptionService.getInstance();\n      mockSubscriptionService.getUserTier.mockRejectedValue(new Error('Network error'));\n\n      const { result } = renderHook(\n        () => ({\n          auth: useAuth(),\n          featureGate: useFeatureGate('advanced_alarms')\n        }),\n        { wrapper: FullTestWrapper }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // Hooks should still be functional with fallback behavior\n      expect(result.current.auth.isLoading).toBe(false);\n      expect(result.current.featureGate.isLoading).toBe(false);\n    });\n  });\n\n  describe('Performance with Full Provider Stack', () => {\n    it('should maintain acceptable performance with all providers and hooks', async () => {\n      const mockUser = { id: 'user-123', email: 'test@example.com' };\n      const startTime = Date.now();\n\n      const { result } = renderHook(\n        () => ({\n          auth: useAuth(),\n          subscription: useSubscription(\"user-123\"),\n          featureGate: useFeatureGate(\"advanced_alarms\"),\n        }),\n        {\n          wrapper: (props) => <FullTestWrapper {...props} initialUser={mockUser} userTier=\"basic\" />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 200));\n      });\n\n      const endTime = Date.now();\n      const duration = endTime - startTime;\n\n      // Should initialize within reasonable time even with full stack\n      expect(duration).toBeLessThan(500);\n\n      // All hooks should be ready\n      expect(result.current.auth.isLoading).toBe(false);\n      expect(result.current.subscription.isLoading).toBe(false);\n      expect(result.current.featureGate.isLoading).toBe(false);\n      expect(result.current.alarms.isLoading).toBe(false);\n    });\n  });\n\n  describe('State Synchronization Across Hooks', () => {\n    it('should maintain consistent state across all hooks when user data changes', async () => {\n      const mockUser = { id: 'user-123', email: 'test@example.com' };\n\n      const { result } = renderHook(\n        () => ({\n          auth: useAuth(),\n          featureGate: useFeatureGate(\"advanced_alarms\"),\n          subscription: useSubscription(\"user-123\"),\n        }),\n        {\n          wrapper: (props) => <FullTestWrapper {...props} initialUser={mockUser} userTier=\"basic\" />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 200));\n      });\n\n      // All hooks should reflect the same user context\n      expect(result.current.auth.user?.id).toBe('user-123');\n      expect(result.current.featureGate.hasAccess).toBe(true); // Basic user has access\n      expect(result.current.alarms.canUseAdvancedFeatures).toBe(true);\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/__tests__/integration/useAdvancedAlarms.integration.test.tsx",
    "messages": [
      {
        "ruleId": null,
        "nodeType": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Expression expected.",
        "line": 187,
        "column": 6
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\nimport { renderHook, act } from \"@testing-library/react\";\nimport React from \"react\";\nimport { AnalyticsProvider } from \"../../../components/AnalyticsProvider\";\nimport { FeatureAccessProvider } from \"../../../contexts/FeatureAccessContext\";\nimport { LanguageProvider } from \"../../../contexts/LanguageContext\";\nimport { StrugglingSamProvider } from \"../../../contexts/StrugglingsamContext\";\n\n// Mock dependencies\njest.mock('../../../services/alarm-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      getAllAlarms: jest.fn(),\n      createAlarm: jest.fn(),\n      updateAlarm: jest.fn(),\n      deleteAlarm: jest.fn(),\n      duplicateAlarm: jest.fn(),\n      exportAlarms: jest.fn(),\n      importAlarms: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/advanced-alarm-scheduler', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      scheduleAlarm: jest.fn(),\n      cancelAlarm: jest.fn(),\n      updateScheduledAlarm: jest.fn(),\n      getNextOccurrence: jest.fn(),\n      optimizeSchedule: jest.fn(),\n      handleLocationTrigger: jest.fn(),\n      checkConditionalRules: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/error-handler', () => ({\n  ErrorHandler: {\n    handleError: jest.fn()\n  }\n}));\n\n// Mock other services\njest.mock('../../../services/subscription-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      getFeatureAccess: jest.fn(),\n      getUserTier: jest.fn()\n    })\n  }\n}));\n\n// Mock analytics hooks\njest.mock('../../useAnalytics', () => ({\n  useAnalytics: () => ({\n    track: jest.fn(),\n    trackPageView: jest.fn(),\n    trackFeatureUsage: jest.fn()\n  }),\n  useEngagementAnalytics: () => ({\n    trackFeatureDiscovery: jest.fn()\n  }),\n  usePerformanceAnalytics: () => ({\n    trackComponentRenderTime: jest.fn()\n  }),\n  ANALYTICS_EVENTS: {\n    SESSION_ENDED: 'session_ended',\n    ERROR_OCCURRED: 'error_occurred',\n    ALARM_CREATED: 'alarm_created',\n    ALARM_UPDATED: 'alarm_updated'\n  }\n}));\n\n// Mock geolocation\nconst mockGeolocation = {\n  getCurrentPosition: jest.fn(),\n  watchPosition: jest.fn(),\n  clearWatch: jest.fn()\n};\n\nObject.defineProperty(global.navigator, 'geolocation', {\n  value: mockGeolocation,\n  writable: true\n});\n\n// Mock i18n\njest.mock('react-i18next', () => ({\n  useTranslation: () => ({\n    t: (key: string) => key,\n    i18n: {\n      language: 'en',\n      exists: jest.fn().mockReturnValue(true)\n    }\n  })\n}));\n\njest.mock('@capacitor/device', () => ({\n  Device: {\n    getLanguageCode: jest.fn().mockResolvedValue({ value: 'en' })\n  }\n}));\n\njest.mock('../../../config/i18n', () => ({\n  SUPPORTED_LANGUAGES: {\n    en: { nativeName: 'English', rtl: false },\n    es: { nativeName: 'Espa√±ol', rtl: false }\n  },\n  getCurrentLanguage: () => 'en',\n  getLanguageInfo: () => ({ nativeName: 'English', rtl: false }),\n  isRTL: () => false,\n  formatTime: (time: string) => time,\n  formatRelativeTime: (date: Date) => date.toLocaleDateString(),\n  changeLanguage: jest.fn()\n}));\n\n// Test wrapper with all necessary providers\ninterface TestWrapperProps {\n  children: React.ReactNode;\n  userId?: string;\n  userTier?: 'free' | 'basic' | 'pro';\n  mockAlarms?: any[];\n}\n\nconst TestWrapper: React.FC<TestWrapperProps> = ({\n  children,\n  userId = 'test-user-123',\n  userTier = 'basic',\n  mockAlarms = []\n}) => {\n  // Mock service responses\n  React.useEffect(() => {\n    const AlarmService = require('../../../services/alarm-service').default;\n    const mockAlarmService = AlarmService.getInstance();\n    mockAlarmService.getAllAlarms.mockResolvedValue(mockAlarms);\n\n    const SubscriptionService = require('../../../services/subscription-service').default;\n    const mockSubscriptionService = SubscriptionService.getInstance();\n    mockSubscriptionService.getUserTier.mockResolvedValue(userTier);\n    mockSubscriptionService.getFeatureAccess.mockResolvedValue({\n      features: {\n        advanced_alarms: {\n          hasAccess: userTier !== 'free',\n          usageLimit: userTier === 'basic' ? 10 : null,\n          usageCount: mockAlarms.length,\n          upgradeRequired: userTier === 'free' ? 'basic' : null\n        },\n        conditional_rules: {\n          hasAccess: userTier === 'pro',\n          upgradeRequired: userTier !== 'pro' ? 'pro' : null\n        },\n        location_triggers: {\n          hasAccess: userTier === 'pro',\n          upgradeRequired: userTier !== 'pro' ? 'pro' : null\n        }\n      }\n    });\n\n      // Service is now imported at the top\n    mockScheduler.scheduleAlarm.mockResolvedValue({ success: true });\n    mockScheduler.getNextOccurrence.mockReturnValue(new Date(Date.now() + 24 * 60 * 60 * 1000));\n  }, [mockAlarms, userTier]);\n\n  return (\n    <AnalyticsProvider>\n      <LanguageProvider>\n        <FeatureAccessProvider userId={userId}>\n          <StrugglingSamProvider userId={userId}>{children}</StrugglingSamProvider>\n        </FeatureAccessProvider>\n      </LanguageProvider>\n    </AnalyticsProvider>\n  );\n};\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    localStorage.clear();\n    mockGeolocation.getCurrentPosition.mockClear();\n  });\n\n  describe(\"Feature Access Integration\", () => {\n    it(\"should respect feature gates from FeatureAccessProvider\", async () => {\n        wrapper: (props) => <TestWrapper {...props} userTier=\"free\" />,\n      });\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // Free users should have limited functionality\n      expect(result.current.canUseAdvancedFeatures).toBe(false);\n    });\n\n    it(\"should enable advanced features for pro users through provider integration\", async () => {\n        wrapper: (props) => <TestWrapper {...props} userTier=\"pro\" />,\n      });\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(result.current.canUseAdvancedFeatures).toBe(true);\n      expect(result.current.canUseConditionalRules).toBe(true);\n      expect(result.current.canUseLocationTriggers).toBe(true);\n    });\n\n    it('should enforce usage limits through FeatureAccessProvider', async () => {\n      const mockAlarms = Array(9).fill(null).map((_, i) => ({\n        id: `alarm-${i}`,\n        name: `Alarm ${i}`,\n        time: '07:00',\n        enabled: true\n      }));\n\n        wrapper: (props) => (\n          <TestWrapper {...props} userTier=\"basic\" mockAlarms={mockAlarms} />\n        ),\n      });\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(result.current.usageInfo).toEqual({\n        used: 9,\n        limit: 10,\n        remaining: 1\n      });\n    });\n\n    it('should block feature creation when limits exceeded', async () => {\n      const mockAlarms = Array(10).fill(null).map((_, i) => ({\n        id: `alarm-${i}`,\n        name: `Alarm ${i}`,\n        time: '07:00',\n        enabled: true\n      }));\n\n        wrapper: (props) => (\n          <TestWrapper {...props} userTier=\"basic\" mockAlarms={mockAlarms} />\n        ),\n      });\n\n      await act(async () => {\n        await result.current.createAlarm({\n          name: 'Test Alarm',\n          time: '08:00',\n          enabled: true,\n          repeatDays: []\n        });\n      });\n\n      expect(result.current.error).toContain('limit');\n    });\n  });\n\n  describe('Analytics Integration', () => {\n    it('should track alarm creation through AnalyticsProvider', async () => {\n      const mockTrack = jest.fn();\n      const useAnalytics = require('../../useAnalytics').useAnalytics;\n      useAnalytics.mockReturnValue({\n        track: mockTrack,\n        trackPageView: jest.fn(),\n        trackFeatureUsage: jest.fn()\n      });\n\n        wrapper: (props) => <TestWrapper {...props} userTier=\"pro\" />,\n      });\n\n      const AlarmService = require('../../../services/alarm-service').default;\n      const mockAlarmService = AlarmService.getInstance();\n      mockAlarmService.createAlarm.mockResolvedValue({\n        id: 'new-alarm-123',\n        name: 'Test Alarm',\n        time: '08:00'\n      });\n\n      await act(async () => {\n        await result.current.createAlarm({\n          name: 'Test Alarm',\n          time: '08:00',\n          enabled: true,\n          repeatDays: []\n        });\n      });\n\n      expect(mockTrack).toHaveBeenCalledWith(\n        'alarm_created',\n        expect.objectContaining({\n          metadata: expect.objectContaining({\n            alarm_id: 'new-alarm-123',\n            has_advanced_features: true\n          })\n        })\n      );\n    });\n\n    it('should track performance metrics for alarm operations', async () => {\n      const mockTrackPerformance = jest.fn();\n      const useAnalytics = require('../../useAnalytics').useAnalytics;\n      useAnalytics.mockReturnValue({\n        track: jest.fn(),\n        trackPageView: jest.fn(),\n        trackFeatureUsage: jest.fn(),\n        trackPerformance: mockTrackPerformance\n      });\n\n        wrapper: TestWrapper,\n      });\n\n      await act(async () => {\n        await result.current.refreshAlarms();\n      });\n\n      expect(mockTrackPerformance).toHaveBeenCalledWith(\n        'alarm_load_duration',\n        expect.any(Number),\n        'alarm_management'\n      );\n    });\n  });\n\n  describe('Language Provider Integration', () => {\n    it('should format alarm times according to language settings', async () => {\n      const mockFormatTime = jest.fn((time) => `Formatted: ${time}`);\n      const i18nConfig = require('../../../config/i18n');\n      i18nConfig.formatTime = mockFormatTime;\n\n      const mockAlarms = [{\n        id: 'alarm-1',\n        name: 'Morning Alarm',\n        time: '07:30',\n        enabled: true\n      }];\n\n        wrapper: (props) => <TestWrapper {...props} mockAlarms={mockAlarms} />,\n      });\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(mockFormatTime).toHaveBeenCalledWith('07:30', 'en');\n    });\n\n    it('should handle RTL layouts for alarm scheduling interface', async () => {\n      const i18nConfig = require('../../../config/i18n');\n      i18nConfig.isRTL.mockReturnValue(true);\n      i18nConfig.getCurrentLanguage.mockReturnValue('ar');\n\n        wrapper: TestWrapper,\n      });\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // Hook should be aware of RTL context\n      expect(result.current.isLoading).toBeDefined();\n    });\n  });\n\n  describe('Struggling Sam Context Integration', () => {\n    it('should trigger achievements through StrugglingSamProvider', async () => {\n      const mockUnlockAchievement = jest.fn();\n\n      const TestWrapperWithAchievements: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n        const [achievements, setAchievements] = React.useState<any[]>([]);\n\n        const contextValue = {\n          achievements,\n          unlockAchievement: mockUnlockAchievement,\n          updateStreak: jest.fn(),\n          shareAchievement: jest.fn(),\n          joinChallenge: jest.fn(),\n          leaveChallenge: jest.fn(),\n          showUpgradePrompt: jest.fn(),\n          dismissUpgradePrompt: jest.fn(),\n          celebrateMilestone: jest.fn(),\n          dismissCelebration: jest.fn(),\n          loadUserData: jest.fn(),\n          refreshCommunityStats: jest.fn(),\n          currentTests: [],\n          userAssignments: [],\n          isFeatureEnabled: jest.fn(),\n          getFeatureVariant: jest.fn(),\n          trackConversion: jest.fn(),\n          trackEngagement: jest.fn(),\n          userStreak: null,\n          activeChallenges: [],\n          upgradePrompts: [],\n          pendingCelebrations: [],\n          communityStats: null,\n          socialProofData: [],\n          currentTestGroup: null,\n          userABTest: null,\n          loading: false,\n          error: null\n        };\n\n        return (\n          <AnalyticsProvider>\n            <LanguageProvider>\n              <FeatureAccessProvider userId=\"test-user-123\">\n                <StrugglingSamProvider userId=\"test-user-123\">\n                  {children}\n                </StrugglingSamProvider>\n              </FeatureAccessProvider>\n            </LanguageProvider>\n          </AnalyticsProvider>\n        );\n      };\n\n        wrapper: TestWrapperWithAchievements,\n      });\n\n      const AlarmService = require('../../../services/alarm-service').default;\n      const mockAlarmService = AlarmService.getInstance();\n      mockAlarmService.createAlarm.mockResolvedValue({\n        id: 'alarm-5',\n        name: 'Fifth Alarm'\n      });\n\n      // Create multiple alarms to trigger achievement\n      for (let i = 0; i < 5; i++) {\n        await act(async () => {\n          await result.current.createAlarm({\n            name: `Alarm ${i}`,\n            time: '07:00',\n            enabled: true,\n            repeatDays: []\n          });\n        });\n      }\n\n      // Should trigger achievement for creating multiple alarms\n      expect(mockUnlockAchievement).toHaveBeenCalledWith(\n        expect.objectContaining({\n          achievementType: 'alarm_master',\n          title: expect.stringContaining('Alarm')\n        })\n      );\n    });\n\n    it('should update streak information when alarm is completed', async () => {\n      const mockUpdateStreak = jest.fn();\n\n      // Mock StrugglingSamProvider with streak tracking\n      const useStrugglingSam = jest.fn().mockReturnValue({\n        updateStreak: mockUpdateStreak,\n        userStreak: {\n          currentStreak: 3,\n          longestStreak: 5\n        }\n      });\n\n        wrapper: TestWrapper,\n      });\n\n      await act(async () => {\n        // Simulate alarm completion triggering streak update\n        result.current.handleAlarmCompleted('alarm-123');\n      });\n\n      // Should integrate with streak tracking\n      expect(result.current.isLoading).toBeDefined();\n    });\n  });\n\n  describe('Location Triggers Integration', () => {\n    it('should integrate geolocation with feature access controls', async () => {\n      mockGeolocation.getCurrentPosition.mockImplementation((success) => {\n        success({\n          coords: {\n            latitude: 37.7749,\n            longitude: -122.4194,\n            accuracy: 10\n          }\n        });\n      });\n\n        wrapper: (props) => <TestWrapper {...props} userTier=\"pro\" />,\n      });\n\n      await act(async () => {\n        await result.current.createAlarm({\n          name: 'Location Alarm',\n          time: '08:00',\n          enabled: true,\n          repeatDays: [],\n          locationTrigger: {\n            latitude: 37.7749,\n            longitude: -122.4194,\n            radius: 100\n          }\n        });\n      });\n\n      expect(mockGeolocation.getCurrentPosition).toHaveBeenCalled();\n    });\n\n    it(\"should deny location features for non-pro users\", async () => {\n        wrapper: (props) => <TestWrapper {...props} userTier=\"basic\" />,\n      });\n\n      await act(async () => {\n        await result.current.createAlarm({\n          name: 'Location Alarm',\n          time: '08:00',\n          enabled: true,\n          repeatDays: [],\n          locationTrigger: {\n            latitude: 37.7749,\n            longitude: -122.4194,\n            radius: 100\n          }\n        });\n      });\n\n      expect(result.current.error).toContain('Pro subscription required');\n    });\n  });\n\n  describe('Cross-Provider Error Handling', () => {\n    it('should handle errors gracefully across all providers', async () => {\n      const mockHandleError = jest.fn();\n      const ErrorHandler = require('../../../services/error-handler').ErrorHandler;\n      ErrorHandler.handleError = mockHandleError;\n\n      // Mock service error\n      const AlarmService = require('../../../services/alarm-service').default;\n      const mockAlarmService = AlarmService.getInstance();\n      mockAlarmService.createAlarm.mockRejectedValue(new Error('Database error'));\n\n        wrapper: TestWrapper,\n      });\n\n      await act(async () => {\n        await result.current.createAlarm({\n          name: 'Test Alarm',\n          time: '07:00',\n          enabled: true,\n          repeatDays: []\n        });\n      });\n\n      expect(mockHandleError).toHaveBeenCalledWith(\n        expect.any(Error),\n        expect.stringContaining('Failed to create alarm'),\n        expect.objectContaining({\n        }),\n      );\n    });\n  });\n\n  describe('Performance with Multiple Providers', () => {\n    it('should maintain performance with full provider stack', async () => {\n      const startTime = Date.now();\n\n        wrapper: TestWrapper,\n      });\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      const endTime = Date.now();\n      const duration = endTime - startTime;\n\n      // Should initialize quickly even with multiple providers\n      expect(duration).toBeLessThan(200);\n      expect(result.current.isLoading).toBe(false);\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/__tests__/integration/useAuth.integration.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 113,
        "column": 29,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 113,
        "endColumn": 74
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 143,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 143,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 163,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 163,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 187,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 187,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 206,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 206,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 226,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 226,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 238,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 238,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 317,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 317,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 346,
        "column": 30,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 346,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 357,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 357,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 371,
        "column": 34,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 371,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 374,
        "column": 21,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 374,
        "endColumn": 52
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 393,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 393,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 411,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 411,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 488,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 488,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 496,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 496,
        "endColumn": 76
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 515,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 515,
        "endColumn": 84
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 536,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 536,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 549,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 549,
        "endColumn": 76
      }
    ],
    "suppressedMessages": [],
    "errorCount": 19,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\nimport { renderHook, act } from \"@testing-library/react\";\nimport React from \"react\";\nimport { useAuth } from \"../../useAuth\";\nimport { AnalyticsProvider } from \"../../../components/AnalyticsProvider\";\nimport { FeatureAccessProvider } from \"../../../contexts/FeatureAccessContext\";\nimport { LanguageProvider } from \"../../../contexts/LanguageContext\";\n\n// Mock dependencies\njest.mock('../../../services/supabase-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      signIn: jest.fn(),\n      signUp: jest.fn(),\n      signOut: jest.fn(),\n      resetPassword: jest.fn(),\n      updateProfile: jest.fn(),\n      getCurrentUser: jest.fn(),\n      getSession: jest.fn(),\n      onAuthStateChange: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/security-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      generateCSRFToken: jest.fn(),\n      validateCSRFToken: jest.fn(),\n      isRateLimited: jest.fn(),\n      resetRateLimit: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/error-handler', () => ({\n  ErrorHandler: {\n    handleError: jest.fn()\n  }\n}));\n\n// Mock analytics hooks\njest.mock('../../useAnalytics', () => ({\n  useAnalytics: () => ({\n    track: jest.fn(),\n    trackPageView: jest.fn(),\n    trackFeatureUsage: jest.fn()\n  }),\n  useEngagementAnalytics: () => ({\n    trackFeatureDiscovery: jest.fn()\n  }),\n  usePerformanceAnalytics: () => ({\n    trackComponentRenderTime: jest.fn()\n  }),\n  ANALYTICS_EVENTS: {\n    SESSION_ENDED: 'session_ended',\n    ERROR_OCCURRED: 'error_occurred',\n    USER_SIGNED_IN: 'user_signed_in',\n    USER_SIGNED_OUT: 'user_signed_out'\n  }\n}));\n\n// Mock i18n\njest.mock('react-i18next', () => ({\n  useTranslation: () => ({\n    t: (key: string) => key,\n    i18n: {\n      language: 'en',\n      exists: jest.fn().mockReturnValue(true)\n    }\n  })\n}));\n\n// Mock Capacitor Device\njest.mock('@capacitor/device', () => ({\n  Device: {\n    getLanguageCode: jest.fn().mockResolvedValue({ value: 'en' })\n  }\n}));\n\n// Mock i18n config\njest.mock('../../../config/i18n', () => ({\n  SUPPORTED_LANGUAGES: {\n    en: { nativeName: 'English', rtl: false },\n    es: { nativeName: 'Espa√±ol', rtl: false }\n  },\n  getCurrentLanguage: () => 'en',\n  getLanguageInfo: () => ({ nativeName: 'English', rtl: false }),\n  isRTL: () => false,\n  formatTime: (time: string) => time,\n  formatRelativeTime: (date: Date) => date.toLocaleDateString(),\n  changeLanguage: jest.fn()\n}));\n\n// Test wrapper with multiple providers\ninterface TestWrapperProps {\n  children: React.ReactNode;\n  userId?: string;\n  mockUser?: any;\n  mockSession?: any;\n}\n\nconst TestWrapper: React.FC<TestWrapperProps> = ({\n  children,\n  userId = 'test-user-123',\n  mockUser = null,\n  mockSession = null\n}) => {\n  // Mock Supabase service responses\n  React.useEffect(() => {\n    const SupabaseService = require('../../../services/supabase-service').default;\n    const mockService = SupabaseService.getInstance();\n\n    mockService.getCurrentUser.mockResolvedValue(mockUser);\n    mockService.getSession.mockResolvedValue(mockSession);\n    mockService.onAuthStateChange.mockImplementation(callback => {\n      // Simulate initial auth state\n      setTimeout(() => callback('SIGNED_IN', mockSession), 10);\n      return { data: { subscription: { unsubscribe: jest.fn() } } };\n    });\n  }, [mockUser, mockSession]);\n\n  return (\n    <AnalyticsProvider>\n      <LanguageProvider>\n        <FeatureAccessProvider userId={userId}>{children}</FeatureAccessProvider>\n      </LanguageProvider>\n    </AnalyticsProvider>\n  );\n};\n\ndescribe('useAuth Integration Tests with Multiple Providers', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    localStorage.clear();\n  });\n\n  describe('Analytics Integration', () => {\n    it('should track authentication events through AnalyticsProvider', async () => {\n      const mockTrack = jest.fn();\n      const useAnalytics = require('../../useAnalytics').useAnalytics;\n      useAnalytics.mockReturnValue({\n        track: mockTrack,\n        trackPageView: jest.fn(),\n        trackFeatureUsage: jest.fn()\n      });\n\n      const mockUser = {\n        id: 'user-123',\n        email: 'test@example.com',\n        user_metadata: { name: 'Test User' }\n      };\n\n      const { result } = renderHook(\n        () => useAuth(),\n        {\n          wrapper: (props) => <TestWrapper {...props} mockUser={mockUser} />\n        }\n      );\n\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n      mockService.signIn.mockResolvedValue({\n        user: mockUser,\n        session: { access_token: 'token' }\n      });\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'password');\n      });\n\n      expect(mockTrack).toHaveBeenCalledWith(\n        'user_signed_in',\n        expect.objectContaining({\n          metadata: expect.objectContaining({\n            user_id: 'user-123',\n            method: 'email'\n          })\n        })\n      );\n    });\n\n    it('should track sign out events with analytics context', async () => {\n      const mockTrack = jest.fn();\n      const useAnalytics = require('../../useAnalytics').useAnalytics;\n      useAnalytics.mockReturnValue({\n        track: mockTrack,\n        trackPageView: jest.fn(),\n        trackFeatureUsage: jest.fn()\n      });\n\n      const mockUser = {\n        id: 'user-123',\n        email: 'test@example.com'\n      };\n\n      const { result } = renderHook(\n        () => useAuth(),\n        {\n          wrapper: (props) => <TestWrapper {...props} mockUser={mockUser} />\n        }\n      );\n\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n      mockService.signOut.mockResolvedValue({ error: null });\n\n      await act(async () => {\n        await result.current.signOut();\n      });\n\n      expect(mockTrack).toHaveBeenCalledWith(\n        'user_signed_out',\n        expect.objectContaining({\n          metadata: expect.objectContaining({\n            user_id: 'user-123'\n          })\n        })\n      );\n    });\n\n    it('should track authentication errors through analytics', async () => {\n      const mockTrack = jest.fn();\n      const useAnalytics = require('../../useAnalytics').useAnalytics;\n      useAnalytics.mockReturnValue({\n        track: mockTrack,\n        trackPageView: jest.fn(),\n        trackFeatureUsage: jest.fn()\n      });\n\n      const { result } = renderHook(\n        () => useAuth(),\n        { wrapper: TestWrapper }\n      );\n\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n      mockService.signIn.mockRejectedValue(new Error('Invalid credentials'));\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'wrongpassword');\n      });\n\n      expect(mockTrack).toHaveBeenCalledWith(\n        'auth_error',\n        expect.objectContaining({\n          metadata: expect.objectContaining({\n            error_type: 'sign_in_failed',\n            error_message: 'Invalid credentials'\n          })\n        })\n      );\n    });\n  });\n\n  describe('FeatureAccessProvider Integration', () => {\n    it('should trigger feature access reload on authentication state change', async () => {\n      const mockUser = {\n        id: 'user-123',\n        email: 'test@example.com'\n      };\n\n      const mockRefreshFeatureAccess = jest.fn();\n\n      // Mock the FeatureAccessProvider to spy on refresh calls\n      const TestWrapperWithSpy: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n        const [refreshCount, setRefreshCount] = React.useState(0);\n\n        React.useEffect(() => {\n          // Simulate refresh on auth change\n          if (mockUser) {\n            mockRefreshFeatureAccess();\n            setRefreshCount(c => c + 1);\n          }\n        }, []);\n\n        return (\n          <AnalyticsProvider>\n            <LanguageProvider>\n              <FeatureAccessProvider userId={mockUser?.id || ''}>\n                {children}\n              </FeatureAccessProvider>\n            </LanguageProvider>\n          </AnalyticsProvider>\n        );\n      };\n\n      const { result } = renderHook(\n        () => useAuth(),\n        {\n          wrapper: TestWrapperWithSpy\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(mockRefreshFeatureAccess).toHaveBeenCalled();\n    });\n\n    it('should clear feature access on sign out', async () => {\n      const mockUser = {\n        id: 'user-123',\n        email: 'test@example.com'\n      };\n\n      const { result } = renderHook(\n        () => useAuth(),\n        {\n          wrapper: (props) => <TestWrapper {...props} mockUser={mockUser} />\n        }\n      );\n\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n\n      // Simulate sign out clearing the user\n      mockService.signOut.mockResolvedValue({ error: null });\n      mockService.onAuthStateChange.mockImplementation((callback) => {\n        setTimeout(() => callback('SIGNED_OUT', null), 10);\n        return { data: { subscription: { unsubscribe: jest.fn() } } };\n      });\n\n      await act(async () => {\n        await result.current.signOut();\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(result.current.user).toBeNull();\n    });\n  });\n\n  describe('Language Provider Integration', () => {\n    it('should work with language context for localized error messages', async () => {\n      const mockT = jest.fn((key) => {\n        const translations: Record<string, string> = {\n          'auth.error.invalid_credentials': 'Credenciales inv√°lidas',\n          'auth.error.rate_limited': 'Demasiados intentos'\n        };\n        return translations[key] || key;\n      });\n\n      const useTranslation = require('react-i18next').useTranslation;\n      useTranslation.mockReturnValue({\n        t: mockT,\n        i18n: { language: 'es', exists: jest.fn().mockReturnValue(true) }\n      });\n\n      const { result } = renderHook(\n        () => useAuth(),\n        { wrapper: TestWrapper }\n      );\n\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n      mockService.signIn.mockRejectedValue(new Error('Invalid credentials'));\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'wrongpassword');\n      });\n\n      // Should use localized error messages\n      expect(mockT).toHaveBeenCalledWith('auth.error.invalid_credentials');\n    });\n\n    it('should respect RTL layout preferences from language context', async () => {\n      // Mock RTL language\n      const getCurrentLanguage = require('../../../config/i18n').getCurrentLanguage;\n      getCurrentLanguage.mockReturnValue('ar');\n\n      const isRTL = require('../../../config/i18n').isRTL;\n      isRTL.mockReturnValue(true);\n\n      const { result } = renderHook(\n        () => useAuth(),\n        { wrapper: TestWrapper }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 50));\n      });\n\n      // Hook should be aware of RTL context through provider chain\n      expect(result.current.isLoading).toBeDefined();\n    });\n  });\n\n  describe('Rate Limiting with Provider Integration', () => {\n    it('should coordinate rate limiting across provider context', async () => {\n      const SecurityService = require('../../../services/security-service').default;\n      const mockSecurityService = SecurityService.getInstance();\n      mockSecurityService.isRateLimited.mockReturnValue(true);\n\n      const { result } = renderHook(\n        () => useAuth(),\n        { wrapper: TestWrapper }\n      );\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'password');\n      });\n\n      expect(result.current.rateLimitInfo.isLimited).toBe(true);\n      expect(result.current.error).toContain('rate limit');\n    });\n\n    it('should reset rate limits through integrated context', async () => {\n      const SecurityService = require('../../../services/security-service').default;\n      const mockSecurityService = SecurityService.getInstance();\n\n      // Start rate limited\n      mockSecurityService.isRateLimited.mockReturnValue(true);\n\n      const { result } = renderHook(\n        () => useAuth(),\n        { wrapper: TestWrapper }\n      );\n\n      // Reset rate limit\n      mockSecurityService.isRateLimited.mockReturnValue(false);\n      mockSecurityService.resetRateLimit.mockResolvedValue(undefined);\n\n      await act(async () => {\n        await result.current.resetRateLimit();\n      });\n\n      expect(result.current.rateLimitInfo.isLimited).toBe(false);\n    });\n  });\n\n  describe('Session Management Integration', () => {\n    it('should coordinate session state across all providers', async () => {\n      const mockUser = {\n        id: 'user-123',\n        email: 'test@example.com'\n      };\n\n      const mockSession = {\n        access_token: 'token-123',\n        expires_at: Date.now() + 3600000, // 1 hour\n        user: mockUser\n      };\n\n      const { result } = renderHook(\n        () => useAuth(),\n        {\n          wrapper: (props) => <TestWrapper {...props} mockUser={mockUser} mockSession={mockSession} />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(result.current.user).toEqual(mockUser);\n      expect(result.current.session).toEqual(mockSession);\n    });\n\n    it('should handle session timeout across provider chain', async () => {\n      const mockExpiredSession = {\n        access_token: 'expired-token',\n        expires_at: Date.now() - 1000, // Expired\n        user: { id: 'user-123' }\n      };\n\n      const { result } = renderHook(\n        () => useAuth(),\n        {\n          wrapper: (props) => <TestWrapper {...props} mockSession={mockExpiredSession} />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // Should detect session timeout\n      expect(result.current.sessionTimeoutWarning).toBe(true);\n    });\n  });\n\n  describe('Error Handling Across Providers', () => {\n    it('should propagate errors through provider chain properly', async () => {\n      const mockHandleError = jest.fn();\n      const ErrorHandler = require('../../../services/error-handler').ErrorHandler;\n      ErrorHandler.handleError = mockHandleError;\n\n      const { result } = renderHook(\n        () => useAuth(),\n        { wrapper: TestWrapper }\n      );\n\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n      mockService.signIn.mockRejectedValue(new Error('Network error'));\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'password');\n      });\n\n      expect(mockHandleError).toHaveBeenCalledWith(\n        expect.any(Error),\n        expect.stringContaining('Authentication failed'),\n        expect.objectContaining({\n          context: expect.stringContaining('useAuth')\n        })\n      );\n    });\n\n    it('should handle provider initialization errors gracefully', async () => {\n      // Mock FeatureAccessProvider error\n      const SubscriptionService = require('../../../services/subscription-service').default;\n      const mockService = SubscriptionService.getInstance();\n      mockService.getFeatureAccess.mockRejectedValue(new Error('Service down'));\n\n      const { result } = renderHook(\n        () => useAuth(),\n        { wrapper: TestWrapper }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // Auth hook should still work despite provider errors\n      expect(result.current.isLoading).toBe(false);\n    });\n  });\n\n  describe('Performance Integration', () => {\n    it('should track performance metrics through provider chain', async () => {\n      const mockTrackPerformance = jest.fn();\n      const useAnalytics = require('../../useAnalytics').useAnalytics;\n      useAnalytics.mockReturnValue({\n        track: jest.fn(),\n        trackPageView: jest.fn(),\n        trackFeatureUsage: jest.fn(),\n        trackPerformance: mockTrackPerformance\n      });\n\n      const { result } = renderHook(\n        () => useAuth(),\n        { wrapper: TestWrapper }\n      );\n\n      const SupabaseService = require('../../../services/supabase-service').default;\n      const mockService = SupabaseService.getInstance();\n\n      // Add delay to measure performance\n      mockService.signIn.mockImplementation(() =>\n        new Promise(resolve =>\n          setTimeout(() => resolve({\n            user: { id: 'user-123' },\n            session: { access_token: 'token' }\n          }), 100)\n        )\n      );\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'password');\n      });\n\n      // Should track auth performance through analytics provider\n      expect(mockTrackPerformance).toHaveBeenCalledWith(\n        'auth_sign_in_duration',\n        expect.any(Number),\n        'authentication'\n      );\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/__tests__/integration/useFeatureGate.integration.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 70,
        "column": 33,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 70,
        "endColumn": 82
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 132,
        "column": 34,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 132,
        "endColumn": 83
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 277,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 277,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 376,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 376,
        "endColumn": 84
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 398,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 398,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 402,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 402,
        "endColumn": 84
      }
    ],
    "suppressedMessages": [],
    "errorCount": 6,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\nimport { renderHook, act } from \"@testing-library/react\";\nimport React from \"react\";\nimport { useFeatureGate } from \"../../useFeatureGate\";\nimport { FeatureAccessProvider } from \"../../../contexts/FeatureAccessContext\";\nimport { AnalyticsProvider } from \"../../../components/AnalyticsProvider\";\n\n// Mock dependencies\njest.mock('../../../services/subscription-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      getFeatureAccess: jest.fn(),\n      getUserTier: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/feature-gate-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      trackFeatureAttempt: jest.fn(),\n      grantTemporaryAccess: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/error-handler', () => ({\n  ErrorHandler: {\n    handleError: jest.fn()\n  }\n}));\n\n// Mock analytics hooks\njest.mock('../../useAnalytics', () => ({\n  useAnalytics: () => ({\n    track: jest.fn(),\n    trackPageView: jest.fn(),\n    trackFeatureUsage: jest.fn()\n  }),\n  useEngagementAnalytics: () => ({\n    trackFeatureDiscovery: jest.fn()\n  }),\n  usePerformanceAnalytics: () => ({\n    trackComponentRenderTime: jest.fn()\n  }),\n  ANALYTICS_EVENTS: {\n    SESSION_ENDED: 'session_ended',\n    ERROR_OCCURRED: 'error_occurred'\n  }\n}));\n\n// Test wrapper combining multiple providers\ninterface TestWrapperProps {\n  children: React.ReactNode;\n  userId?: string;\n  featureAccess?: any;\n  userTier?: 'free' | 'basic' | 'pro';\n}\n\nconst TestWrapper: React.FC<TestWrapperProps> = ({\n  children,\n  userId = 'test-user-123',\n  featureAccess = null,\n  userTier = 'free'\n}) => {\n  // Mock subscription service responses\n  React.useEffect(() => {\n    const SubscriptionService = require('../../../services/subscription-service').default;\n    const mockService = SubscriptionService.getInstance();\n\n    mockService.getFeatureAccess.mockResolvedValue(featureAccess || {\n      features: {\n        advanced_alarms: {\n          hasAccess: userTier !== 'free',\n          usageLimit: userTier === 'basic' ? 5 : null,\n          usageCount: 0,\n          upgradeRequired: userTier === 'free' ? 'basic' : null\n        },\n        premium_themes: {\n          hasAccess: userTier === 'pro',\n          upgradeRequired: userTier !== 'pro' ? 'pro' : null\n        },\n        export_data: {\n          hasAccess: userTier === 'pro',\n          upgradeRequired: userTier !== 'pro' ? 'pro' : null\n        }\n      }\n    });\n\n    mockService.getUserTier.mockResolvedValue(userTier);\n  }, [featureAccess, userTier]);\n\n  return (\n    <AnalyticsProvider>\n      <FeatureAccessProvider userId={userId}>\n        {children}\n      </FeatureAccessProvider>\n    </AnalyticsProvider>\n  );\n};\n\ndescribe('useFeatureGate Integration Tests with FeatureAccessProvider', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    localStorage.clear();\n  });\n\n  describe('Free Tier User Integration', () => {\n    it('should integrate with FeatureAccessProvider for blocked features', async () => {\n      const { result } = renderHook(\n        () => useFeatureGate('advanced_alarms'),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"free\" />\n        }\n      );\n\n      // Wait for provider to initialize\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(result.current.hasAccess).toBe(false);\n      expect(result.current.requiredTier).toBe('basic');\n      expect(result.current.isLoading).toBe(false);\n    });\n\n    it('should track feature attempts through context providers', async () => {\n      const mockTrackFeatureAttempt = jest.fn();\n\n      const FeatureGateService = require('../../../services/feature-gate-service').default;\n      FeatureGateService.getInstance().trackFeatureAttempt = mockTrackFeatureAttempt;\n\n      const { result } = renderHook(\n        () => useFeatureGate('premium_themes'),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"free\" />\n        }\n      );\n\n      await act(async () => {\n        result.current.requestAccess();\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(mockTrackFeatureAttempt).toHaveBeenCalledWith(\n        'test-user-123',\n        'premium_themes',\n        false,\n        expect.any(Object)\n      );\n    });\n\n    it('should trigger upgrade callbacks through FeatureAccessProvider', async () => {\n      const mockOnUpgradeRequired = jest.fn();\n\n      const CustomWrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => (\n        <AnalyticsProvider>\n          <FeatureAccessProvider\n            userId=\"test-user-123\"\n            onUpgradeRequired={mockOnUpgradeRequired}\n          >\n            {children}\n          </FeatureAccessProvider>\n        </AnalyticsProvider>\n      );\n\n      const { result } = renderHook(\n        () => useFeatureGate('premium_themes'),\n        { wrapper: CustomWrapper }\n      );\n\n      await act(async () => {\n        result.current.requestAccess();\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(mockOnUpgradeRequired).toHaveBeenCalledWith('premium_themes', 'pro');\n    });\n  });\n\n  describe('Basic Tier User Integration', () => {\n    it('should provide limited access with usage tracking', async () => {\n      const { result } = renderHook(\n        () => useFeatureGate('advanced_alarms'),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"basic\" />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(result.current.hasAccess).toBe(true);\n      expect(result.current.usage).toEqual({\n        used: 0,\n        limit: 5,\n        remaining: 5\n      });\n    });\n\n    it('should handle usage limits through integrated providers', async () => {\n      const customFeatureAccess = {\n        features: {\n          advanced_alarms: {\n            hasAccess: true,\n            usageLimit: 5,\n            usageCount: 4, // Near limit\n            upgradeRequired: null\n          }\n        }\n      };\n\n      const { result } = renderHook(\n        () => useFeatureGate('advanced_alarms'),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"basic\" featureAccess={customFeatureAccess} />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(result.current.hasAccess).toBe(true);\n      expect(result.current.usage).toEqual({\n        used: 4,\n        limit: 5,\n        remaining: 1\n      });\n    });\n  });\n\n  describe('Pro Tier User Integration', () => {\n    it('should provide unlimited access through provider integration', async () => {\n      const { result } = renderHook(\n        () => useFeatureGate('export_data'),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"pro\" />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(result.current.hasAccess).toBe(true);\n      expect(result.current.requiredTier).toBeNull();\n      expect(result.current.usage).toBeNull(); // No usage limits for pro\n    });\n\n    it('should bypass soft gates with pro tier privileges', async () => {\n      const { result } = renderHook(\n        () => useFeatureGate('premium_themes', { softGate: true }),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"pro\" />\n        }\n      );\n\n      await act(async () => {\n        result.current.bypassGate('Pro tier automatic bypass');\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(result.current.hasAccess).toBe(true);\n      expect(result.current.isBypassed).toBe(false); // Pro users don't need bypasses\n    });\n  });\n\n  describe('Analytics Integration', () => {\n    it('should integrate analytics tracking through AnalyticsProvider', async () => {\n      const mockTrack = jest.fn();\n\n      // Mock the analytics hook to spy on calls\n      const useAnalytics = require('../../useAnalytics').useAnalytics;\n      useAnalytics.mockReturnValue({\n        track: mockTrack,\n        trackPageView: jest.fn(),\n        trackFeatureUsage: jest.fn()\n      });\n\n      const { result } = renderHook(\n        () => useFeatureGate('advanced_alarms'),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"free\" />\n        }\n      );\n\n      await act(async () => {\n        result.current.requestAccess();\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // Verify analytics integration through provider chain\n      expect(mockTrack).toHaveBeenCalled();\n    });\n  });\n\n  describe('Provider State Updates', () => {\n    it('should react to FeatureAccessProvider state changes', async () => {\n      const { result, rerender } = renderHook(\n        () => useFeatureGate('advanced_alarms'),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"free\" />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(result.current.hasAccess).toBe(false);\n\n      // Simulate tier upgrade through provider\n      rerender();\n\n      const { result: resultAfterUpgrade } = renderHook(\n        () => useFeatureGate('advanced_alarms'),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"basic\" />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(resultAfterUpgrade.current.hasAccess).toBe(true);\n    });\n\n    it('should handle provider refresh and re-sync', async () => {\n      const mockRefreshFeatureAccess = jest.fn();\n\n      const CustomProviderWrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => {\n        const [refreshTrigger, setRefreshTrigger] = React.useState(0);\n\n        React.useEffect(() => {\n          // Simulate provider refresh\n          const timer = setTimeout(() => setRefreshTrigger(1), 50);\n          return () => clearTimeout(timer);\n        }, []);\n\n        return (\n          <AnalyticsProvider>\n            <FeatureAccessProvider\n              userId=\"test-user-123\"\n              autoRefresh={true}\n              refreshInterval={100}\n            >\n              {children}\n            </FeatureAccessProvider>\n          </AnalyticsProvider>\n        );\n      };\n\n      const { result } = renderHook(\n        () => useFeatureGate('advanced_alarms'),\n        { wrapper: CustomProviderWrapper }\n      );\n\n      // Wait for initial load and refresh\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 200));\n      });\n\n      // Hook should be responsive to provider updates\n      expect(result.current.isLoading).toBe(false);\n    });\n  });\n\n  describe('Error Handling Integration', () => {\n    it('should handle FeatureAccessProvider errors gracefully', async () => {\n      // Mock service to throw error\n      const SubscriptionService = require('../../../services/subscription-service').default;\n      const mockService = SubscriptionService.getInstance();\n      mockService.getFeatureAccess.mockRejectedValue(new Error('Network error'));\n\n      const { result } = renderHook(\n        () => useFeatureGate('advanced_alarms'),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"free\" />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // Hook should handle provider errors gracefully\n      expect(result.current.hasAccess).toBe(false);\n      expect(result.current.error).toBeNull(); // Hook should not expose provider errors\n    });\n\n    it('should integrate error reporting through providers', async () => {\n      const mockHandleError = jest.fn();\n      const ErrorHandler = require('../../../services/error-handler').ErrorHandler;\n      ErrorHandler.handleError = mockHandleError;\n\n      // Force provider error\n      const SubscriptionService = require('../../../services/subscription-service').default;\n      const mockService = SubscriptionService.getInstance();\n      mockService.getUserTier.mockRejectedValue(new Error('Service unavailable'));\n\n      renderHook(\n        () => useFeatureGate('advanced_alarms'),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"free\" />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(mockHandleError).toHaveBeenCalledWith(\n        expect.any(Error),\n        expect.stringContaining('Failed to load feature access data'),\n        expect.objectContaining({\n          context: 'FeatureAccessProvider'\n        })\n      );\n    });\n  });\n\n  describe('Multi-Provider Integration', () => {\n    it('should work with multiple providers in the chain', async () => {\n      const MultiProviderWrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => (\n        <AnalyticsProvider>\n          <FeatureAccessProvider userId=\"test-user-123\">\n            {children}\n          </FeatureAccessProvider>\n        </AnalyticsProvider>\n      );\n\n      const { result } = renderHook(\n        () => {\n          const featureGate = useFeatureGate('advanced_alarms');\n          return {\n            featureGate,\n            // Could test other context-dependent hooks here\n          };\n        },\n        { wrapper: MultiProviderWrapper }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(result.current.featureGate.hasAccess).toBeDefined();\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/__tests__/integration/usePWA.integration.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 147,
        "column": 24,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 147,
        "endColumn": 64
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 152,
        "column": 33,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 152,
        "endColumn": 82
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 221,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 221,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 233,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 233,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 262,
        "column": 30,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 262,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 282,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 282,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 302,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 302,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 314,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 314,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 334,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 334,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 342,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 342,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 361,
        "column": 30,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 361,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 405,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 405,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 422,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 422,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 478,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 478,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 493,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 493,
        "endColumn": 66
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 535,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 535,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 589,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 589,
        "endColumn": 57
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 621,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 621,
        "endColumn": 70
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 629,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 629,
        "endColumn": 66
      }
    ],
    "suppressedMessages": [],
    "errorCount": 19,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\n/// <reference lib=\"dom\" />\nimport { renderHook, act } from \"@testing-library/react\";\nimport React from \"react\";\nimport {\n  usePWA,\n  useInstallPrompt,\n  useServiceWorkerUpdate,\n  usePushNotifications,\n} from \"../../usePWA\";\nimport { AnalyticsProvider } from \"../../../components/AnalyticsProvider\";\nimport { FeatureAccessProvider } from \"../../../contexts/FeatureAccessContext\";\nimport { LanguageProvider } from \"../../../contexts/LanguageContext\";\n\n// Mock PWA Manager Service\njest.mock('../../../services/pwa-manager', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      isPWASupported: jest.fn().mockReturnValue(true),\n      isInstalled: jest.fn().mockReturnValue(false),\n      isStandalone: jest.fn().mockReturnValue(false),\n      canInstall: jest.fn().mockReturnValue(true),\n      install: jest.fn(),\n      checkForUpdates: jest.fn(),\n      updateServiceWorker: jest.fn(),\n      subscribeToPushNotifications: jest.fn(),\n      unsubscribeFromPushNotifications: jest.fn(),\n      requestNotificationPermission: jest.fn(),\n      on: jest.fn(),\n      off: jest.fn(),\n      emit: jest.fn()\n    })\n  }\n}));\n\n// Mock service worker\nconst mockServiceWorker = {\n  register: jest.fn(),\n  getRegistration: jest.fn(),\n  addEventListener: jest.fn(),\n  removeEventListener: jest.fn()\n};\n\nObject.defineProperty(global.navigator, 'serviceWorker', {\n  value: mockServiceWorker,\n  writable: true\n});\n\n// Mock push notifications\nObject.defineProperty(global.Notification, 'permission', {\n  value: 'default',\n  writable: true\n});\n\nObject.defineProperty(global.Notification, 'requestPermission', {\n  value: jest.fn().mockResolvedValue('granted'),\n  writable: true\n});\n\n// Mock analytics hooks\njest.mock('../../useAnalytics', () => ({\n  useAnalytics: () => ({\n    track: jest.fn(),\n    trackPageView: jest.fn(),\n    trackFeatureUsage: jest.fn()\n  }),\n  useEngagementAnalytics: () => ({\n    trackFeatureDiscovery: jest.fn()\n  }),\n  usePerformanceAnalytics: () => ({\n    trackComponentRenderTime: jest.fn()\n  }),\n  ANALYTICS_EVENTS: {\n    SESSION_ENDED: 'session_ended',\n    ERROR_OCCURRED: 'error_occurred',\n    PWA_INSTALLED: 'pwa_installed',\n    SERVICE_WORKER_UPDATED: 'service_worker_updated'\n  }\n}));\n\n// Mock i18n\njest.mock('react-i18next', () => ({\n  useTranslation: () => ({\n    t: (key: string) => key,\n    i18n: {\n      language: 'en',\n      exists: jest.fn().mockReturnValue(true)\n    }\n  })\n}));\n\njest.mock('@capacitor/device', () => ({\n  Device: {\n    getLanguageCode: jest.fn().mockResolvedValue({ value: 'en' })\n  }\n}));\n\njest.mock('../../../config/i18n', () => ({\n  SUPPORTED_LANGUAGES: {\n    en: { nativeName: 'English', rtl: false },\n    es: { nativeName: 'Espa√±ol', rtl: false }\n  },\n  getCurrentLanguage: () => 'en',\n  getLanguageInfo: () => ({ nativeName: 'English', rtl: false }),\n  isRTL: () => false,\n  formatTime: (time: string) => time,\n  formatRelativeTime: (date: Date) => date.toLocaleDateString(),\n  changeLanguage: jest.fn()\n}));\n\n// Mock subscription service\njest.mock('../../../services/subscription-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: () => ({\n      getFeatureAccess: jest.fn(),\n      getUserTier: jest.fn()\n    })\n  }\n}));\n\njest.mock('../../../services/error-handler', () => ({\n  ErrorHandler: {\n    handleError: jest.fn()\n  }\n}));\n\n// Test wrapper with multiple providers\ninterface TestWrapperProps {\n  children: React.ReactNode;\n  userId?: string;\n  userTier?: 'free' | 'basic' | 'pro';\n  pwaSupported?: boolean;\n  isInstalled?: boolean;\n}\n\nconst TestWrapper: React.FC<TestWrapperProps> = ({\n  children,\n  userId = 'test-user-123',\n  userTier = 'basic',\n  pwaSupported = true,\n  isInstalled = false\n}) => {\n  // Mock service responses\n  React.useEffect(() => {\n    const PWAManager = require('../../../services/pwa-manager').default;\n    const mockPWAManager = PWAManager.getInstance();\n    mockPWAManager.isPWASupported.mockReturnValue(pwaSupported);\n    mockPWAManager.isInstalled.mockReturnValue(isInstalled);\n\n    const SubscriptionService = require('../../../services/subscription-service').default;\n    const mockSubscriptionService = SubscriptionService.getInstance();\n    mockSubscriptionService.getUserTier.mockResolvedValue(userTier);\n    mockSubscriptionService.getFeatureAccess.mockResolvedValue({\n      features: {\n        pwa_notifications: {\n          hasAccess: userTier !== 'free',\n          upgradeRequired: userTier === 'free' ? 'basic' : null\n        },\n        background_sync: {\n          hasAccess: userTier === 'pro',\n          upgradeRequired: userTier !== 'pro' ? 'pro' : null\n        },\n        offline_mode: {\n          hasAccess: true\n        }\n      }\n    });\n  }, [pwaSupported, isInstalled, userTier]);\n\n  return (\n    <AnalyticsProvider>\n      <LanguageProvider>\n        <FeatureAccessProvider userId={userId}>{children}</FeatureAccessProvider>\n      </LanguageProvider>\n    </AnalyticsProvider>\n  );\n};\n\ndescribe('PWA Hooks Integration Tests with Multiple Providers', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n    localStorage.clear();\n  });\n\n  describe('usePWA with FeatureAccessProvider Integration', () => {\n    it('should respect PWA feature access controls', async () => {\n      const { result } = renderHook(\n        () => usePWA(),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"free\" />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(result.current.capabilities.pushNotifications).toBe(false);\n    });\n\n    it('should enable advanced PWA features for pro users', async () => {\n      const { result } = renderHook(\n        () => usePWA(),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"pro\" />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(result.current.capabilities.backgroundSync).toBe(true);\n      expect(result.current.capabilities.pushNotifications).toBe(true);\n    });\n\n    it('should track PWA events through AnalyticsProvider', async () => {\n      const mockTrack = jest.fn();\n      const useAnalytics = require('../../useAnalytics').useAnalytics;\n      useAnalytics.mockReturnValue({\n        track: mockTrack,\n        trackPageView: jest.fn(),\n        trackFeatureUsage: jest.fn()\n      });\n\n      const { result } = renderHook(\n        () => usePWA(),\n        { wrapper: TestWrapper }\n      );\n\n      const PWAManager = require('../../../services/pwa-manager').default;\n      const mockPWAManager = PWAManager.getInstance();\n      mockPWAManager.install.mockResolvedValue(true);\n\n      await act(async () => {\n        await result.current.install();\n      });\n\n      expect(mockTrack).toHaveBeenCalledWith(\n        'pwa_installed',\n        expect.objectContaining({\n          metadata: expect.objectContaining({\n            installation_source: 'user_action'\n          })\n        })\n      );\n    });\n  });\n\n  describe('useInstallPrompt with Language Integration', () => {\n    it('should show localized install prompts', async () => {\n      const mockT = jest.fn((key) => {\n        const translations: Record<string, string> = {\n          'pwa.install.title': 'Instalar Aplicaci√≥n',\n          'pwa.install.message': 'Instalar Relife para mejor experiencia'\n        };\n        return translations[key] || key;\n      });\n\n      const useTranslation = require('react-i18next').useTranslation;\n      useTranslation.mockReturnValue({\n        t: mockT,\n        i18n: { language: 'es', exists: jest.fn().mockReturnValue(true) }\n      });\n\n      const { result } = renderHook(\n        () => useInstallPrompt(),\n        { wrapper: TestWrapper }\n      );\n\n      await act(async () => {\n        result.current.showPrompt();\n      });\n\n      expect(mockT).toHaveBeenCalledWith('pwa.install.title');\n      expect(mockT).toHaveBeenCalledWith('pwa.install.message');\n    });\n\n    it('should handle RTL layouts for install UI', async () => {\n      const i18nConfig = require('../../../config/i18n');\n      i18nConfig.isRTL.mockReturnValue(true);\n      i18nConfig.getCurrentLanguage.mockReturnValue('ar');\n\n      const { result } = renderHook(\n        () => useInstallPrompt(),\n        { wrapper: TestWrapper }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 50));\n      });\n\n      expect(result.current.canInstall).toBeDefined();\n    });\n  });\n\n  describe('useServiceWorkerUpdate with Analytics Integration', () => {\n    it('should track service worker updates through analytics', async () => {\n      const mockTrack = jest.fn();\n      const useAnalytics = require('../../useAnalytics').useAnalytics;\n      useAnalytics.mockReturnValue({\n        track: mockTrack,\n        trackPageView: jest.fn(),\n        trackFeatureUsage: jest.fn()\n      });\n\n      const { result } = renderHook(\n        () => useServiceWorkerUpdate(),\n        { wrapper: TestWrapper }\n      );\n\n      const PWAManager = require('../../../services/pwa-manager').default;\n      const mockPWAManager = PWAManager.getInstance();\n      mockPWAManager.updateServiceWorker.mockResolvedValue(true);\n\n      await act(async () => {\n        await result.current.updateServiceWorker();\n      });\n\n      expect(mockTrack).toHaveBeenCalledWith(\n        'service_worker_updated',\n        expect.objectContaining({\n          metadata: expect.objectContaining({\n            update_source: 'manual'\n          })\n        })\n      );\n    });\n\n    it('should handle update errors with error reporting integration', async () => {\n      const mockHandleError = jest.fn();\n      const ErrorHandler = require('../../../services/error-handler').ErrorHandler;\n      ErrorHandler.handleError = mockHandleError;\n\n      const { result } = renderHook(\n        () => useServiceWorkerUpdate(),\n        { wrapper: TestWrapper }\n      );\n\n      const PWAManager = require('../../../services/pwa-manager').default;\n      const mockPWAManager = PWAManager.getInstance();\n      mockPWAManager.updateServiceWorker.mockRejectedValue(new Error('Update failed'));\n\n      await act(async () => {\n        await result.current.updateServiceWorker();\n      });\n\n      expect(mockHandleError).toHaveBeenCalledWith(\n        expect.any(Error),\n        expect.stringContaining('Service worker update failed'),\n        expect.objectContaining({\n          context: 'useServiceWorkerUpdate'\n        })\n      );\n    });\n\n    it('should show update notifications in user language', async () => {\n      const mockT = jest.fn((key) => key);\n      const useTranslation = require('react-i18next').useTranslation;\n      useTranslation.mockReturnValue({\n        t: mockT,\n        i18n: { language: 'fr', exists: jest.fn().mockReturnValue(true) }\n      });\n\n      const { result } = renderHook(\n        () => useServiceWorkerUpdate(),\n        { wrapper: TestWrapper }\n      );\n\n      await act(async () => {\n        // Simulate update available\n        result.current.showUpdateNotification();\n      });\n\n      expect(mockT).toHaveBeenCalledWith(expect.stringContaining('update'));\n    });\n  });\n\n  describe('usePushNotifications with Feature Gates', () => {\n    it('should enforce notification permissions through feature access', async () => {\n      const { result } = renderHook(\n        () => usePushNotifications(),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"free\" />\n        }\n      );\n\n      await act(async () => {\n        await result.current.subscribe();\n      });\n\n      expect(result.current.error).toContain('subscription required');\n    });\n\n    it('should enable push notifications for subscribed users', async () => {\n      const { result } = renderHook(\n        () => usePushNotifications(),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"basic\" />\n        }\n      );\n\n      const PWAManager = require('../../../services/pwa-manager').default;\n      const mockPWAManager = PWAManager.getInstance();\n      mockPWAManager.subscribeToPushNotifications.mockResolvedValue({\n        endpoint: 'https://example.com/push',\n        keys: { p256dh: 'key', auth: 'auth' }\n      });\n\n      await act(async () => {\n        await result.current.subscribe();\n      });\n\n      expect(result.current.subscription).toBeTruthy();\n      expect(result.current.isSubscribed).toBe(true);\n    });\n\n    it('should track notification permission requests', async () => {\n      const mockTrack = jest.fn();\n      const useAnalytics = require('../../useAnalytics').useAnalytics;\n      useAnalytics.mockReturnValue({\n        track: mockTrack,\n        trackPageView: jest.fn(),\n        trackFeatureUsage: jest.fn()\n      });\n\n      const { result } = renderHook(\n        () => usePushNotifications(),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"basic\" />\n        }\n      );\n\n      await act(async () => {\n        await result.current.requestPermission();\n      });\n\n      expect(mockTrack).toHaveBeenCalledWith(\n        'push_permission_requested',\n        expect.objectContaining({\n          metadata: expect.objectContaining({\n            permission_status: expect.any(String)\n          })\n        })\n      );\n    });\n  });\n\n  describe('Multi-Provider PWA State Management', () => {\n    it('should coordinate PWA state across all providers', async () => {\n      const { result } = renderHook(\n        () => ({\n          pwa: usePWA(),\n          install: useInstallPrompt(),\n          updates: useServiceWorkerUpdate(),\n          notifications: usePushNotifications()\n        }),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"pro\" />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      // All PWA hooks should be initialized consistently\n      expect(result.current.pwa.isSupported).toBe(true);\n      expect(result.current.install.canInstall).toBeDefined();\n      expect(result.current.updates.isUpdateAvailable).toBeDefined();\n      expect(result.current.notifications.permission).toBeDefined();\n    });\n\n    it('should handle PWA installation flow with provider integration', async () => {\n      const mockTrack = jest.fn();\n      const useAnalytics = require('../../useAnalytics').useAnalytics;\n      useAnalytics.mockReturnValue({\n        track: mockTrack,\n        trackPageView: jest.fn(),\n        trackFeatureUsage: jest.fn()\n      });\n\n      const { result } = renderHook(\n        () => ({\n          pwa: usePWA(),\n          install: useInstallPrompt()\n        }),\n        { wrapper: TestWrapper }\n      );\n\n      const PWAManager = require('../../../services/pwa-manager').default;\n      const mockPWAManager = PWAManager.getInstance();\n      mockPWAManager.install.mockResolvedValue(true);\n\n      await act(async () => {\n        await result.current.install.install();\n      });\n\n      // Should update PWA state and track analytics\n      expect(mockTrack).toHaveBeenCalledWith(\n        expect.stringContaining('pwa_install'),\n        expect.any(Object)\n      );\n    });\n  });\n\n  describe('Offline/Online State Integration', () => {\n    it('should coordinate offline state with feature access', async () => {\n      const { result } = renderHook(\n        () => usePWA(),\n        { wrapper: TestWrapper }\n      );\n\n      // Simulate going offline\n      await act(async () => {\n        window.dispatchEvent(new Event('offline'));\n        await new Promise(resolve => setTimeout(resolve, 50));\n      });\n\n      expect(result.current.isOnline).toBe(false);\n\n      // Simulate going back online\n      await act(async () => {\n        window.dispatchEvent(new Event('online'));\n        await new Promise(resolve => setTimeout(resolve, 50));\n      });\n\n      expect(result.current.isOnline).toBe(true);\n    });\n\n    it('should track connectivity changes through analytics', async () => {\n      const mockTrack = jest.fn();\n      const useAnalytics = require('../../useAnalytics').useAnalytics;\n      useAnalytics.mockReturnValue({\n        track: mockTrack,\n        trackPageView: jest.fn(),\n        trackFeatureUsage: jest.fn()\n      });\n\n      renderHook(\n        () => usePWA(),\n        { wrapper: TestWrapper }\n      );\n\n      await act(async () => {\n        window.dispatchEvent(new Event('offline'));\n        await new Promise(resolve => setTimeout(resolve, 50));\n      });\n\n      expect(mockTrack).toHaveBeenCalledWith(\n        'connection_changed',\n        expect.objectContaining({\n          metadata: expect.objectContaining({\n            connection_status: 'offline'\n          })\n        })\n      );\n    });\n  });\n\n  describe('Background Sync with Feature Gates', () => {\n    it('should enable background sync only for pro users', async () => {\n      const { result: basicResult } = renderHook(\n        () => usePWA(),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"basic\" />\n        }\n      );\n\n      const { result: proResult } = renderHook(\n        () => usePWA(),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"pro\" />\n        }\n      );\n\n      await act(async () => {\n        await new Promise(resolve => setTimeout(resolve, 100));\n      });\n\n      expect(basicResult.current.capabilities.backgroundSync).toBe(false);\n      expect(proResult.current.capabilities.backgroundSync).toBe(true);\n    });\n\n    it('should track background sync usage through analytics', async () => {\n      const mockTrack = jest.fn();\n      const useAnalytics = require('../../useAnalytics').useAnalytics;\n      useAnalytics.mockReturnValue({\n        track: mockTrack,\n        trackPageView: jest.fn(),\n        trackFeatureUsage: jest.fn()\n      });\n\n      const { result } = renderHook(\n        () => usePWA(),\n        {\n          wrapper: (props) => <TestWrapper {...props} userTier=\"pro\" />\n        }\n      );\n\n      await act(async () => {\n        result.current.registerBackgroundSync('alarm-sync');\n      });\n\n      expect(mockTrack).toHaveBeenCalledWith(\n        'background_sync_registered',\n        expect.objectContaining({\n          metadata: expect.objectContaining({\n            sync_tag: 'alarm-sync'\n          })\n        })\n      );\n    });\n  });\n\n  describe('Error Handling Across PWA Providers', () => {\n    it('should handle PWA errors gracefully with provider integration', async () => {\n      const mockHandleError = jest.fn();\n      const ErrorHandler = require('../../../services/error-handler').ErrorHandler;\n      ErrorHandler.handleError = mockHandleError;\n\n      const { result } = renderHook(\n        () => usePWA(),\n        { wrapper: TestWrapper }\n      );\n\n      const PWAManager = require('../../../services/pwa-manager').default;\n      const mockPWAManager = PWAManager.getInstance();\n      mockPWAManager.install.mockRejectedValue(new Error('Install failed'));\n\n      await act(async () => {\n        await result.current.install();\n      });\n\n      expect(mockHandleError).toHaveBeenCalledWith(\n        expect.any(Error),\n        expect.stringContaining('PWA installation failed'),\n        expect.objectContaining({\n          context: 'usePWA'\n        })\n      );\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/__tests__/useAdvancedAlarms.test.ts",
    "messages": [
      {
        "ruleId": null,
        "nodeType": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Declaration or statement expected.",
        "line": 62,
        "column": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\n/**\n * Tests advanced alarm scheduling, optimization, and management functionality\n */\n\nimport { renderHook, act, waitFor } from \"@testing-library/react\";\nimport {\n  renderHookWithProviders,\n  createMockAlarm,\n  clearAllMocks,\n} from \"../../__tests__/utils/hook-testing-utils\";\nimport { AlarmService } from \"../../services/alarm\";\n\n// Mock services\njest.mock('../../services/alarm', () => ({\n  AlarmService: {\n    loadAlarms: jest.fn(),\n    createAlarm: jest.fn(),\n    updateAlarm: jest.fn(),\n    deleteAlarm: jest.fn(),\n  },\n}));\n\njest.mock('../../services/advanced-alarm-scheduler', () => ({\n  __esModule: true,\n  default: {\n    initialize: jest.fn(),\n    applySmartOptimizations: jest.fn(),\n    applySeasonalAdjustments: jest.fn(),\n    calculateNextOccurrences: jest.fn(),\n    evaluateConditionalRules: jest.fn(),\n    evaluateLocationTriggers: jest.fn(),\n    exportSchedule: jest.fn(),\n    importSchedule: jest.fn(),\n    getStats: jest.fn(),\n  },\n}));\n\n// Mock geolocation\nconst mockGeolocation = {\n  getCurrentPosition: jest.fn(),\n  watchPosition: jest.fn(),\n  clearWatch: jest.fn(),\n};\n\nObject.defineProperty(navigator, 'geolocation', {\n  value: mockGeolocation,\n  writable: true,\n});\n\n// Mock URL and blob for exports\nObject.defineProperty(global, 'URL', {\n  value: {\n    createObjectURL: jest.fn(() => 'blob:url'),\n    revokeObjectURL: jest.fn(),\n  },\n  writable: true,\n});\n\n  const mockBasicAlarm = createMockAlarm();\n\n    ...mockBasicAlarm,\n    scheduleType: 'daily',\n    recurrencePattern: undefined,\n    conditionalRules: [\n      {\n        id: 'weather-rule',\n        type: 'weather',\n        condition: 'sunny',\n        action: 'enable',\n        isActive: true,\n      },\n    ],\n    locationTriggers: [\n      {\n        id: 'home-trigger',\n        name: 'Home',\n        latitude: 40.7128,\n        longitude: -74.0060,\n        radius: 100,\n        action: 'enable',\n        isActive: true,\n      },\n    ],\n    calendarIntegration: {\n      isEnabled: true,\n      calendarId: 'primary',\n      syncMode: 'read_only',\n      respectBusyTime: true,\n    },\n    timeZone: 'America/New_York',\n    seasonalAdjustments: [\n      {\n        id: 'winter-adjustment',\n        season: 'winter',\n        timeOffset: 30,\n        isActive: true,\n      },\n    ],\n    smartOptimizations: [\n      {\n        id: 'sleep-pattern',\n        type: 'sleep_pattern',\n        isEnabled: true,\n        settings: { analysisWeeks: 4 },\n      },\n    ],\n    dependencies: [\n      {\n        alarmId: 'dependent-alarm-id',\n        type: 'sequence',\n        delay: 600,\n      },\n    ],\n  };\n\n  beforeEach(() => {\n    clearAllMocks();\n    jest.clearAllTimers();\n    jest.useFakeTimers();\n\n    // Reset all mocks to default successful responses\n      // AlarmService is now imported at the top\n\n    AlarmService.loadAlarms.mockResolvedValue([mockBasicAlarm]);\n    AlarmService.createAlarm.mockResolvedValue(mockBasicAlarm);\n    AlarmService.updateAlarm.mockResolvedValue(mockBasicAlarm);\n    AlarmService.deleteAlarm.mockResolvedValue(true);\n\n      Promise.resolve(alarm),\n    );\n      (alarm) => alarm,\n    );\n      new Date(Date.now() + 24 * 60 * 60 * 1000),\n    ]);\n      true,\n    );\n      true,\n    );\n    });\n      success: 1,\n      failed: 0,\n      errors: [],\n    });\n      totalAlarms: 1,\n      activeAlarms: 1,\n      scheduledNotifications: 5,\n    });\n\n    mockGeolocation.getCurrentPosition.mockImplementation(success =>\n      success({\n        coords: {\n          latitude: 40.7128,\n          longitude: -74.0060,\n          accuracy: 10,\n        },\n        timestamp: Date.now(),\n      })\n    );\n\n    // Mock DOM methods for export functionality\n    document.createElement = jest.fn().mockImplementation((tag) => {\n      if (tag === 'a') {\n        return {\n          href: '',\n          download: '',\n          click: jest.fn(),\n        };\n      }\n      return {};\n    });\n    document.body.appendChild = jest.fn();\n    document.body.removeChild = jest.fn();\n  });\n\n  afterEach(() => {\n    jest.clearAllTimers();\n    jest.useRealTimers();\n  });\n\n  describe(\"Initialization\", () => {\n    it(\"should initialize with default state\", () => {\n\n      expect(result.current.alarms).toEqual([]);\n      expect(result.current.loading).toBe(true);\n      expect(result.current.error).toBeNull();\n    });\n\n    it(\"should load alarms and initialize scheduler on mount\", async () => {\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.alarms).toHaveLength(1);\n      expect(result.current.alarms[0]).toMatchObject({\n        ...mockBasicAlarm,\n        scheduleType: 'daily',\n        conditionalRules: [],\n        locationTriggers: [],\n        seasonalAdjustments: [],\n        smartOptimizations: [],\n        dependencies: [],\n      });\n\n    });\n\n    it('should handle alarm loading errors', async () => {\n      const { AlarmService } = require('../../services/alarm');\n      AlarmService.loadAlarms.mockRejectedValue(new Error('Failed to load'));\n\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      expect(result.current.error).toBe('Failed to load alarms');\n      expect(result.current.alarms).toEqual([]);\n    });\n\n    it(\"should handle scheduler initialization errors\", async () => {\n        new Error(\"Scheduler failed\"),\n      );\n\n\n      await waitFor(() => {\n        expect(result.current.error).toBe('Failed to initialize scheduler');\n      });\n    });\n  });\n\n  describe(\"Creating Alarms\", () => {\n    it(\"should create advanced alarm successfully\", async () => {\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const newAlarmData = {\n        userId: 'test-user',\n        time: '08:00',\n        label: 'New Advanced Alarm',\n        days: [1, 2, 3, 4, 5],\n        sound: 'default-alarm.mp3',\n        difficulty: 'medium' as const,\n        snoozeEnabled: true,\n        snoozeInterval: 5,\n        voiceMood: 'motivational' as const,\n        isActive: true,\n        scheduleType: \"weekly\" as const,\n        timeZone: \"America/New_York\",\n      };\n\n      let createdAlarm;\n      await act(async () => {\n        createdAlarm = await result.current.createAlarm(newAlarmData);\n      });\n\n      expect(createdAlarm).toBeDefined();\n      expect(result.current.alarms).toHaveLength(2); // Original + new\n      expect(result.current.error).toBeNull();\n\n      expect(\n      ).toHaveBeenCalled();\n      expect(\n      ).toHaveBeenCalled();\n    });\n\n    it('should handle alarm creation errors', async () => {\n      const { AlarmService } = require('../../services/alarm');\n      AlarmService.createAlarm.mockRejectedValue(new Error('Creation failed'));\n\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const newAlarmData = {\n        userId: 'test-user',\n        time: '08:00',\n        label: 'Failed Alarm',\n        days: [1, 2, 3, 4, 5],\n        sound: 'default-alarm.mp3',\n        difficulty: 'medium' as const,\n        snoozeEnabled: true,\n        snoozeInterval: 5,\n        voiceMood: 'motivational' as const,\n        isActive: true,\n        scheduleType: 'daily' as const,\n      };\n\n      await expect(async () => {\n        await act(async () => {\n          await result.current.createAlarm(newAlarmData);\n        });\n      }).rejects.toThrow('Creation failed');\n\n      expect(result.current.error).toBe('Failed to create alarm');\n    });\n  });\n\n  describe(\"Updating Alarms\", () => {\n    it(\"should update alarm successfully\", async () => {\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const updates = {\n        label: 'Updated Alarm',\n        time: '09:00',\n        conditionalRules: [\n          {\n            id: 'new-rule',\n            type: 'weather' as const,\n            condition: 'rainy',\n            action: 'disable' as const,\n            isActive: true,\n          },\n        ],\n      };\n\n      let updatedAlarm;\n      await act(async () => {\n        updatedAlarm = await result.current.updateAlarm(mockBasicAlarm.id, updates);\n      });\n\n      expect(updatedAlarm).toBeDefined();\n      expect(result.current.alarms[0].label).toBe('Updated Alarm');\n      expect(result.current.error).toBeNull();\n\n      expect(\n      ).toHaveBeenCalledWith(mockBasicAlarm.id);\n      expect(\n      ).toHaveBeenCalled();\n    });\n\n    it(\"should handle update of non-existent alarm\", async () => {\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      await expect(async () => {\n        await act(async () => {\n          await result.current.updateAlarm('non-existent-id', { label: 'Test' });\n        });\n      }).rejects.toThrow('Alarm not found');\n\n      expect(result.current.error).toBe('Failed to update alarm');\n    });\n\n    it('should handle alarm update errors', async () => {\n      const { AlarmService } = require('../../services/alarm');\n      AlarmService.updateAlarm.mockRejectedValue(new Error('Update failed'));\n\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      await expect(async () => {\n        await act(async () => {\n          await result.current.updateAlarm(mockBasicAlarm.id, { label: 'Test' });\n        });\n      }).rejects.toThrow('Update failed');\n\n      expect(result.current.error).toBe('Failed to update alarm');\n    });\n  });\n\n  describe(\"Deleting Alarms\", () => {\n    it(\"should delete alarm successfully\", async () => {\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      await act(async () => {\n        await result.current.deleteAlarm(mockBasicAlarm.id);\n      });\n\n      expect(result.current.alarms).toHaveLength(0);\n      expect(result.current.error).toBeNull();\n\n      expect(\n      ).toHaveBeenCalledWith(mockBasicAlarm.id);\n    });\n\n    it('should handle alarm deletion errors', async () => {\n      const { AlarmService } = require('../../services/alarm');\n      AlarmService.deleteAlarm.mockRejectedValue(new Error('Deletion failed'));\n\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      await expect(async () => {\n        await act(async () => {\n          await result.current.deleteAlarm(mockBasicAlarm.id);\n        });\n      }).rejects.toThrow('Deletion failed');\n\n      expect(result.current.error).toBe('Failed to delete alarm');\n    });\n  });\n\n  describe(\"Alarm Duplication\", () => {\n    it(\"should duplicate alarm successfully\", async () => {\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      let duplicatedAlarm;\n      await act(async () => {\n        duplicatedAlarm = await result.current.duplicateAlarm(mockBasicAlarm.id, {\n          label: 'Duplicated Alarm',\n        });\n      });\n\n      expect(duplicatedAlarm).toBeDefined();\n      expect(duplicatedAlarm?.label).toBe('Duplicated Alarm');\n      expect(result.current.alarms).toHaveLength(2);\n    });\n\n    it(\"should handle duplication of non-existent alarm\", async () => {\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      await expect(async () => {\n        await act(async () => {\n          await result.current.duplicateAlarm('non-existent-id');\n        });\n      }).rejects.toThrow('Alarm not found');\n\n      expect(result.current.error).toBe('Failed to duplicate alarm');\n    });\n\n    it(\"should use default label when duplicating without modifications\", async () => {\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      let duplicatedAlarm;\n      await act(async () => {\n        duplicatedAlarm = await result.current.duplicateAlarm(mockBasicAlarm.id);\n      });\n\n      expect(duplicatedAlarm?.label).toBe(`${mockBasicAlarm.label} (Copy)`);\n    });\n  });\n\n  describe('Bulk Operations', () => {\n    it('should perform bulk update successfully', async () => {\n      // Add multiple alarms first\n      const { AlarmService } = require('../../services/alarm');\n      const alarm2 = { ...mockBasicAlarm, id: 'alarm-2' };\n      const alarm3 = { ...mockBasicAlarm, id: 'alarm-3' };\n      AlarmService.loadAlarms.mockResolvedValue([mockBasicAlarm, alarm2, alarm3]);\n\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const updates = { isActive: false };\n      let bulkResult;\n      await act(async () => {\n        bulkResult = await result.current.bulkUpdate(['alarm-2', 'alarm-3'], updates);\n      });\n\n      expect(bulkResult).toEqual({\n        success: 2,\n        failed: 0,\n        errors: [],\n      });\n      expect(result.current.error).toBeNull();\n    });\n\n    it('should handle partial failures in bulk update', async () => {\n      const { AlarmService } = require('../../services/alarm');\n      const alarm2 = { ...mockBasicAlarm, id: 'alarm-2' };\n      AlarmService.loadAlarms.mockResolvedValue([mockBasicAlarm, alarm2]);\n\n      // Make update fail for one alarm\n      AlarmService.updateAlarm.mockImplementation((id) => {\n        if (id === 'alarm-2') {\n          return Promise.reject(new Error('Update failed for alarm-2'));\n        }\n        return Promise.resolve(mockBasicAlarm);\n      });\n\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const updates = { isActive: false };\n      let bulkResult;\n      await act(async () => {\n        bulkResult = await result.current.bulkUpdate([mockBasicAlarm.id, 'alarm-2'], updates);\n      });\n\n      expect(bulkResult).toEqual({\n        success: 1,\n        failed: 1,\n        errors: ['Failed to update alarm alarm-2: Update failed for alarm-2'],\n      });\n    });\n  });\n\n  describe(\"Next Occurrence Calculation\", () => {\n    it(\"should calculate next occurrence\", async () => {\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const nextOccurrence =\n\n      expect(nextOccurrence).toBeInstanceOf(Date);\n      expect(nextOccurrence!.getTime()).toBeGreaterThan(Date.now());\n\n      expect(\n    });\n\n    it(\"should handle calculation errors\", async () => {\n        throw new Error(\"Calculation failed\");\n      });\n\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const nextOccurrence =\n\n      expect(nextOccurrence).toBeNull();\n    });\n  });\n\n  describe(\"Import/Export\", () => {\n    it(\"should export alarms successfully\", async () => {\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      let exportData;\n      await act(async () => {\n        exportData = await result.current.exportAlarms();\n      });\n\n\n      // Verify download functionality was triggered\n      expect(document.createElement).toHaveBeenCalledWith('a');\n      expect(document.body.appendChild).toHaveBeenCalled();\n      expect(document.body.removeChild).toHaveBeenCalled();\n    });\n\n    it(\"should handle export errors\", async () => {\n        new Error(\"Export failed\"),\n      );\n\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      await expect(async () => {\n        await act(async () => {\n          await result.current.exportAlarms();\n        });\n      }).rejects.toThrow('Export failed');\n\n      expect(result.current.error).toBe('Failed to export alarms');\n    });\n\n    it('should import alarms successfully', async () => {\n      const mockFile = new File(\n        \"test-alarms.json\",\n        { type: \"application/json\" },\n      );\n\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      let importResult;\n      await act(async () => {\n        importResult = await result.current.importAlarms(mockFile);\n      });\n\n      expect(importResult).toEqual({\n        success: 1,\n        failed: 0,\n        errors: [],\n      });\n      expect(result.current.error).toBeNull();\n\n        source: \"backup\",\n        options: {\n          overwriteExisting: false,\n          preserveIds: false,\n          adjustTimeZones: true,\n          skipInvalid: true,\n        },\n      });\n    });\n\n    it('should handle import errors', async () => {\n      const mockFile = new File(['invalid json'], 'test-alarms.json', {\n        type: 'application/json',\n      });\n\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      await expect(async () => {\n        await act(async () => {\n          await result.current.importAlarms(mockFile);\n        });\n      }).rejects.toThrow();\n\n      expect(result.current.error).toBe('Failed to import alarms');\n    });\n  });\n\n  describe(\"Scheduling Features\", () => {\n    it(\"should handle conditional rules evaluation\", async () => {\n\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const newAlarmData = {\n        userId: 'test-user',\n        time: '08:00',\n        label: 'Conditional Alarm',\n        days: [1, 2, 3, 4, 5],\n        sound: 'default-alarm.mp3',\n        difficulty: 'medium' as const,\n        snoozeEnabled: true,\n        snoozeInterval: 5,\n        voiceMood: 'motivational' as const,\n        isActive: true,\n        scheduleType: \"daily\" as const,\n      };\n\n      await act(async () => {\n        await result.current.createAlarm(newAlarmData);\n      });\n\n      expect(\n      ).toHaveBeenCalled();\n      // Should not schedule notifications if conditional rules fail\n      expect(\n      ).not.toHaveBeenCalled();\n    });\n\n    it(\"should handle location triggers\", async () => {\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const newAlarmData = {\n        userId: 'test-user',\n        time: '08:00',\n        label: 'Location Alarm',\n        days: [1, 2, 3, 4, 5],\n        sound: 'default-alarm.mp3',\n        difficulty: 'medium' as const,\n        snoozeEnabled: true,\n        snoozeInterval: 5,\n        voiceMood: 'motivational' as const,\n        isActive: true,\n        scheduleType: \"daily\" as const,\n      };\n\n      await act(async () => {\n        await result.current.createAlarm(newAlarmData);\n      });\n\n      expect(mockGeolocation.getCurrentPosition).toHaveBeenCalled();\n\n      expect(\n      ).toHaveBeenCalled();\n    });\n\n    it('should handle geolocation errors gracefully', async () => {\n      mockGeolocation.getCurrentPosition.mockImplementation((success, error) =>\n        error(new Error('Geolocation failed'))\n      );\n\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const newAlarmData = {\n        userId: 'test-user',\n        time: '08:00',\n        label: 'Location Alarm',\n        days: [1, 2, 3, 4, 5],\n        sound: 'default-alarm.mp3',\n        difficulty: 'medium' as const,\n        snoozeEnabled: true,\n        snoozeInterval: 5,\n        voiceMood: 'motivational' as const,\n        isActive: true,\n        scheduleType: \"daily\" as const,\n      };\n\n      await act(async () => {\n        await result.current.createAlarm(newAlarmData);\n      });\n\n      // Should continue with scheduling even if geolocation fails\n      expect(\n      ).toHaveBeenCalled();\n    });\n  });\n\n  describe(\"Statistics\", () => {\n    it(\"should get scheduling statistics\", async () => {\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const stats = result.current.getSchedulingStats();\n\n      expect(stats).toEqual({\n        totalAlarms: 1,\n        activeAlarms: 1,\n        scheduledNotifications: 5,\n      });\n\n    });\n\n    it(\"should handle statistics errors\", async () => {\n        throw new Error(\"Stats failed\");\n      });\n\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const stats = result.current.getSchedulingStats();\n\n      expect(stats).toBeNull();\n    });\n  });\n\n  describe(\"Refresh Functionality\", () => {\n    it(\"should refresh alarms manually\", async () => {\n\n      await waitFor(() => {\n        expect(result.current.loading).toBe(false);\n      });\n\n      const { AlarmService } = require('../../services/alarm');\n      AlarmService.loadAlarms.mockClear();\n\n      await act(async () => {\n        await result.current.refresh();\n      });\n\n      expect(AlarmService.loadAlarms).toHaveBeenCalled();\n      expect(result.current.loading).toBe(false);\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/__tests__/useAuth.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 88,
        "column": 43,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 88,
        "endColumn": 77
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 89,
        "column": 29,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 89,
        "endColumn": 63
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 131,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 131,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 146,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 146,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 163,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 163,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 182,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 182,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 198,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 198,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 214,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 214,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 232,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 232,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 252,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 252,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 267,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 267,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 285,
        "column": 45,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 285,
        "endColumn": 79
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 306,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 306,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 323,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 323,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 341,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 341,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 358,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 358,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 388,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 388,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 404,
        "column": 45,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 404,
        "endColumn": 79
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 420,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 420,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 440,
        "column": 45,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 440,
        "endColumn": 79
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 460,
        "column": 45,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 460,
        "endColumn": 79
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 509,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 509,
        "endColumn": 65
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 539,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 539,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 540,
        "column": 32,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 540,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 563,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 563,
        "endColumn": 69
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 564,
        "column": 32,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 564,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 585,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 585,
        "endColumn": 62
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 611,
        "column": 28,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 611,
        "endColumn": 62
      }
    ],
    "suppressedMessages": [],
    "errorCount": 28,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Vitest globals are available globally, no need to import\nimport { vi } from 'vitest';\n/**\n * Unit tests for useAuth hook\n * Tests authentication, session management, rate limiting, and security features\n */\n\nimport { renderHook, act, waitFor } from '@testing-library/react';\nimport useAuth from '../useAuth';\nimport {\n  renderHookWithProviders,\n  createMockUser,\n  clearAllMocks,\n} from '../../__tests__/utils/hook-testing-utils';\nimport { server, mockApiError, mockApiSuccess } from '../../__tests__/mocks/msw-setup';\n\n// Mock services\njest.mock('../../services/supabase', () => ({\n  SupabaseService: {\n    getCurrentUser: jest.fn(),\n    signIn: jest.fn(),\n    signUp: jest.fn(),\n    signOut: jest.fn(),\n  },\n  supabase: {\n    auth: {\n      onAuthStateChange: jest.fn(() => ({\n        data: {\n          subscription: {\n            unsubscribe: jest.fn(),\n          },\n        },\n      })),\n      refreshSession: jest.fn(),\n      resetPasswordForEmail: jest.fn(),\n    },\n    from: jest.fn(() => ({\n      update: jest.fn(() => ({\n        eq: jest.fn(() => ({\n          eq: jest.fn(),\n        })),\n      })),\n    })),\n  },\n}));\n\njest.mock('../../services/error-handler', () => ({\n  ErrorHandler: {\n    handleError: jest.fn(),\n  },\n}));\n\njest.mock('../../services/analytics', () => ({\n  __esModule: true,\n  default: {\n    getInstance: jest.fn(() => ({\n      trackFeatureUsage: jest.fn(),\n      trackError: jest.fn(),\n    })),\n  },\n}));\n\njest.mock('../../services/security', () => ({\n  __esModule: true,\n  default: {\n    generateCSRFToken: jest.fn(() => 'mock-csrf-token'),\n    checkRateLimit: jest.fn(() => true),\n  },\n}));\n\n// Mock performance\nObject.defineProperty(window, 'performance', {\n  value: {\n    now: jest.fn(() => 1000),\n  },\n  writable: true,\n});\n\ndescribe('useAuth Hook', () => {\n  const mockUser = createMockUser();\n\n  beforeEach(() => {\n    clearAllMocks();\n    jest.clearAllTimers();\n    jest.useFakeTimers();\n\n    // Reset all mocks to default successful responses\n    const { SupabaseService, supabase } = require('../../services/supabase');\n    const SecurityService = require('../../services/security').default;\n\n    SupabaseService.getCurrentUser.mockResolvedValue(null);\n    SupabaseService.signIn.mockResolvedValue({ user: mockUser, error: null });\n    SupabaseService.signUp.mockResolvedValue({ user: mockUser, error: null });\n    SupabaseService.signOut.mockResolvedValue({ error: null });\n\n    supabase.auth.refreshSession.mockResolvedValue({\n      data: { session: { user: mockUser } },\n      error: null,\n    });\n\n    supabase.auth.resetPasswordForEmail.mockResolvedValue({ error: null });\n    supabase.from.mockReturnValue({\n      update: jest.fn().mockReturnValue({\n        eq: jest.fn().mockResolvedValue({ error: null }),\n      }),\n    });\n\n    SecurityService.checkRateLimit.mockReturnValue(true);\n  });\n\n  afterEach(() => {\n    jest.clearAllTimers();\n    jest.useRealTimers();\n  });\n\n  describe('Initialization', () => {\n    it('should initialize with default state', () => {\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      expect(result.current.user).toBeNull();\n      expect(result.current.isLoading).toBe(false);\n      expect(result.current.isInitialized).toBe(false);\n      expect(result.current.error).toBeNull();\n      expect(result.current.forgotPasswordSuccess).toBe(false);\n      expect(result.current.sessionExpiry).toBeNull();\n      expect(result.current.csrfToken).toBeNull();\n      expect(result.current.rateLimitRemaining).toBe(10);\n    });\n\n    it('should initialize auth state on mount', async () => {\n      const { SupabaseService } = require('../../services/supabase');\n      SupabaseService.getCurrentUser.mockResolvedValue(mockUser);\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      expect(result.current.user).toEqual(mockUser);\n      expect(result.current.csrfToken).toBe('mock-csrf-token');\n      expect(result.current.sessionExpiry).toBeInstanceOf(Date);\n    });\n\n    it('should handle initialization errors', async () => {\n      const { SupabaseService } = require('../../services/supabase');\n      const errorMessage = 'Network error';\n      SupabaseService.getCurrentUser.mockRejectedValue(new Error(errorMessage));\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      expect(result.current.error).toBe('Failed to initialize authentication');\n      expect(result.current.user).toBeNull();\n    });\n  });\n\n  describe('Sign In', () => {\n    it('should sign in successfully', async () => {\n      const { SupabaseService } = require('../../services/supabase');\n      SupabaseService.signIn.mockResolvedValue({ user: mockUser, error: null });\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'password123');\n      });\n\n      expect(result.current.user).toEqual(mockUser);\n      expect(result.current.isLoading).toBe(false);\n      expect(result.current.error).toBeNull();\n      expect(SupabaseService.signIn).toHaveBeenCalledWith(\n        'test@example.com',\n        'password123'\n      );\n    });\n\n    it('should handle sign in errors', async () => {\n      const { SupabaseService } = require('../../services/supabase');\n      const errorMessage = 'Invalid credentials';\n      SupabaseService.signIn.mockResolvedValue({ user: null, error: errorMessage });\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'wrongpassword');\n      });\n\n      expect(result.current.user).toBeNull();\n      expect(result.current.isLoading).toBe(false);\n      expect(result.current.error).toBe(errorMessage);\n    });\n\n    it('should handle rate limiting on sign in', async () => {\n      const SecurityService = require('../../services/security').default;\n      SecurityService.checkRateLimit.mockReturnValue(false);\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'password123');\n      });\n\n      expect(result.current.error).toBe(\n        'Too many sign-in attempts. Please try again in 15 minutes.'\n      );\n      expect(result.current.rateLimitRemaining).toBe(0);\n    });\n\n    it('should handle network errors during sign in', async () => {\n      const { SupabaseService } = require('../../services/supabase');\n      SupabaseService.signIn.mockRejectedValue(new Error('Network error'));\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'password123');\n      });\n\n      expect(result.current.error).toBe(\n        'An unexpected error occurred. Please try again.'\n      );\n      expect(result.current.isLoading).toBe(false);\n    });\n  });\n\n  describe('Sign Up', () => {\n    it('should sign up successfully', async () => {\n      const { SupabaseService } = require('../../services/supabase');\n      SupabaseService.signUp.mockResolvedValue({ user: mockUser, error: null });\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await act(async () => {\n        await result.current.signUp('test@example.com', 'password123', 'Test User');\n      });\n\n      expect(result.current.user).toEqual(mockUser);\n      expect(result.current.isLoading).toBe(false);\n      expect(result.current.error).toBeNull();\n      expect(SupabaseService.signUp).toHaveBeenCalledWith(\n        'test@example.com',\n        'password123',\n        'Test User'\n      );\n    });\n\n    it('should handle sign up errors', async () => {\n      const { SupabaseService } = require('../../services/supabase');\n      const errorMessage = 'Email already exists';\n      SupabaseService.signUp.mockResolvedValue({ user: null, error: errorMessage });\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await act(async () => {\n        await result.current.signUp('existing@example.com', 'password123', 'Test User');\n      });\n\n      expect(result.current.user).toBeNull();\n      expect(result.current.error).toBe(errorMessage);\n    });\n\n    it('should handle rate limiting on sign up', async () => {\n      const SecurityService = require('../../services/security').default;\n      SecurityService.checkRateLimit.mockReturnValue(false);\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await act(async () => {\n        await result.current.signUp('test@example.com', 'password123', 'Test User');\n      });\n\n      expect(result.current.error).toBe(\n        'Too many sign-up attempts. Please try again in 15 minutes.'\n      );\n      expect(result.current.rateLimitRemaining).toBe(0);\n    });\n  });\n\n  describe('Sign Out', () => {\n    it('should sign out successfully', async () => {\n      const { SupabaseService, supabase } = require('../../services/supabase');\n      SupabaseService.getCurrentUser.mockResolvedValue(mockUser);\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      // Wait for initialization\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      await act(async () => {\n        await result.current.signOut();\n      });\n\n      expect(result.current.user).toBeNull();\n      expect(result.current.isLoading).toBe(false);\n      expect(result.current.error).toBeNull();\n      expect(SupabaseService.signOut).toHaveBeenCalled();\n    });\n\n    it('should handle sign out errors', async () => {\n      const { SupabaseService } = require('../../services/supabase');\n      const errorMessage = 'Sign out failed';\n      SupabaseService.signOut.mockResolvedValue({ error: errorMessage });\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await act(async () => {\n        await result.current.signOut();\n      });\n\n      expect(result.current.error).toBe(errorMessage);\n      expect(result.current.isLoading).toBe(false);\n    });\n  });\n\n  describe('Password Reset', () => {\n    it('should reset password successfully', async () => {\n      const { supabase } = require('../../services/supabase');\n      supabase.auth.resetPasswordForEmail.mockResolvedValue({ error: null });\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await act(async () => {\n        await result.current.resetPassword('test@example.com');\n      });\n\n      expect(result.current.forgotPasswordSuccess).toBe(true);\n      expect(result.current.error).toBeNull();\n      expect(supabase.auth.resetPasswordForEmail).toHaveBeenCalledWith(\n        'test@example.com',\n        { redirectTo: `${window.location.origin}/reset-password` }\n      );\n    });\n\n    it('should handle password reset errors', async () => {\n      const { supabase } = require('../../services/supabase');\n      const errorMessage = 'Email not found';\n      supabase.auth.resetPasswordForEmail.mockResolvedValue({\n        error: { message: errorMessage },\n      });\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await act(async () => {\n        await result.current.resetPassword('nonexistent@example.com');\n      });\n\n      expect(result.current.error).toBe(errorMessage);\n      expect(result.current.forgotPasswordSuccess).toBe(false);\n    });\n\n    it('should handle rate limiting on password reset', async () => {\n      const SecurityService = require('../../services/security').default;\n      SecurityService.checkRateLimit.mockReturnValue(false);\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await act(async () => {\n        await result.current.resetPassword('test@example.com');\n      });\n\n      expect(result.current.error).toBe(\n        'Too many password reset attempts. Please try again in 15 minutes.'\n      );\n      expect(result.current.rateLimitRemaining).toBe(0);\n    });\n  });\n\n  describe('Session Management', () => {\n    it('should validate active session', () => {\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      // Mock active session\n      act(() => {\n        result.current.isSessionValid();\n      });\n\n      // Without a user, session should be invalid\n      expect(result.current.isSessionValid()).toBe(false);\n    });\n\n    it('should refresh session successfully', async () => {\n      const { supabase } = require('../../services/supabase');\n      supabase.auth.refreshSession.mockResolvedValue({\n        data: { session: { user: mockUser } },\n        error: null,\n      });\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await act(async () => {\n        await result.current.refreshSession();\n      });\n\n      expect(supabase.auth.refreshSession).toHaveBeenCalled();\n    });\n\n    it('should handle session refresh errors', async () => {\n      const { supabase, SupabaseService } = require('../../services/supabase');\n      supabase.auth.refreshSession.mockResolvedValue({\n        data: null,\n        error: new Error('Session expired'),\n      });\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await act(async () => {\n        await result.current.refreshSession();\n      });\n\n      expect(SupabaseService.signOut).toHaveBeenCalled();\n    });\n\n    it('should handle inactivity timeout', async () => {\n      const { SupabaseService } = require('../../services/supabase');\n      SupabaseService.getCurrentUser.mockResolvedValue(mockUser);\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      // Fast-forward time to trigger inactivity timeout\n      act(() => {\n        jest.advanceTimersByTime(16 * 60 * 1000); // 16 minutes (exceeds 15 minute limit)\n      });\n\n      expect(SupabaseService.signOut).toHaveBeenCalled();\n    });\n  });\n\n  describe('Profile Updates', () => {\n    it('should update user profile successfully', async () => {\n      const { SupabaseService, supabase } = require('../../services/supabase');\n      SupabaseService.getCurrentUser.mockResolvedValue(mockUser);\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      const updates = { name: 'Updated Name' };\n\n      await act(async () => {\n        await result.current.updateUserProfile(updates);\n      });\n\n      expect(result.current.user?.name).toBe('Updated Name');\n      expect(result.current.error).toBeNull();\n    });\n\n    it('should handle profile update errors', async () => {\n      const { SupabaseService, supabase } = require('../../services/supabase');\n      SupabaseService.getCurrentUser.mockResolvedValue(mockUser);\n\n      supabase.from.mockReturnValue({\n        update: jest.fn().mockReturnValue({\n          eq: jest.fn().mockResolvedValue({ error: { message: 'Update failed' } }),\n        }),\n      });\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      await act(async () => {\n        await result.current.updateUserProfile({ name: 'New Name' });\n      });\n\n      expect(result.current.error).toBe('Update failed');\n    });\n\n    it('should throw error when updating profile without user', async () => {\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      await expect(async () => {\n        await act(async () => {\n          await result.current.updateUserProfile({ name: 'New Name' });\n        });\n      }).rejects.toThrow('No user logged in');\n    });\n  });\n\n  describe('Rate Limiting', () => {\n    it('should return rate limit information', () => {\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      const rateLimitInfo = result.current.getRateLimitInfo('sign_in');\n\n      expect(rateLimitInfo).toHaveProperty('remaining');\n      expect(rateLimitInfo).toHaveProperty('resetTime');\n      expect(typeof rateLimitInfo.remaining).toBe('number');\n    });\n\n    it('should handle rate limit service errors', () => {\n      const SecurityService = require('../../services/security').default;\n      SecurityService.checkRateLimit.mockImplementation(() => {\n        throw new Error('Rate limit service error');\n      });\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      const rateLimitInfo = result.current.getRateLimitInfo('sign_in');\n\n      expect(rateLimitInfo.remaining).toBe(0);\n      expect(rateLimitInfo.resetTime).toBeNull();\n    });\n  });\n\n  describe('Utility Functions', () => {\n    it('should clear errors', () => {\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      // Set an error first\n      act(() => {\n        result.current.clearError();\n      });\n\n      expect(result.current.error).toBeNull();\n      expect(result.current.forgotPasswordSuccess).toBe(false);\n    });\n  });\n\n  describe('Analytics Integration', () => {\n    it('should track successful sign in', async () => {\n      const { SupabaseService } = require('../../services/supabase');\n      const AnalyticsService = require('../../services/analytics').default;\n      const mockAnalytics = { trackFeatureUsage: jest.fn() };\n      AnalyticsService.getInstance.mockReturnValue(mockAnalytics);\n\n      SupabaseService.signIn.mockResolvedValue({ user: mockUser, error: null });\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'password123');\n      });\n\n      expect(mockAnalytics.trackFeatureUsage).toHaveBeenCalledWith(\n        'user_sign_in_success',\n        expect.any(Number),\n        {\n          userId: mockUser.id,\n          method: 'email_password',\n        }\n      );\n    });\n\n    it('should track errors', async () => {\n      const { SupabaseService } = require('../../services/supabase');\n      const AnalyticsService = require('../../services/analytics').default;\n      const mockAnalytics = { trackError: jest.fn() };\n      AnalyticsService.getInstance.mockReturnValue(mockAnalytics);\n\n      SupabaseService.signIn.mockRejectedValue(new Error('Network error'));\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      await act(async () => {\n        await result.current.signIn('test@example.com', 'password123');\n      });\n\n      expect(mockAnalytics.trackError).toHaveBeenCalledWith(\n        expect.any(Error),\n        'sign_in_error'\n      );\n    });\n  });\n\n  describe('Auth State Changes', () => {\n    it('should handle auth state change listener', async () => {\n      const { supabase } = require('../../services/supabase');\n      let authStateChangeCallback: (event: string, session: any) => void;\n\n      supabase.auth.onAuthStateChange.mockImplementation(callback => {\n        authStateChangeCallback = callback;\n        return {\n          data: {\n            subscription: {\n              unsubscribe: jest.fn(),\n            },\n          },\n        };\n      });\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      // Simulate signed in event\n      await act(async () => {\n        authStateChangeCallback('SIGNED_IN', { user: mockUser });\n      });\n\n      // The hook should update state based on auth changes\n      expect(supabase.auth.onAuthStateChange).toHaveBeenCalled();\n    });\n\n    it('should handle signed out event', async () => {\n      const { supabase } = require('../../services/supabase');\n      let authStateChangeCallback: (event: string, session: any) => void;\n\n      supabase.auth.onAuthStateChange.mockImplementation(callback => {\n        authStateChangeCallback = callback;\n        return {\n          data: {\n            subscription: {\n              unsubscribe: jest.fn(),\n            },\n          },\n        };\n      });\n\n      const { result } = renderHookWithProviders(() => useAuth());\n\n      // Simulate signed out event\n      await act(async () => {\n        authStateChangeCallback('SIGNED_OUT', null);\n      });\n\n      expect(result.current.user).toBeNull();\n      expect(result.current.sessionExpiry).toBeNull();\n    });\n  });\n});\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/__tests__/useFeatureGate.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 89,
        "column": 30,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 89,
        "endColumn": 65
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\n/**\n * Unit tests for useFeatureGate hook\n * Tests feature access control, upgrade prompts, and business logic\n */\n\nimport { renderHook, act, waitFor } from \"@testing-library/react\";\nimport { FeatureService } from \"../../services/feature\";\nimport useFeatureGate from \"../useFeatureGate\";\nimport { FeatureService } from \"../../services/feature\";\nimport {\n  renderHookWithProviders,\n  createMockSubscription,\n  clearAllMocks,\n} from \"../../__tests__/utils/hook-testing-utils\";\nimport { FeatureService } from \"../../services/feature\";\n\n// Mock useSubscription hook\nconst mockSubscription = {\n  featureAccess: null as FeatureAccess | null,\n  hasFeatureAccess: jest.fn(() => false),\n  isLoading: false,\n  isInitialized: true,\n  subscription: null,\n  currentPlan: null,\n  usage: null,\n  error: null,\n  availablePlans: [],\n  paymentMethods: [],\n  invoiceHistory: [],\n  upcomingInvoice: null,\n  activeTrial: null,\n  availableDiscounts: [],\n  uiState: {\n    selectedPlan: undefined,\n    isLoading: false,\n    isProcessingPayment: false,\n    showPaymentModal: false,\n    showCancelModal: false,\n    showUpgradeModal: false,\n    errors: {},\n    currentStep: 'plan_selection',\n    paymentIntent: undefined\n  },\n  createSubscription: jest.fn(),\n  updateSubscription: jest.fn(),\n  cancelSubscription: jest.fn(),\n  trackFeatureUsage: jest.fn(),\n  getUpgradeRequirement: jest.fn(),\n  addPaymentMethod: jest.fn(),\n  removePaymentMethod: jest.fn(),\n  setDefaultPaymentMethod: jest.fn(),\n  startFreeTrial: jest.fn(),\n  validateDiscountCode: jest.fn(),\n  refreshSubscription: jest.fn(),\n  clearError: jest.fn(),\n  resetUIState: jest.fn(),\n  comparePlans: jest.fn(),\n};\n\njest.mock('../useSubscription', () => ({\n  useSubscription: jest.fn(() => mockSubscription),\n}));\n\n// Mock analytics service\njest.mock('../../services/analytics', () => ({\n  __esModule: true,\n  default: {\n    getInstance: jest.fn(() => ({\n      trackFeatureUsage: jest.fn(),\n    })),\n  },\n}));\n\ndescribe('useFeatureGate Hook', () => {\n  const mockUserId = 'test-user-123';\n  const mockAnalytics = { trackFeatureUsage: jest.fn() };\n\n  beforeEach(() => {\n    clearAllMocks();\n    jest.clearAllMocks();\n\n    // Reset subscription mock to defaults\n    mockSubscription.userTier = 'free';\n    mockSubscription.featureAccess = null;\n    mockSubscription.hasFeatureAccess.mockReturnValue(false);\n\n    // Setup analytics mock\n    const AnalyticsService = require('../../services/analytics').default;\n    AnalyticsService.getInstance.mockReturnValue(mockAnalytics);\n  });\n\n  describe('Initialization', () => {\n    it('should initialize with gated state when no feature access data', () => {\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n        })\n      );\n\n      expect(result.current.hasAccess).toBe(false);\n      expect(result.current.isGated).toBe(true);\n      expect(result.current.upgradeMessage).toBe('Loading subscription data...');\n      expect(result.current.canBypass).toBe(false);\n    });\n\n    it('should allow access for unknown features', () => {\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'free',\n        features: {},\n        lastUpdated: new Date(),\n      };\n\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unknown_feature',\n        })\n      );\n\n      expect(result.current.hasAccess).toBe(true);\n      expect(result.current.isGated).toBe(false);\n      expect(result.current.upgradeMessage).toBe('');\n    });\n  });\n\n  describe('Feature Access Control', () => {\n    it('should grant access when user has feature access', () => {\n      mockSubscription.userTier = 'basic';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'basic',\n        features: {\n          unlimited_alarms: {\n            hasAccess: true,\n            usageLimit: null,\n            usageCount: undefined,\n            upgradeRequired: null,\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(true);\n\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n        })\n      );\n\n      expect(result.current.hasAccess).toBe(true);\n      expect(result.current.isGated).toBe(false);\n      expect(result.current.requiredTier).toBeNull();\n    });\n\n    it('should deny access when user lacks feature access', () => {\n      mockSubscription.userTier = 'free';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'free',\n        features: {\n          unlimited_alarms: {\n            hasAccess: false,\n            usageLimit: null,\n            usageCount: undefined,\n            upgradeRequired: 'basic',\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(false);\n\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n        })\n      );\n\n      expect(result.current.hasAccess).toBe(false);\n      expect(result.current.isGated).toBe(true);\n      expect(result.current.requiredTier).toBe('basic');\n      expect(result.current.upgradeMessage).toBe(\n        'Upgrade to Basic to set unlimited alarms and never miss an important wake-up call!'\n      );\n    });\n\n    it('should handle usage limits correctly', () => {\n      mockSubscription.userTier = 'basic';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'basic',\n        features: {\n          alarm_battles: {\n            hasAccess: true,\n            usageLimit: 10,\n            usageCount: 10, // At limit\n            upgradeRequired: null,\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(true);\n\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'alarm_battles',\n        })\n      );\n\n      expect(result.current.hasAccess).toBe(false);\n      expect(result.current.isGated).toBe(true);\n      expect(result.current.usageLimit).toBe(10);\n      expect(result.current.usageRemaining).toBe(0);\n      expect(result.current.upgradeMessage).toContain('reached your alarm battles limit');\n    });\n\n    it('should calculate usage remaining correctly', () => {\n      mockSubscription.userTier = 'basic';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'basic',\n        features: {\n          alarm_battles: {\n            hasAccess: true,\n            usageLimit: 10,\n            usageCount: 6,\n            upgradeRequired: null,\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(true);\n\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'alarm_battles',\n        })\n      );\n\n      expect(result.current.hasAccess).toBe(true);\n      expect(result.current.isGated).toBe(false);\n      expect(result.current.usageLimit).toBe(10);\n      expect(result.current.usageRemaining).toBe(4);\n    });\n  });\n\n  describe('Soft Gates and Bypass', () => {\n    it('should allow bypass with soft gate enabled', () => {\n      mockSubscription.userTier = 'free';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'free',\n        features: {\n          unlimited_alarms: {\n            hasAccess: false,\n            usageLimit: null,\n            usageCount: undefined,\n            upgradeRequired: 'basic',\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(false);\n\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n          config: { softGate: true },\n        })\n      );\n\n      expect(result.current.hasAccess).toBe(false);\n      expect(result.current.canBypass).toBe(true);\n    });\n\n    it('should manually bypass gate', () => {\n      mockSubscription.userTier = 'free';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'free',\n        features: {\n          unlimited_alarms: {\n            hasAccess: false,\n            usageLimit: null,\n            usageCount: undefined,\n            upgradeRequired: 'basic',\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(false);\n\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n        })\n      );\n\n      expect(result.current.hasAccess).toBe(false);\n\n      act(() => {\n        result.current.bypassGate('testing');\n      });\n\n      expect(result.current.hasAccess).toBe(true);\n      expect(result.current.isGated).toBe(false);\n      expect(result.current.bypassReason).toBe('testing');\n\n      expect(mockAnalytics.trackFeatureUsage).toHaveBeenCalledWith(\n        'feature_gate_bypassed_manual',\n        undefined,\n        {\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n          reason: 'testing',\n        }\n      );\n    });\n  });\n\n  describe('Actions', () => {\n    it('should request access successfully with bypass capability', async () => {\n      mockSubscription.userTier = 'free';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'free',\n        features: {\n          unlimited_alarms: {\n            hasAccess: false,\n            usageLimit: null,\n            usageCount: undefined,\n            upgradeRequired: 'basic',\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(false);\n\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n          config: { softGate: true },\n        })\n      );\n\n      let accessGranted;\n      await act(async () => {\n        accessGranted = await result.current.requestAccess();\n      });\n\n      expect(accessGranted).toBe(true);\n      expect(result.current.hasAccess).toBe(true);\n      expect(result.current.isGated).toBe(false);\n\n      expect(mockAnalytics.trackFeatureUsage).toHaveBeenCalledWith(\n        'feature_gate_bypassed',\n        undefined,\n        {\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n          reason: 'soft_gate',\n        }\n      );\n    });\n\n    it('should fail to request access without bypass capability', async () => {\n      mockSubscription.userTier = 'free';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'free',\n        features: {\n          unlimited_alarms: {\n            hasAccess: false,\n            usageLimit: null,\n            usageCount: undefined,\n            upgradeRequired: 'basic',\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(false);\n\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n        })\n      );\n\n      let accessGranted;\n      await act(async () => {\n        accessGranted = await result.current.requestAccess();\n      });\n\n      expect(accessGranted).toBe(false);\n      expect(result.current.hasAccess).toBe(false);\n\n      expect(mockAnalytics.trackFeatureUsage).toHaveBeenCalledWith(\n        'feature_access_requested',\n        undefined,\n        {\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n          currentTier: 'free',\n          requiredTier: 'basic',\n        }\n      );\n    });\n\n    it('should track feature attempt', () => {\n      mockSubscription.userTier = 'free';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'free',\n        features: {\n          unlimited_alarms: {\n            hasAccess: false,\n            usageLimit: null,\n            usageCount: undefined,\n            upgradeRequired: 'basic',\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(false);\n\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n        })\n      );\n\n      act(() => {\n        result.current.trackFeatureAttempt();\n      });\n\n      expect(mockAnalytics.trackFeatureUsage).toHaveBeenCalledWith(\n        'feature_gate_hit',\n        undefined,\n        {\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n          hasAccess: false,\n          isGated: true,\n          currentTier: 'free',\n          requiredTier: 'basic',\n        }\n      );\n    });\n\n    it('should not track feature attempt when tracking disabled', () => {\n      mockSubscription.userTier = 'free';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'free',\n        features: {\n          unlimited_alarms: {\n            hasAccess: false,\n            usageLimit: null,\n            usageCount: undefined,\n            upgradeRequired: 'basic',\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(false);\n\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n          config: { trackUsage: false },\n        })\n      );\n\n      act(() => {\n        result.current.trackFeatureAttempt();\n      });\n\n      expect(mockAnalytics.trackFeatureUsage).not.toHaveBeenCalledWith(\n        'feature_gate_hit',\n        expect.any(Object),\n        expect.any(Object)\n      );\n    });\n\n    it('should show upgrade modal', () => {\n      mockSubscription.userTier = 'free';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'free',\n        features: {\n          unlimited_alarms: {\n            hasAccess: false,\n            usageLimit: null,\n            usageCount: undefined,\n            upgradeRequired: 'basic',\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(false);\n\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n        })\n      );\n\n      act(() => {\n        result.current.showUpgradeModal();\n      });\n\n      expect(mockAnalytics.trackFeatureUsage).toHaveBeenCalledWith(\n        'upgrade_modal_requested',\n        undefined,\n        {\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n          requiredTier: 'basic',\n        }\n      );\n    });\n\n    it('should not show upgrade modal when redirect disabled', () => {\n      mockSubscription.userTier = 'free';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'free',\n        features: {\n          unlimited_alarms: {\n            hasAccess: false,\n            usageLimit: null,\n            usageCount: undefined,\n            upgradeRequired: 'basic',\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(false);\n\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n          config: { redirectToUpgrade: false },\n        })\n      );\n\n      act(() => {\n        result.current.showUpgradeModal();\n      });\n\n      expect(mockAnalytics.trackFeatureUsage).not.toHaveBeenCalledWith(\n        'upgrade_modal_requested',\n        expect.any(Object),\n        expect.any(Object)\n      );\n    });\n  });\n\n  describe('Callbacks', () => {\n    it('should trigger onAccessDenied callback', () => {\n      const onAccessDenied = jest.fn();\n      const onUpgradeRequired = jest.fn();\n\n      mockSubscription.userTier = 'free';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'free',\n        features: {\n          unlimited_alarms: {\n            hasAccess: false,\n            usageLimit: null,\n            usageCount: undefined,\n            upgradeRequired: 'basic',\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(false);\n\n      renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n          onAccessDenied,\n          onUpgradeRequired,\n        })\n      );\n\n      expect(onAccessDenied).toHaveBeenCalledWith(\n        expect.objectContaining({\n          hasAccess: false,\n          isGated: true,\n          requiredTier: 'basic',\n        })\n      );\n\n      expect(onUpgradeRequired).toHaveBeenCalledWith('basic');\n    });\n\n    it('should not trigger callbacks when access granted', () => {\n      const onAccessDenied = jest.fn();\n      const onUpgradeRequired = jest.fn();\n\n      mockSubscription.userTier = 'basic';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'basic',\n        features: {\n          unlimited_alarms: {\n            hasAccess: true,\n            usageLimit: null,\n            usageCount: undefined,\n            upgradeRequired: null,\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(true);\n\n      renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n          onAccessDenied,\n          onUpgradeRequired,\n        })\n      );\n\n      expect(onAccessDenied).not.toHaveBeenCalled();\n      expect(onUpgradeRequired).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('Feature Definitions', () => {\n    const testCases = [\n      {\n        feature: 'unlimited_alarms',\n        requiredTier: 'basic',\n        message: 'Upgrade to Basic to set unlimited alarms and never miss an important wake-up call!',\n      },\n      {\n        feature: 'smart_scheduling',\n        requiredTier: 'premium',\n        message: 'Upgrade to Premium to unlock AI-powered smart scheduling and optimize your sleep cycles!',\n      },\n      {\n        feature: 'team_features',\n        requiredTier: 'pro',\n        message: 'Upgrade to Pro to create team battles and collaborate with colleagues!',\n      },\n    ];\n\n    testCases.forEach(({ feature, requiredTier, message }) => {\n      it(`should handle ${feature} feature correctly`, () => {\n        mockSubscription.userTier = 'free';\n        mockSubscription.featureAccess = {\n          userId: mockUserId,\n          tier: 'free',\n          features: {\n            [feature]: {\n              hasAccess: false,\n              usageLimit: null,\n              usageCount: undefined,\n            },\n          },\n          lastUpdated: new Date(),\n        };\n        mockSubscription.hasFeatureAccess.mockReturnValue(false);\n\n        const { result } = renderHookWithProviders(() =>\n          useFeatureGate({\n            userId: mockUserId,\n            feature,\n          })\n        );\n\n        expect(result.current.hasAccess).toBe(false);\n        expect(result.current.isGated).toBe(true);\n        expect(result.current.requiredTier).toBe(requiredTier);\n        expect(result.current.upgradeMessage).toBe(message);\n      });\n    });\n  });\n\n  describe('Configuration Options', () => {\n    it('should use custom upgrade message', () => {\n      const customMessage = 'Custom upgrade message for testing';\n\n      mockSubscription.userTier = 'free';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'free',\n        features: {\n          unlimited_alarms: {\n            hasAccess: false,\n            usageLimit: null,\n            usageCount: undefined,\n            upgradeRequired: 'basic',\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(false);\n\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n          config: {\n            customMessage,\n          },\n        })\n      );\n\n      // Note: The current implementation doesn't use customMessage,\n      // but we test the configuration is passed correctly\n      expect(result.current.isGated).toBe(true);\n    });\n\n    it('should handle fallback tier configuration', () => {\n      mockSubscription.userTier = 'free';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'free',\n        features: {},\n        lastUpdated: new Date(),\n      };\n\n      const { result } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n          config: {\n            fallbackTier: 'premium',\n          },\n        })\n      );\n\n      // Configuration is applied but doesn't change the basic gating logic\n      expect(result.current.isGated).toBe(true);\n    });\n  });\n\n  describe('State Updates', () => {\n    it('should update when subscription changes', async () => {\n      mockSubscription.userTier = 'free';\n      mockSubscription.featureAccess = {\n        userId: mockUserId,\n        tier: 'free',\n        features: {\n          unlimited_alarms: {\n            hasAccess: false,\n            usageLimit: null,\n            usageCount: undefined,\n            upgradeRequired: 'basic',\n          },\n        },\n        lastUpdated: new Date(),\n      };\n      mockSubscription.hasFeatureAccess.mockReturnValue(false);\n\n      const { result, rerender } = renderHookWithProviders(() =>\n        useFeatureGate({\n          userId: mockUserId,\n          feature: 'unlimited_alarms',\n        })\n      );\n\n      expect(result.current.hasAccess).toBe(false);\n\n      // Simulate subscription upgrade\n      mockSubscription.userTier = 'basic';\n      mockSubscription.featureAccess.features.unlimited_alarms.hasAccess = true;\n      mockSubscription.hasFeatureAccess.mockReturnValue(true);\n\n      rerender();\n\n      await waitFor(() => {\n        expect(result.current.hasAccess).toBe(true);\n        expect(result.current.isGated).toBe(false);\n      });\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/__tests__/useSubscription.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 144,
        "column": 33,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 144,
        "endColumn": 79
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 145,
        "column": 27,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 145,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 211,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 211,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 266,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 266,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 301,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 301,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 358,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 358,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 413,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 413,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 481,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 481,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 509,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 509,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 621,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 621,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 660,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 660,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 712,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 712,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 740,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 740,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 766,
        "column": 35,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 766,
        "endColumn": 81
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 817,
        "column": 32,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 817,
        "endColumn": 67
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 851,
        "column": 32,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 851,
        "endColumn": 67
      }
    ],
    "suppressedMessages": [],
    "errorCount": 16,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\n/**\n * Unit tests for useSubscription hook\n * Tests subscription management, feature access, billing operations, and premium functionality\n */\n\nimport { renderHook, act, waitFor } from '@testing-library/react';\nimport useSubscription from '../useSubscription';\nimport { renderHookWithProviders, createMockSubscription, clearAllMocks } from '../../__tests__/utils/hook-testing-utils';\nimport type {\n  SubscriptionPlan,\n  FeatureAccess,\n  BillingUsage,\n  PaymentMethod,\n  Invoice,\n  Trial,\n  CreateSubscriptionRequest,\n  UpdateSubscriptionRequest,\n  CancelSubscriptionRequest\n} from '../../types/premium';\n\n// Mock services\njest.mock('../../services/subscription-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: jest.fn(() => ({\n      getSubscriptionDashboard: jest.fn(),\n      getFeatureAccess: jest.fn(),\n      getUserTier: jest.fn(),\n      createSubscription: jest.fn(),\n      updateSubscription: jest.fn(),\n      cancelSubscription: jest.fn(),\n      trackFeatureUsage: jest.fn(),\n      startFreeTrial: jest.fn(),\n      validateDiscountCode: jest.fn(),\n    })),\n  },\n}));\n\njest.mock('../../services/stripe-service', () => ({\n  __esModule: true,\n  default: {\n    getInstance: jest.fn(() => ({\n      addPaymentMethod: jest.fn(),\n      removePaymentMethod: jest.fn(),\n    })),\n  },\n}));\n\njest.mock('../../services/error-handler', () => ({\n  ErrorHandler: {\n    handleError: jest.fn(),\n  },\n}));\n\njest.mock('../../services/analytics', () => ({\n  __esModule: true,\n  default: {\n    getInstance: jest.fn(() => ({\n      trackFeatureUsage: jest.fn(),\n      trackError: jest.fn(),\n    })),\n  },\n}));\n\ndescribe('useSubscription Hook', () => {\n  const mockUserId = 'test-user-123';\n  const mockSubscription = createMockSubscription();\n\n  const mockFeatureAccess: FeatureAccess = {\n    userId: mockUserId,\n    tier: 'premium',\n    features: {\n      'advanced-alarms': {\n        hasAccess: true,\n        usageLimit: 100,\n        usageCount: 50,\n        upgradeRequired: null,\n      },\n      'unlimited-snooze': {\n        hasAccess: true,\n        usageLimit: null,\n        usageCount: undefined,\n        upgradeRequired: null,\n      },\n      'voice-customization': {\n        hasAccess: false,\n        usageLimit: null,\n        usageCount: undefined,\n        upgradeRequired: 'pro',\n      },\n    },\n    lastUpdated: new Date(),\n  };\n\n  const mockPlan: SubscriptionPlan = {\n    id: 'plan_premium',\n    name: 'Premium Plan',\n    tier: 'premium',\n    pricing: {\n      monthly: { amount: 999, currency: 'usd' },\n      yearly: { amount: 9999, currency: 'usd' },\n    },\n    features: ['advanced-alarms', 'unlimited-snooze'],\n    limits: {\n      alarms: 100,\n      customizations: 50,\n    },\n    description: 'Premium features for power users',\n    isPopular: true,\n    trialDays: 7,\n  };\n\n  const mockUsage: BillingUsage = {\n    userId: mockUserId,\n    period: {\n      start: new Date(),\n      end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),\n    },\n    features: {\n      'advanced-alarms': { count: 50, limit: 100 },\n      'api-calls': { count: 1000, limit: 10000 },\n    },\n    totalUsage: 1050,\n    estimatedCost: 999,\n  };\n\n  const mockDashboardData = {\n    subscription: mockSubscription,\n    currentPlan: mockPlan,\n    usage: mockUsage,\n    availablePlans: [mockPlan],\n    paymentMethods: [],\n    invoiceHistory: [],\n    upcomingInvoice: null,\n  };\n\n  beforeEach(() => {\n    clearAllMocks();\n    jest.clearAllTimers();\n    jest.useFakeTimers();\n\n    // Setup default mock implementations\n    const SubscriptionService = require('../../services/subscription-service').default;\n    const StripeService = require('../../services/stripe-service').default;\n\n    const mockSubscriptionService = {\n      getSubscriptionDashboard: jest.fn().mockResolvedValue(mockDashboardData),\n      getFeatureAccess: jest.fn().mockResolvedValue(mockFeatureAccess),\n      createSubscription: jest.fn().mockResolvedValue({\n        success: true,\n        subscription: mockSubscription,\n      }),\n      updateSubscription: jest.fn().mockResolvedValue({ success: true }),\n      cancelSubscription: jest.fn().mockResolvedValue({ success: true }),\n      trackFeatureUsage: jest.fn().mockResolvedValue(true),\n      startFreeTrial: jest.fn().mockResolvedValue({ success: true }),\n      validateDiscountCode: jest.fn().mockResolvedValue({ valid: true }),\n    };\n\n    const mockStripeService = {\n      addPaymentMethod: jest.fn().mockResolvedValue(true),\n      removePaymentMethod: jest.fn().mockResolvedValue(true),\n    };\n\n    SubscriptionService.getInstance.mockReturnValue(mockSubscriptionService);\n    StripeService.getInstance.mockReturnValue(mockStripeService);\n  });\n\n  afterEach(() => {\n    jest.clearAllTimers();\n    jest.useRealTimers();\n  });\n\n  describe('Initialization', () => {\n    it('should initialize with default state', () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      expect(result.current.subscription).toBeNull();\n      expect(result.current.currentPlan).toBeNull();\n      expect(result.current.userTier).toBe('free');\n      expect(result.current.featureAccess).toBeNull();\n      expect(result.current.usage).toBeNull();\n      expect(result.current.isLoading).toBe(false);\n      expect(result.current.isInitialized).toBe(false);\n      expect(result.current.error).toBeNull();\n      expect(result.current.availablePlans).toEqual([]);\n      expect(result.current.paymentMethods).toEqual([]);\n      expect(result.current.invoiceHistory).toEqual([]);\n    });\n\n    it('should load subscription data on initialization', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      expect(result.current.subscription).toEqual(mockSubscription);\n      expect(result.current.currentPlan).toEqual(mockPlan);\n      expect(result.current.userTier).toBe('premium');\n      expect(result.current.featureAccess).toEqual(mockFeatureAccess);\n      expect(result.current.usage).toEqual(mockUsage);\n    });\n\n    it('should handle initialization errors', async () => {\n      const SubscriptionService = require('../../services/subscription-service').default;\n      const mockService = SubscriptionService.getInstance();\n      mockService.getSubscriptionDashboard.mockRejectedValue(new Error('API Error'));\n\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      expect(result.current.error).toBe('Failed to load subscription data. Please refresh the page.');\n      expect(result.current.subscription).toBeNull();\n    });\n\n    it('should not initialize without userId', () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: '' })\n      );\n\n      expect(result.current.isLoading).toBe(false);\n      expect(result.current.isInitialized).toBe(false);\n    });\n  });\n\n  describe('Subscription Creation', () => {\n    it('should create subscription successfully', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      const request: CreateSubscriptionRequest = {\n        planId: 'plan_premium',\n        billingInterval: 'monthly',\n        paymentMethodId: 'pm_123456',\n      };\n\n      let createResult;\n      await act(async () => {\n        createResult = await result.current.createSubscription(request);\n      });\n\n      expect(createResult).toEqual({\n        success: true,\n        requiresAction: false,\n      });\n      expect(result.current.uiState.currentStep).toBe('complete');\n    });\n\n    it('should handle subscription creation with payment action required', async () => {\n      const SubscriptionService = require('../../services/subscription-service').default;\n      const mockService = SubscriptionService.getInstance();\n      mockService.createSubscription.mockResolvedValue({\n        success: true,\n        subscription: mockSubscription,\n        clientSecret: 'pi_123456_secret_xyz',\n      });\n\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      const request: CreateSubscriptionRequest = {\n        planId: 'plan_premium',\n        billingInterval: 'monthly',\n        paymentMethodId: 'pm_123456',\n      };\n\n      let createResult;\n      await act(async () => {\n        createResult = await result.current.createSubscription(request);\n      });\n\n      expect(createResult).toEqual({\n        success: true,\n        requiresAction: true,\n      });\n      expect(result.current.uiState.paymentIntent).toBeDefined();\n    });\n\n    it('should handle subscription creation errors', async () => {\n      const SubscriptionService = require('../../services/subscription-service').default;\n      const mockService = SubscriptionService.getInstance();\n      mockService.createSubscription.mockResolvedValue({\n        success: false,\n        error: 'Payment failed',\n      });\n\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      const request: CreateSubscriptionRequest = {\n        planId: 'plan_premium',\n        billingInterval: 'monthly',\n        paymentMethodId: 'pm_invalid',\n      };\n\n      let createResult;\n      await act(async () => {\n        createResult = await result.current.createSubscription(request);\n      });\n\n      expect(createResult).toEqual({\n        success: false,\n        error: 'Payment failed',\n      });\n      expect(result.current.uiState.errors.general).toBe('Payment failed');\n    });\n  });\n\n  describe('Subscription Updates', () => {\n    it('should update subscription successfully', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      const request: UpdateSubscriptionRequest = {\n        planId: 'plan_pro',\n      };\n\n      let updateResult;\n      await act(async () => {\n        updateResult = await result.current.updateSubscription(request);\n      });\n\n      expect(updateResult).toEqual({ success: true });\n    });\n\n    it('should handle update without active subscription', async () => {\n      const SubscriptionService = require('../../services/subscription-service').default;\n      const mockService = SubscriptionService.getInstance();\n      mockService.getSubscriptionDashboard.mockResolvedValue({\n        ...mockDashboardData,\n        subscription: null,\n      });\n\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      const request: UpdateSubscriptionRequest = {\n        planId: 'plan_pro',\n      };\n\n      let updateResult;\n      await act(async () => {\n        updateResult = await result.current.updateSubscription(request);\n      });\n\n      expect(updateResult).toEqual({\n        success: false,\n        error: 'No active subscription found',\n      });\n    });\n  });\n\n  describe('Subscription Cancellation', () => {\n    it('should cancel subscription successfully', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      const request: CancelSubscriptionRequest = {\n        reason: 'no_longer_needed',\n        feedback: 'Found a different solution',\n      };\n\n      let cancelResult;\n      await act(async () => {\n        cancelResult = await result.current.cancelSubscription(request);\n      });\n\n      expect(cancelResult).toEqual({ success: true });\n    });\n\n    it('should handle cancellation with retention offer', async () => {\n      const SubscriptionService = require('../../services/subscription-service').default;\n      const mockService = SubscriptionService.getInstance();\n      const retentionOffer = {\n        discountPercentage: 50,\n        durationMonths: 3,\n      };\n      mockService.cancelSubscription.mockResolvedValue({\n        success: true,\n        retentionOffer,\n      });\n\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      const request: CancelSubscriptionRequest = {\n        reason: 'too_expensive',\n      };\n\n      let cancelResult;\n      await act(async () => {\n        cancelResult = await result.current.cancelSubscription(request);\n      });\n\n      expect(cancelResult).toEqual({\n        success: true,\n        retentionOffer,\n      });\n    });\n  });\n\n  describe('Feature Access', () => {\n    it('should check feature access correctly', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      // Feature with access\n      expect(result.current.hasFeatureAccess('advanced-alarms')).toBe(true);\n\n      // Feature without access\n      expect(result.current.hasFeatureAccess('voice-customization')).toBe(false);\n\n      // Non-existent feature\n      expect(result.current.hasFeatureAccess('non-existent')).toBe(false);\n    });\n\n    it('should respect usage limits', async () => {\n      const limitedFeatureAccess: FeatureAccess = {\n        ...mockFeatureAccess,\n        features: {\n          'limited-feature': {\n            hasAccess: true,\n            usageLimit: 10,\n            usageCount: 10, // At limit\n            upgradeRequired: null,\n          },\n        },\n      };\n\n      const SubscriptionService = require('../../services/subscription-service').default;\n      const mockService = SubscriptionService.getInstance();\n      mockService.getFeatureAccess.mockResolvedValue(limitedFeatureAccess);\n\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      expect(result.current.hasFeatureAccess('limited-feature')).toBe(false);\n    });\n\n    it('should track feature usage', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      await act(async () => {\n        await result.current.trackFeatureUsage('advanced-alarms', 2);\n      });\n\n      const SubscriptionService = require('../../services/subscription-service').default;\n      const mockService = SubscriptionService.getInstance();\n      expect(mockService.trackFeatureUsage).toHaveBeenCalledWith(\n        mockUserId,\n        'advanced-alarms',\n        2\n      );\n    });\n\n    it('should get upgrade requirement', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      expect(result.current.getUpgradeRequirement('voice-customization')).toBe('pro');\n      expect(result.current.getUpgradeRequirement('advanced-alarms')).toBe(null);\n    });\n  });\n\n  describe('Payment Methods', () => {\n    it('should add payment method', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      let addResult;\n      await act(async () => {\n        addResult = await result.current.addPaymentMethod('pm_123456');\n      });\n\n      expect(addResult).toEqual({ success: true });\n    });\n\n    it('should remove payment method', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      let removeResult;\n      await act(async () => {\n        removeResult = await result.current.removePaymentMethod('pm_123456');\n      });\n\n      expect(removeResult).toEqual({ success: true });\n    });\n\n    it('should set default payment method', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      let setDefaultResult;\n      await act(async () => {\n        setDefaultResult = await result.current.setDefaultPaymentMethod('pm_123456');\n      });\n\n      expect(setDefaultResult).toEqual({ success: true });\n    });\n  });\n\n  describe('Trials and Discounts', () => {\n    it('should start free trial', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      let trialResult;\n      await act(async () => {\n        trialResult = await result.current.startFreeTrial('plan_premium');\n      });\n\n      expect(trialResult).toEqual({ success: true });\n    });\n\n    it('should validate discount code', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      let validationResult;\n      await act(async () => {\n        validationResult = await result.current.validateDiscountCode('SAVE20');\n      });\n\n      expect(validationResult).toEqual({ valid: true });\n    });\n\n    it('should handle invalid discount code', async () => {\n      const SubscriptionService = require('../../services/subscription-service').default;\n      const mockService = SubscriptionService.getInstance();\n      mockService.validateDiscountCode.mockResolvedValue({\n        valid: false,\n        error: 'Invalid discount code',\n      });\n\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      let validationResult;\n      await act(async () => {\n        validationResult = await result.current.validateDiscountCode('INVALID');\n      });\n\n      expect(validationResult).toEqual({\n        valid: false,\n        error: 'Invalid discount code',\n      });\n    });\n  });\n\n  describe('Plan Comparison', () => {\n    it('should compare plans correctly', async () => {\n      const proPlan: SubscriptionPlan = {\n        ...mockPlan,\n        id: 'plan_pro',\n        tier: 'pro',\n        pricing: {\n          monthly: { amount: 1999, currency: 'usd' },\n          yearly: { amount: 19999, currency: 'usd' },\n        },\n      };\n\n      const SubscriptionService = require('../../services/subscription-service').default;\n      const mockService = SubscriptionService.getInstance();\n      mockService.getSubscriptionDashboard.mockResolvedValue({\n        ...mockDashboardData,\n        availablePlans: [mockPlan, proPlan],\n      });\n\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      const comparison = result.current.comparePlans('premium', 'pro');\n\n      expect(comparison.isUpgrade).toBe(true);\n      expect(comparison.isDowngrade).toBe(false);\n      expect(comparison.priceDifference).toBe(1000); // 1999 - 999\n    });\n\n    it('should handle downgrade comparison', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      const comparison = result.current.comparePlans('premium', 'free');\n\n      expect(comparison.isUpgrade).toBe(false);\n      expect(comparison.isDowngrade).toBe(true);\n    });\n  });\n\n  describe('Auto-refresh', () => {\n    it('should auto-refresh subscription data', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({\n          userId: mockUserId,\n          autoRefresh: true,\n          refreshInterval: 1000, // 1 second for testing\n        })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      const SubscriptionService = require('../../services/subscription-service').default;\n      const mockService = SubscriptionService.getInstance();\n\n      // Clear previous calls\n      mockService.getSubscriptionDashboard.mockClear();\n\n      // Fast-forward time to trigger refresh\n      act(() => {\n        jest.advanceTimersByTime(1000);\n      });\n\n      await waitFor(() => {\n        expect(mockService.getSubscriptionDashboard).toHaveBeenCalled();\n      });\n    });\n\n    it('should not auto-refresh when disabled', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({\n          userId: mockUserId,\n          autoRefresh: false,\n        })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      const SubscriptionService = require('../../services/subscription-service').default;\n      const mockService = SubscriptionService.getInstance();\n\n      // Clear previous calls\n      mockService.getSubscriptionDashboard.mockClear();\n\n      // Fast-forward time\n      act(() => {\n        jest.advanceTimersByTime(300000); // 5 minutes\n      });\n\n      // Should not have made additional calls\n      expect(mockService.getSubscriptionDashboard).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('Utility Functions', () => {\n    it('should refresh subscription data manually', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      const SubscriptionService = require('../../services/subscription-service').default;\n      const mockService = SubscriptionService.getInstance();\n\n      // Clear previous calls\n      mockService.getSubscriptionDashboard.mockClear();\n\n      await act(async () => {\n        await result.current.refreshSubscription();\n      });\n\n      expect(mockService.getSubscriptionDashboard).toHaveBeenCalledWith(mockUserId);\n    });\n\n    it('should clear errors', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      act(() => {\n        result.current.clearError();\n      });\n\n      expect(result.current.error).toBeNull();\n    });\n\n    it('should reset UI state', async () => {\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      act(() => {\n        result.current.resetUIState();\n      });\n\n      expect(result.current.uiState.selectedPlan).toBeUndefined();\n      expect(result.current.uiState.isLoading).toBe(false);\n      expect(result.current.uiState.isProcessingPayment).toBe(false);\n      expect(result.current.uiState.currentStep).toBe('plan_selection');\n    });\n  });\n\n  describe('Analytics Integration', () => {\n    it('should track subscription creation success', async () => {\n      const AnalyticsService = require('../../services/analytics').default;\n      const mockAnalytics = { trackFeatureUsage: jest.fn() };\n      AnalyticsService.getInstance.mockReturnValue(mockAnalytics);\n\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId, enableAnalytics: true })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      const request: CreateSubscriptionRequest = {\n        planId: 'plan_premium',\n        billingInterval: 'monthly',\n        paymentMethodId: 'pm_123456',\n      };\n\n      await act(async () => {\n        await result.current.createSubscription(request);\n      });\n\n      expect(mockAnalytics.trackFeatureUsage).toHaveBeenCalledWith(\n        'subscription_created_success',\n        undefined,\n        {\n          userId: mockUserId,\n          planId: 'plan_premium',\n          billingInterval: 'monthly',\n        }\n      );\n    });\n\n    it('should not track when analytics disabled', async () => {\n      const AnalyticsService = require('../../services/analytics').default;\n      const mockAnalytics = { trackFeatureUsage: jest.fn() };\n      AnalyticsService.getInstance.mockReturnValue(mockAnalytics);\n\n      const { result } = renderHookWithProviders(() =>\n        useSubscription({ userId: mockUserId, enableAnalytics: false })\n      );\n\n      await waitFor(() => {\n        expect(result.current.isInitialized).toBe(true);\n      });\n\n      // Analytics should not be initialized when disabled\n      expect(AnalyticsService.getInstance).not.toHaveBeenCalled();\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/useAccessibility.ts",
    "messages": [
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 478,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 478,
        "endColumn": 66,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [12917, 13097],
              "text": "{ event.preventDefault();\n        const nextIndex = (currentFocusIndex + 1) % items.length;\n        setCurrentFocusIndex(nextIndex);\n        items[nextIndex]?.focus();\n        break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 486,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 486,
        "endColumn": 94,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [13153, 13361],
              "text": "{ event.preventDefault();\n        const prevIndex = currentFocusIndex === 0 ? items.length - 1 : currentFocusIndex - 1;\n        setCurrentFocusIndex(prevIndex);\n        items[prevIndex]?.focus();\n        break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 505,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 505,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [13639, 13797],
              "text": "{ event.preventDefault();\n        const lastIndex = items.length - 1;\n        setCurrentFocusIndex(lastIndex);\n        items[lastIndex]?.focus();\n        break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference lib=\"dom\" />\nimport * as React from \"react\";\nimport { useState, useEffect, useCallback, useRef } from \"react\";\nimport AccessibilityPreferencesService, {\n  type AccessibilityPreferences,\n  type AccessibilityState,\n} from '../services/accessibility-preferences';\nimport {\n  createAriaAnnouncement,\n  FocusManager,\n  announcePageChange,\n  isHighContrastMode,\n  prefersReducedMotion,\n  addAccessibleTooltip,\n} from '../utils/accessibility';\n\n/**\n * Main accessibility hook for managing preferences and state\n */\nexport const useAccessibility = () => {\n  const [preferences, setPreferences] = useState<AccessibilityPreferences>({} as AccessibilityPreferences);\n  const [state, setState] = useState<AccessibilityState>({} as AccessibilityState);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const accessibilityService = useRef<AccessibilityPreferencesService>();\n\n  useEffect(() => {\n    accessibilityService.current = AccessibilityPreferencesService.getInstance();\n\n    const initialPreferences = accessibilityService.current.getPreferences();\n    const initialState = accessibilityService.current.getState();\n\n    setPreferences(initialPreferences);\n    setState(initialState);\n    setIsInitialized(true);\n\n    // Subscribe to changes\n    const unsubscribe = accessibilityService.current.subscribe(newPrefs => {\n      setPreferences(newPrefs);\n      setState(accessibilityService.current!.getState());\n    });\n\n    return unsubscribe;\n  }, []);\n\n  const updatePreferences = useCallback((updates: Partial<AccessibilityPreferences>) => {\n    if (accessibilityService.current) {\n      accessibilityService.current.updatePreferences(updates);\n    }\n  }, []);\n\n  const resetToDefaults = useCallback(() => {\n    if (accessibilityService.current) {\n      accessibilityService.current.resetToDefaults();\n    }\n  }, []);\n\n  const testColorContrast = useCallback((foreground: string, background: string) => {\n    if (accessibilityService.current) {\n      return accessibilityService.current.testColorContrast(foreground, background);\n    }\n    return { ratio: 0, wcagAA: false, wcagAAA: false };\n  }, []);\n\n  return {\n    preferences,\n    state,\n    isInitialized,\n    updatePreferences,\n    resetToDefaults,\n    testColorContrast,\n  };\n};\n\n/**\n * Hook for screen reader announcements\n */\nexport const useScreenReader = () => {\n  const { preferences } = useAccessibility();\n\n  const announce = useCallback((\n    message: string,\n    priority: 'polite' | 'assertive' = 'polite'\n  ) => {\n    if (preferences.announceTransitions) {\n      createAriaAnnouncement(message, priority);\n    }\n  }, [preferences.announceTransitions]);\n\n  const announceError = useCallback((message: string) => {\n    if (preferences.announceErrors) {\n      createAriaAnnouncement(`Error: ${message}`, 'assertive');\n    }\n  }, [preferences.announceErrors]);\n\n  const announceSuccess = useCallback((message: string) => {\n    if (preferences.announceSuccess) {\n      createAriaAnnouncement(`Success: ${message}`, 'polite');\n    }\n  }, [preferences.announceSuccess]);\n\n  const announceNavigation = useCallback((pageName: string) => {\n    if (preferences.announceTransitions) {\n      announcePageChange(pageName);\n    }\n  }, [preferences.announceTransitions]);\n\n  return {\n    announce,\n    announceError,\n    announceSuccess,\n    announceNavigation,\n  };\n};\n\n/**\n * Hook for focus management\n */\nexport const useFocusManagement = () => {\n  const { preferences } = useAccessibility();\n  const trapCleanupRef = useRef<(() => void) | null>(null);\n\n  const pushFocus = useCallback((element: HTMLElement) => {\n    if (preferences.keyboardNavigation) {\n      FocusManager.pushFocus(element);\n    }\n  }, [preferences.keyboardNavigation]);\n\n  const popFocus = useCallback(() => {\n    if (preferences.keyboardNavigation) {\n      FocusManager.popFocus();\n    }\n  }, [preferences.keyboardNavigation]);\n\n  const clearFocusStack = useCallback(() => {\n    FocusManager.clearFocusStack();\n  }, []);\n\n  const trapFocus = useCallback((container: HTMLElement) => {\n    if (preferences.keyboardNavigation) {\n      // Clear any existing trap\n      if (trapCleanupRef.current) {\n        trapCleanupRef.current();\n      }\n\n      trapCleanupRef.current = FocusManager.trapFocus(container);\n      return trapCleanupRef.current;\n    }\n    return () => {};\n  }, [preferences.keyboardNavigation]);\n\n  const clearTrap = useCallback(() => {\n    if (trapCleanupRef.current) {\n      trapCleanupRef.current();\n      trapCleanupRef.current = null;\n    }\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      clearTrap();\n    };\n  }, [clearTrap]);\n\n  return {\n    pushFocus,\n    popFocus,\n    clearFocusStack,\n    trapFocus,\n    clearTrap,\n  };\n};\n\n/**\n * Hook for accessible tooltips\n */\nexport const useAccessibleTooltip = () => {\n  const tooltipCleanupRef = useRef<Map<HTMLElement, () => void>>(new Map());\n\n  const addTooltip = useCallback((\n    element: HTMLElement,\n    content: string,\n    options?: {\n      position?: 'top' | 'bottom' | 'left' | 'right';\n      delay?: number;\n    }\n  ) => {\n    // Remove existing tooltip if any\n    const existingCleanup = tooltipCleanupRef.current.get(element);\n    if (existingCleanup) {\n      existingCleanup();\n    }\n\n    // Add new tooltip\n    const cleanup = addAccessibleTooltip(element, content, options);\n    tooltipCleanupRef.current.set(element, cleanup);\n\n    return cleanup;\n  }, []);\n\n  const removeTooltip = useCallback((element: HTMLElement) => {\n    const cleanup = tooltipCleanupRef.current.get(element);\n    if (cleanup) {\n      cleanup();\n      tooltipCleanupRef.current.delete(element);\n    }\n  }, []);\n\n  const removeAllTooltips = useCallback(() => {\n    tooltipCleanupRef.current.forEach(cleanup => cleanup());\n    tooltipCleanupRef.current.clear();\n  }, []);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      removeAllTooltips();\n    };\n  }, [removeAllTooltips]);\n\n  return {\n    addTooltip,\n    removeTooltip,\n    removeAllTooltips,\n  };\n};\n\n/**\n * Hook for mobile accessibility features\n */\nexport const useMobileAccessibility = () => {\n  const { preferences, state } = useAccessibility();\n  const [isVoiceOverActive, setIsVoiceOverActive] = useState(false);\n  const [isTalkBackActive, setIsTalkBackActive] = useState(false);\n\n  useEffect(() => {\n    // Detect iOS VoiceOver\n    const detectVoiceOver = () => {\n      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);\n      const hasVoiceOver = preferences.screenReaderOptimized && isIOS;\n      setIsVoiceOverActive(hasVoiceOver);\n    };\n\n    // Detect Android TalkBack\n    const detectTalkBack = () => {\n      const isAndroid = /Android/.test(navigator.userAgent);\n      const hasTalkBack = preferences.screenReaderOptimized && isAndroid;\n      setIsTalkBackActive(hasTalkBack);\n    };\n\n    detectVoiceOver();\n    detectTalkBack();\n  }, [preferences.screenReaderOptimized]);\n\n  const optimizeForMobileScreenReader = useCallback(() => {\n    if (isVoiceOverActive || isTalkBackActive) {\n      // Apply mobile screen reader optimizations\n      document.body.classList.add('mobile-screen-reader');\n\n      // Increase touch targets\n      document.body.classList.add('a11y-large-touch-targets');\n\n      // Enable enhanced focus\n      document.body.classList.add('a11y-enhanced-focus');\n    }\n  }, [isVoiceOverActive, isTalkBackActive]);\n\n  useEffect(() => {\n    optimizeForMobileScreenReader();\n  }, [optimizeForMobileScreenReader]);\n\n  const getMobileAccessibilityProps = useCallback((elementType: 'button' | 'link' | 'input' | 'select') => {\n    const baseProps = {\n      style: preferences.largerTouchTargets ? {\n        minHeight: '44px',\n        minWidth: '44px',\n        padding: '12px 16px',\n      } : undefined,\n    };\n\n    switch (elementType) {\n      case 'button':\n        return {\n          ...baseProps,\n          'aria-label': undefined, // To be set by component\n          role: 'button' as const,\n          tabIndex: 0,\n        };\n      case 'link':\n        return {\n          ...baseProps,\n          role: 'link' as const,\n          tabIndex: 0,\n        };\n      case 'input':\n        return {\n          ...baseProps,\n          'aria-describedby': undefined, // To be set by component\n          'aria-invalid': false,\n        };\n      case 'select':\n        return {\n          ...baseProps,\n          'aria-expanded': false,\n          'aria-haspopup': 'listbox' as const,\n        };\n      default:\n        return baseProps;\n    }\n  }, [preferences.largerTouchTargets]);\n\n  return {\n    isVoiceOverActive,\n    isTalkBackActive,\n    optimizeForMobileScreenReader,\n    getMobileAccessibilityProps,\n    isMobileScreenReaderActive: isVoiceOverActive || isTalkBackActive,\n    touchDevice: state.touchDevice,\n    hasHover: state.hasHover,\n  };\n};\n\n/**\n * Hook for high contrast mode\n */\nexport const useHighContrast = () => {\n  const { preferences } = useAccessibility();\n  const [systemHighContrast, setSystemHighContrast] = useState(false);\n\n  useEffect(() => {\n    const checkSystemHighContrast = () => {\n      setSystemHighContrast(isHighContrastMode());\n    };\n\n    checkSystemHighContrast();\n\n    // Listen for system changes\n    const mediaQuery = window.matchMedia('(prefers-contrast: high)');\n    const forcedColorsQuery = window.matchMedia('(forced-colors: active)');\n\n    mediaQuery.addEventListener('change', checkSystemHighContrast);\n    forcedColorsQuery.addEventListener('change', checkSystemHighContrast);\n\n    return () => {\n      mediaQuery.removeEventListener('change', checkSystemHighContrast);\n      forcedColorsQuery.removeEventListener('change', checkSystemHighContrast);\n    };\n  }, []);\n\n  const isHighContrastActive = preferences.highContrastMode || systemHighContrast;\n\n  const getHighContrastStyles = useCallback((baseStyles: React.CSSProperties = {}) => {\n    if (!isHighContrastActive) return baseStyles;\n\n    return {\n      ...baseStyles,\n      filter: 'contrast(150%)',\n      border: '1px solid currentColor',\n      outline: '1px solid currentColor',\n    };\n  }, [isHighContrastActive]);\n\n  return {\n    isHighContrastActive,\n    systemHighContrast,\n    userHighContrast: preferences.highContrastMode,\n    getHighContrastStyles,\n  };\n};\n\n/**\n * Hook for reduced motion preferences\n */\nexport const useReducedMotion = () => {\n  const { preferences } = useAccessibility();\n  const [systemReducedMotion, setSystemReducedMotion] = useState(false);\n\n  useEffect(() => {\n    const checkSystemReducedMotion = () => {\n      setSystemReducedMotion(prefersReducedMotion());\n    };\n\n    checkSystemReducedMotion();\n\n    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    mediaQuery.addEventListener('change', checkSystemReducedMotion);\n\n    return () => {\n      mediaQuery.removeEventListener('change', checkSystemReducedMotion);\n    };\n  }, []);\n\n  const shouldReduceMotion = preferences.reducedMotion || systemReducedMotion;\n\n  const getAnimationProps = useCallback((\n    duration: number = 300,\n    easing: string = 'ease-in-out'\n  ) => {\n    if (shouldReduceMotion) {\n      return {\n        transition: 'none',\n        animation: 'none',\n        animationDuration: '0.01ms',\n        transitionDuration: '0.01ms',\n      };\n    }\n\n    return {\n      transitionDuration: `${duration}ms`,\n      transitionTimingFunction: easing,\n    };\n  }, [shouldReduceMotion]);\n\n  return {\n    shouldReduceMotion,\n    systemReducedMotion,\n    userReducedMotion: preferences.reducedMotion,\n    getAnimationProps,\n  };\n};\n\n/**\n * Hook for color blind friendly colors\n */\nexport const useColorBlindFriendly = () => {\n  const { preferences } = useAccessibility();\n\n  const getColorBlindFriendlyColor = useCallback((\n    colorType: 'red' | 'green' | 'blue' | 'orange' | 'purple'\n  ) => {\n    if (!preferences.colorBlindFriendly) {\n      // Return default colors\n      const defaultColors = {\n        red: '#dc2626',\n        green: '#16a34a',\n        blue: '#2563eb',\n        orange: '#ea580c',\n        purple: '#9333ea',\n      };\n      return defaultColors[colorType];\n    }\n\n    // Return color blind friendly alternatives\n    const colorBlindColors = {\n      red: '#d73027',\n      green: '#1a9641',\n      blue: '#313695',\n      orange: '#fdae61',\n      purple: '#762a83',\n    };\n    return colorBlindColors[colorType];\n  }, [preferences.colorBlindFriendly]);\n\n  return {\n    isColorBlindFriendly: preferences.colorBlindFriendly,\n    getColorBlindFriendlyColor,\n  };\n};\n\n/**\n * Hook for keyboard navigation\n */\nexport const useKeyboardNavigation = () => {\n  const { preferences } = useAccessibility();\n  const [currentFocusIndex, setCurrentFocusIndex] = useState(0);\n\n  const handleKeyboardNavigation = useCallback((\n    event: React.KeyboardEvent,\n    items: HTMLElement[],\n    onSelect?: (index: number) => void\n  ) => {\n    if (!preferences.keyboardNavigation) return;\n\n    switch (event.key) {\n      case 'ArrowDown':\n      case 'ArrowRight':\n        event.preventDefault();\n        const nextIndex = (currentFocusIndex + 1) % items.length;\n        setCurrentFocusIndex(nextIndex);\n        items[nextIndex]?.focus();\n        break;\n\n      case 'ArrowUp':\n      case 'ArrowLeft':\n        event.preventDefault();\n        const prevIndex = currentFocusIndex === 0 ? items.length - 1 : currentFocusIndex - 1;\n        setCurrentFocusIndex(prevIndex);\n        items[prevIndex]?.focus();\n        break;\n\n      case 'Enter':\n      case ' ':\n        event.preventDefault();\n        onSelect?.(currentFocusIndex);\n        break;\n\n      case 'Home':\n        event.preventDefault();\n        setCurrentFocusIndex(0);\n        items[0]?.focus();\n        break;\n\n      case 'End':\n        event.preventDefault();\n        const lastIndex = items.length - 1;\n        setCurrentFocusIndex(lastIndex);\n        items[lastIndex]?.focus();\n        break;\n    }\n  }, [preferences.keyboardNavigation, currentFocusIndex]);\n\n  return {\n    isKeyboardNavigationEnabled: preferences.keyboardNavigation,\n    currentFocusIndex,\n    setCurrentFocusIndex,\n    handleKeyboardNavigation,\n  };\n};\n\nexport default {\n  useAccessibility,\n  useScreenReader,\n  useFocusManagement,\n  useAccessibleTooltip,\n  useMobileAccessibility,\n  useHighContrast,\n  useReducedMotion,\n  useColorBlindFriendly,\n  useKeyboardNavigation,\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/useAnalytics.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'analytics' is not defined.",
        "line": 220,
        "column": 7,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 220,
        "endColumn": 16
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback, useEffect, useRef } from 'react';\nimport AnalyticsService, { ANALYTICS_EVENTS, EventProperties, UserProperties } from '../services/analytics';\n\ninterface UseAnalyticsReturn {\n  track: (eventName: string, properties?: EventProperties) => void;\n  trackPageView: (pageName?: string, properties?: EventProperties) => void;\n  trackFeatureUsage: (featureName: string, action: string, properties?: EventProperties) => void;\n  identify: (userId: string, properties?: UserProperties) => void;\n  setUserProperties: (properties: Partial<UserProperties>) => void;\n  incrementProperty: (property: string, value?: number) => void;\n  reset: () => void;\n  isInitialized: boolean;\n}\n\nexport const useAnalytics = (): UseAnalyticsReturn => {\n  const analytics = useRef(AnalyticsService.getInstance());\n  const isInitialized = useRef(false);\n\n  // Initialize analytics on first use\n  useEffect(() => {\n    if (!isInitialized.current) {\n      analytics.current.initialize();\n      isInitialized.current = true;\n    }\n  }, []);\n\n  const track = useCallback((eventName: string, properties?: EventProperties) => {\n    analytics.current.track(eventName, properties);\n  }, []);\n\n  const trackPageView = useCallback((pageName?: string, properties?: EventProperties) => {\n    analytics.current.trackPageView(pageName, properties);\n  }, []);\n\n  const trackFeatureUsage = useCallback((\n    featureName: string,\n    action: string,\n    properties?: EventProperties\n  ) => {\n    analytics.current.trackFeatureUsage(featureName, action, properties);\n  }, []);\n\n  const identify = useCallback((userId: string, properties?: UserProperties) => {\n    analytics.current.identify(userId, properties);\n  }, []);\n\n  const setUserProperties = useCallback((properties: Partial<UserProperties>) => {\n    analytics.current.setUserProperties(properties);\n  }, []);\n\n  const incrementProperty = useCallback((property: string, value?: number) => {\n    analytics.current.incrementProperty(property, value);\n  }, []);\n\n  const reset = useCallback(() => {\n    analytics.current.reset();\n  }, []);\n\n  return {\n    track,\n    trackPageView,\n    trackFeatureUsage,\n    identify,\n    setUserProperties,\n    incrementProperty,\n    reset,\n    isInitialized: isInitialized.current\n  };\n};\n\n// Hook for tracking alarm-specific events\nexport const useAlarmAnalytics = () => {\n  const { track } = useAnalytics();\n\n  const trackAlarmCreated = useCallback((alarmType: string, properties?: EventProperties) => {\n    track(ANALYTICS_EVENTS.ALARM_CREATED, {\n      alarm_type: alarmType,\n      ...properties\n    });\n  }, [track]);\n\n  const trackAlarmTriggered = useCallback((alarmId: string, dismissalMethod?: string, properties?: EventProperties) => {\n    track(ANALYTICS_EVENTS.ALARM_TRIGGERED, {\n      alarm_id: alarmId,\n      dismissal_method: dismissalMethod,\n      ...properties\n    });\n  }, [track]);\n\n  const trackAlarmDismissed = useCallback((alarmId: string, method: string, timeToDismiss: number, properties?: EventProperties) => {\n    track(ANALYTICS_EVENTS.ALARM_DISMISSED, {\n      alarm_id: alarmId,\n      dismissal_method: method,\n      time_to_dismiss: timeToDismiss,\n      ...properties\n    });\n  }, [track]);\n\n  const trackAlarmSnoozed = useCallback((alarmId: string, snoozeCount: number, properties?: EventProperties) => {\n    track(ANALYTICS_EVENTS.ALARM_SNOOZED, {\n      alarm_id: alarmId,\n      snooze_count: snoozeCount,\n      ...properties\n    });\n  }, [track]);\n\n  const trackAlarmMissed = useCallback((alarmId: string, reason: string, properties?: EventProperties) => {\n    track(ANALYTICS_EVENTS.ALARM_MISSED, {\n      alarm_id: alarmId,\n      miss_reason: reason,\n      ...properties\n    });\n  }, [track]);\n\n  return {\n    trackAlarmCreated,\n    trackAlarmTriggered,\n    trackAlarmDismissed,\n    trackAlarmSnoozed,\n    trackAlarmMissed\n  };\n};\n\n// Hook for tracking user engagement\nexport const useEngagementAnalytics = () => {\n  const { track, incrementProperty } = useAnalytics();\n\n  const trackSessionActivity = useCallback(() => {\n    track(ANALYTICS_EVENTS.SESSION_STARTED, {\n      session_start_time: new Date().toISOString(),\n      user_agent: navigator.userAgent,\n      screen_resolution: `${screen.width}x${screen.height}`,\n      viewport_size: `${window.innerWidth}x${window.innerHeight}`,\n      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone\n    });\n  }, [track]);\n\n  const trackFeatureDiscovery = useCallback((featureName: string, discoveryMethod: string) => {\n    track(ANALYTICS_EVENTS.FEATURE_DISCOVERY, {\n      feature_name: featureName,\n      discovery_method: discoveryMethod,\n      timestamp: new Date().toISOString()\n    });\n  }, [track]);\n\n  const trackDailyActive = useCallback(() => {\n    track(ANALYTICS_EVENTS.DAILY_ACTIVE, {\n      date: new Date().toDateString(),\n      timestamp: new Date().toISOString()\n    });\n    incrementProperty('daily_active_count');\n  }, [track, incrementProperty]);\n\n  const trackHelpAccessed = useCallback((helpTopic: string, helpMethod: string) => {\n    track(ANALYTICS_EVENTS.HELP_ACCESSED, {\n      help_topic: helpTopic,\n      access_method: helpMethod,\n      timestamp: new Date().toISOString()\n    });\n  }, [track]);\n\n  return {\n    trackSessionActivity,\n    trackFeatureDiscovery,\n    trackDailyActive,\n    trackHelpAccessed\n  };\n};\n\n// Hook for tracking performance metrics\nexport const usePerformanceAnalytics = () => {\n  const { track } = useAnalytics();\n\n  const trackPageLoadTime = useCallback((pageName: string, loadTime: number) => {\n    track(ANALYTICS_EVENTS.PAGE_LOAD_TIME, {\n      page_name: pageName,\n      load_time: loadTime,\n      timestamp: new Date().toISOString()\n    });\n  }, [track]);\n\n  const trackComponentRenderTime = useCallback((componentName: string, renderTime: number) => {\n    track(ANALYTICS_EVENTS.COMPONENT_RENDER_TIME, {\n      component_name: componentName,\n      render_time: renderTime,\n      timestamp: new Date().toISOString()\n    });\n  }, [track]);\n\n  const trackApiResponseTime = useCallback((endpoint: string, responseTime: number, success: boolean) => {\n    track(ANALYTICS_EVENTS.API_RESPONSE_TIME, {\n      endpoint,\n      response_time: responseTime,\n      success,\n      timestamp: new Date().toISOString()\n    });\n  }, [track]);\n\n  return {\n    trackPageLoadTime,\n    trackComponentRenderTime,\n    trackApiResponseTime\n  };\n};\n\n// Hook for automatic page view tracking\nexport const usePageTracking = (pageName: string) => {\n  const { trackPageView } = useAnalytics();\n\n  useEffect(() => {\n    const startTime = performance.now();\n\n    trackPageView(pageName, {\n      page_entry_time: new Date().toISOString(),\n      referrer: document.referrer\n    });\n\n    return () => {\n      const timeOnPage = performance.now() - startTime;\n      analytics.current.track('page_exit', {\n        page_name: pageName,\n        time_on_page: Math.round(timeOnPage),\n        exit_time: new Date().toISOString()\n      });\n    };\n  }, [pageName, trackPageView]);\n};\n\n// Export analytics events for use in components\nexport { ANALYTICS_EVENTS };",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/useFormAnnouncements.ts",
    "messages": [
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 52,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 52,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [1821, 1928],
              "text": "{ const timeString = formatTime(value);\n        message = `${fieldName} set to ${timeString}`;\n        break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference types=\"node\" />\n// Form-specific screen reader announcement hook\nimport { useCallback, useEffect, useRef } from 'react';\nimport { useScreenReaderAnnouncements } from './useScreenReaderAnnouncements';\nimport type { VoiceMood } from '../types';\nimport { getVoiceMoodConfig, formatTime } from '../utils';\n\nexport interface FormFieldChange {\n  fieldName: string;\n  oldValue?: any;\n  newValue: any;\n  fieldType?: 'text' | 'time' | 'select' | 'toggle' | 'multiselect';\n}\n\nexport function useFormAnnouncements() {\n  const { announce, announceFormValidation } = useScreenReaderAnnouncements();\n  const fieldValues = useRef<Record<string, any>>({});\n  const announcementTimer = useRef<number | null>(null);\n\n  // Announce form field changes with debouncing\n  const announceFieldChange = useCallback((change: FormFieldChange, debounceMs: number = 300) => {\n    const { fieldName, newValue, fieldType = 'text' } = change;\n\n    // Clear existing timer\n    if (announcementTimer.current) {\n      clearTimeout(announcementTimer.current);\n    }\n\n    // Store the new value\n    const oldValue = fieldValues.current[fieldName];\n    fieldValues.current[fieldName] = newValue;\n\n    // Skip announcement if value hasn't actually changed\n    if (oldValue === newValue) return;\n\n    // Debounce announcements for text inputs\n    if (fieldType === 'text' && debounceMs > 0) {\n      announcementTimer.current = setTimeout(() => {\n        announceFieldValue(fieldName, newValue, fieldType);\n      }, debounceMs);\n    } else {\n      // Announce immediately for non-text fields\n      announceFieldValue(fieldName, newValue, fieldType);\n    }\n  }, [announce]);\n\n  const announceFieldValue = useCallback((fieldName: string, value: any, fieldType: string) => {\n    let message = '';\n\n    switch (fieldType) {\n      case 'time':\n        const timeString = formatTime(value);\n        message = `${fieldName} set to ${timeString}`;\n        break;\n      case 'toggle':\n        message = `${fieldName} ${value ? 'selected' : 'deselected'}`;\n        break;\n      case 'multiselect':\n        if (Array.isArray(value)) {\n          const count = value.length;\n          message = count === 0\n            ? `No ${fieldName} selected`\n            : count === 1\n            ? `1 ${fieldName} selected`\n            : `${count} ${fieldName} selected`;\n        }\n        break;\n      case 'select':\n        message = `${fieldName} changed to ${value}`;\n        break;\n      default:\n        if (typeof value === 'string') {\n          if (value.length === 0) {\n            message = `${fieldName} cleared`;\n          } else if (value.length <= 50) {\n            message = `${fieldName}: ${value}`;\n          } else {\n            message = `${fieldName} updated, ${value.length} characters`;\n          }\n        } else {\n          message = `${fieldName} changed to ${value}`;\n        }\n    }\n\n    announce({\n      type: 'custom',\n      message,\n      priority: 'polite'\n    });\n  }, [announce]);\n\n  // Announce day selection changes\n  const announceDayToggle = useCallback((dayName: string, isSelected: boolean, totalSelected: number) => {\n    const selectionStatus = isSelected ? 'selected' : 'deselected';\n    const totalMessage = totalSelected === 0\n      ? 'No days selected'\n      : totalSelected === 1\n      ? '1 day selected'\n      : `${totalSelected} days selected`;\n\n    announce({\n      type: 'custom',\n      message: `${dayName} ${selectionStatus}. ${totalMessage}.`,\n      priority: 'polite'\n    });\n  }, [announce]);\n\n  // Announce voice mood selection\n  const announceVoiceMoodSelection = useCallback((mood: VoiceMood) => {\n    const moodConfig = getVoiceMoodConfig(mood);\n\n    announce({\n      type: 'custom',\n      message: `Voice mood selected: ${moodConfig.name}. ${moodConfig.description}`,\n      priority: 'polite'\n    });\n  }, [announce]);\n\n  // Announce form validation errors with context\n  const announceValidationErrors = useCallback((errors: Record<string, string>) => {\n    const errorKeys = Object.keys(errors);\n    const errorCount = errorKeys.length;\n\n    if (errorCount === 0) return;\n\n    let errorMessage = `Form has ${errorCount} error${errorCount > 1 ? 's' : ''}: `;\n    const errorDescriptions: string[] = [];\n\n    errorKeys.forEach(field => {\n      errorDescriptions.push(`${field} - ${errors[field]}`);\n    });\n\n    errorMessage += errorDescriptions.join(', ');\n\n    announce({\n      type: 'error',\n      message: errorMessage,\n      priority: 'assertive'\n    });\n  }, [announce]);\n\n  // Announce successful form submission\n  const announceFormSuccess = useCallback((action: 'create' | 'update', itemType: string = 'item') => {\n    const actionText = action === 'create' ? 'created' : 'updated';\n    announce({\n      type: 'success',\n      message: `${itemType} ${actionText} successfully.`,\n      priority: 'polite'\n    });\n  }, [announce]);\n\n  // Announce form cancellation\n  const announceFormCancel = useCallback((itemType: string = 'form') => {\n    announce({\n      type: 'custom',\n      message: `${itemType} cancelled. No changes were saved.`,\n      priority: 'polite'\n    });\n  }, [announce]);\n\n  // Announce focus management\n  const announceFocusMove = useCallback((fromField: string, toField: string, reason?: string) => {\n    const reasonText = reason ? ` ${reason}` : '';\n    announce({\n      type: 'custom',\n      message: `Focus moved from ${fromField} to ${toField}${reasonText}`,\n      priority: 'polite'\n    });\n  }, [announce]);\n\n  // Announce when form is ready for input\n  const announceFormReady = useCallback((formTitle: string, isEditing: boolean = false) => {\n    const action = isEditing ? 'editing' : 'creating';\n    announce({\n      type: 'custom',\n      message: `${formTitle} form ready for ${action}. Use tab to navigate between fields.`,\n      priority: 'polite'\n    });\n  }, [announce]);\n\n  // Real-time field validation announcements\n  const announceFieldValidation = useCallback((fieldName: string, isValid: boolean, errorMessage?: string) => {\n    if (!isValid && errorMessage) {\n      announceFormValidation(fieldName, isValid, errorMessage);\n    } else if (isValid) {\n      // Only announce success for fields that were previously invalid\n      const wasInvalid = fieldValues.current[`${fieldName}_invalid`];\n      if (wasInvalid) {\n        announce({\n          type: 'custom',\n          message: `${fieldName} is now valid`,\n          priority: 'polite'\n        });\n        fieldValues.current[`${fieldName}_invalid`] = false;\n      }\n    } else {\n      // Mark field as invalid for future success announcements\n      fieldValues.current[`${fieldName}_invalid`] = true;\n    }\n  }, [announceFormValidation, announce]);\n\n  // Click-to-hear functionality for form fields\n  const announceFieldDescription = useCallback((fieldName: string, value: any, description: string, options?: string) => {\n    const currentValueText = value ? ` Current value: ${value}.` : ' No value set.';\n    const optionsText = options ? ` Available options: ${options}` : '';\n\n    announce({\n      type: 'custom',\n      message: `${fieldName}.${currentValueText} ${description}${optionsText}`,\n      priority: 'polite'\n    });\n  }, [announce]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      if (announcementTimer.current) {\n        clearTimeout(announcementTimer.current);\n      }\n    };\n  }, []);\n\n  return {\n    announceFieldChange,\n    announceDayToggle,\n    announceVoiceMoodSelection,\n    announceValidationErrors,\n    announceFormSuccess,\n    announceFormCancel,\n    announceFocusMove,\n    announceFormReady,\n    announceFieldValidation,\n    announceFieldDescription\n  };\n}\n\nexport default useFormAnnouncements;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/useGamingAnnouncements.ts",
    "messages": [
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 260,
        "column": 7,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 260,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [8650, 8819],
              "text": "{ const levelData = data as Partial<PlayerLevel>;\n      return `Level up! You are now level ${levelData.current}. ${levelData.experienceToNext} XP needed for next level.`; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 263,
        "column": 7,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 263,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [8848, 8975],
              "text": "{ const xpData = data as ExperienceGain;\n      return `${xpData.amount} XP gained from ${xpData.source}. ${xpData.reason || ''}`; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 314,
        "column": 7,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 314,
        "endColumn": 64,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [10680, 10836],
              "text": "{ const percentage = Math.round((progress / target) * 100);\n      return `Quest progress: ${questTitle} - ${percentage}% complete (${progress} of ${target})`; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Gaming-specific Screen Reader Announcements\n// Extends the base screen reader system with gaming features\nimport { useCallback, useEffect, useRef } from 'react';\nimport { useScreenReaderAnnouncements } from './useScreenReaderAnnouncements';\nimport type {\n  Battle,\n  Achievement,\n  User as UserType,\n  Reward,\n  Quest,\n  DailyChallenge,\n  WeeklyChallenge,\n  PlayerLevel,\n  ExperienceGain,\n  BattleType\n} from '../types';\n\ninterface GamingAnnouncement {\n  type: 'battle' | 'achievement' | 'level' | 'friend' | 'reward' | 'quest' | 'leaderboard' | 'tournament' | 'xp-gain';\n  action?: string;\n  data?: any;\n  priority?: 'polite' | 'assertive';\n  customMessage?: string;\n}\n\nexport function useGamingAnnouncements(enabled = true) {\n  const { announce } = useScreenReaderAnnouncements({ enabled });\n  const previousValues = useRef<Record<string, any>>({});\n\n  const announceGaming = useCallback((announcement: GamingAnnouncement) => {\n    if (!enabled) return;\n\n    const { type, action, data, priority = 'polite', customMessage } = announcement;\n    let message = customMessage || '';\n\n    switch (type) {\n      case 'battle':\n        message = formatBattleAnnouncement(action!, data);\n        break;\n      case 'achievement':\n        message = formatAchievementAnnouncement(action!, data);\n        break;\n      case 'level':\n        message = formatLevelAnnouncement(action!, data);\n        break;\n      case 'friend':\n        message = formatFriendAnnouncement(action!, data);\n        break;\n      case 'reward':\n        message = formatRewardAnnouncement(action!, data);\n        break;\n      case 'quest':\n        message = formatQuestAnnouncement(action!, data);\n        break;\n      case 'leaderboard':\n        message = formatLeaderboardAnnouncement(action!, data);\n        break;\n      case 'tournament':\n        message = formatTournamentAnnouncement(action!, data);\n        break;\n      case 'xp-gain':\n        message = formatXpGainAnnouncement(data);\n        break;\n    }\n\n    if (message) {\n      announce({\n        type: 'custom',\n        message,\n        priority\n      });\n    }\n  }, [enabled, announce]);\n\n  // Battle announcements\n  const announceBattleEvent = useCallback((action: 'created' | 'joined' | 'started' | 'won' | 'lost' | 'ended', battleData: Partial<Battle>) => {\n    announceGaming({\n      type: 'battle',\n      action,\n      data: battleData,\n      priority: action === 'won' || action === 'lost' ? 'assertive' : 'polite'\n    });\n  }, [announceGaming]);\n\n  // Achievement announcements\n  const announceAchievement = useCallback((action: 'unlocked' | 'progress' | 'completed', achievementData: Partial<Achievement>) => {\n    announceGaming({\n      type: 'achievement',\n      action,\n      data: achievementData,\n      priority: action === 'unlocked' ? 'assertive' : 'polite'\n    });\n  }, [announceGaming]);\n\n  // Level/XP announcements\n  const announceLevelChange = useCallback((action: 'level-up' | 'xp-gained', levelData: Partial<PlayerLevel> | ExperienceGain) => {\n    announceGaming({\n      type: 'level',\n      action,\n      data: levelData,\n      priority: action === 'level-up' ? 'assertive' : 'polite'\n    });\n  }, [announceGaming]);\n\n  // Friend system announcements\n  const announceFriendEvent = useCallback((action: 'added' | 'request-sent' | 'request-received' | 'removed', friendData: Partial<UserType>) => {\n    announceGaming({\n      type: 'friend',\n      action,\n      data: friendData,\n      priority: 'polite'\n    });\n  }, [announceGaming]);\n\n  // Reward announcements\n  const announceRewardEvent = useCallback((action: 'claimed' | 'available' | 'expired', rewardData: Partial<Reward>) => {\n    announceGaming({\n      type: 'reward',\n      action,\n      data: rewardData,\n      priority: action === 'claimed' ? 'assertive' : 'polite'\n    });\n  }, [announceGaming]);\n\n  // Quest announcements\n  const announceQuestEvent = useCallback((action: 'started' | 'completed' | 'progress' | 'failed', questData: Partial<Quest>) => {\n    announceGaming({\n      type: 'quest',\n      action,\n      data: questData,\n      priority: action === 'completed' ? 'assertive' : 'polite'\n    });\n  }, [announceGaming]);\n\n  // Leaderboard announcements\n  const announceLeaderboardChange = useCallback((action: 'rank-up' | 'rank-down' | 'new-record', leaderboardData: { oldRank?: number; newRank: number; score?: number }) => {\n    announceGaming({\n      type: 'leaderboard',\n      action,\n      data: leaderboardData,\n      priority: 'polite'\n    });\n  }, [announceGaming]);\n\n  // Tournament announcements\n  const announceTournamentEvent = useCallback((action: 'joined' | 'eliminated' | 'advanced' | 'won', tournamentData: any) => {\n    announceGaming({\n      type: 'tournament',\n      action,\n      data: tournamentData,\n      priority: action === 'won' ? 'assertive' : 'polite'\n    });\n  }, [announceGaming]);\n\n  // Auto-tracking for common state changes\n  const trackBattleCount = useCallback((battles: Battle[]) => {\n    const activeBattleCount = battles.filter(b => b.status === 'active').length;\n    const previousCount = previousValues.current.activeBattles || 0;\n\n    if (previousCount !== activeBattleCount && previousCount > 0) {\n      const difference = activeBattleCount - previousCount;\n      if (difference > 0) {\n        announceGaming({\n          type: 'battle',\n          customMessage: `${difference} new battle${difference > 1 ? 's' : ''} available`,\n          priority: 'polite'\n        });\n      }\n    }\n    previousValues.current.activeBattles = activeBattleCount;\n  }, [announceGaming]);\n\n  const trackAchievements = useCallback((achievements: Achievement[]) => {\n    const unlockedCount = achievements.filter(a => a.unlockedAt).length;\n    const previousCount = previousValues.current.achievements || 0;\n\n    if (unlockedCount > previousCount && previousCount > 0) {\n      const newAchievements = unlockedCount - previousCount;\n      announceGaming({\n        type: 'achievement',\n        customMessage: `${newAchievements} new achievement${newAchievements > 1 ? 's' : ''} unlocked!`,\n        priority: 'assertive'\n      });\n    }\n    previousValues.current.achievements = unlockedCount;\n  }, [announceGaming]);\n\n  return {\n    announceGaming,\n    announceBattleEvent,\n    announceAchievement,\n    announceLevelChange,\n    announceFriendEvent,\n    announceRewardEvent,\n    announceQuestEvent,\n    announceLeaderboardChange,\n    announceTournamentEvent,\n    trackBattleCount,\n    trackAchievements\n  };\n}\n\n// Helper functions for formatting announcements\n\nfunction formatBattleAnnouncement(action: string, data: Partial<Battle>): string {\n  const battleTypeNames: Record<BattleType, string> = {\n    speed: 'Speed Battle',\n    consistency: 'Consistency Challenge',\n    tasks: 'Task Master',\n    bragging: 'Bragging Rights',\n    group: 'Group Battle',\n    tournament: 'Tournament Battle'\n  };\n\n  const battleName = data.type ? battleTypeNames[data.type] : 'Battle';\n  const participantCount = data.participants?.length || 0;\n\n  switch (action) {\n    case 'created':\n      return `${battleName} created with ${participantCount} participants. Battle starts soon.`;\n    case 'joined':\n      return `Joined ${battleName}. ${participantCount} participants total.`;\n    case 'started':\n      return `${battleName} has started! Good luck!`;\n    case 'won':\n      return `Victory! You won the ${battleName}! Congratulations!`;\n    case 'lost':\n      return `${battleName} ended. Better luck next time!`;\n    case 'ended':\n      return `${battleName} has concluded. Check results for final standings.`;\n    default:\n      return `${battleName} event: ${action}`;\n  }\n}\n\nfunction formatAchievementAnnouncement(action: string, data: Partial<Achievement>): string {\n  const achievementName = data.name || 'Achievement';\n  const rarity = data.rarity || 'common';\n  const rarityText = rarity === 'common' ? '' : ` ${rarity} `;\n\n  switch (action) {\n    case 'unlocked':\n      return `Achievement unlocked! ${achievementName}${rarityText ? ` - ${rarityText}rarity` : ''}. ${data.description || ''}`;\n    case 'progress':\n      if (data.progress) {\n        const percentage = Math.round((data.progress.current / data.progress.target) * 100);\n        return `Achievement progress: ${achievementName} - ${percentage}% complete (${data.progress.current} of ${data.progress.target})`;\n      }\n      return `Progress made on ${achievementName}`;\n    case 'completed':\n      return `Achievement completed: ${achievementName}! Rewards claimed.`;\n    default:\n      return `${achievementName}: ${action}`;\n  }\n}\n\nfunction formatLevelAnnouncement(action: string, data: any): string {\n  switch (action) {\n    case 'level-up':\n      const levelData = data as Partial<PlayerLevel>;\n      return `Level up! You are now level ${levelData.current}. ${levelData.experienceToNext} XP needed for next level.`;\n    case 'xp-gained':\n      const xpData = data as ExperienceGain;\n      return `${xpData.amount} XP gained from ${xpData.source}. ${xpData.reason || ''}`;\n    default:\n      return `Level event: ${action}`;\n  }\n}\n\nfunction formatFriendAnnouncement(action: string, data: Partial<UserType>): string {\n  const friendName = data.displayName || data.username || 'Friend';\n\n  switch (action) {\n    case 'added':\n      return `${friendName} added to friends list. Level ${data.level || 'unknown'}.`;\n    case 'request-sent':\n      return `Friend request sent to ${friendName}.`;\n    case 'request-received':\n      return `Friend request received from ${friendName}. Level ${data.level || 'unknown'}.`;\n    case 'removed':\n      return `${friendName} removed from friends list.`;\n    default:\n      return `Friend event with ${friendName}: ${action}`;\n  }\n}\n\nfunction formatRewardAnnouncement(action: string, data: Partial<Reward>): string {\n  const rewardTitle = data.title || 'Reward';\n  const rarity = data.rarity || 'common';\n\n  switch (action) {\n    case 'claimed':\n      return `Reward claimed: ${rewardTitle}${rarity !== 'common' ? ` (${rarity} rarity)` : ''}. ${data.description || ''}`;\n    case 'available':\n      return `New reward available: ${rewardTitle}. ${data.description || ''}`;\n    case 'expired':\n      return `Reward expired: ${rewardTitle}`;\n    default:\n      return `Reward event: ${rewardTitle} - ${action}`;\n  }\n}\n\nfunction formatQuestAnnouncement(action: string, data: Partial<Quest>): string {\n  const questTitle = data.title || 'Quest';\n  const progress = data.progress || 0;\n  const target = data.target || 1;\n\n  switch (action) {\n    case 'started':\n      return `Quest started: ${questTitle}. ${data.description || ''}`;\n    case 'completed':\n      return `Quest completed: ${questTitle}! Rewards earned.`;\n    case 'progress':\n      const percentage = Math.round((progress / target) * 100);\n      return `Quest progress: ${questTitle} - ${percentage}% complete (${progress} of ${target})`;\n    case 'failed':\n      return `Quest failed: ${questTitle}. Try again next time.`;\n    default:\n      return `Quest event: ${questTitle} - ${action}`;\n  }\n}\n\nfunction formatLeaderboardAnnouncement(action: string, data: { oldRank?: number; newRank: number; score?: number }): string {\n  switch (action) {\n    case 'rank-up':\n      return `Leaderboard rank improved! Moved from rank ${data.oldRank} to rank ${data.newRank}.`;\n    case 'rank-down':\n      return `Leaderboard rank changed. Now rank ${data.newRank}${data.oldRank ? ` (was rank ${data.oldRank})` : ''}.`;\n    case 'new-record':\n      return `New personal best! Score: ${data.score}. Rank: ${data.newRank}.`;\n    default:\n      return `Leaderboard update: rank ${data.newRank}`;\n  }\n}\n\nfunction formatTournamentAnnouncement(action: string, data: any): string {\n  const tournamentName = data.name || 'Tournament';\n\n  switch (action) {\n    case 'joined':\n      return `Joined ${tournamentName}. ${data.participantCount || ''} participants registered.`;\n    case 'eliminated':\n      return `Eliminated from ${tournamentName}. Great effort!`;\n    case 'advanced':\n      return `Advanced to the next round in ${tournamentName}!`;\n    case 'won':\n      return `Tournament victory! You won ${tournamentName}! Congratulations, champion!`;\n    default:\n      return `Tournament event: ${tournamentName} - ${action}`;\n  }\n}\n\nfunction formatXpGainAnnouncement(data: ExperienceGain): string {\n  return `${data.amount} XP earned from ${data.source}. ${data.reason || 'Keep up the great work!'}`;\n}\n\nexport default useGamingAnnouncements;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/hooks/useSmartFeaturesAnnouncements.ts",
    "messages": [
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 56,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 56,
        "endColumn": 91,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [2433, 2650],
              "text": "{ const xpReward = challenge.rewards.find(r => r.type === 'experience')?.value || 0;\n        message = `Congratulations! Challenge completed: ${challenge.name}. You earned ${xpReward} experience points!`;\n        break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { useCallback } from 'react';\nimport { useScreenReaderAnnouncements } from './useScreenReaderAnnouncements';\nimport type {\n  WeatherData,\n  LocationChallenge,\n  FitnessIntegration,\n  FitnessChallenge,\n  SmartAlarmSettings\n} from '../types/index';\n\nexport function useSmartFeaturesAnnouncements() {\n  const { announce } = useScreenReaderAnnouncements();\n\n  // Tab navigation announcements\n  const announceTabChange = useCallback((tabName: string) => {\n    const tabDescriptions: Record<string, string> = {\n      weather: 'Weather tab selected. View weather-smart alarm features and forecasts.',\n      location: 'Location tab selected. Manage location-based challenges and track progress.',\n      fitness: 'Fitness tab selected. View fitness data, connected apps, and active challenges.',\n      settings: 'Settings tab selected. Configure smart alarm features and privacy settings.'\n    };\n\n    const description = tabDescriptions[tabName] || `${tabName} tab selected`;\n    announce(description, 'polite');\n  }, [announce]);\n\n  // Weather announcements\n  const announceWeatherUpdate = useCallback((weatherData: WeatherData) => {\n    const condition = weatherData.condition.replace('_', ' ');\n    announce(\n      `Weather updated. Currently ${weatherData.temperature} degrees celsius and ${condition} in ${weatherData.location}. Humidity at ${weatherData.humidity} percent.`,\n      'polite'\n    );\n  }, [announce]);\n\n  const announceWeatherAdjustment = useCallback((adjustment: { type: string; message: string; timeChange?: number }) => {\n    let message = `Smart alarm adjustment: ${adjustment.message}`;\n    if (adjustment.timeChange) {\n      message += ` Your alarm will ring ${Math.abs(adjustment.timeChange)} minutes ${adjustment.timeChange > 0 ? 'later' : 'earlier'}.`;\n    }\n    announce(message, 'assertive');\n  }, [announce]);\n\n  // Location challenge announcements\n  const announceLocationChallengeStatus = useCallback((challenge: LocationChallenge, action: 'created' | 'started' | 'completed' | 'failed' | 'updated') => {\n    let message = '';\n\n    switch (action) {\n      case 'created':\n        message = `New location challenge created: ${challenge.name}. ${challenge.description}`;\n        break;\n      case 'started':\n        message = `Location challenge started: ${challenge.name}. Navigate to ${challenge.targetLocation.name} within ${challenge.radius} meters.`;\n        break;\n      case 'completed':\n        const xpReward = challenge.rewards.find(r => r.type === 'experience')?.value || 0;\n        message = `Congratulations! Challenge completed: ${challenge.name}. You earned ${xpReward} experience points!`;\n        break;\n      case 'failed':\n        message = `Challenge expired: ${challenge.name}. Try again tomorrow for another chance!`;\n        break;\n      case 'updated':\n        message = `Challenge progress updated: ${challenge.name}. You are ${challenge.progress.distanceToTarget} meters away from the target.`;\n        break;\n    }\n\n    announce(message, action === 'completed' ? 'assertive' : 'polite');\n  }, [announce]);\n\n  const announceLocationProgress = useCallback((challenge: LocationChallenge) => {\n    const distance = challenge.progress.distanceToTarget;\n    const timeInRadius = challenge.progress.timeInRadius || 0;\n\n    let message = `${challenge.name} progress update.`;\n\n    if (distance <= challenge.radius) {\n      message += ` You are now within the target area! `;\n      if (challenge.type === 'stay_duration') {\n        message += `You have been in the area for ${timeInRadius} minutes.`;\n      }\n    } else {\n      message += ` You are ${distance} meters away from the target location.`;\n    }\n\n    announce(message, 'polite');\n  }, [announce]);\n\n  // Fitness announcements\n  const announceFitnessDataUpdate = useCallback((data: { steps: number; sleepHours: number; activeMinutes: number; distance: number }) => {\n    announce(\n      `Fitness data updated. Today you have taken ${data.steps.toLocaleString()} steps, slept for ${data.sleepHours} hours, been active for ${data.activeMinutes} minutes, and traveled ${(data.distance / 1000).toFixed(1)} kilometers.`,\n      'polite'\n    );\n  }, [announce]);\n\n  const announceFitnessIntegration = useCallback((integration: FitnessIntegration, action: 'connected' | 'disconnected' | 'synced') => {\n    const providerName = integration.provider.replace('_', ' ');\n    let message = '';\n\n    switch (action) {\n      case 'connected':\n        message = `${providerName} successfully connected! Your fitness data will now sync automatically.`;\n        break;\n      case 'disconnected':\n        message = `${providerName} has been disconnected. Fitness challenges may not track automatically.`;\n        break;\n      case 'synced':\n        message = `${providerName} data synchronized. Last sync completed at ${new Date(integration.lastSync).toLocaleTimeString()}.`;\n        break;\n    }\n\n    announce(message, 'polite');\n  }, [announce]);\n\n  const announceFitnessChallengeProgress = useCallback((challenge: FitnessChallenge) => {\n    const progressPercent = Math.round((challenge.currentValue / challenge.targetValue) * 100);\n    const remainingValue = challenge.targetValue - challenge.currentValue;\n\n    let message = `${challenge.name} progress update. You are ${progressPercent} percent complete with ${remainingValue.toLocaleString()} ${challenge.unit} remaining.`;\n\n    if (challenge.completed) {\n      const xpReward = challenge.rewards.find(r => r.type === 'experience')?.value || 0;\n      message += ` Challenge completed! You earned ${xpReward} experience points.`;\n    } else if (progressPercent >= 75) {\n      message += ` You are almost there! Keep going!`;\n    } else if (progressPercent >= 50) {\n      message += ` You are halfway to your goal!`;\n    }\n\n    announce(message, challenge.completed ? 'assertive' : 'polite');\n  }, [announce]);\n\n  // Settings announcements\n  const announceSettingChange = useCallback((settingName: string, newValue: boolean | number, description: string) => {\n    let message = '';\n\n    if (typeof newValue === 'boolean') {\n      message = `${settingName} ${newValue ? 'enabled' : 'disabled'}. ${description}`;\n    } else {\n      message = `${settingName} set to ${newValue}. ${description}`;\n    }\n\n    announce(message, 'polite');\n  }, [announce]);\n\n  const announcePermissionStatus = useCallback((permission: string, status: 'granted' | 'denied' | 'required') => {\n    let message = '';\n\n    switch (status) {\n      case 'granted':\n        message = `${permission} permission granted. Smart features are now available.`;\n        break;\n      case 'denied':\n        message = `${permission} permission denied. Some smart features may not work properly.`;\n        break;\n      case 'required':\n        message = `${permission} permission is required for optimal smart alarm functionality.`;\n        break;\n    }\n\n    announce(message, status === 'denied' ? 'assertive' : 'polite');\n  }, [announce]);\n\n  // Challenge creation announcements\n  const announceCreateChallenge = useCallback(() => {\n    announce('Creating new location challenge. Configure your challenge settings and save to activate.', 'polite');\n  }, [announce]);\n\n  const announceConnectFitnessApp = useCallback((provider: string) => {\n    announce(`Connecting to ${provider.replace('_', ' ')}. Please follow the authentication process to link your account.`, 'polite');\n  }, [announce]);\n\n  // Navigation announcements\n  const announceNavigateToChallenge = useCallback((challengeName: string, targetLocation: string) => {\n    announce(`Opening navigation to ${targetLocation} for challenge: ${challengeName}. Follow the directions to reach your destination.`, 'assertive');\n  }, [announce]);\n\n  // Click-to-hear functionality for detailed information\n  const announceDetailedWeather = useCallback((weatherData: WeatherData) => {\n    const forecast = weatherData.forecast.map(f =>\n      `${f.time}: ${f.temperature} degrees, ${f.condition.replace('_', ' ')}${f.precipitation > 0 ? `, ${f.precipitation} percent chance of rain` : ''}`\n    ).join('. ');\n\n    announce(\n      `Detailed weather information. Currently ${weatherData.temperature} degrees celsius and ${weatherData.condition.replace('_', ' ')} in ${weatherData.location}. Humidity ${weatherData.humidity} percent, wind speed ${weatherData.windSpeed} kilometers per hour. Tomorrow's forecast: ${forecast}`,\n      'polite'\n    );\n  }, [announce]);\n\n  const announceDetailedChallenge = useCallback((challenge: LocationChallenge) => {\n    let message = `Detailed challenge information for ${challenge.name}. ${challenge.description}. `;\n\n    message += `Challenge type: ${challenge.type.replace('_', ' ')}. `;\n    message += `Target location: ${challenge.targetLocation.name}. `;\n    message += `Required radius: ${challenge.radius} meters. `;\n\n    if (challenge.timeLimit) {\n      message += `Time limit: ${challenge.timeLimit} minutes. `;\n    }\n\n    const rewards = challenge.rewards.map(r => `${r.value} ${r.description}`).join(', ');\n    message += `Rewards: ${rewards}. `;\n\n    message += `Current status: ${challenge.status}. `;\n    message += `Distance to target: ${challenge.progress.distanceToTarget} meters.`;\n\n    announce(message, 'polite');\n  }, [announce]);\n\n  const announceDetailedFitnessChallenge = useCallback((challenge: FitnessChallenge) => {\n    const progressPercent = Math.round((challenge.currentValue / challenge.targetValue) * 100);\n    const remainingValue = challenge.targetValue - challenge.currentValue;\n\n    let message = `Detailed fitness challenge: ${challenge.name}. ${challenge.description}. `;\n    message += `Difficulty: ${challenge.difficulty}. `;\n    message += `Target: ${challenge.targetValue.toLocaleString()} ${challenge.unit}. `;\n    message += `Current progress: ${challenge.currentValue.toLocaleString()} ${challenge.unit}, which is ${progressPercent} percent complete. `;\n    message += `Remaining: ${remainingValue.toLocaleString()} ${challenge.unit}. `;\n\n    const rewards = challenge.rewards.map(r => `${r.value} ${r.description}`).join(', ');\n    message += `Rewards: ${rewards}. `;\n\n    if (challenge.expiresAt) {\n      const expiresAt = new Date(challenge.expiresAt);\n      message += `Expires at ${expiresAt.toLocaleString()}.`;\n    }\n\n    announce(message, 'polite');\n  }, [announce]);\n\n  return {\n    announceTabChange,\n    announceWeatherUpdate,\n    announceWeatherAdjustment,\n    announceLocationChallengeStatus,\n    announceLocationProgress,\n    announceFitnessDataUpdate,\n    announceFitnessIntegration,\n    announceFitnessChallengeProgress,\n    announceSettingChange,\n    announcePermissionStatus,\n    announceCreateChallenge,\n    announceConnectFitnessApp,\n    announceNavigateToChallenge,\n    announceDetailedWeather,\n    announceDetailedChallenge,\n    announceDetailedFitnessChallenge\n  };\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/__tests__/analytics.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 353,
        "column": 30,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 353,
        "endColumn": 65
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\nimport AnalyticsService, { ANALYTICS_EVENTS } from \"../analytics\";\nimport { config } from \"../../config/environment\";\n\n// Mock PostHog\nconst mockPostHog = {\n  init: jest.fn(),\n  identify: jest.fn(),\n  reset: jest.fn(),\n  capture: jest.fn(),\n  people: {\n    set: jest.fn(),\n    increment: jest.fn()\n  },\n  register: jest.fn(),\n  getFeatureFlag: jest.fn(),\n  startSessionRecording: jest.fn(),\n  stopSessionRecording: jest.fn()\n};\n\njest.mock('posthog-js', () => mockPostHog);\n\ndescribe('AnalyticsService', () => {\n  let analytics: AnalyticsService;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    analytics = AnalyticsService.getInstance();\n  });\n\n  afterEach(() => {\n    localStorage.clear();\n    // Reset singleton instance for clean tests\n    (AnalyticsService as any).instance = undefined;\n  });\n\n  describe('Initialization', () => {\n    it('should initialize PostHog with correct configuration', () => {\n      analytics.initialize();\n\n      expect(mockPostHog.init).toHaveBeenCalledWith(\n        expect.any(String),\n        expect.objectContaining({\n          api_host: expect.any(String),\n          debug: expect.any(Boolean),\n          respect_dnt: true,\n          capture_pageview: true,\n          capture_pageleave: true,\n          autocapture: expect.any(Boolean)\n        })\n      );\n    });\n\n    it('should not initialize twice', () => {\n      analytics.initialize();\n      analytics.initialize();\n\n      expect(mockPostHog.init).toHaveBeenCalledTimes(1);\n    });\n\n    it('should skip initialization in test environment', () => {\n      const originalEnv = process.env.NODE_ENV;\n      process.env.NODE_ENV = 'test';\n\n      analytics.initialize();\n\n      expect(mockPostHog.init).not.toHaveBeenCalled();\n      process.env.NODE_ENV = originalEnv;\n    });\n\n    it('should track app launch event on initialization', () => {\n      analytics.initialize();\n\n      expect(mockPostHog.capture).toHaveBeenCalledWith(\n        ANALYTICS_EVENTS.APP_LAUNCHED,\n        expect.objectContaining({\n          environment: expect.any(String),\n          timestamp: expect.any(String)\n        })\n      );\n    });\n  });\n\n  describe('User Identification', () => {\n    beforeEach(() => {\n      analytics.initialize();\n      jest.clearAllMocks();\n    });\n\n    it('should identify user with correct properties', () => {\n      const userId = 'user123';\n      const properties = {\n        id: userId,\n        email: 'user@example.com',\n        username: 'testuser',\n        createdAt: '2024-01-01T00:00:00Z',\n        totalAlarms: 5,\n        isSubscribed: true\n      };\n\n      analytics.identify(userId, properties);\n\n      expect(mockPostHog.identify).toHaveBeenCalledWith(\n        userId,\n        expect.objectContaining({\n          email: properties.email,\n          username: properties.username,\n          created_at: properties.createdAt,\n          total_alarms: properties.totalAlarms,\n          is_subscribed: properties.isSubscribed\n        })\n      );\n    });\n\n    it('should reset user identity', () => {\n      analytics.reset();\n\n      expect(mockPostHog.reset).toHaveBeenCalled();\n    });\n  });\n\n  describe('Event Tracking', () => {\n    beforeEach(() => {\n      analytics.initialize();\n      jest.clearAllMocks();\n    });\n\n    it('should track events with enhanced properties', () => {\n      const eventName = 'test_event';\n      const properties = {\n        category: 'test',\n        value: 100\n      };\n\n      analytics.track(eventName, properties);\n\n      expect(mockPostHog.capture).toHaveBeenCalledWith(\n        eventName,\n        expect.objectContaining({\n          ...properties,\n          timestamp: expect.any(String),\n          session_id: expect.any(String),\n          source: 'web'\n        })\n      );\n    });\n\n    it('should track page views with contextual information', () => {\n      const pageName = 'dashboard';\n      const properties = { user_role: 'admin' };\n\n      analytics.trackPageView(pageName, properties);\n\n      expect(mockPostHog.capture).toHaveBeenCalledWith(\n        '$pageview',\n        expect.objectContaining({\n          page_name: pageName,\n          page_url: expect.any(String),\n          page_path: expect.any(String),\n          ...properties\n        })\n      );\n    });\n\n    it('should track feature usage', () => {\n      const featureName = 'alarm_creation';\n      const action = 'button_clicked';\n      const properties = { alarm_type: 'voice' };\n\n      analytics.trackFeatureUsage(featureName, action, properties);\n\n      expect(mockPostHog.capture).toHaveBeenCalledWith(\n        'feature_used',\n        expect.objectContaining({\n          feature_name: featureName,\n          action,\n          ...properties\n        })\n      );\n    });\n  });\n\n  describe('User Properties', () => {\n    beforeEach(() => {\n      analytics.initialize();\n      jest.clearAllMocks();\n    });\n\n    it('should set user properties', () => {\n      const properties = {\n        plan: 'premium',\n        totalAlarms: 10\n      };\n\n      analytics.setUserProperties(properties);\n\n      expect(mockPostHog.people.set).toHaveBeenCalledWith(\n        expect.objectContaining(properties)\n      );\n    });\n\n    it('should increment numeric properties', () => {\n      const property = 'alarms_created';\n      const value = 3;\n\n      analytics.incrementProperty(property, value);\n\n      expect(mockPostHog.people.increment).toHaveBeenCalledWith({\n        [property]: value\n      });\n    });\n  });\n\n  describe('Performance Tracking', () => {\n    beforeEach(() => {\n      analytics.initialize();\n      jest.clearAllMocks();\n    });\n\n    it('should track performance markers', () => {\n      const markerName = 'component_render';\n\n      analytics.startPerformanceMarker(markerName);\n\n      // Simulate some work\n      setTimeout(() => {\n        const duration = analytics.endPerformanceMarker(markerName);\n\n        expect(typeof duration).toBe('number');\n        expect(duration).toBeGreaterThanOrEqual(0);\n        expect(mockPostHog.capture).toHaveBeenCalledWith(\n          'performance_marker',\n          expect.objectContaining({\n            marker_name: markerName,\n            duration: expect.any(Number)\n          })\n        );\n      }, 10);\n    });\n\n    it('should handle invalid performance markers gracefully', () => {\n      const duration = analytics.endPerformanceMarker('nonexistent_marker');\n\n      expect(duration).toBe(0);\n      expect(mockPostHog.capture).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('Error Handling', () => {\n    beforeEach(() => {\n      analytics.initialize();\n      jest.clearAllMocks();\n    });\n\n    it('should track errors with context', () => {\n      const error = new Error('Test error');\n      const context = 'component_mount';\n      const metadata = { userId: 'user123' };\n\n      analytics.trackError(error, context, metadata);\n\n      expect(mockPostHog.capture).toHaveBeenCalledWith(\n        ANALYTICS_EVENTS.ERROR_OCCURRED,\n        expect.objectContaining({\n          error_message: error.message,\n          error_stack: error.stack,\n          context,\n          metadata\n        })\n      );\n    });\n\n    it('should handle string errors', () => {\n      const errorMessage = 'String error';\n      const context = 'api_call';\n\n      analytics.trackError(errorMessage, context);\n\n      expect(mockPostHog.capture).toHaveBeenCalledWith(\n        ANALYTICS_EVENTS.ERROR_OCCURRED,\n        expect.objectContaining({\n          error_message: errorMessage,\n          context\n        })\n      );\n    });\n  });\n\n  describe('Feature Flags', () => {\n    beforeEach(() => {\n      analytics.initialize();\n      jest.clearAllMocks();\n    });\n\n    it('should get feature flag values', () => {\n      const flagName = 'new_feature_enabled';\n      const expectedValue = true;\n\n      mockPostHog.getFeatureFlag.mockReturnValue(expectedValue);\n\n      const result = analytics.getFeatureFlag(flagName);\n\n      expect(mockPostHog.getFeatureFlag).toHaveBeenCalledWith(flagName);\n      expect(result).toBe(expectedValue);\n    });\n  });\n\n  describe('Session Recording', () => {\n    beforeEach(() => {\n      analytics.initialize();\n      jest.clearAllMocks();\n    });\n\n    it('should start session recording', () => {\n      analytics.enableSessionRecording(true);\n\n      expect(mockPostHog.startSessionRecording).toHaveBeenCalled();\n    });\n\n    it('should stop session recording', () => {\n      analytics.enableSessionRecording(false);\n\n      expect(mockPostHog.stopSessionRecording).toHaveBeenCalled();\n    });\n  });\n\n  describe('Analytics Events Constants', () => {\n    it('should have all required event constants', () => {\n      expect(ANALYTICS_EVENTS).toHaveProperty('APP_LAUNCHED');\n      expect(ANALYTICS_EVENTS).toHaveProperty('USER_SIGNED_IN');\n      expect(ANALYTICS_EVENTS).toHaveProperty('USER_SIGNED_OUT');\n      expect(ANALYTICS_EVENTS).toHaveProperty('ALARM_CREATED');\n      expect(ANALYTICS_EVENTS).toHaveProperty('ALARM_TRIGGERED');\n      expect(ANALYTICS_EVENTS).toHaveProperty('ALARM_DISMISSED');\n      expect(ANALYTICS_EVENTS).toHaveProperty('PWA_INSTALLED');\n      expect(ANALYTICS_EVENTS).toHaveProperty('ERROR_OCCURRED');\n      expect(ANALYTICS_EVENTS).toHaveProperty('SESSION_STARTED');\n      expect(ANALYTICS_EVENTS).toHaveProperty('SESSION_ENDED');\n    });\n\n    it('should have consistent event naming convention', () => {\n      Object.values(ANALYTICS_EVENTS).forEach(eventName => {\n        expect(eventName).toMatch(/^[a-z_]+$/);\n        expect(eventName).not.toContain(' ');\n        expect(eventName).not.toContain('-');\n      });\n    });\n  });\n\n  describe('Environment Handling', () => {\n    it('should handle missing configuration gracefully', () => {\n      // Mock empty configuration\n      const originalConfig = require('../../config/environment').config;\n      jest.doMock('../../config/environment', () => ({\n        config: {\n          analytics: {\n            posthog: {\n              apiKey: '',\n              host: ''\n            }\n          }\n        }\n      }));\n\n      analytics.initialize();\n\n      expect(mockPostHog.init).not.toHaveBeenCalled();\n    });\n  });\n\n  describe('Integration with React Hooks', () => {\n    it('should work correctly with React component lifecycle', () => {\n      // Simulate React component mount\n      analytics.initialize();\n      analytics.identify('user123', { email: 'test@example.com' });\n\n      // Simulate user interactions\n      analytics.track(ANALYTICS_EVENTS.ALARM_CREATED, { alarm_type: 'voice' });\n      analytics.track(ANALYTICS_EVENTS.ALARM_TRIGGERED, { alarm_id: 'alarm123' });\n\n      // Verify events were tracked\n      expect(mockPostHog.capture).toHaveBeenCalledTimes(3); // APP_LAUNCHED + 2 custom events\n\n      // Simulate component unmount\n      analytics.reset();\n\n      expect(mockPostHog.reset).toHaveBeenCalled();\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/__tests__/error-handler.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 209,
        "column": 47,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 209,
        "endColumn": 73
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 225,
        "column": 29,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 225,
        "endColumn": 55
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 252,
        "column": 23,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 252,
        "endColumn": 44
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\nimport { ErrorHandler } from \"../error-handler\";\nimport { testUtils } from \"../../test-setup\";\n\n// Mock Sentry\njest.mock('@sentry/browser', () => ({\n  captureException: jest.fn(),\n  captureMessage: jest.fn(),\n  withScope: jest.fn((callback) => callback({\n    setTag: jest.fn(),\n    setContext: jest.fn(),\n    setLevel: jest.fn(),\n  })),\n}));\n\n// Mock PostHog\njest.mock('posthog-js', () => ({\n  capture: jest.fn(),\n  identify: jest.fn(),\n}));\n\ndescribe('ErrorHandler', () => {\n  beforeEach(() => {\n    testUtils.clearAllMocks();\n    jest.clearAllMocks();\n\n    // Reset error storage\n    localStorage.clear();\n\n    // Mock console methods\n    jest.spyOn(console, 'error').mockImplementation();\n    jest.spyOn(console, 'warn').mockImplementation();\n  });\n\n  afterEach(() => {\n    jest.restoreAllMocks();\n  });\n\n  describe('error handling', () => {\n    test('handles basic error with context', () => {\n      const error = new Error('Test error');\n      const context = {\n        component: 'TestComponent',\n        action: 'testAction',\n        userId: 'test-user-123',\n      };\n\n      const errorId = ErrorHandler.handleError(error, context);\n\n      expect(errorId).toMatch(/^err-\\d+-[a-f0-9]+$/);\n      expect(console.error).toHaveBeenCalledWith(\n        'Error handled:',\n        expect.objectContaining({\n          id: errorId,\n          message: 'Test error',\n          context: context,\n        })\n      );\n    });\n\n    test('generates unique error IDs', () => {\n      const error1 = new Error('Error 1');\n      const error2 = new Error('Error 2');\n\n      const id1 = ErrorHandler.handleError(error1);\n      const id2 = ErrorHandler.handleError(error2);\n\n      expect(id1).not.toBe(id2);\n    });\n\n    test('includes stack trace in error details', () => {\n      const error = new Error('Test error');\n      error.stack = 'Error: Test error\\n    at test.js:10:5';\n\n      ErrorHandler.handleError(error);\n\n      expect(console.error).toHaveBeenCalledWith(\n        'Error handled:',\n        expect.objectContaining({\n          stack: error.stack,\n        })\n      );\n    });\n\n    test('handles errors without stack traces', () => {\n      const error = new Error('Test error');\n      delete error.stack;\n\n      const errorId = ErrorHandler.handleError(error);\n\n      expect(errorId).toBeTruthy();\n      expect(console.error).toHaveBeenCalledWith(\n        'Error handled:',\n        expect.objectContaining({\n          stack: 'No stack trace available',\n        })\n      );\n    });\n  });\n\n  describe('error severity classification', () => {\n    test('classifies critical errors correctly', () => {\n      const criticalError = new Error('Cannot access critical resource');\n\n      const errorId = ErrorHandler.handleError(criticalError, {\n        severity: 'critical',\n        component: 'AuthService',\n      });\n\n      expect(console.error).toHaveBeenCalledWith(\n        'Error handled:',\n        expect.objectContaining({\n          severity: 'critical',\n        })\n      );\n    });\n\n    test('auto-detects severity from error type', () => {\n      const networkError = new Error('Network request failed');\n      (networkError as any).name = 'NetworkError';\n\n      ErrorHandler.handleError(networkError);\n\n      expect(console.error).toHaveBeenCalledWith(\n        'Error handled:',\n        expect.objectContaining({\n          severity: 'medium',\n        })\n      );\n    });\n\n    test('defaults to medium severity', () => {\n      const error = new Error('Unknown error');\n\n      ErrorHandler.handleError(error);\n\n      expect(console.error).toHaveBeenCalledWith(\n        'Error handled:',\n        expect.objectContaining({\n          severity: 'medium',\n        })\n      );\n    });\n  });\n\n  describe('error storage and retrieval', () => {\n    test('stores error in localStorage', () => {\n      const error = new Error('Test error');\n\n      const errorId = ErrorHandler.handleError(error, {\n        component: 'TestComponent',\n      });\n\n      const storedErrors = JSON.parse(localStorage.getItem('error-logs') || '[]');\n      expect(storedErrors).toHaveLength(1);\n      expect(storedErrors[0]).toEqual(\n        expect.objectContaining({\n          id: errorId,\n          message: 'Test error',\n          context: { component: 'TestComponent' },\n        })\n      );\n    });\n\n    test('retrieves stored errors by ID', () => {\n      const error = new Error('Retrievable error');\n      const errorId = ErrorHandler.handleError(error);\n\n      const retrievedError = ErrorHandler.getError(errorId);\n\n      expect(retrievedError).toEqual(\n        expect.objectContaining({\n          id: errorId,\n          message: 'Retrievable error',\n        })\n      );\n    });\n\n    test('returns null for non-existent error ID', () => {\n      const retrievedError = ErrorHandler.getError('non-existent-id');\n      expect(retrievedError).toBeNull();\n    });\n\n    test('retrieves all errors', () => {\n      ErrorHandler.handleError(new Error('Error 1'));\n      ErrorHandler.handleError(new Error('Error 2'));\n      ErrorHandler.handleError(new Error('Error 3'));\n\n      const allErrors = ErrorHandler.getAllErrors();\n      expect(allErrors).toHaveLength(3);\n    });\n\n    test('limits stored errors to maximum count', () => {\n      // Generate more errors than the limit (assuming limit is 100)\n      for (let i = 0; i < 105; i++) {\n        ErrorHandler.handleError(new Error(`Error ${i}`));\n      }\n\n      const allErrors = ErrorHandler.getAllErrors();\n      expect(allErrors.length).toBeLessThanOrEqual(100);\n\n      // Should keep the most recent errors\n      expect(allErrors[0].message).toBe('Error 104');\n    });\n  });\n\n  describe('external service integration', () => {\n    test('reports to Sentry with correct data', () => {\n      const { captureException, withScope } = require('@sentry/browser');\n\n      const error = new Error('Sentry test error');\n      const context = {\n        component: 'TestComponent',\n        userId: 'test-user',\n        severity: 'high',\n      };\n\n      ErrorHandler.handleError(error, context);\n\n      expect(withScope).toHaveBeenCalled();\n      expect(captureException).toHaveBeenCalledWith(error);\n    });\n\n    test('sets Sentry scope with context data', () => {\n      const { withScope } = require('@sentry/browser');\n\n      const error = new Error('Context test error');\n      const context = {\n        component: 'TestComponent',\n        userId: 'test-user',\n        severity: 'high',\n        extra: { key: 'value' },\n      };\n\n      ErrorHandler.handleError(error, context);\n\n      const scopeCallback = withScope.mock.calls[0][0];\n      const mockScope = {\n        setTag: jest.fn(),\n        setContext: jest.fn(),\n        setLevel: jest.fn(),\n      };\n\n      scopeCallback(mockScope);\n\n      expect(mockScope.setTag).toHaveBeenCalledWith('component', 'TestComponent');\n      expect(mockScope.setContext).toHaveBeenCalledWith('errorContext', context);\n      expect(mockScope.setLevel).toHaveBeenCalledWith('error');\n    });\n\n    test('reports to PostHog analytics', () => {\n      const posthog = require('posthog-js');\n\n      const error = new Error('Analytics test error');\n\n      ErrorHandler.handleError(error, {\n        component: 'TestComponent',\n        userId: 'test-user',\n      });\n\n      expect(posthog.capture).toHaveBeenCalledWith('error_occurred', {\n        error_message: 'Analytics test error',\n        error_component: 'TestComponent',\n        error_severity: 'medium',\n        user_id: 'test-user',\n      });\n    });\n  });\n\n  describe('error categorization', () => {\n    test('categorizes network errors', () => {\n      const networkError = new Error('Failed to fetch');\n      (networkError as any).name = 'NetworkError';\n\n      ErrorHandler.handleError(networkError);\n\n      expect(console.error).toHaveBeenCalledWith(\n        'Error handled:',\n        expect.objectContaining({\n          category: 'network',\n        })\n      );\n    });\n\n    test('categorizes validation errors', () => {\n      const validationError = new Error('Invalid input');\n      (validationError as any).name = 'ValidationError';\n\n      ErrorHandler.handleError(validationError);\n\n      expect(console.error).toHaveBeenCalledWith(\n        'Error handled:',\n        expect.objectContaining({\n          category: 'validation',\n        })\n      );\n    });\n\n    test('categorizes authentication errors', () => {\n      const authError = new Error('Unauthorized access');\n      (authError as any).name = 'AuthenticationError';\n\n      ErrorHandler.handleError(authError);\n\n      expect(console.error).toHaveBeenCalledWith(\n        'Error handled:',\n        expect.objectContaining({\n          category: 'authentication',\n        })\n      );\n    });\n\n    test('defaults to general category for unknown errors', () => {\n      const unknownError = new Error('Unknown error type');\n\n      ErrorHandler.handleError(unknownError);\n\n      expect(console.error).toHaveBeenCalledWith(\n        'Error handled:',\n        expect.objectContaining({\n          category: 'general',\n        })\n      );\n    });\n  });\n\n  describe('error context enhancement', () => {\n    test('includes browser information', () => {\n      const error = new Error('Browser context test');\n\n      ErrorHandler.handleError(error);\n\n      expect(console.error).toHaveBeenCalledWith(\n        'Error handled:',\n        expect.objectContaining({\n          browserContext: expect.objectContaining({\n            userAgent: expect.any(String),\n            url: expect.any(String),\n            timestamp: expect.any(Number),\n          }),\n        })\n      );\n    });\n\n    test('includes performance context when available', () => {\n      // Mock performance.memory\n      (performance as any).memory = {\n        usedJSHeapSize: 10000000,\n        totalJSHeapSize: 20000000,\n      };\n\n      const error = new Error('Performance context test');\n\n      ErrorHandler.handleError(error);\n\n      expect(console.error).toHaveBeenCalledWith(\n        'Error handled:',\n        expect.objectContaining({\n          performanceContext: expect.objectContaining({\n            memoryUsage: expect.any(Object),\n          }),\n        })\n      );\n    });\n\n    test('handles missing performance API gracefully', () => {\n      const originalMemory = (performance as any).memory;\n      delete (performance as any).memory;\n\n      const error = new Error('No performance API test');\n\n      expect(() => {\n        ErrorHandler.handleError(error);\n      }).not.toThrow();\n\n      // Restore\n      (performance as any).memory = originalMemory;\n    });\n  });\n\n  describe('error filtering and sampling', () => {\n    test('filters out ignored error types', () => {\n      const ignoredError = new Error('Script error.');\n\n      const errorId = ErrorHandler.handleError(ignoredError);\n\n      expect(errorId).toBeNull();\n      expect(console.error).not.toHaveBeenCalled();\n    });\n\n    test('applies sampling rate to reduce noise', () => {\n      // Mock Math.random to control sampling\n      const originalRandom = Math.random;\n      Math.random = jest.fn(() => 0.95); // Above default sampling threshold\n\n      const error = new Error('Sampled error');\n\n      const errorId = ErrorHandler.handleError(error);\n\n      expect(errorId).toBeNull();\n\n      // Restore\n      Math.random = originalRandom;\n    });\n\n    test('always processes critical errors regardless of sampling', () => {\n      const originalRandom = Math.random;\n      Math.random = jest.fn(() => 0.95);\n\n      const criticalError = new Error('Critical error');\n\n      const errorId = ErrorHandler.handleError(criticalError, {\n        severity: 'critical',\n      });\n\n      expect(errorId).toBeTruthy();\n\n      Math.random = originalRandom;\n    });\n  });\n\n  describe('error recovery suggestions', () => {\n    test('provides recovery suggestions for network errors', () => {\n      const networkError = new Error('Network error');\n      (networkError as any).name = 'NetworkError';\n\n      ErrorHandler.handleError(networkError);\n\n      expect(console.error).toHaveBeenCalledWith(\n        'Error handled:',\n        expect.objectContaining({\n          recoverySuggestions: expect.arrayContaining([\n            'Check internet connection',\n            'Retry the operation',\n          ]),\n        })\n      );\n    });\n\n    test('provides suggestions for storage errors', () => {\n      const storageError = new Error('QuotaExceededError');\n      (storageError as any).name = 'QuotaExceededError';\n\n      ErrorHandler.handleError(storageError);\n\n      expect(console.error).toHaveBeenCalledWith(\n        'Error handled:',\n        expect.objectContaining({\n          recoverySuggestions: expect.arrayContaining([\n            'Clear browser storage',\n            'Free up disk space',\n          ]),\n        })\n      );\n    });\n  });\n\n  describe('error statistics and analytics', () => {\n    test('tracks error frequency by type', () => {\n      ErrorHandler.handleError(new Error('Type A error'));\n      ErrorHandler.handleError(new Error('Type A error'));\n      ErrorHandler.handleError(new Error('Type B error'));\n\n      const stats = ErrorHandler.getErrorStatistics();\n\n      expect(stats.errorsByType).toEqual(\n        expect.objectContaining({\n          'Error': 3,\n        })\n      );\n    });\n\n    test('tracks error frequency by component', () => {\n      ErrorHandler.handleError(new Error('Error 1'), { component: 'ComponentA' });\n      ErrorHandler.handleError(new Error('Error 2'), { component: 'ComponentA' });\n      ErrorHandler.handleError(new Error('Error 3'), { component: 'ComponentB' });\n\n      const stats = ErrorHandler.getErrorStatistics();\n\n      expect(stats.errorsByComponent).toEqual({\n        'ComponentA': 2,\n        'ComponentB': 1,\n      });\n    });\n\n    test('calculates error rate over time', () => {\n      const now = Date.now();\n      const oneHourAgo = now - (60 * 60 * 1000);\n\n      // Mock timestamps\n      jest.spyOn(Date, 'now')\n        .mockReturnValueOnce(oneHourAgo)\n        .mockReturnValueOnce(now)\n        .mockReturnValueOnce(now);\n\n      ErrorHandler.handleError(new Error('Old error'));\n      ErrorHandler.handleError(new Error('Recent error 1'));\n      ErrorHandler.handleError(new Error('Recent error 2'));\n\n      const stats = ErrorHandler.getErrorStatistics();\n\n      expect(stats.recentErrorRate).toBeGreaterThan(0);\n    });\n  });\n\n  describe('error cleanup and maintenance', () => {\n    test('clears old errors beyond retention period', () => {\n      const oldDate = Date.now() - (8 * 24 * 60 * 60 * 1000); // 8 days ago\n\n      // Mock Date.now for old error\n      jest.spyOn(Date, 'now').mockReturnValueOnce(oldDate);\n\n      ErrorHandler.handleError(new Error('Old error'));\n\n      // Restore Date.now\n      jest.spyOn(Date, 'now').mockRestore();\n\n      // Add recent error\n      ErrorHandler.handleError(new Error('Recent error'));\n\n      // Trigger cleanup\n      ErrorHandler.cleanupOldErrors();\n\n      const allErrors = ErrorHandler.getAllErrors();\n      expect(allErrors).toHaveLength(1);\n      expect(allErrors[0].message).toBe('Recent error');\n    });\n\n    test('clears all errors on demand', () => {\n      ErrorHandler.handleError(new Error('Error 1'));\n      ErrorHandler.handleError(new Error('Error 2'));\n\n      ErrorHandler.clearAllErrors();\n\n      const allErrors = ErrorHandler.getAllErrors();\n      expect(allErrors).toHaveLength(0);\n    });\n  });\n\n  describe('error export and debugging', () => {\n    test('exports error data for debugging', () => {\n      ErrorHandler.handleError(new Error('Export test error'), {\n        component: 'TestComponent',\n        userId: 'test-user',\n      });\n\n      const exportData = ErrorHandler.exportErrorData();\n\n      expect(exportData).toMatch(/^data:application\\/json/);\n\n      const jsonData = JSON.parse(\n        decodeURIComponent(exportData.split(',')[1])\n      );\n\n      expect(jsonData.errors).toHaveLength(1);\n      expect(jsonData.errors[0]).toEqual(\n        expect.objectContaining({\n          message: 'Export test error',\n          context: expect.objectContaining({\n            component: 'TestComponent',\n          }),\n        })\n      );\n    });\n\n    test('includes error statistics in export', () => {\n      ErrorHandler.handleError(new Error('Stat error 1'), { component: 'A' });\n      ErrorHandler.handleError(new Error('Stat error 2'), { component: 'A' });\n\n      const exportData = ErrorHandler.exportErrorData();\n      const jsonData = JSON.parse(\n        decodeURIComponent(exportData.split(',')[1])\n      );\n\n      expect(jsonData.statistics).toEqual(\n        expect.objectContaining({\n          errorsByComponent: { 'A': 2 },\n          errorsByType: { 'Error': 2 },\n        })\n      );\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/__tests__/performance-monitor.test.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 94,
        "column": 59,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 94,
        "endColumn": 80
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 198,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 198,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 215,
        "column": 26,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 215,
        "endColumn": 47
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 231,
        "column": 25,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 231,
        "endColumn": 46
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { expect, test, jest } from \"@jest/globals\";\nimport PerformanceMonitor from \"../performance-monitor\";\n\n// Mock Web Vitals\njest.mock('web-vitals', () => ({\n  getCLS: jest.fn(),\n  getFID: jest.fn(),\n  getFCP: jest.fn(),\n  getLCP: jest.fn(),\n  getTTFB: jest.fn(),\n}));\n\n// Mock performance API\nconst mockPerformanceObserver = {\n  observe: jest.fn(),\n  disconnect: jest.fn(),\n  takeRecords: jest.fn(() => []),\n};\n\nconst mockPerformanceEntry = {\n  name: 'test-entry',\n  entryType: 'measure',\n  startTime: 100,\n  duration: 50,\n  detail: {},\n};\n\nObject.defineProperty(global, 'PerformanceObserver', {\n  value: jest.fn(() => mockPerformanceObserver),\n  writable: true,\n});\n\nObject.defineProperty(global, 'performance', {\n  value: {\n    now: jest.fn(() => Date.now()),\n    mark: jest.fn(),\n    measure: jest.fn(),\n    getEntriesByType: jest.fn(() => [mockPerformanceEntry]),\n    getEntriesByName: jest.fn(() => [mockPerformanceEntry]),\n    clearMarks: jest.fn(),\n    clearMeasures: jest.fn(),\n    navigation: {\n      type: 0, // TYPE_NAVIGATE\n    },\n    timing: {\n      navigationStart: 1000,\n      loadEventEnd: 2000,\n      domContentLoadedEventEnd: 1500,\n    },\n    memory: {\n      usedJSHeapSize: 10000000,\n      totalJSHeapSize: 20000000,\n      jsHeapSizeLimit: 100000000,\n    },\n  },\n  writable: true,\n});\n\ndescribe('PerformanceMonitor', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n\n    // Reset singleton instance\n    (PerformanceMonitor as any).instance = null;\n\n    // Mock localStorage\n    const mockStorage = {\n      getItem: jest.fn(),\n      setItem: jest.fn(),\n      removeItem: jest.fn(),\n    };\n    Object.defineProperty(window, 'localStorage', {\n      value: mockStorage,\n      writable: true,\n    });\n  });\n\n  describe('initialization', () => {\n    test('creates singleton instance', () => {\n      const instance1 = PerformanceMonitor.getInstance();\n      const instance2 = PerformanceMonitor.getInstance();\n\n      expect(instance1).toBe(instance2);\n    });\n\n    test('initializes performance observers', () => {\n      PerformanceMonitor.getInstance();\n\n      expect(global.PerformanceObserver).toHaveBeenCalled();\n      expect(mockPerformanceObserver.observe).toHaveBeenCalled();\n    });\n\n    test('starts web vitals collection', () => {\n      const { getCLS, getFID, getFCP, getLCP, getTTFB } = require('web-vitals');\n\n      PerformanceMonitor.getInstance();\n\n      expect(getCLS).toHaveBeenCalledWith(expect.any(Function));\n      expect(getFID).toHaveBeenCalledWith(expect.any(Function));\n      expect(getFCP).toHaveBeenCalledWith(expect.any(Function));\n      expect(getLCP).toHaveBeenCalledWith(expect.any(Function));\n      expect(getTTFB).toHaveBeenCalledWith(expect.any(Function));\n    });\n  });\n\n  describe('performance tracking', () => {\n    test('starts tracking with performance mark', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      monitor.startTracking('test-operation');\n\n      expect(performance.mark).toHaveBeenCalledWith('test-operation-start');\n    });\n\n    test('ends tracking with performance measure', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      monitor.startTracking('test-operation');\n      monitor.endTracking('test-operation');\n\n      expect(performance.mark).toHaveBeenCalledWith('test-operation-end');\n      expect(performance.measure).toHaveBeenCalledWith(\n        'test-operation',\n        'test-operation-start',\n        'test-operation-end'\n      );\n    });\n\n    test('returns tracking result with duration', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      // Mock performance.getEntriesByName to return a measure\n      performance.getEntriesByName = jest.fn(() => [{\n        name: 'test-operation',\n        duration: 150,\n        startTime: 100,\n      }]);\n\n      monitor.startTracking('test-operation');\n      const result = monitor.endTracking('test-operation');\n\n      expect(result).toEqual({\n        name: 'test-operation',\n        duration: 150,\n        startTime: 100,\n        endTime: 250,\n      });\n    });\n\n    test('handles tracking operation that was not started', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      const result = monitor.endTracking('non-existent-operation');\n\n      expect(result).toBeNull();\n    });\n\n    test('prevents duplicate tracking starts', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      monitor.startTracking('duplicate-test');\n      monitor.startTracking('duplicate-test');\n\n      // Should only call performance.mark once\n      expect(performance.mark).toHaveBeenCalledTimes(1);\n    });\n  });\n\n  describe('user action tracking', () => {\n    test('tracks user actions with context', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      monitor.trackUserAction('button-click', {\n        buttonId: 'save-button',\n        page: 'alarm-form',\n      });\n\n      // Should store the action (implementation detail)\n      expect(localStorage.setItem).toHaveBeenCalled();\n    });\n\n    test('includes timestamp in user action', () => {\n      const mockNow = 1234567890;\n      performance.now = jest.fn(() => mockNow);\n\n      const monitor = PerformanceMonitor.getInstance();\n\n      monitor.trackUserAction('click', { target: 'button' });\n\n      // Verify timestamp is included\n      const storedData = JSON.parse(localStorage.setItem.mock.calls[0][1]);\n      expect(storedData.timestamp).toBe(mockNow);\n    });\n  });\n\n  describe('web vitals collection', () => {\n    test('collects and stores CLS metric', () => {\n      const { getCLS } = require('web-vitals');\n      const monitor = PerformanceMonitor.getInstance();\n\n      // Simulate CLS callback\n      const clsCallback = getCLS.mock.calls[0][0];\n      clsCallback({\n        name: 'CLS',\n        value: 0.1,\n        id: 'test-cls-id',\n        delta: 0.05,\n      });\n\n      const metrics = monitor.getWebVitals();\n      expect(metrics.cls).toBe(0.1);\n    });\n\n    test('collects and stores FID metric', () => {\n      const { getFID } = require('web-vitals');\n      const monitor = PerformanceMonitor.getInstance();\n\n      const fidCallback = getFID.mock.calls[0][0];\n      fidCallback({\n        name: 'FID',\n        value: 50,\n        id: 'test-fid-id',\n        delta: 25,\n      });\n\n      const metrics = monitor.getWebVitals();\n      expect(metrics.fid).toBe(50);\n    });\n\n    test('collects all core web vitals', () => {\n      const webVitals = require('web-vitals');\n      const monitor = PerformanceMonitor.getInstance();\n\n      // Simulate all vitals callbacks\n      webVitals.getCLS.mock.calls[0][0]({ name: 'CLS', value: 0.1 });\n      webVitals.getFID.mock.calls[0][0]({ name: 'FID', value: 50 });\n      webVitals.getFCP.mock.calls[0][0]({ name: 'FCP', value: 1500 });\n      webVitals.getLCP.mock.calls[0][0]({ name: 'LCP', value: 2000 });\n      webVitals.getTTFB.mock.calls[0][0]({ name: 'TTFB', value: 200 });\n\n      const metrics = monitor.getWebVitals();\n      expect(metrics).toEqual({\n        cls: 0.1,\n        fid: 50,\n        fcp: 1500,\n        lcp: 2000,\n        ttfb: 200,\n      });\n    });\n  });\n\n  describe('resource performance', () => {\n    test('tracks resource loading times', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      // Mock performance entries for resources\n      performance.getEntriesByType = jest.fn(() => [\n        {\n          name: 'https://example.com/script.js',\n          entryType: 'resource',\n          startTime: 100,\n          responseEnd: 250,\n          transferSize: 1024,\n        },\n        {\n          name: 'https://example.com/style.css',\n          entryType: 'resource',\n          startTime: 50,\n          responseEnd: 200,\n          transferSize: 2048,\n        },\n      ]);\n\n      const resources = monitor.getResourcePerformance();\n\n      expect(resources).toHaveLength(2);\n      expect(resources[0]).toEqual({\n        name: 'https://example.com/script.js',\n        duration: 150,\n        size: 1024,\n        type: 'script',\n      });\n    });\n\n    test('categorizes resource types correctly', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      performance.getEntriesByType = jest.fn(() => [\n        {\n          name: 'https://example.com/image.png',\n          entryType: 'resource',\n          startTime: 100,\n          responseEnd: 300,\n          transferSize: 5000,\n        },\n      ]);\n\n      const resources = monitor.getResourcePerformance();\n\n      expect(resources[0].type).toBe('image');\n    });\n  });\n\n  describe('memory monitoring', () => {\n    test('tracks memory usage', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      const memoryInfo = monitor.getMemoryUsage();\n\n      expect(memoryInfo).toEqual({\n        used: 10000000,\n        total: 20000000,\n        limit: 100000000,\n        percentage: 10,\n      });\n    });\n\n    test('handles browsers without memory API', () => {\n      const originalMemory = performance.memory;\n      delete (performance as any).memory;\n\n      const monitor = PerformanceMonitor.getInstance();\n\n      const memoryInfo = monitor.getMemoryUsage();\n\n      expect(memoryInfo).toBeNull();\n\n      // Restore\n      (performance as any).memory = originalMemory;\n    });\n  });\n\n  describe('navigation timing', () => {\n    test('calculates page load time', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      const loadTime = monitor.getPageLoadTime();\n\n      // loadEventEnd - navigationStart = 2000 - 1000 = 1000ms\n      expect(loadTime).toBe(1000);\n    });\n\n    test('calculates DOM content loaded time', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      const domTime = monitor.getDOMContentLoadedTime();\n\n      // domContentLoadedEventEnd - navigationStart = 1500 - 1000 = 500ms\n      expect(domTime).toBe(500);\n    });\n  });\n\n  describe('data persistence', () => {\n    test('saves performance data to localStorage', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      monitor.trackUserAction('test-action', { data: 'test' });\n\n      expect(localStorage.setItem).toHaveBeenCalledWith(\n        'performance-data',\n        expect.any(String)\n      );\n    });\n\n    test('loads performance data from localStorage', () => {\n      const testData = {\n        userActions: [{ action: 'test', timestamp: 123 }],\n        webVitals: { cls: 0.1 },\n      };\n\n      localStorage.getItem = jest.fn(() => JSON.stringify(testData));\n\n      const monitor = PerformanceMonitor.getInstance();\n      const data = monitor.getPerformanceData();\n\n      expect(data.userActions).toEqual(testData.userActions);\n    });\n\n    test('handles corrupted localStorage data gracefully', () => {\n      localStorage.getItem = jest.fn(() => 'invalid-json');\n\n      const monitor = PerformanceMonitor.getInstance();\n      const data = monitor.getPerformanceData();\n\n      // Should return default empty structure\n      expect(data).toEqual({\n        userActions: [],\n        webVitals: {},\n        tracking: {},\n        resources: [],\n      });\n    });\n  });\n\n  describe('performance budgets', () => {\n    test('checks if metrics are within budget', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      // Set performance budget\n      monitor.setPerformanceBudget({\n        cls: 0.1,\n        fid: 100,\n        lcp: 2500,\n      });\n\n      // Mock current metrics\n      monitor.webVitals = { cls: 0.05, fid: 50, lcp: 2000 };\n\n      const budgetStatus = monitor.checkPerformanceBudget();\n\n      expect(budgetStatus.withinBudget).toBe(true);\n      expect(budgetStatus.violations).toHaveLength(0);\n    });\n\n    test('identifies budget violations', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      monitor.setPerformanceBudget({\n        cls: 0.1,\n        fid: 100,\n        lcp: 2500,\n      });\n\n      // Mock metrics that exceed budget\n      monitor.webVitals = { cls: 0.15, fid: 150, lcp: 3000 };\n\n      const budgetStatus = monitor.checkPerformanceBudget();\n\n      expect(budgetStatus.withinBudget).toBe(false);\n      expect(budgetStatus.violations).toHaveLength(3);\n      expect(budgetStatus.violations).toEqual([\n        { metric: 'cls', budget: 0.1, actual: 0.15 },\n        { metric: 'fid', budget: 100, actual: 150 },\n        { metric: 'lcp', budget: 2500, actual: 3000 },\n      ]);\n    });\n  });\n\n  describe('cleanup and disposal', () => {\n    test('disconnects performance observers on dispose', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      monitor.dispose();\n\n      expect(mockPerformanceObserver.disconnect).toHaveBeenCalled();\n    });\n\n    test('clears performance marks and measures', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      monitor.dispose();\n\n      expect(performance.clearMarks).toHaveBeenCalled();\n      expect(performance.clearMeasures).toHaveBeenCalled();\n    });\n\n    test('saves final data before disposal', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      monitor.dispose();\n\n      expect(localStorage.setItem).toHaveBeenCalled();\n    });\n  });\n\n  describe('error handling', () => {\n    test('handles performance API unavailability gracefully', () => {\n      const originalPerformance = global.performance;\n      delete (global as any).performance;\n\n      expect(() => {\n        PerformanceMonitor.getInstance();\n      }).not.toThrow();\n\n      // Restore\n      (global as any).performance = originalPerformance;\n    });\n\n    test('handles PerformanceObserver unavailability', () => {\n      const originalPO = global.PerformanceObserver;\n      delete (global as any).PerformanceObserver;\n\n      expect(() => {\n        PerformanceMonitor.getInstance();\n      }).not.toThrow();\n\n      // Restore\n      (global as any).PerformanceObserver = originalPO;\n    });\n\n    test('handles localStorage errors gracefully', () => {\n      const consoleError = jest.spyOn(console, 'error').mockImplementation();\n\n      localStorage.setItem = jest.fn(() => {\n        throw new Error('Storage quota exceeded');\n      });\n\n      const monitor = PerformanceMonitor.getInstance();\n\n      expect(() => {\n        monitor.trackUserAction('test');\n      }).not.toThrow();\n\n      consoleError.mockRestore();\n    });\n  });\n\n  describe('performance reporting', () => {\n    test('generates comprehensive performance report', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      // Setup test data\n      monitor.webVitals = { cls: 0.1, fid: 50, lcp: 2000, fcp: 1500, ttfb: 200 };\n      monitor.trackUserAction('test-action');\n\n      const report = monitor.generatePerformanceReport();\n\n      expect(report).toEqual({\n        timestamp: expect.any(Number),\n        webVitals: monitor.webVitals,\n        navigationTiming: {\n          pageLoadTime: 1000,\n          domContentLoadedTime: 500,\n        },\n        resourcePerformance: expect.any(Array),\n        memoryUsage: expect.any(Object),\n        userActions: expect.any(Array),\n        performanceBudget: expect.any(Object),\n      });\n    });\n\n    test('exports performance data for analysis', () => {\n      const monitor = PerformanceMonitor.getInstance();\n\n      const exportData = monitor.exportPerformanceData();\n\n      expect(exportData).toMatch(/^data:application\\/json;charset=utf-8,/);\n\n      const jsonData = JSON.parse(\n        decodeURIComponent(exportData.split(',')[1])\n      );\n      expect(jsonData).toHaveProperty('webVitals');\n      expect(jsonData).toHaveProperty('userActions');\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/__tests__/test-setup.ts",
    "messages": [
      {
        "ruleId": "no-prototype-builtins",
        "severity": 2,
        "message": "Do not access Object.prototype method 'hasOwnProperty' from target object.",
        "line": 17,
        "column": 15,
        "nodeType": "CallExpression",
        "messageId": "prototypeBuildIn",
        "endLine": 17,
        "endColumn": 29,
        "suggestions": [
          {
            "messageId": "callObjectPrototype",
            "data": { "prop": "hasOwnProperty" },
            "fix": {
              "range": [508, 527],
              "text": "Object.prototype.hasOwnProperty.call(arg, "
            },
            "desc": "Call Object.prototype.hasOwnProperty explicitly."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 291,
        "column": 29,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 291,
        "endColumn": 91
      },
      {
        "ruleId": "@typescript-eslint/no-namespace",
        "severity": 2,
        "message": "ES2015 module syntax is preferred over namespaces.",
        "line": 398,
        "column": 3,
        "nodeType": "TSModuleDeclaration",
        "messageId": "moduleSyntaxIsPreferred",
        "endLine": 402,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference lib=\"dom\" />\n/**\n * Test setup for Analytics & Crash Reporting Services\n * Provides consistent test environment and mocks for all analytics tests\n */\n\nimport '@testing-library/jest-dom';\n\n// Extend Jest matchers\nexpect.extend({\n  toHaveBeenCalledWithObjectContaining(received: jest.Mock, expected: object) {\n    const pass = received.mock.calls.some(call =>\n      call.some(arg =>\n        typeof arg === 'object' &&\n        arg !== null &&\n        Object.keys(expected).every(key =>\n          arg.hasOwnProperty(key) && arg[key] === expected[key]\n        )\n      )\n    );\n\n    if (pass) {\n      return {\n        message: () =>\n          `expected mock not to have been called with object containing ${JSON.stringify(expected)}`,\n        pass: true\n      };\n    } else {\n      return {\n        message: () =>\n          `expected mock to have been called with object containing ${JSON.stringify(expected)}`,\n        pass: false\n      };\n    }\n  }\n});\n\n// Mock browser APIs consistently across all tests\nObject.defineProperty(global, 'localStorage', {\n  value: {\n    getItem: jest.fn((key: string) => {\n      // Default return values for common test scenarios\n      if (key === 'relife_consent') {\n        return JSON.stringify({\n          analytics: true,\n          errorReporting: true,\n          performance: true,\n          timestamp: Date.now(),\n          version: '1.0'\n        });\n      }\n      if (key === 'relife_privacy_settings') {\n        return JSON.stringify({\n          dataRetention: 365,\n          anonymizeIP: true,\n          shareUsageData: false\n        });\n      }\n      return null;\n    }),\n    setItem: jest.fn(),\n    removeItem: jest.fn(),\n    clear: jest.fn()\n  }\n});\n\nObject.defineProperty(global, 'sessionStorage', {\n  value: {\n    getItem: jest.fn(),\n    setItem: jest.fn(),\n    removeItem: jest.fn(),\n    clear: jest.fn()\n  }\n});\n\n// Mock Performance API\nObject.defineProperty(global, 'performance', {\n  writable: true,\n  value: {\n    now: jest.fn(() => 1000),\n    mark: jest.fn(),\n    measure: jest.fn(),\n    getEntriesByType: jest.fn(() => []),\n    getEntriesByName: jest.fn(() => []),\n    memory: {\n      usedJSHeapSize: 50 * 1024 * 1024, // 50MB\n      totalJSHeapSize: 100 * 1024 * 1024, // 100MB\n      jsHeapSizeLimit: 200 * 1024 * 1024 // 200MB\n    },\n    navigation: {\n      type: 0,\n      redirectCount: 0\n    },\n    timing: {\n      navigationStart: 1000,\n      loadEventEnd: 2000,\n      domContentLoadedEventEnd: 1500,\n      responseStart: 1200,\n      requestStart: 1100,\n      fetchStart: 1000,\n      domInteractive: 1300\n    }\n  }\n});\n\n// Mock PerformanceObserver\nglobal.PerformanceObserver = jest.fn().mockImplementation(callback => ({\n  observe: jest.fn(),\n  disconnect: jest.fn(),\n  takeRecords: jest.fn(() => [])\n})) as any;\n\n// Mock IntersectionObserver\nglobal.IntersectionObserver = jest.fn().mockImplementation(callback => ({\n  observe: jest.fn(),\n  unobserve: jest.fn(),\n  disconnect: jest.fn(),\n  root: null,\n  rootMargin: '',\n  thresholds: []\n})) as any;\n\n// Mock URL and URLSearchParams\nObject.defineProperty(global, 'URL', {\n  writable: true,\n  value: class URL {\n    constructor(public href: string, base?: string) {\n      if (base && !href.startsWith('http')) {\n        this.href = new URL(base).origin + '/' + href.replace(/^\\//, '');\n      }\n\n      const url = new (global as any).URL(this.href);\n      this.protocol = url.protocol;\n      this.hostname = url.hostname;\n      this.pathname = url.pathname;\n      this.search = url.search;\n      this.hash = url.hash;\n      this.origin = url.origin;\n    }\n\n    protocol = '';\n    hostname = '';\n    pathname = '';\n    search = '';\n    hash = '';\n    origin = '';\n  }\n});\n\n// Mock Navigator\nObject.defineProperty(global, 'navigator', {\n  writable: true,\n  value: {\n    userAgent: 'Mozilla/5.0 (compatible; Jest Test Environment)',\n    language: 'en-US',\n    languages: ['en-US', 'en'],\n    platform: 'Test',\n    onLine: true,\n    connection: {\n      effectiveType: '4g',\n      downlink: 10,\n      rtt: 100\n    },\n    permissions: {\n      query: jest.fn().mockResolvedValue({ state: 'granted' })\n    },\n    serviceWorker: {\n      register: jest.fn().mockResolvedValue({}),\n      ready: Promise.resolve({})\n    }\n  }\n});\n\n// Mock Window methods\nObject.defineProperty(global, 'window', {\n  writable: true,\n  value: {\n    ...global.window,\n    addEventListener: jest.fn(),\n    removeEventListener: jest.fn(),\n    location: {\n      href: 'https://localhost:3000',\n      origin: 'https://localhost:3000',\n      protocol: 'https:',\n      hostname: 'localhost',\n      pathname: '/',\n      search: '',\n      hash: ''\n    },\n    history: {\n      pushState: jest.fn(),\n      replaceState: jest.fn(),\n      back: jest.fn(),\n      forward: jest.fn()\n    },\n    innerWidth: 1920,\n    innerHeight: 1080,\n    screen: {\n      width: 1920,\n      height: 1080,\n      availWidth: 1920,\n      availHeight: 1080\n    }\n  }\n});\n\n// Mock Date for consistent timestamps in tests\nconst mockDate = new Date('2023-01-01T00:00:00.000Z');\nconst OriginalDate = Date;\n\nglobal.Date = jest.fn((dateString?: string | number | Date) => {\n  if (dateString) {\n    return new OriginalDate(dateString);\n  }\n  return mockDate;\n}) as any;\n\n// Preserve static methods\nObject.setPrototypeOf(global.Date, OriginalDate);\nglobal.Date.now = jest.fn(() => mockDate.getTime());\nglobal.Date.UTC = OriginalDate.UTC;\nglobal.Date.parse = OriginalDate.parse;\n\n// Mock crypto for generating UUIDs\nObject.defineProperty(global, 'crypto', {\n  value: {\n    randomUUID: jest.fn(() => 'mock-uuid-123-456-789'),\n    getRandomValues: jest.fn((array: Uint8Array) => {\n      for (let i = 0; i < array.length; i++) {\n        array[i] = Math.floor(Math.random() * 256);\n      }\n      return array;\n    })\n  }\n});\n\n// Mock console methods to track warnings and errors\nconst originalConsoleError = console.error;\nconst originalConsoleWarn = console.warn;\nconst originalConsoleInfo = console.info;\nconst originalConsoleLog = console.log;\n\n// Store original methods for tests that need them\n(global as any).originalConsole = {\n  error: originalConsoleError,\n  warn: originalConsoleWarn,\n  info: originalConsoleInfo,\n  log: originalConsoleLog\n};\n\n// Mock console methods\nconsole.error = jest.fn();\nconsole.warn = jest.fn();\nconsole.info = jest.fn();\nconsole.log = jest.fn();\n\n// Utility function to restore console methods\n(global as any).restoreConsole = () => {\n  console.error = originalConsoleError;\n  console.warn = originalConsoleWarn;\n  console.info = originalConsoleInfo;\n  console.log = originalConsoleLog;\n};\n\n// Mock fetch for API calls\nglobal.fetch = jest.fn(() =>\n  Promise.resolve({\n    ok: true,\n    status: 200,\n    statusText: 'OK',\n    json: () => Promise.resolve({}),\n    text: () => Promise.resolve(''),\n    headers: new Map()\n  })\n) as any;\n\n// Common test utilities\n(global as any).testUtils = {\n  // Reset all singleton instances\n  resetSingletons: () => {\n    const services = [\n      'AnalyticsConfigService',\n      'PrivacyComplianceService',\n      'SentryService',\n      'AnalyticsService',\n      'AppAnalyticsService',\n      'PerformanceAnalyticsService'\n    ];\n\n    services.forEach(service => {\n      const serviceModule = require(`../${service.replace(/Service$/, '').toLowerCase()}`);\n      if (serviceModule.default) {\n        (serviceModule.default as any).instance = null;\n      }\n    });\n  },\n\n  // Create mock user data\n  createMockUser: (overrides = {}) => ({\n    id: 'test-user-123',\n    email: 'test@example.com',\n    name: 'Test User',\n    username: 'testuser123',\n    displayName: 'Test User',\n    avatar: undefined,\n    level: 1,\n    experience: 0,\n    joinDate: '2023-01-01T00:00:00.000Z',\n    lastActive: '2023-01-01T00:00:00.000Z',\n    preferences: {\n      theme: 'auto' as const,\n      notificationsEnabled: true,\n      voiceDismissalSensitivity: 5,\n      defaultVoiceMood: 'motivational' as const,\n      hapticFeedback: true,\n      snoozeMinutes: 10,\n      maxSnoozes: 3,\n      rewardsEnabled: true,\n      aiInsightsEnabled: true,\n      personalizedMessagesEnabled: true,\n      shareAchievements: false\n    },\n    createdAt: '2023-01-01T00:00:00.000Z',\n    ...overrides\n  }),\n\n  // Create mock alarm data\n  createMockAlarm: (overrides = {}) => ({\n    id: 'alarm-123',\n    time: '07:00',\n    type: 'wake_up',\n    enabled: true,\n    repeatDays: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'],\n    ...overrides\n  }),\n\n  // Create mock performance entry\n  createMockPerformanceEntry: (overrides = {}) => ({\n    name: 'test-metric',\n    entryType: 'measure',\n    startTime: 1000,\n    duration: 100,\n    ...overrides\n  }),\n\n  // Wait for async operations\n  waitForAsync: () => new Promise(resolve => setTimeout(resolve, 0)),\n\n  // Advance timers and wait\n  advanceTimersAndWait: async (ms: number) => {\n    jest.advanceTimersByTime(ms);\n    await (global as any).testUtils.waitForAsync();\n  }\n};\n\n// Setup environment variables for consistent testing\nprocess.env.NODE_ENV = 'test';\nprocess.env.REACT_APP_ENVIRONMENT = 'test';\nprocess.env.REACT_APP_SENTRY_DSN = 'https://test@sentry.io/123456';\nprocess.env.REACT_APP_POSTHOG_API_KEY = 'test-posthog-key';\nprocess.env.REACT_APP_POSTHOG_HOST = 'https://test.posthog.com';\n\n// Global test cleanup\nafterEach(() => {\n  // Clear all mocks\n  jest.clearAllMocks();\n\n  // Reset timers\n  if (jest.isMockFunction(setTimeout)) {\n    jest.clearAllTimers();\n  }\n\n  // Reset localStorage\n  (global.localStorage.getItem as jest.Mock).mockClear();\n  (global.localStorage.setItem as jest.Mock).mockClear();\n\n  // Reset console mocks\n  (console.error as jest.Mock).mockClear();\n  (console.warn as jest.Mock).mockClear();\n  (console.info as jest.Mock).mockClear();\n  (console.log as jest.Mock).mockClear();\n\n  // Reset performance.now\n  (global.performance.now as jest.Mock).mockReturnValue(1000);\n\n  // Reset Date.now\n  (global.Date.now as jest.Mock).mockReturnValue(mockDate.getTime());\n});\n\n// Global test teardown\nafterAll(() => {\n  // Restore original console methods\n  (global as any).restoreConsole();\n});\n\n// Add custom Jest matchers types\ndeclare global {\n  namespace jest {\n    interface Matchers<R> {\n      toHaveBeenCalledWithObjectContaining(expected: object): R;\n    }\n  }\n}\n\nexport {};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/accessibility-preferences.ts",
    "messages": [
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\:.",
        "line": 395,
        "column": 45,
        "nodeType": "TemplateElement",
        "messageId": "unnecessaryEscape",
        "endLine": 395,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [12396, 12397], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [12396, 12396], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference lib=\"dom\" />\n/**\n * Accessibility Preferences System\n * Comprehensive accessibility settings management with system integration\n */\n\nexport interface AccessibilityPreferences {\n  // Visual preferences\n  highContrastMode: boolean;\n  reducedMotion: boolean;\n  fontSize: 'small' | 'medium' | 'large' | 'extra-large';\n  colorBlindFriendly: boolean;\n  darkMode: boolean;\n\n  // Focus and navigation\n  enhancedFocusRings: boolean;\n  focusRingColor: string;\n  skipLinksVisible: boolean;\n  keyboardNavigation: boolean;\n\n  // Screen reader and audio\n  screenReaderOptimized: boolean;\n  announceTransitions: boolean;\n  announceErrors: boolean;\n  announceSuccess: boolean;\n  speechRate: number; // 0.5 to 2.0\n\n  // Touch and interaction\n  largerTouchTargets: boolean;\n  hapticFeedback: boolean;\n  longPressDelay: number; // milliseconds\n\n  // Advanced features\n  voiceCommands: boolean;\n  gestureNavigation: boolean;\n  autoplay: boolean;\n  blinkingElements: boolean;\n}\n\nexport interface AccessibilityState extends AccessibilityPreferences {\n  isSystemDarkMode: boolean;\n  isSystemReducedMotion: boolean;\n  isSystemHighContrast: boolean;\n  systemFontScale: number;\n  screenReaderActive: boolean;\n  touchDevice: boolean;\n  hasHover: boolean;\n}\n\nclass AccessibilityPreferencesService {\n  private static instance: AccessibilityPreferencesService;\n  private preferences: AccessibilityPreferences;\n  private listeners: Array<(prefs: AccessibilityPreferences) => void> = [];\n  private mediaQueries: Map<string, MediaQueryList> = new Map();\n  private styleElement?: HTMLStyleElement;\n\n  private defaultPreferences: AccessibilityPreferences = {\n    // Visual preferences\n    highContrastMode: false,\n    reducedMotion: false,\n    fontSize: 'medium',\n    colorBlindFriendly: false,\n    darkMode: false,\n\n    // Focus and navigation\n    enhancedFocusRings: true,\n    focusRingColor: '#007AFF',\n    skipLinksVisible: true,\n    keyboardNavigation: true,\n\n    // Screen reader and audio\n    screenReaderOptimized: false,\n    announceTransitions: true,\n    announceErrors: true,\n    announceSuccess: true,\n    speechRate: 1.0,\n\n    // Touch and interaction\n    largerTouchTargets: false,\n    hapticFeedback: true,\n    longPressDelay: 500,\n\n    // Advanced features\n    voiceCommands: false,\n    gestureNavigation: true,\n    autoplay: false,\n    blinkingElements: true,\n  };\n\n  private constructor() {\n    this.preferences = this.loadPreferences();\n    this.initializeSystemDetection();\n    this.applyPreferences();\n  }\n\n  static getInstance(): AccessibilityPreferencesService {\n    if (!AccessibilityPreferencesService.instance) {\n      AccessibilityPreferencesService.instance = new AccessibilityPreferencesService();\n    }\n    return AccessibilityPreferencesService.instance;\n  }\n\n  /**\n   * Initialize system accessibility detection\n   */\n  private initializeSystemDetection(): void {\n    // Dark mode detection\n    if (window.matchMedia) {\n      const darkModeQuery = window.matchMedia('(prefers-color-scheme: dark)');\n      this.mediaQueries.set('dark-mode', darkModeQuery);\n      darkModeQuery.addEventListener('change', () => this.handleSystemChange());\n\n      // Reduced motion detection\n      const reducedMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n      this.mediaQueries.set('reduced-motion', reducedMotionQuery);\n      reducedMotionQuery.addEventListener('change', () => this.handleSystemChange());\n\n      // High contrast detection (Windows)\n      const highContrastQuery = window.matchMedia('(prefers-contrast: high)');\n      this.mediaQueries.set('high-contrast', highContrastQuery);\n      highContrastQuery.addEventListener('change', () => this.handleSystemChange());\n\n      // Touch device detection\n      const hoverQuery = window.matchMedia('(hover: hover)');\n      this.mediaQueries.set('hover', hoverQuery);\n      hoverQuery.addEventListener('change', () => this.handleSystemChange());\n    }\n\n    // Screen reader detection\n    this.detectScreenReader();\n  }\n\n  /**\n   * Detect if screen reader is active\n   */\n  private detectScreenReader(): void {\n    // Multiple methods to detect screen readers\n    const indicators = [\n      // NVDA, JAWS, etc. often set these\n      navigator.userAgent.includes('NVDA') ||\n      navigator.userAgent.includes('JAWS'),\n\n      // Check for common screen reader APIs\n      'speechSynthesis' in window && window.speechSynthesis.getVoices().length > 0,\n\n      // Check for accessibility APIs\n      'accessibility' in navigator,\n\n      // Check for reduced motion (often enabled with screen readers)\n      window.matchMedia?.('(prefers-reduced-motion: reduce)').matches,\n    ];\n\n    const screenReaderLikely = indicators.filter(Boolean).length >= 2;\n\n    if (screenReaderLikely && !this.preferences.screenReaderOptimized) {\n      this.updatePreferences({\n        screenReaderOptimized: true,\n        reducedMotion: true,\n        announceTransitions: true,\n        enhancedFocusRings: true,\n      });\n    }\n  }\n\n  /**\n   * Handle system preference changes\n   */\n  private handleSystemChange(): void {\n    const state = this.getState();\n\n    // Auto-adjust based on system preferences if user hasn't manually set them\n    if (!this.hasUserOverride('reducedMotion') && state.isSystemReducedMotion) {\n      this.updatePreferences({ reducedMotion: true });\n    }\n\n    if (!this.hasUserOverride('highContrastMode') && state.isSystemHighContrast) {\n      this.updatePreferences({ highContrastMode: true });\n    }\n\n    if (!this.hasUserOverride('darkMode') && state.isSystemDarkMode) {\n      this.updatePreferences({ darkMode: true });\n    }\n\n    this.notifyListeners();\n  }\n\n  /**\n   * Check if user has manually overridden a preference\n   */\n  private hasUserOverride(preference: keyof AccessibilityPreferences): boolean {\n    const stored = localStorage.getItem('accessibility-overrides');\n    if (!stored) return false;\n\n    try {\n      const overrides = JSON.parse(stored);\n      return preference in overrides;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Load preferences from storage\n   */\n  private loadPreferences(): AccessibilityPreferences {\n    try {\n      const stored = localStorage.getItem('accessibility-preferences');\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        return { ...this.defaultPreferences, ...parsed };\n      }\n    } catch (error) {\n      console.warn('Failed to load accessibility preferences:', error);\n    }\n\n    return { ...this.defaultPreferences };\n  }\n\n  /**\n   * Save preferences to storage\n   */\n  private savePreferences(): void {\n    try {\n      localStorage.setItem('accessibility-preferences', JSON.stringify(this.preferences));\n    } catch (error) {\n      console.warn('Failed to save accessibility preferences:', error);\n    }\n  }\n\n  /**\n   * Apply preferences to the document\n   */\n  private applyPreferences(): void {\n    const root = document.documentElement;\n    const body = document.body;\n\n    // Apply CSS custom properties\n    root.style.setProperty('--a11y-font-scale', this.getFontScale());\n    root.style.setProperty('--a11y-focus-ring-color', this.preferences.focusRingColor);\n    root.style.setProperty('--a11y-long-press-delay', `${this.preferences.longPressDelay}ms`);\n\n    // Apply class-based preferences\n    body.classList.toggle('a11y-high-contrast', this.preferences.highContrastMode);\n    body.classList.toggle('a11y-reduced-motion', this.preferences.reducedMotion);\n    body.classList.toggle('a11y-large-touch-targets', this.preferences.largerTouchTargets);\n    body.classList.toggle('a11y-enhanced-focus', this.preferences.enhancedFocusRings);\n    body.classList.toggle('a11y-screen-reader', this.preferences.screenReaderOptimized);\n    body.classList.toggle('a11y-color-blind-friendly', this.preferences.colorBlindFriendly);\n    body.classList.toggle('a11y-skip-links-visible', this.preferences.skipLinksVisible);\n    body.classList.toggle('a11y-no-autoplay', !this.preferences.autoplay);\n    body.classList.toggle('a11y-no-blinking', !this.preferences.blinkingElements);\n\n    // Create or update CSS styles\n    this.updateAccessibilityStyles();\n\n    // Configure speech synthesis\n    this.configureSpeechSynthesis();\n  }\n\n  /**\n   * Get font scale multiplier\n   */\n  private getFontScale(): string {\n    const scales = {\n      'small': '0.875',\n      'medium': '1',\n      'large': '1.125',\n      'extra-large': '1.25',\n    };\n    return scales[this.preferences.fontSize];\n  }\n\n  /**\n   * Update accessibility CSS styles\n   */\n  private updateAccessibilityStyles(): void {\n    if (this.styleElement) {\n      this.styleElement.remove();\n    }\n\n    this.styleElement = document.createElement('style');\n    this.styleElement.id = 'accessibility-styles';\n\n    const css = `\n      /* Font scaling */\n      .a11y-font-scale {\n        font-size: calc(1rem * var(--a11y-font-scale, 1));\n      }\n\n      /* High contrast mode */\n      body.a11y-high-contrast {\n        filter: contrast(150%);\n      }\n\n      body.a11y-high-contrast * {\n        border-color: currentColor !important;\n        outline-color: currentColor !important;\n      }\n\n      body.a11y-high-contrast .bg-gray-50 { background-color: #ffffff !important; }\n      body.a11y-high-contrast .bg-gray-100 { background-color: #f0f0f0 !important; }\n      body.a11y-high-contrast .text-gray-600 { color: #000000 !important; }\n      body.a11y-high-contrast .text-gray-400 { color: #333333 !important; }\n\n      /* Reduced motion */\n      body.a11y-reduced-motion *,\n      body.a11y-reduced-motion *::before,\n      body.a11y-reduced-motion *::after {\n        animation-duration: 0.01ms !important;\n        animation-iteration-count: 1 !important;\n        transition-duration: 0.01ms !important;\n        scroll-behavior: auto !important;\n      }\n\n      /* Enhanced focus rings */\n      body.a11y-enhanced-focus *:focus {\n        outline: 3px solid var(--a11y-focus-ring-color, #007AFF) !important;\n        outline-offset: 2px !important;\n        border-radius: 4px !important;\n        box-shadow: 0 0 0 6px rgba(0, 122, 255, 0.2) !important;\n      }\n\n      /* Large touch targets */\n      body.a11y-large-touch-targets button,\n      body.a11y-large-touch-targets [role=\"button\"],\n      body.a11y-large-touch-targets input,\n      body.a11y-large-touch-targets select,\n      body.a11y-large-touch-targets textarea {\n        min-height: 44px !important;\n        min-width: 44px !important;\n        padding: 12px 16px !important;\n      }\n\n      /* Screen reader optimizations */\n      body.a11y-screen-reader .sr-only {\n        position: static !important;\n        width: auto !important;\n        height: auto !important;\n        padding: 0 !important;\n        margin: 0 !important;\n        overflow: visible !important;\n        clip: auto !important;\n        white-space: normal !important;\n      }\n\n      /* Color blind friendly adjustments */\n      body.a11y-color-blind-friendly {\n        --color-red: #d73027;\n        --color-green: #1a9641;\n        --color-blue: #313695;\n        --color-orange: #fdae61;\n        --color-purple: #762a83;\n      }\n\n      /* Skip links visibility */\n      body.a11y-skip-links-visible .skip-link {\n        position: static !important;\n        transform: none !important;\n        opacity: 1 !important;\n        background: var(--a11y-focus-ring-color, #007AFF) !important;\n        color: white !important;\n        padding: 8px 16px !important;\n        margin: 4px !important;\n        display: inline-block !important;\n        border-radius: 4px !important;\n        text-decoration: none !important;\n        font-weight: bold !important;\n      }\n\n      /* Disable autoplay */\n      body.a11y-no-autoplay video,\n      body.a11y-no-autoplay audio {\n        autoplay: none !important;\n      }\n\n      /* Disable blinking/flashing */\n      body.a11y-no-blinking *,\n      body.a11y-no-blinking *::before,\n      body.a11y-no-blinking *::after {\n        animation-name: none !important;\n        -webkit-animation-name: none !important;\n      }\n\n      body.a11y-no-blinking .blink,\n      body.a11y-no-blinking .flash,\n      body.a11y-no-blinking .pulse {\n        animation: none !important;\n      }\n\n      /* Improved text contrast */\n      body.a11y-high-contrast .text-sm { font-size: 0.95rem !important; }\n      body.a11y-high-contrast .text-xs { font-size: 0.85rem !important; }\n\n      /* Focus within improvements */\n      body.a11y-enhanced-focus .focus-within\\:ring {\n        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1) !important;\n      }\n\n      /* Print accessibility */\n      @media print {\n        body.a11y-screen-reader .no-print { display: none !important; }\n        body.a11y-high-contrast { filter: none !important; }\n      }\n\n      /* Responsive accessibility */\n      @media (max-width: 768px) {\n        body.a11y-large-touch-targets button,\n        body.a11y-large-touch-targets [role=\"button\"] {\n          min-height: 48px !important;\n          min-width: 48px !important;\n        }\n      }\n    `;\n\n    this.styleElement.textContent = css;\n    document.head.appendChild(this.styleElement);\n  }\n\n  /**\n   * Configure speech synthesis settings\n   */\n  private configureSpeechSynthesis(): void {\n    if ('speechSynthesis' in window && typeof SpeechSynthesisUtterance !== 'undefined') {\n      try {\n        // Set default speech rate\n        const utterance = new SpeechSynthesisUtterance('');\n        utterance.rate = this.preferences.speechRate;\n      } catch (error) {\n        console.warn('Speech synthesis configuration failed:', error);\n      }\n    }\n  }\n\n  /**\n   * Update preferences\n   */\n  updatePreferences(updates: Partial<AccessibilityPreferences>): void {\n    this.preferences = { ...this.preferences, ...updates };\n\n    // Track user overrides\n    const overrides = JSON.parse(localStorage.getItem('accessibility-overrides') || '{}');\n    Object.keys(updates).forEach(key => {\n      overrides[key] = true;\n    });\n    localStorage.setItem('accessibility-overrides', JSON.stringify(overrides));\n\n    this.savePreferences();\n    this.applyPreferences();\n    this.notifyListeners();\n  }\n\n  /**\n   * Get current preferences\n   */\n  getPreferences(): AccessibilityPreferences {\n    return { ...this.preferences };\n  }\n\n  /**\n   * Get current state including system preferences\n   */\n  getState(): AccessibilityState {\n    return {\n      ...this.preferences,\n      isSystemDarkMode: this.mediaQueries.get('dark-mode')?.matches ?? false,\n      isSystemReducedMotion: this.mediaQueries.get('reduced-motion')?.matches ?? false,\n      isSystemHighContrast: this.mediaQueries.get('high-contrast')?.matches ?? false,\n      systemFontScale: parseFloat(getComputedStyle(document.documentElement).fontSize) / 16,\n      screenReaderActive: this.preferences.screenReaderOptimized,\n      touchDevice: 'ontouchstart' in window,\n      hasHover: this.mediaQueries.get('hover')?.matches ?? true,\n    };\n  }\n\n  /**\n   * Reset to defaults\n   */\n  resetToDefaults(): void {\n    this.preferences = { ...this.defaultPreferences };\n    localStorage.removeItem('accessibility-preferences');\n    localStorage.removeItem('accessibility-overrides');\n    this.applyPreferences();\n    this.notifyListeners();\n  }\n\n  /**\n   * Subscribe to preference changes\n   */\n  subscribe(listener: (prefs: AccessibilityPreferences) => void): () => void {\n    this.listeners.push(listener);\n    return () => {\n      const index = this.listeners.indexOf(listener);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Notify all listeners of changes\n   */\n  private notifyListeners(): void {\n    this.listeners.forEach(listener => {\n      try {\n        listener(this.getPreferences());\n      } catch (error) {\n        console.error('Error in accessibility preference listener:', error);\n      }\n    });\n  }\n\n  /**\n   * Test color contrast\n   */\n  testColorContrast(foreground: string, background: string): { ratio: number; wcagAA: boolean; wcagAAA: boolean } {\n    // Simplified contrast calculation (would use a proper contrast library in production)\n    const ratio = 4.5; // Placeholder - implement proper contrast calculation\n    return {\n      ratio,\n      wcagAA: ratio >= 4.5,\n      wcagAAA: ratio >= 7,\n    };\n  }\n\n  /**\n   * Cleanup method\n   */\n  cleanup(): void {\n    this.mediaQueries.forEach(query => {\n      query.removeEventListener('change', this.handleSystemChange);\n    });\n    this.mediaQueries.clear();\n\n    if (this.styleElement) {\n      this.styleElement.remove();\n    }\n\n    this.listeners = [];\n  }\n}\n\nexport default AccessibilityPreferencesService;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/alarm-api-security.ts",
    "messages": [
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 394,
        "column": 13,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 394,
        "endColumn": 75,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [13138, 13386],
              "text": "{ const alarmValidation = this.validateAlarmData(sanitizedData);\n            errors.push(...alarmValidation.errors);\n            warnings.push(...alarmValidation.warnings);\n            sanitizedData = alarmValidation.sanitizedData;\n            break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 416,
        "column": 13,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 416,
        "endColumn": 77,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [14116, 14369],
              "text": "{ const importValidation = this.validateImportData(sanitizedData);\n            errors.push(...importValidation.errors);\n            warnings.push(...importValidation.warnings);\n            sanitizedData = importValidation.sanitizedData;\n            break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 589,
        "column": 11,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 589,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [20011, 20203],
              "text": "{ const limit = parseInt(value, 10);\n          if (isNaN(limit) || limit < 1 || limit > 1000) {\n            errors.push('Limit must be a number between 1 and 1000');\n          }\n          break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 596,
        "column": 11,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 596,
        "endColumn": 46,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [20238, 20412],
              "text": "{ const offset = parseInt(value, 10);\n          if (isNaN(offset) || offset < 0) {\n            errors.push('Offset must be a non-negative number');\n          }\n          break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Alarm API Security Headers and Validation Service\n// Provides comprehensive security for alarm API endpoints including headers, validation, and protection mechanisms\n\nimport SecurityService from './security';\nimport SecurityMonitoringForensicsService from './security-monitoring-forensics';\nimport AlarmRateLimitingService from './alarm-rate-limiting';\nimport { ErrorHandler } from './error-handler';\n\ninterface APIRequest {\n  method: string;\n  url: string;\n  headers: Record<string, string>;\n  body?: any;\n  params?: Record<string, string>;\n  query?: Record<string, string>;\n  userId?: string;\n  ip?: string;\n  userAgent?: string;\n  timestamp?: Date;\n}\n\ninterface SecurityHeaders {\n  'Content-Security-Policy': string;\n  'X-Content-Type-Options': string;\n  'X-Frame-Options': string;\n  'X-XSS-Protection': string;\n  'Strict-Transport-Security': string;\n  'Referrer-Policy': string;\n  'Permissions-Policy': string;\n  'X-Permitted-Cross-Domain-Policies': string;\n  'X-Rate-Limit-Limit'?: string;\n  'X-Rate-Limit-Remaining'?: string;\n  'X-Rate-Limit-Reset'?: string;\n  'X-Request-ID': string;\n  'X-Content-Security-Policy': string;\n  'Cache-Control': string;\n  'Pragma': string;\n  'Expires': string;\n}\n\ninterface ValidationResult {\n  valid: boolean;\n  errors: string[];\n  warnings: string[];\n  sanitizedData?: any;\n  securityFlags?: string[];\n}\n\ninterface APISecurityContext {\n  requestId: string;\n  userId?: string;\n  operation: string;\n  authenticated: boolean;\n  rateLimited: boolean;\n  validatedInput: boolean;\n  securityLevel: 'low' | 'medium' | 'high' | 'critical';\n  threats: string[];\n  headers: SecurityHeaders;\n  startTime: Date;\n}\n\ntype AlarmAPIEndpoint =\n  | 'GET /alarms'\n  | 'POST /alarms'\n  | 'PUT /alarms/:id'\n  | 'DELETE /alarms/:id'\n  | 'POST /alarms/bulk'\n  | 'GET /alarms/export'\n  | 'POST /alarms/import'\n  | 'POST /alarms/:id/snooze'\n  | 'POST /alarms/:id/dismiss'\n  | 'GET /alarms/backup'\n  | 'POST /alarms/backup'\n  | 'POST /alarms/restore'\n  | 'GET /alarms/security/status'\n  | 'POST /alarms/security/test';\n\nexport class AlarmAPISecurityService {\n  private static instance: AlarmAPISecurityService;\n  private static readonly CSRF_TOKEN_HEADER = 'X-CSRF-Token';\n  private static readonly REQUEST_ID_HEADER = 'X-Request-ID';\n  private static readonly SIGNATURE_HEADER = 'X-Request-Signature';\n  private static readonly TIMESTAMP_HEADER = 'X-Request-Timestamp';\n  private static readonly NONCE_HEADER = 'X-Request-Nonce';\n\n  private activeRequests: Map<string, APISecurityContext> = new Map();\n  private csrfTokens: Map<string, { token: string; expiresAt: Date; used: boolean }> = new Map();\n  private requestNonces: Set<string> = new Set();\n\n  // Security configuration\n  private readonly CSP_POLICY = [\n    \"default-src 'self'\",\n    \"script-src 'self' 'unsafe-inline' 'unsafe-eval'\",\n    \"style-src 'self' 'unsafe-inline'\",\n    \"img-src 'self' data: blob:\",\n    \"font-src 'self' data:\",\n    \"connect-src 'self' wss: https:\",\n    \"media-src 'self' data:\",\n    \"object-src 'none'\",\n    \"base-uri 'self'\",\n    \"form-action 'self'\",\n    \"frame-ancestors 'none'\",\n    \"upgrade-insecure-requests\"\n  ].join('; ');\n\n  private readonly ENDPOINT_SECURITY_LEVELS: Record<AlarmAPIEndpoint, 'low' | 'medium' | 'high' | 'critical'> = {\n    'GET /alarms': 'medium',\n    'POST /alarms': 'high',\n    'PUT /alarms/:id': 'high',\n    'DELETE /alarms/:id': 'critical',\n    'POST /alarms/bulk': 'critical',\n    'GET /alarms/export': 'high',\n    'POST /alarms/import': 'critical',\n    'POST /alarms/:id/snooze': 'medium',\n    'POST /alarms/:id/dismiss': 'medium',\n    'GET /alarms/backup': 'high',\n    'POST /alarms/backup': 'critical',\n    'POST /alarms/restore': 'critical',\n    'GET /alarms/security/status': 'medium',\n    'POST /alarms/security/test': 'high'\n  };\n\n  private constructor() {\n    this.startCleanupTimer();\n  }\n\n  static getInstance(): AlarmAPISecurityService {\n    if (!AlarmAPISecurityService.instance) {\n      AlarmAPISecurityService.instance = new AlarmAPISecurityService();\n    }\n    return AlarmAPISecurityService.instance;\n  }\n\n  /**\n   * Validate and secure an incoming API request\n   */\n  async validateRequest(request: APIRequest): Promise<{\n    context: APISecurityContext;\n    proceed: boolean;\n    response?: { status: number; headers: SecurityHeaders; body: any };\n  }> {\n    const requestId = this.generateRequestId();\n    const startTime = new Date();\n\n    try {\n      // Initialize security context\n      const endpoint = this.normalizeEndpoint(request.method, request.url);\n      const securityLevel = this.getEndpointSecurityLevel(endpoint);\n\n      const context: APISecurityContext = {\n        requestId,\n        userId: request.userId,\n        operation: endpoint,\n        authenticated: !!request.userId,\n        rateLimited: false,\n        validatedInput: false,\n        securityLevel,\n        threats: [],\n        headers: this.generateSecurityHeaders(requestId),\n        startTime\n      };\n\n      this.activeRequests.set(requestId, context);\n\n      // 1. Basic request validation\n      const basicValidation = await this.performBasicValidation(request);\n      if (!basicValidation.valid) {\n        context.threats.push('basic_validation_failed');\n        return this.createSecurityResponse(context, 400, 'Invalid request format', basicValidation.errors);\n      }\n\n      // 2. Rate limiting check\n      if (request.userId) {\n        const operation = this.mapEndpointToOperation(endpoint);\n        const rateLimitResult = await AlarmRateLimitingService.checkRateLimit(\n          request.userId,\n          operation,\n          request.ip\n        );\n\n        context.rateLimited = !rateLimitResult.allowed;\n        context.headers['X-Rate-Limit-Limit'] = rateLimitResult.remaining.toString();\n        context.headers['X-Rate-Limit-Remaining'] = rateLimitResult.remaining.toString();\n        context.headers['X-Rate-Limit-Reset'] = Math.floor(rateLimitResult.resetTime.getTime() / 1000).toString();\n\n        if (!rateLimitResult.allowed) {\n          context.threats.push('rate_limit_exceeded');\n          return this.createSecurityResponse(context, 429, 'Rate limit exceeded', [], {\n            retryAfter: rateLimitResult.retryAfter,\n            escalation: rateLimitResult.escalation\n          });\n        }\n      }\n\n      // 3. CSRF protection for state-changing operations\n      if (this.requiresCSRFProtection(request.method)) {\n        const csrfValidation = await this.validateCSRFToken(request);\n        if (!csrfValidation.valid) {\n          context.threats.push('csrf_validation_failed');\n          return this.createSecurityResponse(context, 403, 'CSRF validation failed', csrfValidation.errors);\n        }\n      }\n\n      // 4. Request signature validation for critical operations\n      if (securityLevel === 'critical') {\n        const signatureValidation = await this.validateRequestSignature(request);\n        if (!signatureValidation.valid) {\n          context.threats.push('signature_validation_failed');\n          return this.createSecurityResponse(context, 403, 'Request signature invalid', signatureValidation.errors);\n        }\n      }\n\n      // 5. Input validation and sanitization\n      const inputValidation = await this.validateAndSanitizeInput(request, endpoint);\n      context.validatedInput = inputValidation.valid;\n      if (!inputValidation.valid) {\n        context.threats.push('input_validation_failed');\n        return this.createSecurityResponse(context, 400, 'Invalid input data', inputValidation.errors);\n      }\n\n      // 6. Replay attack protection\n      if (securityLevel === 'high' || securityLevel === 'critical') {\n        const replayValidation = await this.validateReplayProtection(request);\n        if (!replayValidation.valid) {\n          context.threats.push('replay_attack_detected');\n          return this.createSecurityResponse(context, 403, 'Replay attack detected', replayValidation.errors);\n        }\n      }\n\n      // 7. Threat detection\n      const threatAnalysis = await this.analyzePotentialThreats(request, context);\n      context.threats.push(...threatAnalysis.threats);\n\n      if (threatAnalysis.block) {\n        return this.createSecurityResponse(context, 403, 'Request blocked by security policy', threatAnalysis.reasons);\n      }\n\n      // Update sanitized request data\n      if (inputValidation.sanitizedData) {\n        request.body = inputValidation.sanitizedData;\n      }\n\n      // Log successful validation\n      await this.logAPISecurityEvent('request_validated', context, { endpoint, securityLevel });\n\n      // Request validation passed\n      return {\n        context,\n        proceed: true\n      };\n\n    } catch (error) {\n      ErrorHandler.handleError(\n        error instanceof Error ? error : new Error(String(error)),\n        'API security validation failed',\n        { context: 'api_security', metadata: { requestId, endpoint: request.url } }\n      );\n\n      // Create default security context for error case\n      const errorContext: APISecurityContext = {\n        requestId,\n        operation: 'error',\n        authenticated: false,\n        rateLimited: false,\n        validatedInput: false,\n        securityLevel: 'critical',\n        threats: ['validation_error'],\n        headers: this.generateSecurityHeaders(requestId),\n        startTime\n      };\n\n      return this.createSecurityResponse(errorContext, 500, 'Security validation error');\n    }\n  }\n\n  /**\n   * Generate comprehensive security headers for API responses\n   */\n  generateSecurityHeaders(requestId: string, additional?: Partial<SecurityHeaders>): SecurityHeaders {\n    const headers: SecurityHeaders = {\n      'Content-Security-Policy': this.CSP_POLICY,\n      'X-Content-Type-Options': 'nosniff',\n      'X-Frame-Options': 'DENY',\n      'X-XSS-Protection': '1; mode=block',\n      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains; preload',\n      'Referrer-Policy': 'strict-origin-when-cross-origin',\n      'Permissions-Policy': 'camera=(), microphone=(), geolocation=(), usb=(), magnetometer=(), accelerometer=(), gyroscope=()',\n      'X-Permitted-Cross-Domain-Policies': 'none',\n      'X-Request-ID': requestId,\n      'X-Content-Security-Policy': this.CSP_POLICY,\n      'Cache-Control': 'no-store, no-cache, must-revalidate, private',\n      'Pragma': 'no-cache',\n      'Expires': '0'\n    };\n\n    // Merge additional headers\n    return { ...headers, ...additional };\n  }\n\n  /**\n   * Finalize API response with security enhancements\n   */\n  async finalizeResponse(\n    context: APISecurityContext,\n    status: number,\n    responseData: any\n  ): Promise<{ status: number; headers: SecurityHeaders; body: any }> {\n    try {\n      // Calculate response time\n      const responseTime = Date.now() - context.startTime.getTime();\n\n      // Add performance headers\n      context.headers['X-Response-Time'] = `${responseTime}ms`;\n      context.headers['X-Security-Level'] = context.securityLevel;\n\n      // Log API response\n      await this.logAPISecurityEvent('response_sent', context, {\n        status,\n        responseTime,\n        dataSize: JSON.stringify(responseData).length\n      });\n\n      // Clean up active request\n      this.activeRequests.delete(context.requestId);\n\n      // Sanitize response data for security\n      const sanitizedResponse = this.sanitizeResponseData(responseData, context.securityLevel);\n\n      return {\n        status,\n        headers: context.headers,\n        body: sanitizedResponse\n      };\n\n    } catch (error) {\n      console.error('[AlarmAPISecurity] Failed to finalize response:', error);\n      return {\n        status: 500,\n        headers: context.headers,\n        body: { error: 'Response processing failed' }\n      };\n    }\n  }\n\n  /**\n   * Generate CSRF token for client\n   */\n  async generateCSRFToken(userId: string): Promise<string> {\n    const token = SecurityService.generateCSRFToken();\n    const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour expiration\n\n    this.csrfTokens.set(token, {\n      token,\n      expiresAt,\n      used: false\n    });\n\n    // Clean up old tokens for this user\n    const userTokens = Array.from(this.csrfTokens.entries()).filter(\n      ([, tokenData]) => !tokenData.used && tokenData.expiresAt > new Date()\n    );\n\n    if (userTokens.length > 10) {\n      const oldestToken = userTokens[0][0];\n      this.csrfTokens.delete(oldestToken);\n    }\n\n    return token;\n  }\n\n  /**\n   * Validate API request input data\n   */\n  private async validateAndSanitizeInput(request: APIRequest, endpoint: string): Promise<ValidationResult> {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    let sanitizedData: any = null;\n\n    try {\n      if (request.body) {\n        // Basic structure validation\n        if (typeof request.body !== 'object' || request.body === null) {\n          errors.push('Request body must be a valid JSON object');\n          return { valid: false, errors, warnings };\n        }\n\n        // Deep clone for sanitization\n        sanitizedData = JSON.parse(JSON.stringify(request.body));\n\n        // Endpoint-specific validation\n        switch (endpoint) {\n          case 'POST /alarms':\n          case 'PUT /alarms/:id':\n            const alarmValidation = this.validateAlarmData(sanitizedData);\n            errors.push(...alarmValidation.errors);\n            warnings.push(...alarmValidation.warnings);\n            sanitizedData = alarmValidation.sanitizedData;\n            break;\n\n          case 'POST /alarms/bulk':\n            if (!Array.isArray(sanitizedData.alarms)) {\n              errors.push('Bulk operation requires an array of alarms');\n            } else if (sanitizedData.alarms.length > 100) {\n              errors.push('Bulk operation limited to 100 alarms per request');\n            } else {\n              sanitizedData.alarms = sanitizedData.alarms.map((alarm: any) => {\n                const validation = this.validateAlarmData(alarm);\n                errors.push(...validation.errors);\n                warnings.push(...validation.warnings);\n                return validation.sanitizedData;\n              });\n            }\n            break;\n\n          case 'POST /alarms/import':\n            const importValidation = this.validateImportData(sanitizedData);\n            errors.push(...importValidation.errors);\n            warnings.push(...importValidation.warnings);\n            sanitizedData = importValidation.sanitizedData;\n            break;\n\n          case 'POST /alarms/restore':\n            if (!sanitizedData.backupId || typeof sanitizedData.backupId !== 'string') {\n              errors.push('Valid backup ID is required');\n            }\n            break;\n        }\n\n        // Generic security sanitization\n        sanitizedData = this.sanitizeForSecurity(sanitizedData);\n      }\n\n      // Validate query parameters\n      if (request.query) {\n        const queryValidation = this.validateQueryParameters(request.query, endpoint);\n        errors.push(...queryValidation.errors);\n        warnings.push(...queryValidation.warnings);\n      }\n\n      // Validate URL parameters\n      if (request.params) {\n        const paramValidation = this.validateURLParameters(request.params);\n        errors.push(...paramValidation.errors);\n        warnings.push(...paramValidation.warnings);\n      }\n\n      return {\n        valid: errors.length === 0,\n        errors,\n        warnings,\n        sanitizedData\n      };\n\n    } catch (error) {\n      errors.push('Failed to validate input data');\n      return { valid: false, errors, warnings };\n    }\n  }\n\n  /**\n   * Validate alarm data structure and content\n   */\n  private validateAlarmData(alarm: any): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const sanitizedData: any = {};\n\n    // Required fields validation\n    if (!alarm.label || typeof alarm.label !== 'string') {\n      errors.push('Alarm label is required and must be a string');\n    } else {\n      sanitizedData.label = SecurityService.sanitizeInput(alarm.label, { maxLength: 100 });\n      if (sanitizedData.label !== alarm.label) {\n        warnings.push('Alarm label was sanitized for security');\n      }\n    }\n\n    if (!alarm.time || typeof alarm.time !== 'string') {\n      errors.push('Alarm time is required and must be a string');\n    } else {\n      // Validate time format (HH:MM)\n      const timeRegex = /^([01]?[0-9]|2[0-3]):[0-5][0-9]$/;\n      if (!timeRegex.test(alarm.time)) {\n        errors.push('Alarm time must be in HH:MM format');\n      } else {\n        sanitizedData.time = alarm.time;\n      }\n    }\n\n    // Optional fields with validation\n    sanitizedData.enabled = Boolean(alarm.enabled);\n    sanitizedData.isActive = Boolean(alarm.isActive);\n\n    if (alarm.days) {\n      if (Array.isArray(alarm.days)) {\n        sanitizedData.days = alarm.days.filter(d => typeof d === 'number' && d >= 0 && d <= 6);\n        if (sanitizedData.days.length !== alarm.days.length) {\n          warnings.push('Some invalid days were filtered out');\n        }\n      } else {\n        errors.push('Days must be an array of numbers (0-6)');\n      }\n    } else {\n      sanitizedData.days = [];\n    }\n\n    if (alarm.voiceMood) {\n      const validMoods = ['energetic', 'calm', 'motivational', 'gentle', 'stern'];\n      if (validMoods.includes(alarm.voiceMood)) {\n        sanitizedData.voiceMood = alarm.voiceMood;\n      } else {\n        warnings.push('Invalid voice mood, defaulting to \"energetic\"');\n        sanitizedData.voiceMood = 'energetic';\n      }\n    }\n\n    if (alarm.sound) {\n      sanitizedData.sound = SecurityService.sanitizeInput(String(alarm.sound));\n    }\n\n    if (typeof alarm.snoozeEnabled === 'boolean') {\n      sanitizedData.snoozeEnabled = alarm.snoozeEnabled;\n    }\n\n    if (typeof alarm.snoozeInterval === 'number' && alarm.snoozeInterval > 0 && alarm.snoozeInterval <= 60) {\n      sanitizedData.snoozeInterval = alarm.snoozeInterval;\n    } else if (alarm.snoozeInterval !== undefined) {\n      warnings.push('Invalid snooze interval, defaulting to 5 minutes');\n      sanitizedData.snoozeInterval = 5;\n    }\n\n    return { valid: errors.length === 0, errors, warnings, sanitizedData };\n  }\n\n  /**\n   * Validate import data\n   */\n  private validateImportData(data: any): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n    const sanitizedData: any = {};\n\n    if (!data.alarms || !Array.isArray(data.alarms)) {\n      errors.push('Import data must contain an array of alarms');\n      return { valid: false, errors, warnings };\n    }\n\n    if (data.alarms.length > 1000) {\n      errors.push('Import limited to 1000 alarms');\n      return { valid: false, errors, warnings };\n    }\n\n    sanitizedData.alarms = data.alarms.map((alarm: any, index: number) => {\n      const validation = this.validateAlarmData(alarm);\n      validation.errors.forEach(error => errors.push(`Alarm ${index}: ${error}`));\n      validation.warnings.forEach(warning => warnings.push(`Alarm ${index}: ${warning}`));\n      return validation.sanitizedData;\n    });\n\n    // Validate metadata if present\n    if (data.metadata) {\n      sanitizedData.metadata = {\n        version: SecurityService.sanitizeInput(String(data.metadata.version || '1.0')),\n        exportedAt: data.metadata.exportedAt ? new Date(data.metadata.exportedAt).toISOString() : new Date().toISOString(),\n        source: SecurityService.sanitizeInput(String(data.metadata.source || 'unknown'))\n      };\n    }\n\n    return { valid: errors.length === 0, errors, warnings, sanitizedData };\n  }\n\n  /**\n   * Validate query parameters\n   */\n  private validateQueryParameters(query: Record<string, string>, endpoint: string): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    Object.entries(query).forEach(([key, value]) => {\n      // Sanitize all query values\n      const sanitized = SecurityService.sanitizeInput(value);\n      if (sanitized !== value) {\n        warnings.push(`Query parameter ${key} was sanitized`);\n      }\n\n      // Endpoint-specific validation\n      switch (key) {\n        case 'limit':\n          const limit = parseInt(value, 10);\n          if (isNaN(limit) || limit < 1 || limit > 1000) {\n            errors.push('Limit must be a number between 1 and 1000');\n          }\n          break;\n\n        case 'offset':\n          const offset = parseInt(value, 10);\n          if (isNaN(offset) || offset < 0) {\n            errors.push('Offset must be a non-negative number');\n          }\n          break;\n\n        case 'search':\n          if (value.length > 100) {\n            errors.push('Search query too long (max 100 characters)');\n          }\n          break;\n      }\n    });\n\n    return { valid: errors.length === 0, errors, warnings };\n  }\n\n  /**\n   * Validate URL parameters\n   */\n  private validateURLParameters(params: Record<string, string>): ValidationResult {\n    const errors: string[] = [];\n    const warnings: string[] = [];\n\n    Object.entries(params).forEach(([key, value]) => {\n      switch (key) {\n        case 'id':\n          if (!value || typeof value !== 'string' || value.length < 1 || value.length > 50) {\n            errors.push('Invalid ID parameter');\n          }\n          break;\n      }\n    });\n\n    return { valid: errors.length === 0, errors, warnings };\n  }\n\n  /**\n   * Basic request validation\n   */\n  private async performBasicValidation(request: APIRequest): Promise<ValidationResult> {\n    const errors: string[] = [];\n\n    // Method validation\n    const validMethods = ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'];\n    if (!validMethods.includes(request.method.toUpperCase())) {\n      errors.push('Invalid HTTP method');\n    }\n\n    // URL validation\n    if (!request.url || typeof request.url !== 'string') {\n      errors.push('Invalid URL');\n    }\n\n    // Headers validation\n    if (!request.headers || typeof request.headers !== 'object') {\n      errors.push('Invalid headers');\n    } else {\n      // Check for required headers\n      const contentType = request.headers['content-type'] || request.headers['Content-Type'];\n      if (['POST', 'PUT'].includes(request.method.toUpperCase()) && request.body) {\n        if (!contentType || !contentType.includes('application/json')) {\n          errors.push('Content-Type must be application/json for requests with body');\n        }\n      }\n\n      // Check for suspicious headers\n      Object.entries(request.headers).forEach(([key, value]) => {\n        if (this.isSuspiciousHeader(key, value)) {\n          errors.push(`Suspicious header detected: ${key}`);\n        }\n      });\n    }\n\n    // User agent validation\n    if (request.userAgent && this.isSuspiciousUserAgent(request.userAgent)) {\n      errors.push('Suspicious User-Agent detected');\n    }\n\n    return { valid: errors.length === 0, errors, warnings: [] };\n  }\n\n  /**\n   * CSRF token validation\n   */\n  private async validateCSRFToken(request: APIRequest): Promise<ValidationResult> {\n    const token = request.headers[AlarmAPISecurityService.CSRF_TOKEN_HEADER];\n\n    if (!token) {\n      return { valid: false, errors: ['CSRF token is required'], warnings: [] };\n    }\n\n    const tokenData = this.csrfTokens.get(token);\n    if (!tokenData) {\n      return { valid: false, errors: ['Invalid CSRF token'], warnings: [] };\n    }\n\n    if (tokenData.used) {\n      return { valid: false, errors: ['CSRF token already used'], warnings: [] };\n    }\n\n    if (tokenData.expiresAt < new Date()) {\n      this.csrfTokens.delete(token);\n      return { valid: false, errors: ['CSRF token expired'], warnings: [] };\n    }\n\n    // Mark token as used\n    tokenData.used = true;\n    return { valid: true, errors: [], warnings: [] };\n  }\n\n  /**\n   * Request signature validation\n   */\n  private async validateRequestSignature(request: APIRequest): Promise<ValidationResult> {\n    const signature = request.headers[AlarmAPISecurityService.SIGNATURE_HEADER];\n    const timestamp = request.headers[AlarmAPISecurityService.TIMESTAMP_HEADER];\n\n    if (!signature || !timestamp) {\n      return { valid: false, errors: ['Request signature and timestamp are required for critical operations'], warnings: [] };\n    }\n\n    // Validate timestamp (must be within 5 minutes)\n    const requestTime = new Date(timestamp);\n    const now = new Date();\n    const timeDiff = Math.abs(now.getTime() - requestTime.getTime());\n\n    if (timeDiff > 5 * 60 * 1000) { // 5 minutes\n      return { valid: false, errors: ['Request timestamp is too old'], warnings: [] };\n    }\n\n    // Validate signature\n    const expectedSignature = this.generateRequestSignature(request, timestamp);\n    if (signature !== expectedSignature) {\n      return { valid: false, errors: ['Invalid request signature'], warnings: [] };\n    }\n\n    return { valid: true, errors: [], warnings: [] };\n  }\n\n  /**\n   * Replay attack protection\n   */\n  private async validateReplayProtection(request: APIRequest): Promise<ValidationResult> {\n    const nonce = request.headers[AlarmAPISecurityService.NONCE_HEADER];\n\n    if (!nonce) {\n      return { valid: false, errors: ['Request nonce is required'], warnings: [] };\n    }\n\n    if (this.requestNonces.has(nonce)) {\n      return { valid: false, errors: ['Request nonce already used (replay attack detected)'], warnings: [] };\n    }\n\n    // Add nonce to set\n    this.requestNonces.add(nonce);\n\n    // Clean up old nonces (keep last 10000)\n    if (this.requestNonces.size > 10000) {\n      const noncesArray = Array.from(this.requestNonces);\n      this.requestNonces = new Set(noncesArray.slice(-5000));\n    }\n\n    return { valid: true, errors: [], warnings: [] };\n  }\n\n  /**\n   * Analyze potential security threats in request\n   */\n  private async analyzePotentialThreats(request: APIRequest, context: APISecurityContext): Promise<{\n    threats: string[];\n    block: boolean;\n    reasons: string[];\n  }> {\n    const threats: string[] = [];\n    const reasons: string[] = [];\n    let block = false;\n\n    // SQL injection patterns\n    if (this.containsSQLInjection(JSON.stringify(request.body) + JSON.stringify(request.query))) {\n      threats.push('sql_injection_attempt');\n      reasons.push('Potential SQL injection detected');\n      block = true;\n    }\n\n    // XSS patterns\n    if (this.containsXSS(JSON.stringify(request.body))) {\n      threats.push('xss_attempt');\n      reasons.push('Potential XSS attack detected');\n      block = true;\n    }\n\n    // Large payload attack\n    if (request.body && JSON.stringify(request.body).length > 10 * 1024 * 1024) { // 10MB\n      threats.push('large_payload_attack');\n      reasons.push('Payload too large');\n      block = true;\n    }\n\n    // Suspicious patterns in URL\n    if (this.containsSuspiciousURLPatterns(request.url)) {\n      threats.push('suspicious_url_pattern');\n      reasons.push('Suspicious URL pattern detected');\n      // Don't block for this, just log\n    }\n\n    // Excessive nested objects (JSON bomb)\n    if (request.body && this.isJSONBomb(request.body)) {\n      threats.push('json_bomb_attempt');\n      reasons.push('Potential JSON bomb detected');\n      block = true;\n    }\n\n    return { threats, block, reasons };\n  }\n\n  // Helper methods for threat detection\n  private containsSQLInjection(input: string): boolean {\n    const sqlPatterns = [\n      /(\\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|UNION)\\b)/i,\n      /(\\b(OR|AND)\\s+\\d+\\s*=\\s*\\d+)/i,\n      /(;|\\|\\||--|\\*|\\bxp_\\b)/i\n    ];\n    return sqlPatterns.some(pattern => pattern.test(input));\n  }\n\n  private containsXSS(input: string): boolean {\n    const xssPatterns = [\n      /<script[^>]*>.*?<\\/script>/gi,\n      /javascript:/gi,\n      /on\\w+\\s*=/gi,\n      /<iframe[^>]*>.*?<\\/iframe>/gi,\n      /<object[^>]*>.*?<\\/object>/gi\n    ];\n    return xssPatterns.some(pattern => pattern.test(input));\n  }\n\n  private containsSuspiciousURLPatterns(url: string): boolean {\n    const suspiciousPatterns = [\n      /\\.\\.\\//, // Directory traversal\n      /%2e%2e%2f/i, // Encoded directory traversal\n      /\\0/, // Null byte\n      /%00/i // Encoded null byte\n    ];\n    return suspiciousPatterns.some(pattern => pattern.test(url));\n  }\n\n  private isJSONBomb(obj: any, depth = 0, maxDepth = 100): boolean {\n    if (depth > maxDepth) return true;\n\n    if (typeof obj === 'object' && obj !== null) {\n      if (Array.isArray(obj)) {\n        if (obj.length > 10000) return true;\n        return obj.some(item => this.isJSONBomb(item, depth + 1, maxDepth));\n      } else {\n        const keys = Object.keys(obj);\n        if (keys.length > 1000) return true;\n        return keys.some(key => this.isJSONBomb(obj[key], depth + 1, maxDepth));\n      }\n    }\n\n    return false;\n  }\n\n  private isSuspiciousHeader(key: string, value: string): boolean {\n    const suspiciousHeaders = ['x-forwarded-for', 'x-real-ip'];\n    const suspiciousValues = /(<script|javascript:|data:)/i;\n\n    return suspiciousHeaders.includes(key.toLowerCase()) && suspiciousValues.test(value);\n  }\n\n  private isSuspiciousUserAgent(userAgent: string): boolean {\n    const suspiciousPatterns = [\n      /bot|crawler|spider/i,\n      /script|curl|wget|python/i,\n      /<script|javascript:/i\n    ];\n    return suspiciousPatterns.some(pattern => pattern.test(userAgent));\n  }\n\n  // Utility methods\n  private normalizeEndpoint(method: string, url: string): string {\n    // Normalize URL by replacing ID parameters with :id\n    const normalizedUrl = url.replace(/\\/[0-9a-fA-F-]{8,}/g, '/:id');\n    return `${method.toUpperCase()} ${normalizedUrl}`;\n  }\n\n  private getEndpointSecurityLevel(endpoint: string): 'low' | 'medium' | 'high' | 'critical' {\n    return this.ENDPOINT_SECURITY_LEVELS[endpoint as AlarmAPIEndpoint] || 'medium';\n  }\n\n  private mapEndpointToOperation(endpoint: string): any {\n    const operationMap: Record<string, any> = {\n      'POST /alarms': 'create_alarm',\n      'PUT /alarms/:id': 'update_alarm',\n      'DELETE /alarms/:id': 'delete_alarm',\n      'POST /alarms/bulk': 'bulk_operations',\n      'GET /alarms/export': 'alarm_export',\n      'POST /alarms/import': 'alarm_import',\n      'POST /alarms/:id/snooze': 'snooze_alarm',\n      'POST /alarms/:id/dismiss': 'dismiss_alarm',\n      'POST /alarms/backup': 'backup_create',\n      'POST /alarms/restore': 'backup_restore',\n      'GET /alarms': 'data_access'\n    };\n    return operationMap[endpoint] || 'data_access';\n  }\n\n  private requiresCSRFProtection(method: string): boolean {\n    return ['POST', 'PUT', 'DELETE'].includes(method.toUpperCase());\n  }\n\n  private generateRequestId(): string {\n    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private generateRequestSignature(request: APIRequest, timestamp: string): string {\n    const signatureData = {\n      method: request.method,\n      url: request.url,\n      body: request.body,\n      timestamp\n    };\n    return SecurityService.hashData(JSON.stringify(signatureData));\n  }\n\n  private sanitizeForSecurity(data: any): any {\n    if (typeof data === 'string') {\n      return SecurityService.sanitizeInput(data);\n    }\n\n    if (Array.isArray(data)) {\n      return data.map(item => this.sanitizeForSecurity(item));\n    }\n\n    if (typeof data === 'object' && data !== null) {\n      const sanitized: any = {};\n      Object.entries(data).forEach(([key, value]) => {\n        const sanitizedKey = SecurityService.sanitizeInput(key);\n        sanitized[sanitizedKey] = this.sanitizeForSecurity(value);\n      });\n      return sanitized;\n    }\n\n    return data;\n  }\n\n  private sanitizeResponseData(data: any, securityLevel: string): any {\n    // Remove sensitive fields based on security level\n    if (securityLevel === 'low') {\n      return data; // No sanitization for low security\n    }\n\n    // Deep clone and sanitize\n    const sanitized = JSON.parse(JSON.stringify(data));\n\n    // Remove sensitive fields\n    this.removeSensitiveFields(sanitized);\n\n    return sanitized;\n  }\n\n  private removeSensitiveFields(obj: any): void {\n    if (typeof obj === 'object' && obj !== null) {\n      const sensitiveFields = ['password', 'token', 'secret', 'key', 'signature', 'csrf'];\n\n      sensitiveFields.forEach(field => {\n        delete obj[field];\n      });\n\n      Object.values(obj).forEach(value => {\n        if (typeof value === 'object') {\n          this.removeSensitiveFields(value);\n        }\n      });\n    }\n  }\n\n  private createSecurityResponse(\n    context: APISecurityContext,\n    status: number,\n    message: string,\n    errors: string[] = [],\n    additional: any = {}\n  ): { context: APISecurityContext; proceed: false; response: { status: number; headers: SecurityHeaders; body: any } } {\n    return {\n      context,\n      proceed: false,\n      response: {\n        status,\n        headers: context.headers,\n        body: {\n          error: message,\n          errors,\n          requestId: context.requestId,\n          timestamp: new Date().toISOString(),\n          ...additional\n        }\n      }\n    };\n  }\n\n  private async logAPISecurityEvent(event: string, context: APISecurityContext, details: any = {}): Promise<void> {\n    await SecurityMonitoringForensicsService.logSecurityEvent(\n      event === 'request_validated' ? 'data_access' : 'security_test_failure',\n      context.threats.length > 0 ? 'high' : 'low',\n      'alarm_api_security',\n      {\n        requestId: context.requestId,\n        operation: context.operation,\n        securityLevel: context.securityLevel,\n        threats: context.threats,\n        event,\n        ...details\n      },\n      context.userId\n    );\n  }\n\n  private startCleanupTimer(): void {\n    setInterval(() => {\n      this.cleanupExpiredData();\n    }, 15 * 60 * 1000); // Every 15 minutes\n  }\n\n  private cleanupExpiredData(): void {\n    const now = new Date();\n\n    // Cleanup expired CSRF tokens\n    for (const [token, data] of this.csrfTokens.entries()) {\n      if (data.expiresAt < now || data.used) {\n        this.csrfTokens.delete(token);\n      }\n    }\n\n    // Cleanup old requests\n    for (const [requestId, context] of this.activeRequests.entries()) {\n      if (now.getTime() - context.startTime.getTime() > 10 * 60 * 1000) { // 10 minutes\n        this.activeRequests.delete(requestId);\n      }\n    }\n\n    // Limit nonces set size\n    if (this.requestNonces.size > 10000) {\n      const noncesArray = Array.from(this.requestNonces);\n      this.requestNonces = new Set(noncesArray.slice(-5000));\n    }\n  }\n\n  /**\n   * Get security statistics for monitoring\n   */\n  async getSecurityStats(): Promise<{\n    activeRequests: number;\n    blockedRequests: number;\n    threatsDetected: number;\n    csrfTokensActive: number;\n    requestNoncesActive: number;\n    securityLevel: 'low' | 'medium' | 'high' | 'critical';\n  }> {\n    const activeRequests = this.activeRequests.size;\n    const threatCount = Array.from(this.activeRequests.values())\n      .reduce((sum, context) => sum + context.threats.length, 0);\n\n    const blockedRequests = Array.from(this.activeRequests.values())\n      .filter(context => context.threats.length > 0).length;\n\n    let securityLevel: 'low' | 'medium' | 'high' | 'critical' = 'low';\n    if (threatCount > 10) {\n      securityLevel = 'critical';\n    } else if (threatCount > 5) {\n      securityLevel = 'high';\n    } else if (threatCount > 2) {\n      securityLevel = 'medium';\n    }\n\n    return {\n      activeRequests,\n      blockedRequests,\n      threatsDetected: threatCount,\n      csrfTokensActive: this.csrfTokens.size,\n      requestNoncesActive: this.requestNonces.size,\n      securityLevel\n    };\n  }\n\n  /**\n   * Cleanup resources\n   */\n  destroy(): void {\n    this.activeRequests.clear();\n    this.csrfTokens.clear();\n    this.requestNonces.clear();\n    console.log('[AlarmAPISecurity] Service destroyed');\n  }\n}\n\nexport default AlarmAPISecurityService.getInstance();",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/alarm-executor.ts",
    "messages": [
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 267,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 267,
        "endColumn": 66,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [8055, 8746],
              "text": "{ const adjustmentMinutes = action.parameters.minutes || 0;\n        const newTime = this.adjustTimeByMinutes(alarm.time, adjustmentMinutes);\n        // Update the alarm with new time using the correct format\n        await AlarmService.updateAlarm(alarm.id, {\n          time: newTime,\n          label: alarm.label,\n          days: alarm.days,\n          voiceMood: alarm.voiceMood,\n          sound: alarm.sound,\n          difficulty: alarm.difficulty,\n          snoozeEnabled: alarm.snoozeEnabled,\n          snoozeInterval: alarm.snoozeInterval,\n          maxSnoozes: alarm.maxSnoozes,\n          battleId: alarm.battleId,\n          weatherEnabled: alarm.weatherEnabled\n        });\n        break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 268,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 268,
        "endColumn": 81,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [8055, 8746],
              "text": "{ const adjustmentMinutes = action.parameters.minutes || 0;\n        const newTime = this.adjustTimeByMinutes(alarm.time, adjustmentMinutes);\n        // Update the alarm with new time using the correct format\n        await AlarmService.updateAlarm(alarm.id, {\n          time: newTime,\n          label: alarm.label,\n          days: alarm.days,\n          voiceMood: alarm.voiceMood,\n          sound: alarm.sound,\n          difficulty: alarm.difficulty,\n          snoozeEnabled: alarm.snoozeEnabled,\n          snoozeInterval: alarm.snoozeInterval,\n          maxSnoozes: alarm.maxSnoozes,\n          battleId: alarm.battleId,\n          weatherEnabled: alarm.weatherEnabled\n        });\n        break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * AlarmExecutor - Handles smart optimizations, conditional rules, and advanced execution logic\n */\nimport type {\n  Alarm,\n  SmartOptimization,\n  SeasonalAdjustment,\n  LocationTrigger,\n  SunSchedule,\n  ConditionalRule,\n  SchedulingConfig\n} from '../types/index';\nimport { AlarmService } from './alarm';\n\nexport class AlarmExecutor {\n  \n  // ===== SMART OPTIMIZATIONS =====\n\n  static async applySmartOptimizations(\n    alarm: Alarm,\n    config: SchedulingConfig\n  ): Promise<Alarm> {\n    if (!alarm.smartOptimizations || !config.enableSmartAdjustments) {\n      return alarm;\n    }\n\n    let optimizedAlarm = { ...alarm };\n\n    for (const optimization of alarm.smartOptimizations.filter(o => o.isEnabled)) {\n      try {\n        optimizedAlarm = await this.applyOptimization(optimizedAlarm, optimization, config);\n      } catch (error) {\n        console.error('Error applying optimization:', optimization.type, error);\n      }\n    }\n\n    return optimizedAlarm;\n  }\n\n  private static async applyOptimization(\n    alarm: Alarm,\n    optimization: SmartOptimization,\n    config: SchedulingConfig\n  ): Promise<Alarm> {\n    const { type, parameters } = optimization;\n    let adjustmentMinutes = 0;\n\n    switch (type) {\n      case 'sleep_cycle':\n        adjustmentMinutes = await this.calculateSleepCycleAdjustment(alarm);\n        break;\n\n      case 'sunrise_sunset':\n        adjustmentMinutes = await this.calculateSunriseAdjustment(alarm);\n        break;\n\n      case 'traffic_conditions':\n        adjustmentMinutes = await this.calculateTrafficAdjustment(alarm);\n        break;\n\n      case 'weather_forecast':\n        adjustmentMinutes = await this.calculateWeatherAdjustment(alarm);\n        break;\n\n      case 'energy_levels':\n        adjustmentMinutes = await this.calculateEnergyLevelAdjustment(alarm);\n        break;\n        \n      default:\n        return alarm;\n    }\n\n    // Apply constraints\n    const maxAdjustment = optimization.parameters.maxAdjustment || config.maxDailyAdjustment;\n    adjustmentMinutes = Math.max(-maxAdjustment, Math.min(maxAdjustment, adjustmentMinutes));\n\n    // Adjust alarm time\n    if (adjustmentMinutes !== 0) {\n      const optimizedTime = this.adjustTimeByMinutes(alarm.time, adjustmentMinutes);\n      const updatedOptimization = { ...optimization, lastApplied: new Date() };\n\n      return {\n        ...alarm,\n        time: optimizedTime,\n        smartOptimizations: alarm.smartOptimizations?.map(o =>\n          o.type === type ? optimization : o\n        )\n      };\n    }\n\n    return alarm;\n  }\n\n  private static async calculateSleepCycleAdjustment(alarm: Alarm): Promise<number> {\n    // In a real implementation, this would analyze user's sleep patterns\n    // and adjust timing to align with optimal sleep cycles (90-minute cycles)\n    const sleepCycleMinutes = 90;\n    const optimalWakeMinutes = [0, 15, 30]; // Best times within a cycle to wake\n    \n    const [hours, minutes] = alarm.time.split(':').map(Number);\n    const totalMinutes = hours * 60 + minutes;\n    const cyclePosition = totalMinutes % sleepCycleMinutes;\n    \n    // Find nearest optimal wake time\n    let bestAdjustment = 0;\n    let minDistance = Infinity;\n    \n    for (const optimal of optimalWakeMinutes) {\n      const distance = Math.abs(cyclePosition - optimal);\n      if (distance < minDistance) {\n        minDistance = distance;\n        bestAdjustment = optimal - cyclePosition;\n      }\n    }\n    \n    // Only adjust if significant improvement (> 10 minutes)\n    return minDistance > 10 ? bestAdjustment : 0;\n  }\n\n  private static async calculateSunriseAdjustment(alarm: Alarm): Promise<number> {\n    // In a real implementation, get actual sunrise time for user's location\n    // For now, simulate adjustment based on season\n    const now = new Date();\n    const month = now.getMonth() + 1;\n    \n    // Summer: earlier sunrise, winter: later sunrise\n    if (month >= 6 && month <= 8) {\n      return -15; // Wake 15 minutes earlier in summer\n    } else if (month >= 12 || month <= 2) {\n      return 15; // Wake 15 minutes later in winter\n    }\n    \n    return 0;\n  }\n\n  private static async calculateTrafficAdjustment(alarm: Alarm): Promise<number> {\n    // In a real implementation, integrate with traffic APIs\n    // Simulate traffic-based adjustment\n    const now = new Date();\n    const dayOfWeek = now.getDay();\n    const [hours] = alarm.time.split(':').map(Number);\n    \n    // Rush hour adjustments (weekdays 7-9 AM)\n    if (dayOfWeek >= 1 && dayOfWeek <= 5 && hours >= 7 && hours <= 9) {\n      return -10; // Leave 10 minutes earlier for traffic\n    }\n    \n    return 0;\n  }\n\n  private static async calculateWeatherAdjustment(alarm: Alarm): Promise<number> {\n    // In a real implementation, get actual weather forecast\n    // Simulate weather-based adjustment\n    const conditions = ['clear', 'rain', 'snow', 'fog'];\n    const randomCondition = conditions[Math.floor(Math.random() * conditions.length)];\n    \n    switch (randomCondition) {\n      case 'rain':\n      case 'snow':\n        return -5; // Wake 5 minutes earlier for bad weather\n      case 'fog':\n        return -10; // Wake 10 minutes earlier for fog\n      default:\n        return 0;\n    }\n  }\n\n  private static async calculateEnergyLevelAdjustment(alarm: Alarm): Promise<number> {\n    // In a real implementation, analyze user's energy patterns from fitness trackers\n    // or user-reported data. For now, simulate based on time of alarm\n    const [hours] = alarm.time.split(':').map(Number);\n    \n    // Very early alarms might benefit from slight delay\n    if (hours < 6) {\n      return 5; // Allow 5 more minutes for very early alarms\n    }\n    \n    return 0;\n  }\n\n  // ===== SEASONAL ADJUSTMENTS =====\n\n  static applySeasonalAdjustments(\n    alarm: Alarm,\n    date: Date = new Date()\n  ): Alarm {\n    if (!alarm.seasonalAdjustments || alarm.seasonalAdjustments.length === 0) {\n      return alarm;\n    }\n\n    const currentSeason = this.getCurrentSeason(date);\n    const activeAdjustment = alarm.seasonalAdjustments.find(\n      adj => adj.season === currentSeason && adj.isActive\n    );\n\n    if (activeAdjustment) {\n      const adjustedTime = this.adjustTimeByMinutes(alarm.time, activeAdjustment.adjustmentMinutes);\n      return { ...alarm, time: adjustedTime };\n    }\n\n    return alarm;\n  }\n\n  private static getCurrentSeason(date: Date): 'spring' | 'summer' | 'fall' | 'winter' {\n    const month = date.getMonth() + 1; // 1-12\n\n    if (month >= 3 && month <= 5) return 'spring';\n    if (month >= 6 && month <= 8) return 'summer';\n    if (month >= 9 && month <= 11) return 'fall';\n    return 'winter';\n  }\n\n  // ===== LOCATION-BASED ALARMS =====\n\n  static async evaluateLocationTriggers(\n    alarm: Alarm,\n    currentLocation?: GeolocationPosition\n  ): Promise<boolean> {\n    if (!alarm.locationTriggers || !currentLocation) {\n      return true;\n    }\n\n    for (const trigger of alarm.locationTriggers.filter(t => t.isActive)) {\n      const distance = this.calculateDistance(\n        currentLocation.coords.latitude,\n        currentLocation.coords.longitude,\n        trigger.location.latitude,\n        trigger.location.longitude\n      );\n\n      const isWithinRadius = distance <= trigger.radius;\n\n      switch (trigger.type) {\n        case 'enter_location':\n          if (isWithinRadius) {\n            await this.executeLocationAction(alarm, trigger.action);\n            return trigger.action.type !== 'disable_alarm';\n          }\n          break;\n\n        case 'exit_location':\n          if (!isWithinRadius) {\n            await this.executeLocationAction(alarm, trigger.action);\n            return trigger.action.type !== 'disable_alarm';\n          }\n          break;\n      }\n    }\n\n    return true;\n  }\n\n  private static async executeLocationAction(\n    alarm: Alarm,\n    action: any\n  ): Promise<void> {\n    switch (action.type) {\n      case 'enable_alarm':\n        await AlarmService.toggleAlarm(alarm.id, true);\n        break;\n\n      case 'disable_alarm':\n        await AlarmService.toggleAlarm(alarm.id, false);\n        break;\n\n      case 'adjust_time':\n        const adjustmentMinutes = action.parameters.minutes || 0;\n        const newTime = this.adjustTimeByMinutes(alarm.time, adjustmentMinutes);\n        // Update the alarm with new time using the correct format\n        await AlarmService.updateAlarm(alarm.id, {\n          time: newTime,\n          label: alarm.label,\n          days: alarm.days,\n          voiceMood: alarm.voiceMood,\n          sound: alarm.sound,\n          difficulty: alarm.difficulty,\n          snoozeEnabled: alarm.snoozeEnabled,\n          snoozeInterval: alarm.snoozeInterval,\n          maxSnoozes: alarm.maxSnoozes,\n          battleId: alarm.battleId,\n          weatherEnabled: alarm.weatherEnabled\n        });\n        break;\n\n      case 'notification':\n        await this.sendNotification(\n          action.parameters.message || 'Location-based alarm triggered',\n          action.parameters\n        );\n        break;\n    }\n  }\n\n  private static calculateDistance(\n    lat1: number,\n    lon1: number,\n    lat2: number,\n    lon2: number\n  ): number {\n    const R = 6371; // Earth's radius in kilometers\n    const dLat = this.deg2rad(lat2 - lat1);\n    const dLon = this.deg2rad(lon2 - lon1);\n    const a =\n      Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n      Math.cos(this.deg2rad(lat1)) * Math.cos(this.deg2rad(lat2)) *\n      Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n    const distance = R * c * 1000; // Distance in meters\n    return distance;\n  }\n\n  private static deg2rad(deg: number): number {\n    return deg * (Math.PI / 180);\n  }\n\n  // ===== SUN-BASED SCHEDULING =====\n\n  static async calculateSunBasedTime(sunSchedule: SunSchedule, date: Date = new Date()): Promise<string> {\n    try {\n      const sunTimes = await this.getSunTimes(sunSchedule.location, date);\n      const baseTime = sunSchedule.type === 'sunrise' ? sunTimes.sunrise : sunTimes.sunset;\n\n      // Apply offset\n      const adjustedTime = new Date(baseTime.getTime() + (sunSchedule.offset * 60 * 1000));\n\n      // Apply seasonal adjustment if enabled\n      if (sunSchedule.seasonalAdjustment) {\n        const seasonalOffset = this.getSeasonalSunOffset(date);\n        adjustedTime.setMinutes(adjustedTime.getMinutes() + seasonalOffset);\n      }\n\n      return this.formatTimeToHHMM(adjustedTime);\n    } catch (error) {\n      console.error('Error calculating sun-based time:', error);\n      return '07:00'; // Fallback time\n    }\n  }\n\n  private static async getSunTimes(location: any, date: Date): Promise<{ sunrise: Date; sunset: Date }> {\n    // This would integrate with a sunrise/sunset API\n    // For now, return estimated times based on location and date\n    const sunrise = new Date(date);\n    const sunset = new Date(date);\n\n    // Simplified calculation - in real implementation, use SunCalc or similar library\n    sunrise.setHours(6, 30, 0, 0);\n    sunset.setHours(18, 30, 0, 0);\n\n    return { sunrise, sunset };\n  }\n\n  private static getSeasonalSunOffset(date: Date): number {\n    const month = date.getMonth() + 1;\n    \n    // Seasonal adjustments for sunrise/sunset timing\n    if (month >= 6 && month <= 8) {\n      return -10; // Summer: slightly earlier\n    } else if (month >= 12 || month <= 2) {\n      return 10; // Winter: slightly later\n    }\n    \n    return 0;\n  }\n\n  // ===== CONDITIONAL RULES EVALUATION =====\n\n  static async evaluateConditionalRules(\n    alarm: Alarm,\n    forDate?: Date\n  ): Promise<boolean> {\n    if (!alarm.conditionalRules || alarm.conditionalRules.length === 0) {\n      return true;\n    }\n\n    for (const rule of alarm.conditionalRules.filter(r => r.isActive)) {\n      let conditionMet = false;\n\n      try {\n        switch (rule.type) {\n          case 'weather':\n            conditionMet = await this.evaluateWeatherCondition(rule.conditions);\n            break;\n          case 'calendar':\n            conditionMet = await this.evaluateCalendarCondition(rule.conditions);\n            break;\n          case 'sleep_quality':\n            conditionMet = await this.evaluateSleepQualityCondition(rule.conditions);\n            break;\n          case 'day_of_week':\n            conditionMet = await this.evaluateDayOfWeekCondition(rule.conditions);\n            break;\n          case 'time_since_last':\n            conditionMet = await this.evaluateTimeSinceLastCondition(rule.conditions);\n            break;\n          default:\n            console.log(`Unknown conditional rule type: ${rule.type}`);\n            conditionMet = true;\n            break;\n        }\n      } catch (error) {\n        console.error(`Error evaluating conditional rule ${rule.type}:`, error);\n        conditionMet = true; // Default to allowing the alarm\n      }\n\n      if (rule.action.type === 'disable_alarm' && conditionMet) {\n        return false;\n      } else if (rule.action.type === 'enable_alarm' && !conditionMet) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private static async evaluateWeatherCondition(conditions: any): Promise<boolean> {\n    // In a real implementation, get actual weather data\n    // For now, simulate weather condition evaluation\n    const weatherConditions = ['sunny', 'rainy', 'cloudy', 'snowy'];\n    const currentWeather = weatherConditions[Math.floor(Math.random() * weatherConditions.length)];\n    \n    if (conditions.weatherType) {\n      return conditions.weatherType === currentWeather;\n    }\n    \n    if (conditions.temperature) {\n      // Simulate temperature check (in real implementation, get actual temperature)\n      const currentTemp = 20 + Math.random() * 15; // 20-35¬∞C\n      return currentTemp >= conditions.temperature.min && currentTemp <= conditions.temperature.max;\n    }\n    \n    return true;\n  }\n\n  private static async evaluateCalendarCondition(conditions: any): Promise<boolean> {\n    // In a real implementation, integrate with calendar APIs\n    // For now, simulate calendar condition evaluation\n    const hasEvents = Math.random() > 0.5;\n    \n    if (conditions.hasEvents !== undefined) {\n      return conditions.hasEvents === hasEvents;\n    }\n    \n    return true;\n  }\n\n  private static async evaluateSleepQualityCondition(conditions: any): Promise<boolean> {\n    // In a real implementation, integrate with sleep tracking devices/apps\n    // For now, simulate sleep quality evaluation\n    const sleepQuality = Math.floor(Math.random() * 100); // 0-100 quality score\n    \n    if (conditions.minQuality) {\n      return sleepQuality >= conditions.minQuality;\n    }\n    \n    return true;\n  }\n\n  private static async evaluateDayOfWeekCondition(conditions: any): Promise<boolean> {\n    const currentDay = new Date().getDay();\n    \n    if (conditions.daysOfWeek && Array.isArray(conditions.daysOfWeek)) {\n      return conditions.daysOfWeek.includes(currentDay);\n    }\n    \n    return true;\n  }\n\n  private static async evaluateTimeSinceLastCondition(conditions: any): Promise<boolean> {\n    // In a real implementation, track when alarms were last triggered\n    // For now, simulate time since last condition\n    const hoursSinceLastAlarm = Math.floor(Math.random() * 24);\n    \n    if (conditions.minHours) {\n      return hoursSinceLastAlarm >= conditions.minHours;\n    }\n    \n    return true;\n  }\n\n  // ===== UTILITY METHODS =====\n\n  private static adjustTimeByMinutes(timeString: string, minutes: number): string {\n    const [hours, mins] = timeString.split(':').map(Number);\n    const date = new Date();\n    date.setHours(hours, mins + minutes, 0, 0);\n    return this.formatTimeToHHMM(date);\n  }\n\n  private static formatTimeToHHMM(date: Date): string {\n    return date.toTimeString().slice(0, 5);\n  }\n\n  private static async sendNotification(message: string, parameters: any): Promise<void> {\n    // In a real implementation, send actual notifications\n    console.log(`Notification: ${message}`, parameters);\n  }\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/feature-gate-service.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SubscriptionTier' is not defined.",
        "line": 460,
        "column": 35,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 460,
        "endColumn": 51
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SubscriptionTier' is not defined.",
        "line": 503,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 503,
        "endColumn": 31
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SubscriptionTier' is not defined.",
        "line": 504,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 504,
        "endColumn": 35
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Feature Gate Service for Relife Alarm App\n// Centralized feature access control and management\n\nimport type {\n  FeatureAccess,\n  FeatureGate,\n  PremiumFeature\n} from '../types/premium';\nimport SubscriptionService from './subscription-service';\nimport { ErrorHandler } from './error-handler';\nimport AnalyticsService from './analytics';\n\ninterface FeatureDefinition {\n  id: string;\n  name: string;\n  description: string;\n  category: string;\n  usageLimit?: number;\n  resetPeriod?: 'daily' | 'weekly' | 'monthly';\n  gracePeriodDays?: number;\n  isCore: boolean;\n  comingSoon?: boolean;\n}\n\ninterface FeatureAccessResult {\n  hasAccess: boolean;\n  reason:\n    | \"tier_sufficient\"\n    | \"tier_insufficient\"\n    | \"usage_exceeded\"\n    | \"feature_disabled\"\n    | \"grace_period\"\n    | \"trial_access\";\n  usageRemaining?: number;\n  usageLimit?: number;\n  resetDate?: Date;\n  upgradeMessage?: string;\n}\n\ninterface FeatureRestriction {\n  userId: string;\n  feature: string;\n  restrictedUntil: Date;\n  reason: string;\n  canBypass: boolean;\n}\n\nclass FeatureGateService {\n  private static instance: FeatureGateService;\n  private subscriptionService: SubscriptionService;\n  private analytics: AnalyticsService;\n  private featureDefinitions = new Map<string, FeatureDefinition>();\n  private accessCache = new Map<string, { access: FeatureAccessResult; timestamp: number }>();\n  private restrictions = new Map<string, FeatureRestriction>();\n  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\n  private constructor() {\n    this.subscriptionService = SubscriptionService.getInstance();\n    this.analytics = AnalyticsService.getInstance();\n    this.initializeFeatureDefinitions();\n  }\n\n  public static getInstance(): FeatureGateService {\n    if (!FeatureGateService.instance) {\n      FeatureGateService.instance = new FeatureGateService();\n    }\n    return FeatureGateService.instance;\n  }\n\n  /**\n   * Initialize feature definitions\n   */\n  private initializeFeatureDefinitions(): void {\n    const features: FeatureDefinition[] = [\n      // Basic Tier Features\n      {\n        id: 'unlimited_alarms',\n        name: 'Unlimited Alarms',\n        description: 'Set unlimited number of alarms',\n        category: 'alarms',\n        requiredTier: 'basic',\n        isCore: true\n      },\n      {\n        id: 'custom_sounds',\n        name: 'Custom Sounds',\n        description: 'Upload custom alarm sounds',\n        category: 'alarms',\n        requiredTier: 'basic',\n        usageLimit: 10,\n        resetPeriod: 'monthly',\n        isCore: true\n      },\n      {\n        id: 'basic_themes',\n        name: 'Premium Themes',\n        description: 'Access to premium visual themes',\n        category: 'themes',\n        requiredTier: 'basic',\n        isCore: true\n      },\n      {\n        id: 'alarm_battles',\n        name: 'Alarm Battles',\n        description: 'Participate in competitive wake-up challenges',\n        category: 'battles',\n        requiredTier: 'basic',\n        usageLimit: 5,\n        resetPeriod: 'monthly',\n        isCore: true\n      },\n\n      // Premium Tier Features\n      {\n        id: 'unlimited_battles',\n        name: 'Unlimited Battles',\n        description: 'Join unlimited alarm battles',\n        category: 'battles',\n        requiredTier: 'premium',\n        isCore: true\n      },\n      {\n        id: 'smart_scheduling',\n        name: 'Smart Scheduling',\n        description: 'AI-powered optimal alarm timing',\n        category: 'ai',\n        requiredTier: 'premium',\n        isCore: true\n      },\n      {\n        id: 'calendar_integration',\n        name: 'Calendar Integration',\n        description: 'Sync with external calendars',\n        category: 'integrations',\n        requiredTier: 'premium',\n        isCore: true\n      },\n      {\n        id: 'weather_integration',\n        name: 'Weather Integration',\n        description: 'Weather-based alarm adjustments',\n        category: 'integrations',\n        requiredTier: 'premium',\n        isCore: true\n      },\n      {\n        id: 'advanced_analytics',\n        name: 'Advanced Analytics',\n        description: 'Detailed sleep and wake pattern analysis',\n        category: 'analytics',\n        requiredTier: 'premium',\n        isCore: true\n      },\n      {\n        id: 'voice_ai_advanced',\n        name: 'Advanced Voice AI',\n        description: 'Enhanced voice recognition and responses',\n        category: 'voice',\n        requiredTier: 'premium',\n        isCore: true\n      },\n\n      // Pro Tier Features\n      {\n        id: 'team_features',\n        name: 'Team Collaboration',\n        description: 'Team battles and group challenges',\n        category: 'collaboration',\n        requiredTier: 'pro',\n        isCore: true\n      },\n      {\n        id: 'api_access',\n        name: 'API Access',\n        description: 'Developer API for custom integrations',\n        category: 'integrations',\n        requiredTier: 'pro',\n        usageLimit: 10000,\n        resetPeriod: 'monthly',\n        isCore: true\n      },\n      {\n        id: 'white_label',\n        name: 'White Label',\n        description: 'Remove Relife branding',\n        category: 'customization',\n        requiredTier: 'pro',\n        isCore: true\n      },\n      {\n        id: 'custom_themes',\n        name: 'Custom Theme Creator',\n        description: 'Create and share custom themes',\n        category: 'themes',\n        requiredTier: 'pro',\n        isCore: true\n      },\n      {\n        id: 'tournament_creation',\n        name: 'Tournament Creation',\n        description: 'Create and manage tournaments',\n        category: 'battles',\n        requiredTier: 'pro',\n        isCore: true\n      },\n      {\n        id: 'priority_support',\n        name: 'Priority Support',\n        description: 'Priority customer support',\n        category: 'support',\n        requiredTier: 'premium',\n        isCore: true\n      }\n    ];\n\n    features.forEach(feature => {\n      this.featureDefinitions.set(feature.id, feature);\n    });\n  }\n\n  /**\n   * Check if user has access to a feature\n   */\n  public async checkFeatureAccess(userId: string, featureId: string): Promise<FeatureAccessResult> {\n    try {\n      // Check cache first\n      const cacheKey = `${userId}:${featureId}`;\n      const cached = this.accessCache.get(cacheKey);\n\n      if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {\n        return cached.access;\n      }\n\n      // Check if feature is restricted\n      const restriction = this.restrictions.get(cacheKey);\n      if (restriction && restriction.restrictedUntil > new Date()) {\n        return {\n          hasAccess: restriction.canBypass,\n          reason: 'feature_disabled',\n          upgradeMessage: `This feature is temporarily restricted: ${restriction.reason}`\n        };\n      }\n\n      const featureDef = this.featureDefinitions.get(featureId);\n      if (!featureDef) {\n        // Unknown feature, default to no access\n        return {\n          hasAccess: false,\n          reason: 'feature_disabled',\n          upgradeMessage: 'This feature is not available'\n        };\n      }\n\n      if (featureDef.comingSoon) {\n        return {\n          hasAccess: false,\n          reason: 'feature_disabled',\n          upgradeMessage: 'This feature is coming soon!'\n        };\n      }\n\n      // Get user's subscription tier and feature access\n      const [userTier, featureAccess] = await Promise.all([\n        this.subscriptionService.getUserTier(userId),\n        this.subscriptionService.getFeatureAccess(userId)\n      ]);\n\n      // Check tier requirements\n      const tierAccess = this.checkTierAccess(userTier, featureDef.requiredTier);\n      if (!tierAccess) {\n        const result: FeatureAccessResult = {\n          hasAccess: false,\n          reason: 'tier_insufficient',\n          requiredTier: featureDef.requiredTier,\n          upgradeMessage: this.getUpgradeMessage(featureDef)\n        };\n\n        // Cache the result\n        this.accessCache.set(cacheKey, {\n          access: result,\n          timestamp: Date.now()\n        });\n\n        return result;\n      }\n\n      // Check usage limits\n      const featureUsage = featureAccess.features[featureId];\n      if (featureDef.usageLimit && featureUsage) {\n        const usageExceeded = featureUsage.usageCount !== undefined &&\n          featureUsage.usageCount >= featureDef.usageLimit;\n\n        if (usageExceeded) {\n          const result: FeatureAccessResult = {\n            hasAccess: false,\n            reason: 'usage_exceeded',\n            usageRemaining: 0,\n            usageLimit: featureDef.usageLimit,\n            resetDate: featureUsage.resetDate,\n            upgradeMessage: this.getUsageExceededMessage(featureDef)\n          };\n\n          this.accessCache.set(cacheKey, {\n            access: result,\n            timestamp: Date.now()\n          });\n\n          return result;\n        }\n      }\n\n      // Access granted\n      const result: FeatureAccessResult = {\n        hasAccess: true,\n        reason: 'tier_sufficient',\n        usageRemaining: featureDef.usageLimit && featureUsage?.usageCount !== undefined\n          ? Math.max(0, featureDef.usageLimit - featureUsage.usageCount)\n          : undefined,\n        usageLimit: featureDef.usageLimit,\n        resetDate: featureUsage?.resetDate\n      };\n\n      // Cache the result\n      this.accessCache.set(cacheKey, {\n        access: result,\n        timestamp: Date.now()\n      });\n\n      return result;\n\n    } catch (error) {\n      ErrorHandler.handleError(\n        error instanceof Error ? error : new Error(String(error)),\n        'Failed to check feature access',\n        { context: 'feature_gate_service', metadata: { userId, featureId } }\n      );\n\n      // Return safe default on error\n      return {\n        hasAccess: false,\n        reason: 'feature_disabled',\n        upgradeMessage: 'Unable to check feature access. Please try again.'\n      };\n    }\n  }\n\n  /**\n   * Track feature usage attempt\n   */\n  public async trackFeatureAttempt(\n    userId: string,\n    featureId: string,\n    granted: boolean,\n    context?: Record<string, any>\n  ): Promise<void> {\n    try {\n      const featureDef = this.featureDefinitions.get(featureId);\n\n      this.analytics.trackFeatureUsage('feature_access_attempt', undefined, {\n        userId,\n        featureId,\n        featureName: featureDef?.name || featureId,\n        category: featureDef?.category || 'unknown',\n        granted,\n        requiredTier: featureDef?.requiredTier,\n        context\n      });\n\n      // If usage was denied, track the specific reason\n      if (!granted) {\n        const accessResult = await this.checkFeatureAccess(userId, featureId);\n        this.analytics.trackFeatureUsage('feature_access_denied', undefined, {\n          userId,\n          featureId,\n          reason: accessResult.reason,\n          requiredTier: accessResult.requiredTier\n        });\n      }\n    } catch (error) {\n      // Don't throw on analytics errors\n      console.error('Failed to track feature attempt:', error);\n    }\n  }\n\n  /**\n   * Grant temporary access to a feature\n   */\n  public grantTemporaryAccess(\n    userId: string,\n    featureId: string,\n    durationMinutes: number,\n    reason: string\n  ): void {\n    const cacheKey = `${userId}:${featureId}`;\n    const expiresAt = new Date(Date.now() + durationMinutes * 60 * 1000);\n\n    // Remove any existing restrictions\n    this.restrictions.delete(cacheKey);\n\n    // Grant access in cache\n    this.accessCache.set(cacheKey, {\n      access: {\n        hasAccess: true,\n        reason: 'grace_period',\n        upgradeMessage: `Temporary access granted: ${reason}`\n      },\n      timestamp: Date.now()\n    });\n\n    // Track the temporary access grant\n    this.analytics.trackFeatureUsage('temporary_access_granted', undefined, {\n      userId,\n      featureId,\n      durationMinutes,\n      reason\n    });\n\n    // Schedule removal\n    setTimeout(() => {\n      this.accessCache.delete(cacheKey);\n    }, durationMinutes * 60 * 1000);\n  }\n\n  /**\n   * Restrict access to a feature\n   */\n  public restrictFeatureAccess(\n    userId: string,\n    featureId: string,\n    durationMinutes: number,\n    reason: string,\n    canBypass: boolean = false\n  ): void {\n    const cacheKey = `${userId}:${featureId}`;\n    const restrictedUntil = new Date(Date.now() + durationMinutes * 60 * 1000);\n\n    this.restrictions.set(cacheKey, {\n      userId,\n      feature: featureId,\n      restrictedUntil,\n      reason,\n      canBypass\n    });\n\n    // Clear any cached access\n    this.accessCache.delete(cacheKey);\n\n    this.analytics.trackFeatureUsage('feature_access_restricted', undefined, {\n      userId,\n      featureId,\n      durationMinutes,\n      reason,\n      canBypass\n    });\n  }\n\n  /**\n   * Get all features for a subscription tier\n   */\n  public getFeaturesForTier(tier: SubscriptionTier): FeatureDefinition[] {\n    const tierHierarchy = [\n      \"free\",\n      \"basic\",\n      \"premium\",\n      \"pro\",\n      \"enterprise\",\n    ];\n    const tierLevel = tierHierarchy.indexOf(tier);\n\n    return Array.from(this.featureDefinitions.values()).filter(feature => {\n      const requiredLevel = tierHierarchy.indexOf(feature.requiredTier);\n      return requiredLevel <= tierLevel;\n    });\n  }\n\n  /**\n   * Get feature definition\n   */\n  public getFeatureDefinition(featureId: string): FeatureDefinition | null {\n    return this.featureDefinitions.get(featureId) || null;\n  }\n\n  /**\n   * Clear access cache for user\n   */\n  public clearUserCache(userId: string): void {\n    const keysToDelete: string[] = [];\n\n    for (const key of this.accessCache.keys()) {\n      if (key.startsWith(`${userId}:`)) {\n        keysToDelete.push(key);\n      }\n    }\n\n    keysToDelete.forEach(key => this.accessCache.delete(key));\n  }\n\n  /**\n   * Private helper methods\n   */\n\n  private checkTierAccess(\n    userTier: SubscriptionTier,\n    requiredTier: SubscriptionTier\n  ): boolean {\n    const tierHierarchy = [\n      \"free\",\n      \"basic\",\n      \"premium\",\n      \"pro\",\n      \"enterprise\",\n    ];\n    const userLevel = tierHierarchy.indexOf(userTier);\n    const requiredLevel = tierHierarchy.indexOf(requiredTier);\n    return userLevel >= requiredLevel;\n  }\n\n  private getUpgradeMessage(feature: FeatureDefinition): string {\n    const tierNames = {\n      basic: 'Basic',\n      premium: 'Premium',\n      pro: 'Pro',\n      enterprise: 'Enterprise'\n    };\n\n    const tierName = tierNames[feature.requiredTier] || 'Premium';\n\n    switch (feature.category) {\n      case 'alarms':\n        return `Upgrade to ${tierName} to unlock ${feature.name.toLowerCase()} and enhance your wake-up experience!`;\n      case 'battles':\n        return `Upgrade to ${tierName} to access ${feature.name.toLowerCase()} and compete with friends!`;\n      case 'ai':\n        return `Upgrade to ${tierName} to unlock ${feature.name.toLowerCase()} and optimize your sleep schedule with AI!`;\n      case 'integrations':\n        return `Upgrade to ${tierName} to enable ${feature.name.toLowerCase()} and sync your data seamlessly!`;\n      case 'analytics':\n        return `Upgrade to ${tierName} to access ${feature.name.toLowerCase()} and track your sleep patterns!`;\n      case 'collaboration':\n        return `Upgrade to ${tierName} to unlock ${feature.name.toLowerCase()} and work together with your team!`;\n      default:\n        return `Upgrade to ${tierName} to unlock ${feature.name.toLowerCase()} and get the most out of Relife!`;\n    }\n  }\n\n  private getUsageExceededMessage(feature: FeatureDefinition): string {\n    const resetPeriod = feature.resetPeriod || 'monthly';\n    return `You've reached your ${resetPeriod} limit for ${feature.name.toLowerCase()}. Upgrade for unlimited access!`;\n  }\n}\n\nexport default FeatureGateService;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/health-tracker-integration.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'Alarm' is not defined.",
        "line": 310,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 310,
        "endColumn": 63
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'Alarm' is not defined.",
        "line": 477,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 477,
        "endColumn": 17
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'Alarm' is not defined.",
        "line": 483,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 483,
        "endColumn": 44
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'Alarm' is not defined.",
        "line": 488,
        "column": 38,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 488,
        "endColumn": 43
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "\n/**\n * Health Tracker Integration Service\n *\n * Features:\n * - Sleep tracking and analysis\n * - Heart rate monitoring\n * - Activity level integration\n * - Sleep quality optimization\n * - Circadian rhythm analysis\n * - Recovery time suggestions\n * - Stress level monitoring\n * - Multi-device support (Apple Health, Google Fit, Fitbit, etc.)\n */\n\nexport interface SleepData {\n  date: Date;\n  bedTime: Date;\n  sleepTime: Date;\n  wakeTime: Date;\n  totalSleepMinutes: number;\n  deepSleepMinutes: number;\n  lightSleepMinutes: number;\n  remSleepMinutes: number;\n  awakeMinutes: number;\n  sleepEfficiency: number; // percentage\n  restingHeartRate: number;\n  sleepQuality: 'poor' | 'fair' | 'good' | 'excellent';\n  sleepScore: number; // 0-100\n}\n\nexport interface ActivityData {\n  date: Date;\n  steps: number;\n  caloriesBurned: number;\n  activeMinutes: number;\n  exerciseMinutes: number;\n  activityLevel: 'sedentary' | 'lightly_active' | 'fairly_active' | 'very_active';\n  stressLevel: number; // 0-100\n  energyLevel: number; // 0-100\n}\n\nexport interface HealthInsight {\n  id: string;\n  type: 'sleep_pattern' | 'recovery' | 'optimization' | 'alert' | 'trend';\n  priority: 'low' | 'medium' | 'high' | 'urgent';\n  title: string;\n  description: string;\n  recommendation: string;\n  confidence: number;\n  impact: 'low' | 'medium' | 'high';\n  data: any;\n  actionable: boolean;\n  expiresAt?: Date;\n  createdAt: Date;\n}\n\nexport interface CircadianProfile {\n  chronotype: 'morning' | 'evening' | 'intermediate';\n  naturalWakeTime: string; // HH:mm\n  naturalBedTime: string; // HH:mm\n  optimalSleepDuration: number; // minutes\n  sleepDebtTolerance: number; // minutes\n  weekdayPattern: {\n    bedTime: string;\n    wakeTime: string;\n    sleepDuration: number;\n  };\n  weekendPattern: {\n    bedTime: string;\n    wakeTime: string;\n    sleepDuration: number;\n  };\n}\n\nexport interface HealthConfig {\n  enabled: boolean;\n  connectedDevices: Array<{\n    id: string;\n    name: string;\n    type: 'apple_health' | 'google_fit' | 'fitbit' | 'garmin' | 'samsung_health' | 'oura';\n    isActive: boolean;\n    lastSync: Date | null;\n    permissions: string[];\n  }>;\n  dataRetentionDays: number;\n  syncIntervalMinutes: number;\n  sleepTracking: {\n    enabled: boolean;\n    automaticDetection: boolean;\n    minSleepDuration: number; // minutes\n    sleepWindowStart: string; // HH:mm\n    sleepWindowEnd: string; // HH:mm\n  };\n  analytics: {\n    enabled: boolean;\n    trendAnalysisDays: number;\n    alertThresholds: {\n      sleepDebt: number; // minutes\n      sleepEfficiency: number; // percentage\n      restingHeartRateIncrease: number; // bpm\n    };\n  };\n}\n\nclass HealthTrackerIntegration {\n  private static instance: HealthTrackerIntegration;\n  private isInitialized = false;\n  private config: HealthConfig;\n  private sleepHistory: SleepData[] = [];\n  private activityHistory: ActivityData[] = [];\n  private insights: HealthInsight[] = [];\n  private circadianProfile: CircadianProfile | null = null;\n  private lastSyncTime: Date | null = null;\n\n  private constructor() {\n    this.config = this.getDefaultConfig();\n  }\n\n  public static getInstance(): HealthTrackerIntegration {\n    if (!HealthTrackerIntegration.instance) {\n      HealthTrackerIntegration.instance = new HealthTrackerIntegration();\n    }\n    return HealthTrackerIntegration.instance;\n  }\n\n  /**\n   * Initialize the health tracker integration\n   */\n  public async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      await this.loadConfiguration();\n      await this.loadHealthData();\n\n      if (this.config.enabled) {\n        await this.syncHealthData();\n        await this.analyzeCircadianRhythm();\n        await this.generateHealthInsights();\n\n        // Start periodic sync\n        this.startPeriodicSync();\n      }\n\n      this.isInitialized = true;\n    } catch (error) {\n      console.error('Failed to initialize HealthTrackerIntegration:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get sleep-optimized wake time suggestions\n   */\n  public async getSleepOptimizedWakeTime(targetWakeTime: string, date: Date = new Date()): Promise<{\n    suggestedTime: string;\n    reasoning: string[];\n    confidence: number;\n    sleepCycles: number;\n    expectedQuality: 'poor' | 'fair' | 'good' | 'excellent';\n  } | null> {\n    if (!this.config.enabled || this.sleepHistory.length < 7) {\n      return null;\n    }\n\n    // Analyze recent sleep patterns\n    const recentSleep = this.sleepHistory.slice(-14);\n    const averageSleepDuration = recentSleep.reduce((sum, s) => sum + s.totalSleepMinutes, 0) / recentSleep.length;\n    const averageBedTime = this.calculateAverageTime(recentSleep.map(s => s.bedTime));\n\n    // Calculate optimal sleep cycles (90-minute cycles)\n    const targetTime = this.parseTimeString(targetWakeTime);\n    const targetWakeDate = new Date(date);\n    targetWakeDate.setHours(targetTime.hours, targetTime.minutes, 0, 0);\n\n    // Find the best wake time within ¬±30 minutes that aligns with sleep cycles\n    let bestTime = targetWakeDate;\n    let bestQuality = 'fair';\n    let confidence = 0.5;\n    const reasoning: string[] = [];\n\n    // Calculate sleep cycles based on average bedtime\n    const estimatedBedTime = new Date(averageBedTime);\n    estimatedBedTime.setDate(date.getDate());\n    if (estimatedBedTime > targetWakeDate) {\n      estimatedBedTime.setDate(estimatedBedTime.getDate() - 1);\n    }\n\n    const sleepDurationMs = targetWakeDate.getTime() - estimatedBedTime.getTime();\n    const sleepCycles = Math.round(sleepDurationMs / (90 * 60 * 1000));\n\n    // Adjust to complete sleep cycles\n    if (sleepCycles >= 4 && sleepCycles <= 6) {\n      const optimalWakeTime = new Date(estimatedBedTime.getTime() + sleepCycles * 90 * 60 * 1000);\n      const adjustment = Math.abs(optimalWakeTime.getTime() - targetWakeDate.getTime()) / (60 * 1000);\n\n      if (adjustment <= 30) {\n        bestTime = optimalWakeTime;\n        confidence = 0.8;\n        bestQuality = sleepCycles >= 5 ? 'good' : 'fair';\n        reasoning.push(`Aligned with ${sleepCycles} complete sleep cycles`);\n        reasoning.push(`Based on your average bedtime pattern`);\n      }\n    }\n\n    // Check against circadian profile\n    if (this.circadianProfile) {\n      const naturalWake = this.parseTimeString(this.circadianProfile.naturalWakeTime);\n      const naturalWakeDate = new Date(date);\n      naturalWakeDate.setHours(naturalWake.hours, naturalWake.minutes, 0, 0);\n\n      const deviation = Math.abs(bestTime.getTime() - naturalWakeDate.getTime()) / (60 * 1000);\n      if (deviation > 60) {\n        confidence *= 0.8;\n        reasoning.push(`Deviates from your natural chronotype by ${Math.round(deviation)} minutes`);\n      } else {\n        confidence = Math.min(confidence * 1.2, 1);\n        reasoning.push('Aligns well with your natural wake time');\n      }\n    }\n\n    // Consider recent sleep quality\n    const recentQuality = recentSleep.slice(-3);\n    const avgQuality = recentQuality.reduce((sum, s) => sum + s.sleepScore, 0) / recentQuality.length;\n\n    if (avgQuality < 60) {\n      reasoning.push('Recent sleep quality suggests need for longer recovery');\n      if (sleepCycles < 5) {\n        bestQuality = 'poor';\n        reasoning.push('Insufficient sleep cycles for recovery');\n      }\n    }\n\n    return {\n      suggestedTime: `${bestTime.getHours().toString().padStart(2, '0')}:${bestTime.getMinutes().toString().padStart(2, '0')}`,\n      reasoning,\n      confidence,\n      sleepCycles,\n      expectedQuality: bestQuality\n    };\n  }\n\n  /**\n   * Analyze sleep debt and recovery needs\n   */\n  public analyzeSleepDebt(): {\n    currentDebt: number; // minutes\n    trend: 'improving' | 'stable' | 'worsening';\n    recoveryDays: number;\n    recommendations: string[];\n  } {\n    if (this.sleepHistory.length < 7) {\n      return {\n        currentDebt: 0,\n        trend: 'stable',\n        recoveryDays: 0,\n        recommendations: ['Not enough data for analysis']\n      };\n    }\n\n    const optimalSleep = this.circadianProfile?.optimalSleepDuration || 8 * 60; // 8 hours default\n    const recent14Days = this.sleepHistory.slice(-14);\n    const recent7Days = this.sleepHistory.slice(-7);\n\n    // Calculate sleep debt\n    const currentDebt = recent7Days.reduce((debt, sleep) => {\n      return debt + Math.max(0, optimalSleep - sleep.totalSleepMinutes);\n    }, 0);\n\n    // Calculate trend\n    const earlier7Days = recent14Days.slice(0, 7);\n    const earlierDebt = earlier7Days.reduce((debt, sleep) => {\n      return debt + Math.max(0, optimalSleep - sleep.totalSleepMinutes);\n    }, 0);\n\n    let trend: 'improving' | 'stable' | 'worsening' = 'stable';\n    const debtChange = currentDebt - earlierDebt;\n    if (debtChange > 60) trend = 'worsening';\n    else if (debtChange < -60) trend = 'improving';\n\n    // Calculate recovery time\n    const avgDailyRecovery = 60; // Assume 1 hour recovery per night with optimal sleep\n    const recoveryDays = Math.ceil(currentDebt / avgDailyRecovery);\n\n    // Generate recommendations\n    const recommendations: string[] = [];\n    if (currentDebt > 180) { // 3+ hours\n      recommendations.push('Consider going to bed 30-60 minutes earlier');\n      recommendations.push('Prioritize sleep consistency over late activities');\n    }\n    if (trend === 'worsening') {\n      recommendations.push('Sleep debt is accumulating - adjust your schedule');\n    }\n    if (recoveryDays > 7) {\n      recommendations.push('Consider a few early nights to catch up on sleep');\n    }\n\n    return {\n      currentDebt,\n      trend,\n      recoveryDays,\n      recommendations\n    };\n  }\n\n  /**\n   * Get health-based alarm recommendations\n   */\n  public async getHealthBasedAlarmRecommendations(alarm: Alarm): Promise<HealthInsight[]> {\n    const insights: HealthInsight[] = [];\n\n    if (!this.config.enabled) return insights;\n\n    // Sleep cycle alignment\n    const sleepCycleInsight = this.analyzeSleepCycleAlignment(alarm);\n    if (sleepCycleInsight) insights.push(sleepCycleInsight);\n\n    // Recovery needs\n    const recoveryInsight = this.analyzeRecoveryNeeds(alarm);\n    if (recoveryInsight) insights.push(recoveryInsight);\n\n    // Stress level considerations\n    const stressInsight = this.analyzeStressImpact(alarm);\n    if (stressInsight) insights.push(stressInsight);\n\n    return insights;\n  }\n\n  /**\n   * Sync health data from connected devices\n   */\n  public async syncHealthData(): Promise<void> {\n    if (!this.config.enabled) return;\n\n    try {\n      for (const device of this.config.connectedDevices) {\n        if (device.isActive) {\n          await this.syncFromDevice(device);\n        }\n      }\n\n      this.lastSyncTime = new Date();\n      await this.saveHealthData();\n\n    } catch (error) {\n      console.error('Failed to sync health data:', error);\n    }\n  }\n\n  /**\n   * Get comprehensive health statistics\n   */\n  public getHealthStats(): any {\n    const recent7Days = this.sleepHistory.slice(-7);\n    const recent30Days = this.sleepHistory.slice(-30);\n\n    const avgSleepDuration = recent7Days.length > 0\n      ? recent7Days.reduce((sum, s) => sum + s.totalSleepMinutes, 0) / recent7Days.length\n      : 0;\n\n    const avgSleepEfficiency = recent7Days.length > 0\n      ? recent7Days.reduce((sum, s) => sum + s.sleepEfficiency, 0) / recent7Days.length\n      : 0;\n\n    const avgSleepScore = recent7Days.length > 0\n      ? recent7Days.reduce((sum, s) => sum + s.sleepScore, 0) / recent7Days.length\n      : 0;\n\n    return {\n      isEnabled: this.config.enabled,\n      connectedDevices: this.config.connectedDevices.length,\n      activeDevices: this.config.connectedDevices.filter(d => d.isActive).length,\n      lastSyncTime: this.lastSyncTime,\n      dataPoints: {\n        sleepRecords: this.sleepHistory.length,\n        activityRecords: this.activityHistory.length\n      },\n      recent7Days: {\n        avgSleepDuration: Math.round(avgSleepDuration / 60 * 10) / 10, // hours\n        avgSleepEfficiency: Math.round(avgSleepEfficiency),\n        avgSleepScore: Math.round(avgSleepScore)\n      },\n      trends: {\n        sleepDuration: this.calculateSleepTrend(recent30Days),\n        sleepQuality: this.calculateQualityTrend(recent30Days)\n      },\n      circadianProfile: this.circadianProfile,\n      insights: this.insights.length\n    };\n  }\n\n  /**\n   * Update health configuration\n   */\n  public async updateConfig(config: Partial<HealthConfig>): Promise<void> {\n    this.config = { ...this.config, ...config };\n    await this.saveConfiguration();\n  }\n\n  /**\n   * Helper methods\n   */\n  private async syncFromDevice(device: any): Promise<void> {\n    // This would implement actual device API calls\n    // For now, generate mock data\n    const mockSleepData = this.generateMockSleepData();\n    const mockActivityData = this.generateMockActivityData();\n\n    this.sleepHistory.push(mockSleepData);\n    this.activityHistory.push(mockActivityData);\n\n    // Keep only recent data\n    this.sleepHistory = this.sleepHistory.slice(-this.config.dataRetentionDays);\n    this.activityHistory = this.activityHistory.slice(-this.config.dataRetentionDays);\n\n    device.lastSync = new Date();\n  }\n\n  private generateMockSleepData(): SleepData {\n    const now = new Date();\n    const bedTime = new Date(now);\n    bedTime.setHours(22 + Math.random() * 2, Math.random() * 60);\n    bedTime.setDate(bedTime.getDate() - 1);\n\n    const sleepTime = new Date(bedTime.getTime() + (10 + Math.random() * 20) * 60 * 1000);\n    const wakeTime = new Date(sleepTime.getTime() + (6 + Math.random() * 3) * 60 * 60 * 1000);\n\n    const totalSleep = (wakeTime.getTime() - sleepTime.getTime()) / (60 * 1000);\n\n    return {\n      date: new Date(now.getTime() - 24 * 60 * 60 * 1000),\n      bedTime,\n      sleepTime,\n      wakeTime,\n      totalSleepMinutes: totalSleep,\n      deepSleepMinutes: totalSleep * (0.15 + Math.random() * 0.1),\n      lightSleepMinutes: totalSleep * (0.45 + Math.random() * 0.1),\n      remSleepMinutes: totalSleep * (0.2 + Math.random() * 0.1),\n      awakeMinutes: totalSleep * (0.05 + Math.random() * 0.05),\n      sleepEfficiency: 80 + Math.random() * 15,\n      restingHeartRate: 60 + Math.random() * 20,\n      sleepQuality: ['fair', 'good', 'good', 'excellent'][Math.floor(Math.random() * 4)] as any,\n      sleepScore: 60 + Math.random() * 35\n    };\n  }\n\n  private generateMockActivityData(): ActivityData {\n    return {\n      date: new Date(),\n      steps: 5000 + Math.random() * 10000,\n      caloriesBurned: 1800 + Math.random() * 800,\n      activeMinutes: 30 + Math.random() * 90,\n      exerciseMinutes: Math.random() * 60,\n      activityLevel: ['sedentary', 'lightly_active', 'fairly_active'][Math.floor(Math.random() * 3)] as any,\n      stressLevel: Math.random() * 100,\n      energyLevel: 50 + Math.random() * 50\n    };\n  }\n\n  private parseTimeString(timeStr: string): { hours: number; minutes: number } {\n    const [hours, minutes] = timeStr.split(':').map(Number);\n    return { hours, minutes };\n  }\n\n  private calculateAverageTime(times: Date[]): Date {\n    const avgMinutes = times.reduce((sum, time) =>\n      sum + time.getHours() * 60 + time.getMinutes(), 0\n    ) / times.length;\n\n    const avg = new Date();\n    avg.setHours(Math.floor(avgMinutes / 60), avgMinutes % 60, 0, 0);\n    return avg;\n  }\n\n  private analyzeSleepCycleAlignment(\n    alarm: Alarm\n  ): HealthInsight | null {\n    // Implementation for sleep cycle analysis\n    return null;\n  }\n\n  private analyzeRecoveryNeeds(alarm: Alarm): HealthInsight | null {\n    // Implementation for recovery analysis\n    return null;\n  }\n\n  private analyzeStressImpact(alarm: Alarm): HealthInsight | null {\n    // Implementation for stress analysis\n    return null;\n  }\n\n  private calculateSleepTrend(sleepData: SleepData[]): 'improving' | 'stable' | 'declining' {\n    if (sleepData.length < 14) return 'stable';\n\n    const firstHalf = sleepData.slice(0, Math.floor(sleepData.length / 2));\n    const secondHalf = sleepData.slice(Math.floor(sleepData.length / 2));\n\n    const firstAvg = firstHalf.reduce((sum, s) => sum + s.totalSleepMinutes, 0) / firstHalf.length;\n    const secondAvg = secondHalf.reduce((sum, s) => sum + s.totalSleepMinutes, 0) / secondHalf.length;\n\n    const difference = secondAvg - firstAvg;\n    if (difference > 30) return 'improving';\n    if (difference < -30) return 'declining';\n    return 'stable';\n  }\n\n  private calculateQualityTrend(sleepData: SleepData[]): 'improving' | 'stable' | 'declining' {\n    if (sleepData.length < 14) return 'stable';\n\n    const firstHalf = sleepData.slice(0, Math.floor(sleepData.length / 2));\n    const secondHalf = sleepData.slice(Math.floor(sleepData.length / 2));\n\n    const firstAvg = firstHalf.reduce((sum, s) => sum + s.sleepScore, 0) / firstHalf.length;\n    const secondAvg = secondHalf.reduce((sum, s) => sum + s.sleepScore, 0) / secondHalf.length;\n\n    const difference = secondAvg - firstAvg;\n    if (difference > 10) return 'improving';\n    if (difference < -10) return 'declining';\n    return 'stable';\n  }\n\n  private async analyzeCircadianRhythm(): Promise<void> {\n    if (this.sleepHistory.length < 14) return;\n\n    const recent30Days = this.sleepHistory.slice(-30);\n    const weekdayData = recent30Days.filter(s => {\n      const day = s.date.getDay();\n      return day >= 1 && day <= 5; // Monday to Friday\n    });\n    const weekendData = recent30Days.filter(s => {\n      const day = s.date.getDay();\n      return day === 0 || day === 6; // Saturday and Sunday\n    });\n\n    if (weekdayData.length < 5 || weekendData.length < 2) return;\n\n    // Calculate patterns\n    const avgWeekdayBedTime = this.calculateAverageTime(weekdayData.map(s => s.bedTime));\n    const avgWeekdayWakeTime = this.calculateAverageTime(weekdayData.map(s => s.wakeTime));\n    const avgWeekendBedTime = this.calculateAverageTime(weekendData.map(s => s.bedTime));\n    const avgWeekendWakeTime = this.calculateAverageTime(weekendData.map(s => s.wakeTime));\n\n    // Determine chronotype\n    let chronotype: 'morning' | 'evening' | 'intermediate' = 'intermediate';\n    const avgWakeHour = (avgWeekdayWakeTime.getHours() + avgWeekendWakeTime.getHours()) / 2;\n    if (avgWakeHour < 6.5) chronotype = 'morning';\n    else if (avgWakeHour > 8.5) chronotype = 'evening';\n\n    this.circadianProfile = {\n      chronotype,\n      naturalWakeTime: `${avgWeekendWakeTime.getHours().toString().padStart(2, '0')}:${avgWeekendWakeTime.getMinutes().toString().padStart(2, '0')}`,\n      naturalBedTime: `${avgWeekendBedTime.getHours().toString().padStart(2, '0')}:${avgWeekendBedTime.getMinutes().toString().padStart(2, '0')}`,\n      optimalSleepDuration: weekdayData.reduce((sum, s) => sum + s.totalSleepMinutes, 0) / weekdayData.length,\n      sleepDebtTolerance: 120, // 2 hours\n      weekdayPattern: {\n        bedTime: `${avgWeekdayBedTime.getHours().toString().padStart(2, '0')}:${avgWeekdayBedTime.getMinutes().toString().padStart(2, '0')}`,\n        wakeTime: `${avgWeekdayWakeTime.getHours().toString().padStart(2, '0')}:${avgWeekdayWakeTime.getMinutes().toString().padStart(2, '0')}`,\n        sleepDuration: weekdayData.reduce((sum, s) => sum + s.totalSleepMinutes, 0) / weekdayData.length\n      },\n      weekendPattern: {\n        bedTime: `${avgWeekendBedTime.getHours().toString().padStart(2, '0')}:${avgWeekendBedTime.getMinutes().toString().padStart(2, '0')}`,\n        wakeTime: `${avgWeekendWakeTime.getHours().toString().padStart(2, '0')}:${avgWeekendWakeTime.getMinutes().toString().padStart(2, '0')}`,\n        sleepDuration: weekendData.reduce((sum, s) => sum + s.totalSleepMinutes, 0) / weekendData.length\n      }\n    };\n  }\n\n  private async generateHealthInsights(): Promise<void> {\n    this.insights = [];\n\n    if (this.sleepHistory.length < 7) return;\n\n    // Generate various insights based on health data\n    // This would be expanded with more sophisticated analysis\n  }\n\n  private startPeriodicSync(): void {\n    setInterval(async () => {\n      if (this.config.enabled) {\n        await this.syncHealthData();\n      }\n    }, this.config.syncIntervalMinutes * 60 * 1000);\n  }\n\n  private getDefaultConfig(): HealthConfig {\n    return {\n      enabled: false,\n      connectedDevices: [],\n      dataRetentionDays: 90,\n      syncIntervalMinutes: 60,\n      sleepTracking: {\n        enabled: true,\n        automaticDetection: true,\n        minSleepDuration: 4 * 60, // 4 hours\n        sleepWindowStart: '20:00',\n        sleepWindowEnd: '10:00'\n      },\n      analytics: {\n        enabled: true,\n        trendAnalysisDays: 30,\n        alertThresholds: {\n          sleepDebt: 2 * 60, // 2 hours\n          sleepEfficiency: 80, // 80%\n          restingHeartRateIncrease: 10 // 10 bpm\n        }\n      }\n    };\n  }\n\n  // Persistence methods\n  private async saveConfiguration(): Promise<void> {\n    if (typeof localStorage !== 'undefined') {\n      localStorage.setItem('health_tracker_config', JSON.stringify(this.config, (key, value) => {\n        if (value instanceof Date) {\n          return { __type: 'Date', value: value.toISOString() };\n        }\n        return value;\n      }));\n    }\n  }\n\n  private async loadConfiguration(): Promise<void> {\n    if (typeof localStorage !== 'undefined') {\n      const saved = localStorage.getItem('health_tracker_config');\n      if (saved) {\n        this.config = { ...this.config, ...JSON.parse(saved) };\n      }\n    }\n  }\n\n  private async saveHealthData(): Promise<void> {\n    if (typeof localStorage !== 'undefined') {\n      const data = {\n        sleepHistory: this.sleepHistory,\n        activityHistory: this.activityHistory,\n        insights: this.insights,\n        circadianProfile: this.circadianProfile\n      };\n\n      localStorage.setItem('health_tracker_data', JSON.stringify(data, (key, value) => {\n        if (value instanceof Date) {\n          return { __type: 'Date', value: value.toISOString() };\n        }\n        return value;\n      }));\n    }\n  }\n\n  private async loadHealthData(): Promise<void> {\n    if (typeof localStorage !== 'undefined') {\n      const saved = localStorage.getItem('health_tracker_data');\n      if (saved) {\n        const data = JSON.parse(saved, (key, value) => {\n          if (value && typeof value === 'object' && value.__type === 'Date') {\n            return new Date(value.value);\n          }\n          return value;\n        });\n\n        this.sleepHistory = data.sleepHistory || [];\n        this.activityHistory = data.activityHistory || [];\n        this.insights = data.insights || [];\n        this.circadianProfile = data.circadianProfile || null;\n      }\n    }\n  }\n}\n\nexport default HealthTrackerIntegration;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/offline-sleep-tracker.ts",
    "messages": [
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 469,
        "column": 13,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 469,
        "endColumn": 67,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [14546, 14947],
              "text": "{ const recentSessions = this.sleepSessions.slice(0, 7); // Last 7 sessions\n            if (recentSessions.length > 0) {\n              const avgBedtime = this.calculateAverageBedtime(recentSessions);\n              const bedtimeHour = bedtime.getHours() + bedtime.getMinutes() / 60;\n              progress = Math.abs(bedtimeHour - avgBedtime) <= 0.5; // Within 30 minutes\n            }\n            break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference types=\"node\" />\n/// <reference lib=\"dom\" />\n// Offline Sleep Tracking Service for Relife App\n// Comprehensive sleep data collection and analysis when offline\n\nimport { ErrorHandler } from './error-handler';\nimport SecurityService from './security';\n\ninterface SleepSession {\n  id: string;\n  userId: string;\n  startTime: string; // ISO date string\n  endTime?: string; // ISO date string\n  duration?: number; // minutes\n  quality: number; // 1-10 scale\n  stages: SleepStage[];\n  interruptions: SleepInterruption[];\n  environment: SleepEnvironment;\n  wakeMethod: 'natural' | 'alarm' | 'disturbance';\n  mood: 'refreshed' | 'tired' | 'groggy' | 'energetic';\n  notes?: string;\n  createdAt: string;\n  synced: boolean;\n}\n\ninterface SleepStage {\n  type: 'awake' | 'light' | 'deep' | 'rem';\n  startTime: string;\n  duration: number; // minutes\n  confidence: number; // 0-1, AI confidence in detection\n}\n\ninterface SleepInterruption {\n  time: string;\n  type: 'noise' | 'movement' | 'light' | 'temperature' | 'other';\n  severity: number; // 1-5 scale\n  duration: number; // minutes\n  description?: string;\n}\n\ninterface SleepEnvironment {\n  temperature?: number; // Celsius\n  humidity?: number; // percentage\n  lightLevel?: number; // lux\n  noiseLevel?: number; // decibels\n  roomConditions: 'poor' | 'fair' | 'good' | 'excellent';\n  bedtimeRoutine: string[];\n}\n\ninterface SleepGoal {\n  id: string;\n  type: 'bedtime_consistency' | 'sleep_duration' | 'wake_consistency' | 'sleep_quality' | 'routine_completion';\n  target: number;\n  current: number;\n  progress: number; // percentage\n  streak: number;\n  lastAchieved?: string;\n  active: boolean;\n}\n\ninterface SleepInsight {\n  id: string;\n  type: 'pattern' | 'recommendation' | 'achievement' | 'warning';\n  title: string;\n  description: string;\n  data: Record<string, any>;\n  confidence: number; // 0-1\n  priority: 'low' | 'medium' | 'high';\n  actionable: boolean;\n  actions?: string[];\n  createdAt: string;\n  dismissed?: boolean;\n}\n\ninterface SleepAnalytics {\n  weeklyAverage: number; // hours\n  weeklyQuality: number; // 1-10\n  bedtimeConsistency: number; // percentage\n  wakeTimeConsistency: number; // percentage\n  deepSleepPercentage: number;\n  remSleepPercentage: number;\n  interruptionRate: number; // per night\n  improvementTrend: 'improving' | 'stable' | 'declining';\n  lastCalculated: string;\n}\n\nexport class OfflineSleepTracker {\n  private static instance: OfflineSleepTracker;\n  private readonly STORAGE_KEYS = {\n    SLEEP_SESSIONS: 'relife-sleep-sessions',\n    SLEEP_GOALS: 'relife-sleep-goals',\n    SLEEP_INSIGHTS: 'relife-sleep-insights',\n    SLEEP_ANALYTICS: 'relife-sleep-analytics',\n    CURRENT_SESSION: 'relife-current-sleep-session'\n  };\n\n  private sleepSessions: SleepSession[] = [];\n  private sleepGoals: SleepGoal[] = [];\n  private sleepInsights: SleepInsight[] = [];\n  private sleepAnalytics: SleepAnalytics | null = null;\n  private currentSession: SleepSession | null = null;\n  private isOnline = navigator.onLine;\n  private trackingTimer?: number;\n\n  private constructor() {\n    this.loadFromStorage();\n    this.setupEventListeners();\n    this.initializeDefaultGoals();\n  }\n\n  static getInstance(): OfflineSleepTracker {\n    if (!OfflineSleepTracker.instance) {\n      OfflineSleepTracker.instance = new OfflineSleepTracker();\n    }\n    return OfflineSleepTracker.instance;\n  }\n\n  // ==================== INITIALIZATION ====================\n\n  private async loadFromStorage(): Promise<void> {\n    try {\n      const sessions = SecurityService.secureStorageGet(this.STORAGE_KEYS.SLEEP_SESSIONS);\n      if (sessions && Array.isArray(sessions)) {\n        this.sleepSessions = sessions;\n      }\n\n      const goals = SecurityService.secureStorageGet(this.STORAGE_KEYS.SLEEP_GOALS);\n      if (goals && Array.isArray(goals)) {\n        this.sleepGoals = goals;\n      }\n\n      const insights = SecurityService.secureStorageGet(this.STORAGE_KEYS.SLEEP_INSIGHTS);\n      if (insights && Array.isArray(insights)) {\n        this.sleepInsights = insights;\n      }\n\n      const analytics = SecurityService.secureStorageGet(this.STORAGE_KEYS.SLEEP_ANALYTICS);\n      if (analytics) {\n        this.sleepAnalytics = analytics;\n      }\n\n      const currentSession = SecurityService.secureStorageGet(this.STORAGE_KEYS.CURRENT_SESSION);\n      if (currentSession) {\n        this.currentSession = currentSession;\n        // Resume tracking if we have an active session\n        this.resumeTracking();\n      }\n\n      console.log('[OfflineSleepTracker] Loaded', this.sleepSessions.length, 'sleep sessions');\n    } catch (error) {\n      console.error('[OfflineSleepTracker] Failed to load from storage:', error);\n    }\n  }\n\n  private setupEventListeners(): void {\n    window.addEventListener('online', this.handleOnline.bind(this));\n    window.addEventListener('offline', this.handleOffline.bind(this));\n\n    // Listen for service worker messages\n    if ('serviceWorker' in navigator) {\n      navigator.serviceWorker.addEventListener('message', (event) => {\n        if (event.data.type === 'SLEEP_SYNC_COMPLETE') {\n          this.handleSyncComplete(event.data);\n        }\n      });\n    }\n  }\n\n  private initializeDefaultGoals(): void {\n    if (this.sleepGoals.length === 0) {\n      const defaultGoals: SleepGoal[] = [\n        {\n          id: 'bedtime_consistency',\n          type: 'bedtime_consistency',\n          target: 85, // 85% consistency\n          current: 0,\n          progress: 0,\n          streak: 0,\n          active: true\n        },\n        {\n          id: 'sleep_duration',\n          type: 'sleep_duration',\n          target: 8, // 8 hours\n          current: 0,\n          progress: 0,\n          streak: 0,\n          active: true\n        },\n        {\n          id: 'sleep_quality',\n          type: 'sleep_quality',\n          target: 7, // 7/10 quality score\n          current: 0,\n          progress: 0,\n          streak: 0,\n          active: true\n        }\n      ];\n\n      this.sleepGoals = defaultGoals;\n      this.saveToStorage();\n    }\n  }\n\n  // ==================== SLEEP TRACKING ====================\n\n  async startSleepTracking(userId: string, environment?: Partial<SleepEnvironment>): Promise<string> {\n    try {\n      // End any existing session first\n      if (this.currentSession) {\n        await this.endSleepTracking();\n      }\n\n      const session: SleepSession = {\n        id: `sleep_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        userId,\n        startTime: new Date().toISOString(),\n        quality: 5, // Default middle score\n        stages: [],\n        interruptions: [],\n        environment: {\n          roomConditions: 'fair',\n          bedtimeRoutine: [],\n          ...environment\n        },\n        wakeMethod: 'natural',\n        mood: 'tired',\n        createdAt: new Date().toISOString(),\n        synced: false\n      };\n\n      this.currentSession = session;\n      await this.saveCurrentSession();\n\n      // Start monitoring sleep stages\n      this.startStageTracking();\n\n      console.log('[OfflineSleepTracker] Started sleep tracking:', session.id);\n      return session.id;\n    } catch (error) {\n      ErrorHandler.handleError(error, 'Failed to start sleep tracking', {\n        context: 'OfflineSleepTracker.startSleepTracking'\n      });\n      throw error;\n    }\n  }\n\n  async endSleepTracking(\n    wakeMethod: SleepSession['wakeMethod'] = 'natural',\n    mood: SleepSession['mood'] = 'refreshed',\n    quality?: number,\n    notes?: string\n  ): Promise<SleepSession | null> {\n    try {\n      if (!this.currentSession) {\n        console.warn('[OfflineSleepTracker] No active sleep session to end');\n        return null;\n      }\n\n      const endTime = new Date().toISOString();\n      const startTime = new Date(this.currentSession.startTime);\n      const duration = Math.round((new Date(endTime).getTime() - startTime.getTime()) / (1000 * 60));\n\n      // Complete the session\n      this.currentSession.endTime = endTime;\n      this.currentSession.duration = duration;\n      this.currentSession.wakeMethod = wakeMethod;\n      this.currentSession.mood = mood;\n      this.currentSession.quality = quality || this.calculateSleepQuality(this.currentSession);\n      this.currentSession.notes = notes;\n\n      // Stop stage tracking\n      this.stopStageTracking();\n\n      // Add to sessions list\n      this.sleepSessions.unshift({ ...this.currentSession });\n\n      // Update goals and analytics\n      await this.updateGoalsProgress(this.currentSession);\n      await this.updateSleepAnalytics();\n      await this.generateInsights();\n\n      // Save and clear current session\n      const completedSession = { ...this.currentSession };\n      this.currentSession = null;\n\n      await this.saveToStorage();\n      await this.saveCurrentSession();\n\n      // Queue for sync\n      if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {\n        navigator.serviceWorker.controller.postMessage({\n          type: 'QUEUE_SLEEP_DATA',\n          data: { session: completedSession }\n        });\n      }\n\n      console.log('[OfflineSleepTracker] Ended sleep tracking:', completedSession.id, 'Duration:', duration, 'minutes');\n      return completedSession;\n    } catch (error) {\n      ErrorHandler.handleError(error, 'Failed to end sleep tracking', {\n        context: 'OfflineSleepTracker.endSleepTracking'\n      });\n      return null;\n    }\n  }\n\n  async recordInterruption(\n    type: SleepInterruption['type'],\n    severity: number,\n    description?: string\n  ): Promise<void> {\n    if (!this.currentSession) {\n      return;\n    }\n\n    const interruption: SleepInterruption = {\n      time: new Date().toISOString(),\n      type,\n      severity,\n      duration: 1, // Will be updated when interruption ends\n      description\n    };\n\n    this.currentSession.interruptions.push(interruption);\n    await this.saveCurrentSession();\n\n    console.log('[OfflineSleepTracker] Recorded sleep interruption:', type, severity);\n  }\n\n  // ==================== SLEEP STAGE TRACKING ====================\n\n  private startStageTracking(): void {\n    if (!this.currentSession) return;\n\n    // Initialize with awake stage\n    const awakeStage: SleepStage = {\n      type: 'awake',\n      startTime: this.currentSession.startTime,\n      duration: 0,\n      confidence: 1.0\n    };\n\n    this.currentSession.stages.push(awakeStage);\n\n    // Start monitoring timer (simplified simulation)\n    this.trackingTimer = setInterval(() => {\n      this.simulateSleepStageDetection();\n    }, 60000); // Check every minute\n  }\n\n  private stopStageTracking(): void {\n    if (this.trackingTimer) {\n      clearInterval(this.trackingTimer);\n      this.trackingTimer = undefined;\n    }\n  }\n\n  private resumeTracking(): void {\n    if (this.currentSession && !this.trackingTimer) {\n      console.log('[OfflineSleepTracker] Resuming sleep tracking for session:', this.currentSession.id);\n      this.startStageTracking();\n    }\n  }\n\n  private simulateSleepStageDetection(): void {\n    if (!this.currentSession || this.currentSession.stages.length === 0) return;\n\n    const currentStage = this.currentSession.stages[this.currentSession.stages.length - 1];\n    const sessionDuration = Date.now() - new Date(this.currentSession.startTime).getTime();\n    const sessionMinutes = sessionDuration / (1000 * 60);\n\n    // Update current stage duration\n    currentStage.duration = Math.round(sessionMinutes - this.currentSession.stages.slice(0, -1).reduce((sum, stage) => sum + stage.duration, 0));\n\n    // Simple sleep stage progression simulation\n    let nextStageType = currentStage.type;\n\n    if (sessionMinutes > 15 && currentStage.type === 'awake') {\n      nextStageType = 'light';\n    } else if (sessionMinutes > 45 && currentStage.type === 'light' && currentStage.duration > 20) {\n      nextStageType = 'deep';\n    } else if (sessionMinutes > 90 && currentStage.type === 'deep' && currentStage.duration > 30) {\n      nextStageType = 'rem';\n    } else if (sessionMinutes > 120 && currentStage.type === 'rem' && currentStage.duration > 20) {\n      nextStageType = Math.random() > 0.5 ? 'light' : 'deep';\n    }\n\n    // Add new stage if type changed\n    if (nextStageType !== currentStage.type && currentStage.duration >= 5) { // Minimum 5 minutes per stage\n      const newStage: SleepStage = {\n        type: nextStageType,\n        startTime: new Date().toISOString(),\n        duration: 0,\n        confidence: 0.8 + Math.random() * 0.2 // 80-100% confidence\n      };\n\n      this.currentSession.stages.push(newStage);\n      this.saveCurrentSession();\n    }\n  }\n\n  // ==================== ANALYTICS AND INSIGHTS ====================\n\n  private calculateSleepQuality(session: SleepSession): number {\n    let score = 5; // Base score\n\n    // Duration factor (7-9 hours is optimal)\n    if (session.duration) {\n      const hours = session.duration / 60;\n      if (hours >= 7 && hours <= 9) {\n        score += 2;\n      } else if (hours >= 6 && hours <= 10) {\n        score += 1;\n      } else {\n        score -= 1;\n      }\n    }\n\n    // Interruption factor\n    const interruptionPenalty = Math.min(session.interruptions.length * 0.5, 3);\n    score -= interruptionPenalty;\n\n    // Deep sleep factor\n    const deepSleepMinutes = session.stages\n      .filter(stage => stage.type === 'deep')\n      .reduce((sum, stage) => sum + stage.duration, 0);\n\n    if (session.duration && deepSleepMinutes > session.duration * 0.15) { // More than 15% deep sleep\n      score += 1;\n    }\n\n    // REM sleep factor\n    const remSleepMinutes = session.stages\n      .filter(stage => stage.type === 'rem')\n      .reduce((sum, stage) => sum + stage.duration, 0);\n\n    if (session.duration && remSleepMinutes > session.duration * 0.20) { // More than 20% REM sleep\n      score += 1;\n    }\n\n    return Math.max(1, Math.min(10, Math.round(score)));\n  }\n\n  private async updateGoalsProgress(session: SleepSession): Promise<void> {\n    try {\n      const bedtime = new Date(session.startTime);\n      const duration = (session.duration || 0) / 60; // Convert to hours\n\n      for (const goal of this.sleepGoals) {\n        if (!goal.active) continue;\n\n        let progress = false;\n\n        switch (goal.type) {\n          case 'sleep_duration':\n            progress = duration >= goal.target * 0.9; // Within 90% of target\n            goal.current = duration;\n            break;\n\n          case 'sleep_quality':\n            progress = session.quality >= goal.target;\n            goal.current = session.quality;\n            break;\n\n          case 'bedtime_consistency':\n            // Check if bedtime is within 30 minutes of average bedtime\n            const recentSessions = this.sleepSessions.slice(0, 7); // Last 7 sessions\n            if (recentSessions.length > 0) {\n              const avgBedtime = this.calculateAverageBedtime(recentSessions);\n              const bedtimeHour = bedtime.getHours() + bedtime.getMinutes() / 60;\n              progress = Math.abs(bedtimeHour - avgBedtime) <= 0.5; // Within 30 minutes\n            }\n            break;\n        }\n\n        if (progress) {\n          goal.streak++;\n          goal.lastAchieved = session.createdAt;\n        } else {\n          goal.streak = 0;\n        }\n\n        // Calculate overall progress (simplified)\n        goal.progress = Math.min(100, (goal.streak / 7) * 100); // 7-day streak = 100%\n      }\n\n      await this.saveToStorage();\n    } catch (error) {\n      console.error('[OfflineSleepTracker] Failed to update goals progress:', error);\n    }\n  }\n\n  private calculateAverageBedtime(sessions: SleepSession[]): number {\n    const bedtimes = sessions.map(session => {\n      const bedtime = new Date(session.startTime);\n      return bedtime.getHours() + bedtime.getMinutes() / 60;\n    });\n\n    return bedtimes.reduce((sum, time) => sum + time, 0) / bedtimes.length;\n  }\n\n  private async updateSleepAnalytics(): Promise<void> {\n    try {\n      const recentSessions = this.sleepSessions.slice(0, 7); // Last 7 sessions\n\n      if (recentSessions.length === 0) {\n        return;\n      }\n\n      const weeklyDurations = recentSessions.map(s => (s.duration || 0) / 60);\n      const weeklyQualities = recentSessions.map(s => s.quality);\n\n      this.sleepAnalytics = {\n        weeklyAverage: weeklyDurations.reduce((sum, dur) => sum + dur, 0) / weeklyDurations.length,\n        weeklyQuality: weeklyQualities.reduce((sum, qual) => sum + qual, 0) / weeklyQualities.length,\n        bedtimeConsistency: this.calculateBedtimeConsistency(recentSessions),\n        wakeTimeConsistency: this.calculateWakeTimeConsistency(recentSessions),\n        deepSleepPercentage: this.calculateDeepSleepPercentage(recentSessions),\n        remSleepPercentage: this.calculateRemSleepPercentage(recentSessions),\n        interruptionRate: recentSessions.reduce((sum, s) => sum + s.interruptions.length, 0) / recentSessions.length,\n        improvementTrend: this.calculateImprovementTrend(recentSessions),\n        lastCalculated: new Date().toISOString()\n      };\n\n      await this.saveToStorage();\n    } catch (error) {\n      console.error('[OfflineSleepTracker] Failed to update sleep analytics:', error);\n    }\n  }\n\n  private calculateBedtimeConsistency(sessions: SleepSession[]): number {\n    if (sessions.length < 2) return 0;\n\n    const bedtimes = sessions.map(s => new Date(s.startTime).getHours());\n    const avgBedtime = bedtimes.reduce((sum, time) => sum + time, 0) / bedtimes.length;\n    const deviations = bedtimes.map(time => Math.abs(time - avgBedtime));\n    const avgDeviation = deviations.reduce((sum, dev) => sum + dev, 0) / deviations.length;\n\n    return Math.max(0, 100 - (avgDeviation * 10)); // Lower deviation = higher consistency\n  }\n\n  private calculateWakeTimeConsistency(sessions: SleepSession[]): number {\n    if (sessions.length < 2) return 0;\n\n    const wakeTimes = sessions\n      .filter(s => s.endTime)\n      .map(s => new Date(s.endTime!).getHours());\n\n    if (wakeTimes.length < 2) return 0;\n\n    const avgWakeTime = wakeTimes.reduce((sum, time) => sum + time, 0) / wakeTimes.length;\n    const deviations = wakeTimes.map(time => Math.abs(time - avgWakeTime));\n    const avgDeviation = deviations.reduce((sum, dev) => sum + dev, 0) / deviations.length;\n\n    return Math.max(0, 100 - (avgDeviation * 10));\n  }\n\n  private calculateDeepSleepPercentage(sessions: SleepSession[]): number {\n    let totalSleep = 0;\n    let totalDeep = 0;\n\n    for (const session of sessions) {\n      if (session.duration) {\n        totalSleep += session.duration;\n        totalDeep += session.stages\n          .filter(stage => stage.type === 'deep')\n          .reduce((sum, stage) => sum + stage.duration, 0);\n      }\n    }\n\n    return totalSleep > 0 ? (totalDeep / totalSleep) * 100 : 0;\n  }\n\n  private calculateRemSleepPercentage(sessions: SleepSession[]): number {\n    let totalSleep = 0;\n    let totalRem = 0;\n\n    for (const session of sessions) {\n      if (session.duration) {\n        totalSleep += session.duration;\n        totalRem += session.stages\n          .filter(stage => stage.type === 'rem')\n          .reduce((sum, stage) => sum + stage.duration, 0);\n      }\n    }\n\n    return totalSleep > 0 ? (totalRem / totalSleep) * 100 : 0;\n  }\n\n  private calculateImprovementTrend(sessions: SleepSession[]): 'improving' | 'stable' | 'declining' {\n    if (sessions.length < 4) return 'stable';\n\n    const recent = sessions.slice(0, 3).map(s => s.quality);\n    const older = sessions.slice(3, 6).map(s => s.quality);\n\n    if (recent.length === 0 || older.length === 0) return 'stable';\n\n    const recentAvg = recent.reduce((sum, q) => sum + q, 0) / recent.length;\n    const olderAvg = older.reduce((sum, q) => sum + q, 0) / older.length;\n\n    const difference = recentAvg - olderAvg;\n\n    if (difference > 0.5) return 'improving';\n    if (difference < -0.5) return 'declining';\n    return 'stable';\n  }\n\n  private async generateInsights(): Promise<void> {\n    try {\n      if (this.sleepSessions.length < 3) return; // Need at least 3 sessions for insights\n\n      const insights: SleepInsight[] = [];\n      const recentSessions = this.sleepSessions.slice(0, 7);\n\n      // Pattern insight: Bedtime consistency\n      const bedtimeConsistency = this.calculateBedtimeConsistency(recentSessions);\n      if (bedtimeConsistency < 70) {\n        insights.push({\n          id: `insight_bedtime_${Date.now()}`,\n          type: 'recommendation',\n          title: 'Inconsistent Bedtime Detected',\n          description: `Your bedtime varies significantly. Try going to bed at the same time each night to improve sleep quality. Current consistency: ${bedtimeConsistency.toFixed(1)}%`,\n          data: { consistency: bedtimeConsistency },\n          confidence: 0.9,\n          priority: 'high',\n          actionable: true,\n          actions: ['Set a consistent bedtime', 'Create a bedtime routine', 'Use sleep reminders'],\n          createdAt: new Date().toISOString()\n        });\n      }\n\n      // Sleep duration insight\n      const avgDuration = recentSessions.reduce((sum, s) => sum + (s.duration || 0), 0) / recentSessions.length / 60;\n      if (avgDuration < 7) {\n        insights.push({\n          id: `insight_duration_${Date.now()}`,\n          type: 'warning',\n          title: 'Insufficient Sleep Duration',\n          description: `You're averaging ${avgDuration.toFixed(1)} hours of sleep. Most adults need 7-9 hours for optimal health and performance.`,\n          data: { avgDuration },\n          confidence: 0.95,\n          priority: 'high',\n          actionable: true,\n          actions: ['Go to bed earlier', 'Reduce screen time before bed', 'Create a calming bedtime routine'],\n          createdAt: new Date().toISOString()\n        });\n      }\n\n      // Sleep quality trend\n      if (this.sleepAnalytics && this.sleepAnalytics.improvementTrend === 'improving') {\n        insights.push({\n          id: `insight_improvement_${Date.now()}`,\n          type: 'achievement',\n          title: 'Sleep Quality Improving!',\n          description: `Great job! Your sleep quality has been trending upward. Keep up the good habits!`,\n          data: { trend: 'improving' },\n          confidence: 0.8,\n          priority: 'medium',\n          actionable: false,\n          createdAt: new Date().toISOString()\n        });\n      }\n\n      // Add new insights (avoid duplicates)\n      const existingInsightTypes = this.sleepInsights.map(i => i.type + '_' + i.title);\n      const newInsights = insights.filter(insight =>\n        !existingInsightTypes.includes(insight.type + '_' + insight.title)\n      );\n\n      this.sleepInsights.unshift(...newInsights);\n\n      // Keep only recent insights (last 30 days)\n      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n      this.sleepInsights = this.sleepInsights.filter(insight =>\n        new Date(insight.createdAt) > thirtyDaysAgo\n      );\n\n      if (newInsights.length > 0) {\n        await this.saveToStorage();\n        console.log('[OfflineSleepTracker] Generated', newInsights.length, 'new insights');\n      }\n    } catch (error) {\n      console.error('[OfflineSleepTracker] Failed to generate insights:', error);\n    }\n  }\n\n  // ==================== EVENT HANDLERS ====================\n\n  private async handleOnline(): Promise<void> {\n    this.isOnline = true;\n    console.log('[OfflineSleepTracker] Coming online, syncing sleep data...');\n    await this.syncWithServer();\n  }\n\n  private handleOffline(): void {\n    this.isOnline = false;\n    console.log('[OfflineSleepTracker] Going offline, continuing offline tracking...');\n  }\n\n  private handleSyncComplete(data: any): void {\n    console.log('[OfflineSleepTracker] Sync completed via service worker:', data);\n  }\n\n  // ==================== SYNC MANAGEMENT ====================\n\n  async syncWithServer(): Promise<void> {\n    if (!this.isOnline) return;\n\n    try {\n      console.log('[OfflineSleepTracker] Starting sync with server...');\n\n      const unsyncedSessions = this.sleepSessions.filter(s => !s.synced);\n\n      for (const session of unsyncedSessions) {\n        try {\n          await this.syncSleepSession(session);\n          session.synced = true;\n        } catch (error) {\n          console.error('[OfflineSleepTracker] Failed to sync session:', session.id, error);\n        }\n      }\n\n      if (unsyncedSessions.length > 0) {\n        await this.saveToStorage();\n        console.log('[OfflineSleepTracker] Synced', unsyncedSessions.length, 'sleep sessions');\n      }\n    } catch (error) {\n      ErrorHandler.handleError(error, 'Sleep tracking sync failed', {\n        context: 'OfflineSleepTracker.syncWithServer'\n      });\n    }\n  }\n\n  private async syncSleepSession(session: SleepSession): Promise<void> {\n    // In a real implementation, this would make API calls to sync the session\n    console.log('[OfflineSleepTracker] Syncing sleep session:', session.id);\n\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 100));\n\n    return Promise.resolve();\n  }\n\n  // ==================== DATA ACCESS METHODS ====================\n\n  getSleepSessions(limit = 30): SleepSession[] {\n    return this.sleepSessions.slice(0, limit);\n  }\n\n  getCurrentSession(): SleepSession | null {\n    return this.currentSession;\n  }\n\n  getSleepGoals(): SleepGoal[] {\n    return this.sleepGoals.filter(g => g.active);\n  }\n\n  getSleepInsights(): SleepInsight[] {\n    return this.sleepInsights.filter(i => !i.dismissed);\n  }\n\n  getSleepAnalytics(): SleepAnalytics | null {\n    return this.sleepAnalytics;\n  }\n\n  dismissInsight(insightId: string): void {\n    const insight = this.sleepInsights.find(i => i.id === insightId);\n    if (insight) {\n      insight.dismissed = true;\n      this.saveToStorage();\n    }\n  }\n\n  // ==================== STORAGE MANAGEMENT ====================\n\n  private async saveToStorage(): Promise<void> {\n    try {\n      SecurityService.secureStorageSet(this.STORAGE_KEYS.SLEEP_SESSIONS, this.sleepSessions);\n      SecurityService.secureStorageSet(this.STORAGE_KEYS.SLEEP_GOALS, this.sleepGoals);\n      SecurityService.secureStorageSet(this.STORAGE_KEYS.SLEEP_INSIGHTS, this.sleepInsights);\n\n      if (this.sleepAnalytics) {\n        SecurityService.secureStorageSet(this.STORAGE_KEYS.SLEEP_ANALYTICS, this.sleepAnalytics);\n      }\n    } catch (error) {\n      console.error('[OfflineSleepTracker] Failed to save to storage:', error);\n    }\n  }\n\n  private async saveCurrentSession(): Promise<void> {\n    try {\n      if (this.currentSession) {\n        SecurityService.secureStorageSet(this.STORAGE_KEYS.CURRENT_SESSION, this.currentSession);\n      } else {\n        SecurityService.secureStorageRemove(this.STORAGE_KEYS.CURRENT_SESSION);\n      }\n    } catch (error) {\n      console.error('[OfflineSleepTracker] Failed to save current session:', error);\n    }\n  }\n\n  // ==================== UTILITY METHODS ====================\n\n  getTrackingStats() {\n    return {\n      totalSessions: this.sleepSessions.length,\n      unsyncedSessions: this.sleepSessions.filter(s => !s.synced).length,\n      currentlyTracking: !!this.currentSession,\n      currentSessionDuration: this.currentSession ?\n        Math.round((Date.now() - new Date(this.currentSession.startTime).getTime()) / (1000 * 60)) : 0,\n      averageQuality: this.sleepSessions.length > 0 ?\n        this.sleepSessions.reduce((sum, s) => sum + s.quality, 0) / this.sleepSessions.length : 0,\n      isOnline: this.isOnline\n    };\n  }\n\n  async clearOfflineData(): Promise<void> {\n    try {\n      this.sleepSessions = [];\n      this.sleepGoals = [];\n      this.sleepInsights = [];\n      this.sleepAnalytics = null;\n\n      if (this.currentSession) {\n        await this.endSleepTracking();\n      }\n\n      await this.saveToStorage();\n      await this.saveCurrentSession();\n\n      this.initializeDefaultGoals();\n\n      console.log('[OfflineSleepTracker] Cleared all offline sleep data');\n    } catch (error) {\n      ErrorHandler.handleError(error, 'Failed to clear offline sleep data', {\n        context: 'OfflineSleepTracker.clearOfflineData'\n      });\n    }\n  }\n}\n\nexport default OfflineSleepTracker;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/performance-budget-manager.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'PerformanceEntryList' is not defined.",
        "line": 277,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 277,
        "endColumn": 66
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference types=\"node\" />\nimport type {\n  PerformanceBudget,\n  PerformanceThresholds,\n  PerformanceAlert,\n  PerformanceSnapshot,\n  AdaptivePerformanceConfig,\n  DeviceAdaptation\n} from './types/performance';\nimport { deviceCapabilities, DeviceTier } from './device-capabilities';\n\nexport class PerformanceBudgetManager {\n  private static instance: PerformanceBudgetManager | null = null;\n  private budgets: Map<DeviceTier, PerformanceBudget> = new Map();\n  private thresholds: Map<DeviceTier, PerformanceThresholds> = new Map();\n  private currentSnapshot: PerformanceSnapshot | null = null;\n  private activeAlerts: Map<string, PerformanceAlert> = new Map();\n  private monitoringInterval: number | null = null;\n  private adaptations: DeviceAdaptation | null = null;\n  private listeners: Array<(snapshot: PerformanceSnapshot) => void> = [];\n  private alertListeners: Array<(alert: PerformanceAlert) => void> = [];\n  private isMonitoring = false;\n  private performanceObserver: PerformanceObserver | null = null;\n  private frameRateTracker: FrameRateTracker | null = null;\n\n  private constructor() {\n    this.initializeBudgets();\n    this.initializeThresholds();\n  }\n\n  static getInstance(): PerformanceBudgetManager {\n    if (!this.instance) {\n      this.instance = new PerformanceBudgetManager();\n    }\n    return this.instance;\n  }\n\n  private initializeBudgets(): void {\n    // Low-end device budgets\n    this.budgets.set('low-end', {\n      // Time budgets (ms)\n      pageLoad: 3000,\n      firstContentfulPaint: 1500,\n      largestContentfulPaint: 2500,\n      cumulativeLayoutShift: 0.1,\n      firstInputDelay: 100,\n      timeToInteractive: 3500,\n\n      // Resource budgets (KB)\n      totalBundleSize: 200,\n      initialBundleSize: 100,\n      imageSize: 50,\n      audioSize: 20,\n\n      // Memory budgets (MB)\n      heapSize: 100,\n      domNodes: 1000,\n\n      // Network budgets\n      requestCount: 20,\n      requestDuration: 2000\n    });\n\n    // Mid-range device budgets\n    this.budgets.set('mid-range', {\n      pageLoad: 2000,\n      firstContentfulPaint: 1000,\n      largestContentfulPaint: 2000,\n      cumulativeLayoutShift: 0.1,\n      firstInputDelay: 50,\n      timeToInteractive: 2500,\n\n      totalBundleSize: 500,\n      initialBundleSize: 200,\n      imageSize: 100,\n      audioSize: 50,\n\n      heapSize: 250,\n      domNodes: 2000,\n\n      requestCount: 50,\n      requestDuration: 1500\n    });\n\n    // High-end device budgets\n    this.budgets.set('high-end', {\n      pageLoad: 1500,\n      firstContentfulPaint: 800,\n      largestContentfulPaint: 1500,\n      cumulativeLayoutShift: 0.1,\n      firstInputDelay: 30,\n      timeToInteractive: 2000,\n\n      totalBundleSize: 1000,\n      initialBundleSize: 300,\n      imageSize: 200,\n      audioSize: 100,\n\n      heapSize: 500,\n      domNodes: 5000,\n\n      requestCount: 100,\n      requestDuration: 1000\n    });\n  }\n\n  private initializeThresholds(): void {\n    // Low-end device thresholds\n    this.thresholds.set('low-end', {\n      critical: {\n        memoryUsage: 400, // MB\n        fps: 20,\n        responseTime: 500, // ms\n        errorRate: 5 // percentage\n      },\n      warning: {\n        memoryUsage: 300, // MB\n        fps: 25,\n        responseTime: 300, // ms\n        errorRate: 2 // percentage\n      },\n      good: {\n        memoryUsage: 200, // MB\n        fps: 30,\n        responseTime: 150, // ms\n        errorRate: 0.5 // percentage\n      }\n    });\n\n    // Mid-range device thresholds\n    this.thresholds.set('mid-range', {\n      critical: {\n        memoryUsage: 800, // MB\n        fps: 30,\n        responseTime: 300, // ms\n        errorRate: 3 // percentage\n      },\n      warning: {\n        memoryUsage: 600, // MB\n        fps: 40,\n        responseTime: 200, // ms\n        errorRate: 1 // percentage\n      },\n      good: {\n        memoryUsage: 400, // MB\n        fps: 45,\n        responseTime: 100, // ms\n        errorRate: 0.3 // percentage\n      }\n    });\n\n    // High-end device thresholds\n    this.thresholds.set('high-end', {\n      critical: {\n        memoryUsage: 1500, // MB\n        fps: 45,\n        responseTime: 200, // ms\n        errorRate: 2 // percentage\n      },\n      warning: {\n        memoryUsage: 1000, // MB\n        fps: 55,\n        responseTime: 100, // ms\n        errorRate: 0.5 // percentage\n      },\n      good: {\n        memoryUsage: 600, // MB\n        fps: 60,\n        responseTime: 50, // ms\n        errorRate: 0.1 // percentage\n      }\n    });\n  }\n\n  async initialize(): Promise<void> {\n    try {\n      // Wait for device capabilities to be ready\n      const config = await deviceCapabilities.initialize();\n\n      // Set up device-specific adaptations\n      this.adaptations = this.generateDeviceAdaptations(config.tier);\n\n      // Initialize frame rate tracking\n      this.frameRateTracker = new FrameRateTracker();\n\n      // Set up performance observer\n      if ('PerformanceObserver' in window) {\n        this.setupPerformanceObserver();\n      }\n\n      // Start monitoring\n      this.startMonitoring();\n\n      console.log('Performance Budget Manager initialized for', config.tier, 'device');\n    } catch (error) {\n      console.error('Failed to initialize Performance Budget Manager:', error);\n    }\n  }\n\n  private generateDeviceAdaptations(tier: DeviceTier): DeviceAdaptation {\n    const adaptations: Record<DeviceTier, DeviceAdaptation> = {\n      'low-end': {\n        audioQuality: 'low',\n        imageQuality: 'low',\n        animationComplexity: 'none',\n        cacheStrategy: 'minimal',\n        preloadingStrategy: 'disabled',\n\n        listVirtualization: true,\n        lazyImageLoading: true,\n        reducedAnimations: true,\n        simplifiedUI: true,\n\n        monitoringFrequency: 60000, // 1 minute\n        metricRetention: 50,\n        alertThresholds: this.thresholds.get('low-end')!\n      },\n      'mid-range': {\n        audioQuality: 'medium',\n        imageQuality: 'medium',\n        animationComplexity: 'simple',\n        cacheStrategy: 'moderate',\n        preloadingStrategy: 'conservative',\n\n        listVirtualization: true,\n        lazyImageLoading: true,\n        reducedAnimations: false,\n        simplifiedUI: false,\n\n        monitoringFrequency: 45000, // 45 seconds\n        metricRetention: 200,\n        alertThresholds: this.thresholds.get('mid-range')!\n      },\n      'high-end': {\n        audioQuality: 'high',\n        imageQuality: 'high',\n        animationComplexity: 'complex',\n        cacheStrategy: 'aggressive',\n        preloadingStrategy: 'aggressive',\n\n        listVirtualization: false,\n        lazyImageLoading: false,\n        reducedAnimations: false,\n        simplifiedUI: false,\n\n        monitoringFrequency: 30000, // 30 seconds\n        metricRetention: 500,\n        alertThresholds: this.thresholds.get('high-end')!\n      }\n    };\n\n    return adaptations[tier];\n  }\n\n  private setupPerformanceObserver(): void {\n    try {\n      this.performanceObserver = new PerformanceObserver(list => {\n        const entries = list.getEntries();\n        this.processPerformanceEntries(entries);\n      });\n\n      // Observe different types of performance entries\n      const entryTypes = ['navigation', 'paint', 'largest-contentful-paint', 'first-input', 'layout-shift'];\n\n      for (const type of entryTypes) {\n        try {\n          this.performanceObserver.observe({ type, buffered: true });\n        } catch {\n          // Entry type not supported in this browser\n        }\n      }\n    } catch (error) {\n      console.warn('PerformanceObserver not supported:', error);\n    }\n  }\n\n  private processPerformanceEntries(entries: PerformanceEntryList): void {\n    for (const entry of entries) {\n      switch (entry.entryType) {\n        case 'navigation':\n          this.processNavigationEntry(entry as PerformanceNavigationTiming);\n          break;\n        case 'paint':\n          this.processPaintEntry(entry);\n          break;\n        case 'largest-contentful-paint':\n          this.processLCPEntry(entry);\n          break;\n        case 'first-input':\n          this.processFIDEntry(entry);\n          break;\n        case 'layout-shift':\n          this.processCLSEntry(entry);\n          break;\n      }\n    }\n  }\n\n  private processNavigationEntry(entry: PerformanceNavigationTiming): void {\n    const pageLoad = entry.loadEventEnd - entry.navigationStart;\n    const budget = this.getCurrentBudget();\n\n    if (budget && pageLoad > budget.pageLoad) {\n      this.createAlert('page-load', 'warning',\n        `Page load time (${Math.round(pageLoad)}ms) exceeds budget (${budget.pageLoad}ms)`,\n        { pageLoad }\n      );\n    }\n  }\n\n  private processPaintEntry(entry: PerformanceEntry): void {\n    if (entry.name === 'first-contentful-paint') {\n      const budget = this.getCurrentBudget();\n      if (budget && entry.startTime > budget.firstContentfulPaint) {\n        this.createAlert('fcp', 'warning',\n          `First Contentful Paint (${Math.round(entry.startTime)}ms) exceeds budget (${budget.firstContentfulPaint}ms)`,\n          { fcp: entry.startTime }\n        );\n      }\n    }\n  }\n\n  private processLCPEntry(entry: any): void {\n    const budget = this.getCurrentBudget();\n    if (budget && entry.startTime > budget.largestContentfulPaint) {\n      this.createAlert('lcp', 'warning',\n        `Largest Contentful Paint (${Math.round(entry.startTime)}ms) exceeds budget (${budget.largestContentfulPaint}ms)`,\n        { lcp: entry.startTime }\n      );\n    }\n  }\n\n  private processFIDEntry(entry: any): void {\n    const budget = this.getCurrentBudget();\n    if (budget && entry.processingStart - entry.startTime > budget.firstInputDelay) {\n      this.createAlert('fid', 'warning',\n        `First Input Delay (${Math.round(entry.processingStart - entry.startTime)}ms) exceeds budget (${budget.firstInputDelay}ms)`,\n        { fid: entry.processingStart - entry.startTime }\n      );\n    }\n  }\n\n  private processCLSEntry(entry: any): void {\n    const budget = this.getCurrentBudget();\n    if (budget && entry.value > budget.cumulativeLayoutShift) {\n      this.createAlert('cls', 'warning',\n        `Cumulative Layout Shift (${entry.value.toFixed(3)}) exceeds budget (${budget.cumulativeLayoutShift})`,\n        { cls: entry.value }\n      );\n    }\n  }\n\n  private startMonitoring(): void {\n    if (this.isMonitoring) return;\n\n    const frequency = this.adaptations?.monitoringFrequency || 30000;\n\n    this.monitoringInterval = setInterval(() => {\n      this.capturePerformanceSnapshot();\n    }, frequency);\n\n    this.isMonitoring = true;\n  }\n\n  private async capturePerformanceSnapshot(): Promise<void> {\n    const deviceTier = deviceCapabilities.getDeviceTier() || 'low-end';\n\n    const snapshot: PerformanceSnapshot = {\n      timestamp: Date.now(),\n      deviceTier,\n      frameRate: await this.getFrameRateMetrics(),\n      memory: this.getMemoryMetrics(),\n      network: this.getNetworkMetrics(),\n      rendering: this.getRenderingMetrics(),\n      userExperience: this.getUserExperienceMetrics(),\n      overallScore: 0 // Will be calculated\n    };\n\n    // Calculate overall performance score\n    snapshot.overallScore = this.calculatePerformanceScore(snapshot);\n\n    // Store current snapshot\n    this.currentSnapshot = snapshot;\n\n    // Check against budgets and thresholds\n    this.checkBudgetCompliance(snapshot);\n    this.checkPerformanceThresholds(snapshot);\n\n    // Notify listeners\n    this.notifyListeners(snapshot);\n  }\n\n  private async getFrameRateMetrics(): Promise<any> {\n    if (!this.frameRateTracker) {\n      return {\n        current: 60,\n        average: 60,\n        min: 60,\n        max: 60,\n        drops: 0,\n        targetFPS: 60,\n        history: [60]\n      };\n    }\n\n    return this.frameRateTracker.getMetrics();\n  }\n\n  private getMemoryMetrics(): any {\n    const memory = (performance as any).memory;\n    if (!memory) {\n      return {\n        used: 100,\n        total: 1024,\n        limit: 1024,\n        percentage: 10,\n        pressure: 'low',\n        gcFrequency: 0,\n        heapGrowthRate: 0\n      };\n    }\n\n    const used = Math.round(memory.usedJSHeapSize / 1024 / 1024);\n    const total = Math.round(memory.totalJSHeapSize / 1024 / 1024);\n    const limit = Math.round(memory.jsHeapSizeLimit / 1024 / 1024);\n\n    return {\n      used,\n      total,\n      limit,\n      percentage: (used / limit) * 100,\n      pressure: used > limit * 0.8 ? 'critical' : used > limit * 0.6 ? 'high' : used > limit * 0.4 ? 'medium' : 'low',\n      gcFrequency: 0, // Would need to be tracked separately\n      heapGrowthRate: 0 // Would need historical data\n    };\n  }\n\n  private getNetworkMetrics(): any {\n    const connection = (navigator as any).connection;\n    const entries = performance.getEntriesByType('navigation') as PerformanceNavigationTiming[];\n\n    let latency = 0;\n    if (entries.length > 0) {\n      const entry = entries[0];\n      latency = entry.responseStart - entry.requestStart;\n    }\n\n    return {\n      latency,\n      bandwidth: connection?.downlink || 10,\n      requestCount: performance.getEntriesByType('resource').length,\n      failureRate: 0, // Would need to be tracked\n      cacheHitRate: 0, // Would need to be tracked\n      compressionRatio: 0 // Would need to be tracked\n    };\n  }\n\n  private getRenderingMetrics(): any {\n    const entries = performance.getEntriesByType('measure');\n\n    return {\n      paintTime: 0, // Would need to be measured\n      layoutTime: 0, // Would need to be measured\n      styleRecalcTime: 0, // Would need to be measured\n      compositeTime: 0, // Would need to be measured\n      domNodeCount: document.querySelectorAll('*').length,\n      cssRuleCount: this.getCSSRuleCount(),\n      jsExecutionTime: 0 // Would need to be measured\n    };\n  }\n\n  private getCSSRuleCount(): number {\n    let count = 0;\n    try {\n      for (let i = 0; i < document.styleSheets.length; i++) {\n        const sheet = document.styleSheets[i];\n        try {\n          if (sheet.cssRules) {\n            count += sheet.cssRules.length;\n          }\n        } catch {\n          // CORS or other access issues\n        }\n      }\n    } catch {\n      // Fallback\n    }\n    return count;\n  }\n\n  private getUserExperienceMetrics(): any {\n    const entries = performance.getEntriesByType('navigation') as PerformanceNavigationTiming[];\n\n    if (entries.length === 0) {\n      return {\n        firstContentfulPaint: 0,\n        largestContentfulPaint: 0,\n        cumulativeLayoutShift: 0,\n        firstInputDelay: 0,\n        timeToInteractive: 0,\n        totalBlockingTime: 0,\n        interactionToNextPaint: 0\n      };\n    }\n\n    const entry = entries[0];\n\n    return {\n      firstContentfulPaint: this.getMetricValue('first-contentful-paint'),\n      largestContentfulPaint: this.getMetricValue('largest-contentful-paint'),\n      cumulativeLayoutShift: this.getMetricValue('cumulative-layout-shift'),\n      firstInputDelay: this.getMetricValue('first-input-delay'),\n      timeToInteractive: entry.domContentLoadedEventEnd - entry.navigationStart,\n      totalBlockingTime: 0, // Would need to be calculated\n      interactionToNextPaint: 0 // Would need to be measured\n    };\n  }\n\n  private getMetricValue(metricName: string): number {\n    const entries = performance.getEntriesByName(metricName);\n    if (entries.length > 0) {\n      return entries[entries.length - 1].startTime;\n    }\n    return 0;\n  }\n\n  private calculatePerformanceScore(snapshot: PerformanceSnapshot): number {\n    const thresholds = this.getCurrentThresholds();\n    if (!thresholds) return 50; // Neutral score\n\n    let score = 100;\n\n    // Memory score (25% weight)\n    const memoryRatio = snapshot.memory.used / thresholds.good.memoryUsage;\n    score -= Math.max(0, (memoryRatio - 1) * 25);\n\n    // FPS score (25% weight)\n    const fpsRatio = thresholds.good.fps / snapshot.frameRate.current;\n    score -= Math.max(0, (fpsRatio - 1) * 25);\n\n    // Network score (25% weight)\n    const latencyRatio = snapshot.network.latency / thresholds.good.responseTime;\n    score -= Math.max(0, (latencyRatio - 1) * 25);\n\n    // User experience score (25% weight)\n    const uxScore = this.calculateUXScore(snapshot.userExperience);\n    score = (score * 0.75) + (uxScore * 0.25);\n\n    return Math.max(0, Math.min(100, score));\n  }\n\n  private calculateUXScore(ux: any): number {\n    const budget = this.getCurrentBudget();\n    if (!budget) return 50;\n\n    let score = 100;\n\n    // FCP impact\n    if (ux.firstContentfulPaint > budget.firstContentfulPaint) {\n      score -= 20;\n    }\n\n    // LCP impact\n    if (ux.largestContentfulPaint > budget.largestContentfulPaint) {\n      score -= 30;\n    }\n\n    // CLS impact\n    if (ux.cumulativeLayoutShift > budget.cumulativeLayoutShift) {\n      score -= 25;\n    }\n\n    // FID impact\n    if (ux.firstInputDelay > budget.firstInputDelay) {\n      score -= 25;\n    }\n\n    return Math.max(0, score);\n  }\n\n  private checkBudgetCompliance(snapshot: PerformanceSnapshot): void {\n    const budget = this.getCurrentBudget();\n    if (!budget) return;\n\n    // Check memory budget\n    if (snapshot.memory.used > budget.heapSize) {\n      this.createAlert('memory-budget', 'warning',\n        `Memory usage (${snapshot.memory.used}MB) exceeds budget (${budget.heapSize}MB)`,\n        { memoryUsed: snapshot.memory.used, memoryBudget: budget.heapSize }\n      );\n    }\n\n    // Check DOM node budget\n    if (snapshot.rendering.domNodeCount > budget.domNodes) {\n      this.createAlert('dom-budget', 'warning',\n        `DOM node count (${snapshot.rendering.domNodeCount}) exceeds budget (${budget.domNodes})`,\n        { domNodes: snapshot.rendering.domNodeCount, domBudget: budget.domNodes }\n      );\n    }\n  }\n\n  private checkPerformanceThresholds(snapshot: PerformanceSnapshot): void {\n    const thresholds = this.getCurrentThresholds();\n    if (!thresholds) return;\n\n    // Check memory thresholds\n    if (snapshot.memory.used > thresholds.critical.memoryUsage) {\n      this.createAlert('memory-critical', 'critical',\n        `Critical memory usage: ${snapshot.memory.used}MB`,\n        snapshot,\n        [\n          'Clear unnecessary caches',\n          'Trigger garbage collection',\n          'Reduce cache sizes',\n          'Disable non-essential features'\n        ],\n        this.createMemoryAutoFix()\n      );\n    } else if (snapshot.memory.used > thresholds.warning.memoryUsage) {\n      this.createAlert('memory-warning', 'warning',\n        `High memory usage: ${snapshot.memory.used}MB`,\n        snapshot,\n        [\n          'Monitor memory growth',\n          'Consider cache cleanup',\n          'Review memory-intensive operations'\n        ]\n      );\n    }\n\n    // Check FPS thresholds\n    if (snapshot.frameRate.current < thresholds.critical.fps) {\n      this.createAlert('fps-critical', 'critical',\n        `Critical frame rate: ${snapshot.frameRate.current}fps`,\n        snapshot,\n        [\n          'Reduce animation complexity',\n          'Enable hardware acceleration',\n          'Optimize rendering performance',\n          'Consider reduced motion mode'\n        ],\n        this.createFPSAutoFix()\n      );\n    }\n\n    // Check network thresholds\n    if (snapshot.network.latency > thresholds.critical.responseTime) {\n      this.createAlert('network-critical', 'critical',\n        `Critical response time: ${snapshot.network.latency}ms`,\n        snapshot,\n        [\n          'Enable request caching',\n          'Optimize network requests',\n          'Consider offline mode',\n          'Reduce request frequency'\n        ]\n      );\n    }\n  }\n\n  private createAlert(\n    id: string,\n    severity: 'warning' | 'critical',\n    message: string,\n    metrics?: any,\n    suggestions: string[] = [],\n    autoFix?: () => Promise<void>\n  ): void {\n    const alert: PerformanceAlert = {\n      id,\n      type: this.getAlertType(id),\n      severity,\n      message,\n      timestamp: Date.now(),\n      metrics,\n      suggestions,\n      autoFix\n    };\n\n    this.activeAlerts.set(id, alert);\n    this.notifyAlertListeners(alert);\n\n    // Auto-resolve after some time for non-critical alerts\n    if (severity === 'warning') {\n      setTimeout(() => {\n        this.resolveAlert(id);\n      }, 300000); // 5 minutes\n    }\n  }\n\n  private getAlertType(id: string): 'memory' | 'fps' | 'network' | 'render' | 'user' {\n    if (id.includes('memory')) return 'memory';\n    if (id.includes('fps')) return 'fps';\n    if (id.includes('network')) return 'network';\n    if (id.includes('render') || id.includes('dom')) return 'render';\n    return 'user';\n  }\n\n  private createMemoryAutoFix(): () => Promise<void> {\n    return async () => {\n      // Trigger garbage collection if available\n      if ('gc' in window) {\n        (window as any).gc();\n      }\n\n      // Clear performance entries\n      performance.clearMeasures();\n      performance.clearMarks();\n\n      // Notify other services to reduce memory usage\n      window.dispatchEvent(new CustomEvent('memory-pressure', {\n        detail: { level: 'critical' }\n      }));\n\n      console.log('Applied automatic memory optimization');\n    };\n  }\n\n  private createFPSAutoFix(): () => Promise<void> {\n    return async () => {\n      // Enable reduced motion\n      document.documentElement.style.setProperty('--animation-duration', '0s');\n\n      // Disable non-essential animations\n      const animations = document.getAnimations();\n      animations.forEach(animation => {\n        if (animation.effect) {\n          animation.pause();\n        }\n      });\n\n      // Notify components to reduce complexity\n      window.dispatchEvent(new CustomEvent('performance-critical', {\n        detail: { type: 'fps', action: 'reduce-complexity' }\n      }));\n\n      console.log('Applied automatic FPS optimization');\n    };\n  }\n\n  // Public API methods\n  getCurrentBudget(): PerformanceBudget | null {\n    const tier = deviceCapabilities.getDeviceTier();\n    return tier ? this.budgets.get(tier) || null : null;\n  }\n\n  getCurrentThresholds(): PerformanceThresholds | null {\n    const tier = deviceCapabilities.getDeviceTier();\n    return tier ? this.thresholds.get(tier) || null : null;\n  }\n\n  getAdaptations(): DeviceAdaptation | null {\n    return this.adaptations;\n  }\n\n  getCurrentSnapshot(): PerformanceSnapshot | null {\n    return this.currentSnapshot;\n  }\n\n  getActiveAlerts(): PerformanceAlert[] {\n    return Array.from(this.activeAlerts.values());\n  }\n\n  resolveAlert(id: string): void {\n    if (this.activeAlerts.delete(id)) {\n      console.log(`Resolved performance alert: ${id}`);\n    }\n  }\n\n  async triggerAutoFix(alertId: string): Promise<void> {\n    const alert = this.activeAlerts.get(alertId);\n    if (alert?.autoFix) {\n      try {\n        await alert.autoFix();\n        this.resolveAlert(alertId);\n      } catch (error) {\n        console.error('Auto-fix failed:', error);\n      }\n    }\n  }\n\n  // Event listeners\n  onSnapshot(callback: (snapshot: PerformanceSnapshot) => void): () => void {\n    this.listeners.push(callback);\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  onAlert(callback: (alert: PerformanceAlert) => void): () => void {\n    this.alertListeners.push(callback);\n    return () => {\n      const index = this.alertListeners.indexOf(callback);\n      if (index > -1) {\n        this.alertListeners.splice(index, 1);\n      }\n    };\n  }\n\n  private notifyListeners(snapshot: PerformanceSnapshot): void {\n    this.listeners.forEach(callback => {\n      try {\n        callback(snapshot);\n      } catch (error) {\n        console.error('Error in performance snapshot listener:', error);\n      }\n    });\n  }\n\n  private notifyAlertListeners(alert: PerformanceAlert): void {\n    this.alertListeners.forEach(callback => {\n      try {\n        callback(alert);\n      } catch (error) {\n        console.error('Error in performance alert listener:', error);\n      }\n    });\n  }\n\n  // Cleanup\n  destroy(): void {\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = null;\n    }\n\n    if (this.performanceObserver) {\n      this.performanceObserver.disconnect();\n      this.performanceObserver = null;\n    }\n\n    if (this.frameRateTracker) {\n      this.frameRateTracker.stop();\n      this.frameRateTracker = null;\n    }\n\n    this.isMonitoring = false;\n    this.listeners = [];\n    this.alertListeners = [];\n    this.activeAlerts.clear();\n  }\n}\n\n// Simple frame rate tracker\nclass FrameRateTracker {\n  private frames: number[] = [];\n  private isTracking = false;\n  private animationId: number | null = null;\n\n  constructor() {\n    this.start();\n  }\n\n  start(): void {\n    if (this.isTracking) return;\n    this.isTracking = true;\n    this.track();\n  }\n\n  private track(): void {\n    const start = performance.now();\n\n    this.animationId = requestAnimationFrame(() => {\n      const frameDuration = performance.now() - start;\n      const fps = 1000 / frameDuration;\n\n      this.frames.push(fps);\n\n      // Keep only last 60 frames (roughly 1 second at 60fps)\n      if (this.frames.length > 60) {\n        this.frames.shift();\n      }\n\n      if (this.isTracking) {\n        this.track();\n      }\n    });\n  }\n\n  getMetrics(): any {\n    if (this.frames.length === 0) {\n      return {\n        current: 60,\n        average: 60,\n        min: 60,\n        max: 60,\n        drops: 0,\n        targetFPS: 60,\n        history: [60]\n      };\n    }\n\n    const current = this.frames[this.frames.length - 1] || 60;\n    const average = this.frames.reduce((a, b) => a + b, 0) / this.frames.length;\n    const min = Math.min(...this.frames);\n    const max = Math.max(...this.frames);\n    const drops = this.frames.filter(fps => fps < 55).length;\n\n    return {\n      current: Math.round(current),\n      average: Math.round(average),\n      min: Math.round(min),\n      max: Math.round(max),\n      drops,\n      targetFPS: 60,\n      history: [...this.frames]\n    };\n  }\n\n  stop(): void {\n    this.isTracking = false;\n    if (this.animationId) {\n      cancelAnimationFrame(this.animationId);\n      this.animationId = null;\n    }\n  }\n}\n\n// Export singleton instance\nexport const performanceBudgetManager = PerformanceBudgetManager.getInstance();",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/predictive-analytics-service.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'alarms' is not defined.",
        "line": 529,
        "column": 89,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 529,
        "endColumn": 95
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'alarms' is not defined.",
        "line": 534,
        "column": 70,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 534,
        "endColumn": 76
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'alarms' is not defined.",
        "line": 538,
        "column": 84,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 538,
        "endColumn": 90
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 623,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 623,
        "endColumn": 45,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [23392, 24763],
              "text": "{ const currentMonth = now.getMonth();\n        const isWinter = currentMonth >= 11 || currentMonth <= 1;\n        const isTransition = currentMonth === 2 || currentMonth === 3 || currentMonth === 8 || currentMonth === 9;\n\n        if (isTransition && pattern.metrics.maxVariation > 30) {\n          insights.push({\n            id: this.generateInsightId(),\n            userId,\n            type: 'recommendation',\n            title: 'Seasonal Adjustment Opportunity',\n            description: 'Based on your seasonal patterns, consider adjusting your alarm times for the changing season.',\n            confidence: pattern.confidence,\n            priority: 'medium',\n            category: 'seasonal_optimization',\n            actionable: true,\n            suggestedActions: [\n              isWinter ? 'Gradually shift wake time later for winter comfort' : 'Gradually shift wake time earlier for spring energy',\n              'Consider using light therapy in darker months',\n              'Adjust your evening routine for the new season'\n            ],\n            impact: 'moderate',\n            timeframe: 'next_month',\n            data: { pattern: pattern.metrics, currentSeason: isWinter ? 'winter' : 'spring' },\n            createdAt: now,\n            expiresAt: new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000) // Expires in 30 days\n          });\n        }\n        break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 624,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 624,
        "endColumn": 66,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [23392, 24763],
              "text": "{ const currentMonth = now.getMonth();\n        const isWinter = currentMonth >= 11 || currentMonth <= 1;\n        const isTransition = currentMonth === 2 || currentMonth === 3 || currentMonth === 8 || currentMonth === 9;\n\n        if (isTransition && pattern.metrics.maxVariation > 30) {\n          insights.push({\n            id: this.generateInsightId(),\n            userId,\n            type: 'recommendation',\n            title: 'Seasonal Adjustment Opportunity',\n            description: 'Based on your seasonal patterns, consider adjusting your alarm times for the changing season.',\n            confidence: pattern.confidence,\n            priority: 'medium',\n            category: 'seasonal_optimization',\n            actionable: true,\n            suggestedActions: [\n              isWinter ? 'Gradually shift wake time later for winter comfort' : 'Gradually shift wake time earlier for spring energy',\n              'Consider using light therapy in darker months',\n              'Adjust your evening routine for the new season'\n            ],\n            impact: 'moderate',\n            timeframe: 'next_month',\n            data: { pattern: pattern.metrics, currentSeason: isWinter ? 'winter' : 'spring' },\n            createdAt: now,\n            expiresAt: new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000) // Expires in 30 days\n          });\n        }\n        break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 625,
        "column": 9,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 625,
        "endColumn": 115,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [23392, 24763],
              "text": "{ const currentMonth = now.getMonth();\n        const isWinter = currentMonth >= 11 || currentMonth <= 1;\n        const isTransition = currentMonth === 2 || currentMonth === 3 || currentMonth === 8 || currentMonth === 9;\n\n        if (isTransition && pattern.metrics.maxVariation > 30) {\n          insights.push({\n            id: this.generateInsightId(),\n            userId,\n            type: 'recommendation',\n            title: 'Seasonal Adjustment Opportunity',\n            description: 'Based on your seasonal patterns, consider adjusting your alarm times for the changing season.',\n            confidence: pattern.confidence,\n            priority: 'medium',\n            category: 'seasonal_optimization',\n            actionable: true,\n            suggestedActions: [\n              isWinter ? 'Gradually shift wake time later for winter comfort' : 'Gradually shift wake time earlier for spring energy',\n              'Consider using light therapy in darker months',\n              'Adjust your evening routine for the new season'\n            ],\n            impact: 'moderate',\n            timeframe: 'next_month',\n            data: { pattern: pattern.metrics, currentSeason: isWinter ? 'winter' : 'spring' },\n            createdAt: now,\n            expiresAt: new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000) // Expires in 30 days\n          });\n        }\n        break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'alarms' is not defined.",
        "line": 670,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 670,
        "endColumn": 32
      }
    ],
    "suppressedMessages": [],
    "errorCount": 7,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import type {\n  User,\n  SleepPattern,\n  WakeUpBehavior,\n  AIOptimization,\n  SchedulingRecommendation,\n  PatternInsight\n} from '../types/index';\nimport { Preferences } from '@capacitor/preferences';\nimport MLAlarmOptimizer from './ml-alarm-optimizer';\nimport EnhancedLocationService from './enhanced-location-service';\n\nconst ANALYTICS_CONFIG_KEY = 'predictive_analytics_config';\nconst PATTERNS_CACHE_KEY = 'detected_patterns';\nconst PREDICTIONS_CACHE_KEY = 'predictions_cache';\nconst INSIGHTS_HISTORY_KEY = 'insights_history';\n\ninterface AnalyticsConfig {\n  enabled: boolean;\n  analysisFrequency: 'daily' | 'weekly' | 'biweekly' | 'monthly';\n  patternConfidenceThreshold: number;\n  predictionHorizonDays: number;\n  maxInsightsHistory: number;\n  enableLearning: boolean;\n  personalizedRecommendations: boolean;\n}\n\ninterface DetectedPattern {\n  id: string;\n  type: PatternType;\n  name: string;\n  description: string;\n  confidence: number;\n  frequency: number;\n  trend: 'improving' | 'declining' | 'stable' | 'emerging';\n  dataPoints: number;\n  firstDetected: Date;\n  lastUpdated: Date;\n  metrics: Record<string, number>;\n  context: PatternContext;\n}\n\ntype PatternType =\n  | 'wake_consistency'\n  | 'snooze_behavior'\n  | 'seasonal_adjustment'\n  | 'location_influence'\n  | 'weather_sensitivity'\n  | 'calendar_correlation'\n  | 'sleep_quality_impact'\n  | 'energy_level_pattern'\n  | 'difficulty_optimization'\n  | 'voice_mood_preference';\n\ninterface PatternContext {\n  timeFrame: string;\n  conditions: string[];\n  correlations: Array<{ factor: string; strength: number }>;\n  anomalies: string[];\n}\n\ninterface PredictiveInsight {\n  id: string;\n  userId: string;\n  type: 'optimization' | 'warning' | 'trend' | 'recommendation' | 'anomaly';\n  title: string;\n  description: string;\n  confidence: number;\n  priority: 'low' | 'medium' | 'high' | 'critical';\n  category: string;\n  actionable: boolean;\n  suggestedActions: string[];\n  impact: 'minimal' | 'moderate' | 'significant' | 'major';\n  timeframe: string;\n  data: Record<string, any>;\n  createdAt: Date;\n  expiresAt?: Date;\n  applied?: Date;\n  feedback?: 'helpful' | 'not_helpful' | 'partially_helpful';\n}\n\ninterface TrendAnalysis {\n  metric: string;\n  direction: 'up' | 'down' | 'stable' | 'volatile';\n  magnitude: number;\n  confidence: number;\n  timeframe: string;\n  description: string;\n  projectedValue?: number;\n  projectedDate?: Date;\n}\n\nexport class PredictiveAnalyticsService {\n  private static config: AnalyticsConfig = {\n    enabled: true,\n    analysisFrequency: 'weekly',\n    patternConfidenceThreshold: 0.6,\n    predictionHorizonDays: 30,\n    maxInsightsHistory: 200,\n    enableLearning: true,\n    personalizedRecommendations: true\n  };\n\n  private static detectedPatterns: Map<string, DetectedPattern> = new Map();\n  private static insightsHistory: PredictiveInsight[] = [];\n  private static analysisSchedule: number | null = null;\n  private static lastAnalysisDate: Date | null = null;\n\n  // ===== INITIALIZATION =====\n\n  static async initialize(): Promise<void> {\n    try {\n      await this.loadConfig();\n      await this.loadDetectedPatterns();\n      await this.loadInsightsHistory();\n\n      if (this.config.enabled) {\n        await this.startAnalysisSchedule();\n        await this.runInitialAnalysis();\n      }\n\n      console.log('Predictive Analytics Service initialized');\n    } catch (error) {\n      console.error('Failed to initialize Predictive Analytics:', error);\n    }\n  }\n\n  private static async loadConfig(): Promise<void> {\n    try {\n      const { value } = await Preferences.get({ key: ANALYTICS_CONFIG_KEY });\n      if (value) {\n        this.config = { ...this.config, ...JSON.parse(value) };\n      }\n    } catch (error) {\n      console.error('Error loading analytics config:', error);\n    }\n  }\n\n  private static async loadDetectedPatterns(): Promise<void> {\n    try {\n      const { value } = await Preferences.get({ key: PATTERNS_CACHE_KEY });\n      if (value) {\n        const data = JSON.parse(value);\n        this.detectedPatterns = new Map(Object.entries(data).map(([k, v]) => [k, {\n          ...v as any,\n          firstDetected: new Date((v as any).firstDetected),\n          lastUpdated: new Date((v as any).lastUpdated)\n        }]));\n      }\n    } catch (error) {\n      console.error('Error loading detected patterns:', error);\n    }\n  }\n\n  private static async loadInsightsHistory(): Promise<void> {\n    try {\n      const { value } = await Preferences.get({ key: INSIGHTS_HISTORY_KEY });\n      if (value) {\n        const data = JSON.parse(value);\n        this.insightsHistory = data.map((insight: any) => ({\n          ...insight,\n          createdAt: new Date(insight.createdAt),\n          expiresAt: insight.expiresAt ? new Date(insight.expiresAt) : undefined,\n          applied: insight.applied ? new Date(insight.applied) : undefined\n        }));\n      }\n    } catch (error) {\n      console.error('Error loading insights history:', error);\n    }\n  }\n\n  // ===== PATTERN DETECTION =====\n\n  static async analyzeUserPatterns(\n    userId: string,\n    behaviors: WakeUpBehavior[],\n  ): Promise<DetectedPattern[]> {\n    try {\n      const patterns: DetectedPattern[] = [];\n\n      // Analyze different pattern types\n      patterns.push(...await this.detectWakeConsistencyPatterns(behaviors));\n      patterns.push(...await this.detectSnoozeBehaviorPatterns(behaviors));\n      patterns.push(...await this.detectSeasonalPatterns(behaviors));\n      patterns.push(...await this.detectLocationInfluencePatterns(userId, behaviors));\n      patterns.push(...await this.detectWeatherSensitivityPatterns(behaviors));\n      patterns.push(...await this.detectCalendarCorrelationPatterns(behaviors));\n      patterns.push(...await this.detectSleepQualityImpactPatterns(behaviors));\n      patterns.push(...await this.detectEnergyLevelPatterns(behaviors));\n      patterns.push(...await this.detectDifficultyOptimizationPatterns(behaviors));\n      patterns.push(...await this.detectVoiceMoodPreferences(behaviors));\n\n      // Filter by confidence threshold\n      const validPatterns = patterns.filter(p => p.confidence >= this.config.patternConfidenceThreshold);\n\n      // Update detected patterns cache\n      for (const pattern of validPatterns) {\n        this.detectedPatterns.set(pattern.id, pattern);\n      }\n\n      await this.saveDetectedPatterns();\n      return validPatterns;\n\n    } catch (error) {\n      console.error('Error analyzing user patterns:', error);\n      return [];\n    }\n  }\n\n  private static async detectWakeConsistencyPatterns(behaviors: WakeUpBehavior[]): Promise<DetectedPattern[]> {\n    const patterns: DetectedPattern[] = [];\n\n    if (behaviors.length < 7) return patterns; // Need at least a week of data\n\n    // Group by day of week\n    const dayGroups: Record<string, WakeUpBehavior[]> = {};\n    behaviors.forEach(b => {\n      const day = new Date(b.date).getDay().toString();\n      dayGroups[day] = dayGroups[day] || [];\n      dayGroups[day].push(b);\n    });\n\n    // Calculate consistency for each day\n    const consistencyScores: Record<string, number> = {};\n    const avgWakeTimes: Record<string, number> = {};\n\n    for (const [day, dayBehaviors] of Object.entries(dayGroups)) {\n      if (dayBehaviors.length < 3) continue;\n\n      const wakeTimes = dayBehaviors.map(b => this.timeToMinutes(b.actualWakeTime));\n      const avgTime = wakeTimes.reduce((sum, time) => sum + time, 0) / wakeTimes.length;\n      const variance = wakeTimes.reduce((sum, time) => sum + Math.pow(time - avgTime, 2), 0) / wakeTimes.length;\n      const consistency = Math.max(0, 1 - Math.sqrt(variance) / 60); // Normalize by 1 hour\n\n      consistencyScores[day] = consistency;\n      avgWakeTimes[day] = avgTime;\n    }\n\n    // Detect overall consistency pattern\n    const avgConsistency = Object.values(consistencyScores).reduce((sum, score) => sum + score, 0) / Object.values(consistencyScores).length;\n\n    if (avgConsistency > 0.7) {\n      patterns.push({\n        id: this.generatePatternId('wake_consistency'),\n        type: 'wake_consistency',\n        name: 'Consistent Wake Times',\n        description: `You maintain consistent wake times with ${Math.round(avgConsistency * 100)}% regularity`,\n        confidence: avgConsistency,\n        frequency: behaviors.length,\n        trend: this.calculateTrend(consistencyScores),\n        dataPoints: behaviors.length,\n        firstDetected: new Date(Math.min(...behaviors.map(b => new Date(b.date).getTime()))),\n        lastUpdated: new Date(),\n        metrics: { avgConsistency, ...consistencyScores },\n        context: {\n          timeFrame: `${behaviors.length} days`,\n          conditions: Object.entries(avgWakeTimes).map(([day, time]) =>\n            `${this.getDayName(parseInt(day))}: ${this.minutesToTime(time)}`\n          ),\n          correlations: [],\n          anomalies: this.findConsistencyAnomalies(consistencyScores)\n        }\n      });\n    }\n\n    return patterns;\n  }\n\n  private static async detectSnoozeBehaviorPatterns(behaviors: WakeUpBehavior[]): Promise<DetectedPattern[]> {\n    const patterns: DetectedPattern[] = [];\n\n    const snoozeData = behaviors.filter(b => b.snoozeCount > 0);\n    if (snoozeData.length < 5) return patterns;\n\n    const avgSnoozeCount = snoozeData.reduce((sum, b) => sum + b.snoozeCount, 0) / snoozeData.length;\n    const snoozeFrequency = snoozeData.length / behaviors.length;\n\n    // Detect snooze patterns by day of week\n    const weekdaySnoozes = snoozeData.filter(b => {\n      const day = new Date(b.date).getDay();\n      return day >= 1 && day <= 5;\n    });\n\n    const weekendSnoozes = snoozeData.filter(b => {\n      const day = new Date(b.date).getDay();\n      return day === 0 || day === 6;\n    });\n\n    let description = `You snooze ${Math.round(snoozeFrequency * 100)}% of the time, averaging ${avgSnoozeCount.toFixed(1)} snoozes`;\n    const conditions = [`Snooze frequency: ${Math.round(snoozeFrequency * 100)}%`];\n\n    if (weekdaySnoozes.length > 0 && weekendSnoozes.length > 0) {\n      const weekdayAvg = weekdaySnoozes.reduce((sum, b) => sum + b.snoozeCount, 0) / weekdaySnoozes.length;\n      const weekendAvg = weekendSnoozes.reduce((sum, b) => sum + b.snoozeCount, 0) / weekendSnoozes.length;\n\n      if (weekdayAvg > weekendAvg * 1.5) {\n        description += '. Higher snoozing on weekdays suggests work stress or insufficient sleep';\n        conditions.push('Weekday snooze pattern detected');\n      }\n    }\n\n    patterns.push({\n      id: this.generatePatternId('snooze_behavior'),\n      type: 'snooze_behavior',\n      name: 'Snooze Usage Pattern',\n      description,\n      confidence: Math.min(0.95, snoozeData.length / 10),\n      frequency: snoozeData.length,\n      trend: this.calculateSnoozeTrend(behaviors),\n      dataPoints: behaviors.length,\n      firstDetected: new Date(Math.min(...behaviors.map(b => new Date(b.date).getTime()))),\n      lastUpdated: new Date(),\n      metrics: { avgSnoozeCount, snoozeFrequency },\n      context: {\n        timeFrame: `${behaviors.length} days`,\n        conditions,\n        correlations: this.findSnoozeCorrelations(behaviors),\n        anomalies: []\n      }\n    });\n\n    return patterns;\n  }\n\n  private static async detectSeasonalPatterns(behaviors: WakeUpBehavior[]): Promise<DetectedPattern[]> {\n    const patterns: DetectedPattern[] = [];\n\n    if (behaviors.length < 30) return patterns; // Need at least a month of data\n\n    // Group by month\n    const monthGroups: Record<string, WakeUpBehavior[]> = {};\n    behaviors.forEach(b => {\n      const month = new Date(b.date).getMonth().toString();\n      monthGroups[month] = monthGroups[month] || [];\n      monthGroups[month].push(b);\n    });\n\n    if (Object.keys(monthGroups).length < 2) return patterns;\n\n    // Calculate average wake times by month\n    const monthlyAverages: Record<string, number> = {};\n    for (const [month, monthBehaviors] of Object.entries(monthGroups)) {\n      const wakeTimes = monthBehaviors.map(b => this.timeToMinutes(b.actualWakeTime));\n      monthlyAverages[month] = wakeTimes.reduce((sum, time) => sum + time, 0) / wakeTimes.length;\n    }\n\n    // Detect seasonal variation\n    const times = Object.values(monthlyAverages);\n    const avgTime = times.reduce((sum, time) => sum + time, 0) / times.length;\n    const maxVariation = Math.max(...times.map(time => Math.abs(time - avgTime)));\n\n    if (maxVariation > 20) { // 20+ minute seasonal variation\n      const winterMonths = [11, 0, 1]; // Dec, Jan, Feb\n      const summerMonths = [5, 6, 7]; // Jun, Jul, Aug\n\n      const winterAvg = this.calculateSeasonalAverage(monthlyAverages, winterMonths);\n      const summerAvg = this.calculateSeasonalAverage(monthlyAverages, summerMonths);\n\n      let seasonalDescription = 'Seasonal wake time variation detected';\n      if (winterAvg && summerAvg) {\n        const diff = winterAvg - summerAvg;\n        seasonalDescription = diff > 0\n          ? `You wake ${Math.abs(diff).toFixed(0)} minutes later in winter than summer`\n          : `You wake ${Math.abs(diff).toFixed(0)} minutes earlier in winter than summer`;\n      }\n\n      patterns.push({\n        id: this.generatePatternId('seasonal_adjustment'),\n        type: 'seasonal_adjustment',\n        name: 'Seasonal Wake Time Pattern',\n        description: seasonalDescription,\n        confidence: Math.min(0.9, maxVariation / 60), // Higher variation = higher confidence\n        frequency: behaviors.length,\n        trend: 'stable',\n        dataPoints: behaviors.length,\n        firstDetected: new Date(Math.min(...behaviors.map(b => new Date(b.date).getTime()))),\n        lastUpdated: new Date(),\n        metrics: { maxVariation, winterAvg, summerAvg },\n        context: {\n          timeFrame: `${Object.keys(monthGroups).length} months`,\n          conditions: Object.entries(monthlyAverages).map(([month, avg]) =>\n            `${this.getMonthName(parseInt(month))}: ${this.minutesToTime(avg)}`\n          ),\n          correlations: [{ factor: 'daylight_hours', strength: 0.7 }],\n          anomalies: []\n        }\n      });\n    }\n\n    return patterns;\n  }\n\n  private static async detectLocationInfluencePatterns(userId: string, behaviors: WakeUpBehavior[]): Promise<DetectedPattern[]> {\n    const patterns: DetectedPattern[] = [];\n\n    try {\n      const locationPatterns = EnhancedLocationService.getLocationPatterns();\n      if (locationPatterns.length === 0) return patterns;\n\n      // Group behaviors by location (simplified - would need actual location data per behavior)\n      const homePattern = locationPatterns.find(p => p.type === 'home');\n      const workPattern = locationPatterns.find(p => p.type === 'work');\n\n      if (homePattern && workPattern) {\n        // Simulate location-based analysis\n        const homeBehaviors = behaviors.filter(b => new Date(b.date).getDay() === 0 || new Date(b.date).getDay() === 6);\n        const workBehaviors = behaviors.filter(b => new Date(b.date).getDay() >= 1 && new Date(b.date).getDay() <= 5);\n\n        if (homeBehaviors.length > 3 && workBehaviors.length > 3) {\n          const homeAvgWake = homeBehaviors.reduce((sum, b) => sum + this.timeToMinutes(b.actualWakeTime), 0) / homeBehaviors.length;\n          const workAvgWake = workBehaviors.reduce((sum, b) => sum + this.timeToMinutes(b.actualWakeTime), 0) / workBehaviors.length;\n\n          const timeDiff = Math.abs(homeAvgWake - workAvgWake);\n\n          if (timeDiff > 30) { // 30+ minute difference\n            patterns.push({\n              id: this.generatePatternId('location_influence'),\n              type: 'location_influence',\n              name: 'Location-Based Wake Times',\n              description: `Your wake times vary by ${timeDiff.toFixed(0)} minutes between home and work days`,\n              confidence: 0.8,\n              frequency: behaviors.length,\n              trend: 'stable',\n              dataPoints: behaviors.length,\n              firstDetected: new Date(Math.min(...behaviors.map(b => new Date(b.date).getTime()))),\n              lastUpdated: new Date(),\n              metrics: { homeAvgWake, workAvgWake, timeDiff },\n              context: {\n                timeFrame: `${behaviors.length} days`,\n                conditions: [\n                  `Home days: ${this.minutesToTime(homeAvgWake)}`,\n                  `Work days: ${this.minutesToTime(workAvgWake)}`\n                ],\n                correlations: [{ factor: 'location_type', strength: 0.8 }],\n                anomalies: []\n              }\n            });\n          }\n        }\n      }\n    } catch (error) {\n      console.error('Error detecting location influence patterns:', error);\n    }\n\n    return patterns;\n  }\n\n  private static async detectWeatherSensitivityPatterns(behaviors: WakeUpBehavior[]): Promise<DetectedPattern[]> {\n    const patterns: DetectedPattern[] = [];\n\n    // Simulate weather correlation analysis\n    const rainyDays = behaviors.filter(b => b.context?.weather?.includes('rain'));\n    const sunnyDays = behaviors.filter(b => b.context?.weather?.includes('sun'));\n\n    if (rainyDays.length > 3 && sunnyDays.length > 3) {\n      const rainyAvgWake = rainyDays.reduce((sum, b) => sum + this.timeToMinutes(b.actualWakeTime), 0) / rainyDays.length;\n      const sunnyAvgWake = sunnyDays.reduce((sum, b) => sum + this.timeToMinutes(b.actualWakeTime), 0) / sunnyDays.length;\n\n      const timeDiff = rainyAvgWake - sunnyAvgWake;\n\n      if (Math.abs(timeDiff) > 15) { // 15+ minute difference\n        patterns.push({\n          id: this.generatePatternId('weather_sensitivity'),\n          type: 'weather_sensitivity',\n          name: 'Weather-Sensitive Wake Times',\n          description: timeDiff > 0\n            ? `You wake ${Math.abs(timeDiff).toFixed(0)} minutes later on rainy days`\n            : `You wake ${Math.abs(timeDiff).toFixed(0)} minutes earlier on rainy days`,\n          confidence: 0.7,\n          frequency: rainyDays.length + sunnyDays.length,\n          trend: 'stable',\n          dataPoints: behaviors.length,\n          firstDetected: new Date(Math.min(...behaviors.map(b => new Date(b.date).getTime()))),\n          lastUpdated: new Date(),\n          metrics: { rainyAvgWake, sunnyAvgWake, timeDiff },\n          context: {\n            timeFrame: `${behaviors.length} days`,\n            conditions: [\n              `Rainy days: ${this.minutesToTime(rainyAvgWake)}`,\n              `Sunny days: ${this.minutesToTime(sunnyAvgWake)}`\n            ],\n            correlations: [{ factor: 'weather_condition', strength: 0.7 }],\n            anomalies: []\n          }\n        });\n      }\n    }\n\n    return patterns;\n  }\n\n  // Additional pattern detection methods would continue here...\n  private static async detectCalendarCorrelationPatterns(behaviors: WakeUpBehavior[]): Promise<DetectedPattern[]> {\n    // Implementation for calendar correlation patterns\n    return [];\n  }\n\n  private static async detectSleepQualityImpactPatterns(behaviors: WakeUpBehavior[]): Promise<DetectedPattern[]> {\n    // Implementation for sleep quality impact patterns\n    return [];\n  }\n\n  private static async detectEnergyLevelPatterns(behaviors: WakeUpBehavior[]): Promise<DetectedPattern[]> {\n    // Implementation for energy level patterns\n    return [];\n  }\n\n  private static async detectDifficultyOptimizationPatterns(behaviors: WakeUpBehavior[]): Promise<DetectedPattern[]> {\n    // Implementation for difficulty optimization patterns\n    return [];\n  }\n\n  private static async detectVoiceMoodPreferences(behaviors: WakeUpBehavior[]): Promise<DetectedPattern[]> {\n    // Implementation for voice mood preference patterns\n    return [];\n  }\n\n  // ===== PREDICTIVE INSIGHTS =====\n\n  static async generatePredictiveInsights(\n    userId: string,\n  ): Promise<PredictiveInsight[]> {\n    try {\n      const insights: PredictiveInsight[] = [];\n      const patterns = Array.from(this.detectedPatterns.values());\n\n      // Generate insights based on detected patterns\n      for (const pattern of patterns) {\n        const patternInsights = await this.generateInsightsFromPattern(userId, pattern, alarms);\n        insights.push(...patternInsights);\n      }\n\n      // Generate trend-based insights\n      const trendInsights = await this.generateTrendInsights(userId, alarms);\n      insights.push(...trendInsights);\n\n      // Generate optimization insights\n      const optimizationInsights = await this.generateOptimizationInsights(userId, alarms);\n      insights.push(...optimizationInsights);\n\n      // Filter and prioritize insights\n      const validInsights = insights\n        .filter(insight => insight.confidence > 0.5)\n        .sort((a, b) => this.calculateInsightPriority(b) - this.calculateInsightPriority(a))\n        .slice(0, 10); // Limit to top 10 insights\n\n      // Add to history\n      this.insightsHistory.push(...validInsights);\n\n      // Maintain history size\n      if (this.insightsHistory.length > this.config.maxInsightsHistory) {\n        this.insightsHistory = this.insightsHistory.slice(-this.config.maxInsightsHistory);\n      }\n\n      await this.saveInsightsHistory();\n      return validInsights;\n\n    } catch (error) {\n      console.error('Error generating predictive insights:', error);\n      return [];\n    }\n  }\n\n  private static async generateInsightsFromPattern(\n    userId: string,\n    pattern: DetectedPattern,\n  ): Promise<PredictiveInsight[]> {\n    const insights: PredictiveInsight[] = [];\n    const now = new Date();\n\n    switch (pattern.type) {\n      case 'wake_consistency':\n        if (pattern.confidence > 0.8 && pattern.trend === 'declining') {\n          insights.push({\n            id: this.generateInsightId(),\n            userId,\n            type: 'warning',\n            title: 'Wake Time Consistency Declining',\n            description: 'Your wake time consistency has decreased recently. This might affect your sleep quality and energy levels.',\n            confidence: pattern.confidence,\n            priority: 'medium',\n            category: 'sleep_health',\n            actionable: true,\n            suggestedActions: [\n              'Try to maintain the same bedtime every night',\n              'Consider using a smart alarm that wakes you during light sleep',\n              'Review your evening routine for consistency'\n            ],\n            impact: 'moderate',\n            timeframe: 'next_week',\n            data: { pattern: pattern.metrics },\n            createdAt: now\n          });\n        }\n        break;\n\n      case 'snooze_behavior':\n        if (pattern.metrics.avgSnoozeCount > 2) {\n          insights.push({\n            id: this.generateInsightId(),\n            userId,\n            type: 'optimization',\n            title: 'High Snooze Usage Detected',\n            description: `You average ${pattern.metrics.avgSnoozeCount.toFixed(1)} snoozes per alarm. This suggests your current wake time might not align with your natural sleep cycle.`,\n            confidence: pattern.confidence,\n            priority: 'high',\n            category: 'alarm_optimization',\n            actionable: true,\n            suggestedActions: [\n              'Try moving your bedtime 30 minutes earlier',\n              'Experiment with waking up 15 minutes earlier to align with sleep cycles',\n              'Consider increasing alarm difficulty to reduce snooze temptation'\n            ],\n            impact: 'significant',\n            timeframe: 'next_two_weeks',\n            data: { pattern: pattern.metrics },\n            createdAt: now\n          });\n        }\n        break;\n\n      case 'seasonal_adjustment':\n        const currentMonth = now.getMonth();\n        const isWinter = currentMonth >= 11 || currentMonth <= 1;\n        const isTransition = currentMonth === 2 || currentMonth === 3 || currentMonth === 8 || currentMonth === 9;\n\n        if (isTransition && pattern.metrics.maxVariation > 30) {\n          insights.push({\n            id: this.generateInsightId(),\n            userId,\n            type: 'recommendation',\n            title: 'Seasonal Adjustment Opportunity',\n            description: 'Based on your seasonal patterns, consider adjusting your alarm times for the changing season.',\n            confidence: pattern.confidence,\n            priority: 'medium',\n            category: 'seasonal_optimization',\n            actionable: true,\n            suggestedActions: [\n              isWinter ? 'Gradually shift wake time later for winter comfort' : 'Gradually shift wake time earlier for spring energy',\n              'Consider using light therapy in darker months',\n              'Adjust your evening routine for the new season'\n            ],\n            impact: 'moderate',\n            timeframe: 'next_month',\n            data: { pattern: pattern.metrics, currentSeason: isWinter ? 'winter' : 'spring' },\n            createdAt: now,\n            expiresAt: new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000) // Expires in 30 days\n          });\n        }\n        break;\n    }\n\n    return insights;\n  }\n\n  private static async generateTrendInsights(\n    userId: string,\n  ): Promise<PredictiveInsight[]> {\n    const insights: PredictiveInsight[] = [];\n    // Implementation for trend-based insights would go here\n    return insights;\n  }\n\n  private static async generateOptimizationInsights(\n    userId: string,\n  ): Promise<PredictiveInsight[]> {\n    const insights: PredictiveInsight[] = [];\n\n    // Analyze alarm frequency and distribution\n    const activeAlarms = alarms.filter(a => a.enabled);\n    if (activeAlarms.length > 5) {\n      insights.push({\n        id: this.generateInsightId(),\n        userId,\n        type: 'optimization',\n        title: 'Multiple Alarm Optimization',\n        description: `You have ${activeAlarms.length} active alarms. Consider consolidating similar alarms for better sleep consistency.`,\n        confidence: 0.8,\n        priority: 'medium',\n        category: 'alarm_management',\n        actionable: true,\n        suggestedActions: [\n          'Review alarms with similar times and merge if possible',\n          'Use advanced scheduling instead of multiple daily alarms',\n          'Consider using conditional alarms for varying schedules'\n        ],\n        impact: 'moderate',\n        timeframe: 'this_week',\n        data: { alarmCount: activeAlarms.length },\n        createdAt: new Date()\n      });\n    }\n\n    return insights;\n  }\n\n  // ===== UTILITY METHODS =====\n\n  private static calculateInsightPriority(insight: PredictiveInsight): number {\n    const priorityScores = { critical: 4, high: 3, medium: 2, low: 1 };\n    const impactScores = { major: 4, significant: 3, moderate: 2, minimal: 1 };\n\n    return (priorityScores[insight.priority] * 2) +\n           (impactScores[insight.impact] * 1.5) +\n           (insight.confidence * 2);\n  }\n\n  private static timeToMinutes(timeStr: string): number {\n    const [hours, minutes] = timeStr.split(':').map(Number);\n    return hours * 60 + minutes;\n  }\n\n  private static minutesToTime(minutes: number): string {\n    const hours = Math.floor(minutes / 60);\n    const mins = minutes % 60;\n    return `${hours.toString().padStart(2, '0')}:${mins.toString().padStart(2, '0')}`;\n  }\n\n  private static getDayName(dayOfWeek: number): string {\n    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n    return days[dayOfWeek];\n  }\n\n  private static getMonthName(month: number): string {\n    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n    return months[month];\n  }\n\n  private static calculateTrend(scores: Record<string, number>): DetectedPattern['trend'] {\n    const values = Object.values(scores);\n    if (values.length < 2) return 'stable';\n\n    const recent = values.slice(-3).reduce((sum, v) => sum + v, 0) / Math.min(3, values.length);\n    const older = values.slice(0, -3).reduce((sum, v) => sum + v, 0) / Math.max(1, values.length - 3);\n\n    const diff = recent - older;\n    if (Math.abs(diff) < 0.1) return 'stable';\n    return diff > 0 ? 'improving' : 'declining';\n  }\n\n  private static calculateSnoozeTrend(behaviors: WakeUpBehavior[]): DetectedPattern['trend'] {\n    if (behaviors.length < 14) return 'stable';\n\n    const recent = behaviors.slice(-7);\n    const older = behaviors.slice(-14, -7);\n\n    const recentAvgSnooze = recent.reduce((sum, b) => sum + b.snoozeCount, 0) / recent.length;\n    const olderAvgSnooze = older.reduce((sum, b) => sum + b.snoozeCount, 0) / older.length;\n\n    const diff = recentAvgSnooze - olderAvgSnooze;\n    if (Math.abs(diff) < 0.5) return 'stable';\n    return diff > 0 ? 'declining' : 'improving';\n  }\n\n  private static findConsistencyAnomalies(scores: Record<string, number>): string[] {\n    const anomalies: string[] = [];\n    const avgScore = Object.values(scores).reduce((sum, score) => sum + score, 0) / Object.values(scores).length;\n\n    for (const [day, score] of Object.entries(scores)) {\n      if (score < avgScore - 0.3) {\n        anomalies.push(`${this.getDayName(parseInt(day))} shows lower consistency`);\n      }\n    }\n\n    return anomalies;\n  }\n\n  private static findSnoozeCorrelations(behaviors: WakeUpBehavior[]): Array<{ factor: string; strength: number }> {\n    const correlations: Array<{ factor: string; strength: number }> = [];\n\n    // Analyze correlation with day of week\n    const weekdaySnoozes = behaviors.filter(b => {\n      const day = new Date(b.date).getDay();\n      return day >= 1 && day <= 5;\n    });\n    const weekendSnoozes = behaviors.filter(b => {\n      const day = new Date(b.date).getDay();\n      return day === 0 || day === 6;\n    });\n\n    if (weekdaySnoozes.length > 0 && weekendSnoozes.length > 0) {\n      const weekdayAvg = weekdaySnoozes.reduce((sum, b) => sum + b.snoozeCount, 0) / weekdaySnoozes.length;\n      const weekendAvg = weekendSnoozes.reduce((sum, b) => sum + b.snoozeCount, 0) / weekendSnoozes.length;\n\n      const correlation = Math.abs(weekdayAvg - weekendAvg) / Math.max(weekdayAvg, weekendAvg);\n      if (correlation > 0.3) {\n        correlations.push({ factor: 'day_of_week', strength: correlation });\n      }\n    }\n\n    return correlations;\n  }\n\n  private static calculateSeasonalAverage(monthlyAverages: Record<string, number>, months: number[]): number | null {\n    const seasonalTimes = months\n      .filter(month => monthlyAverages[month.toString()] !== undefined)\n      .map(month => monthlyAverages[month.toString()]);\n\n    if (seasonalTimes.length === 0) return null;\n    return seasonalTimes.reduce((sum, time) => sum + time, 0) / seasonalTimes.length;\n  }\n\n  private static generatePatternId(type: string): string {\n    return `pattern_${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private static generateInsightId(): string {\n    return `insight_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private static async runInitialAnalysis(): Promise<void> {\n    // Run initial pattern analysis if enough data is available\n    console.log('Running initial predictive analysis...');\n  }\n\n  private static async startAnalysisSchedule(): Promise<void> {\n    const intervals = {\n      daily: 24 * 60 * 60 * 1000,\n      weekly: 7 * 24 * 60 * 60 * 1000,\n      biweekly: 14 * 24 * 60 * 60 * 1000,\n      monthly: 30 * 24 * 60 * 60 * 1000\n    };\n\n    const interval = intervals[this.config.analysisFrequency];\n\n    this.analysisSchedule = setInterval(async () => {\n      try {\n        await this.runScheduledAnalysis();\n      } catch (error) {\n        console.error('Error in scheduled analysis:', error);\n      }\n    }, interval) as unknown as number;\n  }\n\n  private static async runScheduledAnalysis(): Promise<void> {\n    console.log('Running scheduled predictive analysis...');\n    this.lastAnalysisDate = new Date();\n    // Implementation for scheduled analysis\n  }\n\n  // ===== STORAGE METHODS =====\n\n  private static async saveDetectedPatterns(): Promise<void> {\n    try {\n      const dataObject = Object.fromEntries(this.detectedPatterns);\n      await Preferences.set({\n        key: PATTERNS_CACHE_KEY,\n        value: JSON.stringify(dataObject)\n      });\n    } catch (error) {\n      console.error('Error saving detected patterns:', error);\n    }\n  }\n\n  private static async saveInsightsHistory(): Promise<void> {\n    try {\n      await Preferences.set({\n        key: INSIGHTS_HISTORY_KEY,\n        value: JSON.stringify(this.insightsHistory)\n      });\n    } catch (error) {\n      console.error('Error saving insights history:', error);\n    }\n  }\n\n  // ===== PUBLIC API =====\n\n  static async enablePredictiveAnalytics(enabled: boolean): Promise<void> {\n    this.config.enabled = enabled;\n\n    if (enabled) {\n      await this.startAnalysisSchedule();\n    } else if (this.analysisSchedule) {\n      clearInterval(this.analysisSchedule);\n      this.analysisSchedule = null;\n    }\n\n    await Preferences.set({\n      key: ANALYTICS_CONFIG_KEY,\n      value: JSON.stringify(this.config)\n    });\n  }\n\n  static getDetectedPatterns(): DetectedPattern[] {\n    return Array.from(this.detectedPatterns.values());\n  }\n\n  static getInsightsHistory(): PredictiveInsight[] {\n    return [...this.insightsHistory];\n  }\n\n  static getRecentInsights(days: number = 7): PredictiveInsight[] {\n    const cutoff = new Date(Date.now() - days * 24 * 60 * 60 * 1000);\n    return this.insightsHistory.filter(insight => insight.createdAt >= cutoff);\n  }\n\n  static async markInsightApplied(insightId: string): Promise<void> {\n    const insight = this.insightsHistory.find(i => i.id === insightId);\n    if (insight) {\n      insight.applied = new Date();\n      await this.saveInsightsHistory();\n    }\n  }\n\n  static async provideFeedback(insightId: string, feedback: PredictiveInsight['feedback']): Promise<void> {\n    const insight = this.insightsHistory.find(i => i.id === insightId);\n    if (insight) {\n      insight.feedback = feedback;\n      await this.saveInsightsHistory();\n    }\n  }\n\n  static getAnalyticsStats(): {\n    patterns: number;\n    insights: number;\n    lastAnalysis: Date | null;\n    isEnabled: boolean;\n  } {\n    return {\n      patterns: this.detectedPatterns.size,\n      insights: this.insightsHistory.length,\n      lastAnalysis: this.lastAnalysisDate,\n      isEnabled: this.config.enabled\n    };\n  }\n\n  static isAnalyticsEnabled(): boolean {\n    return this.config.enabled;\n  }\n}\n\nexport default PredictiveAnalyticsService;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/premium.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'newTier' is not defined.",
        "line": 238,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 238,
        "endColumn": 37
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'currentTier' is not defined.",
        "line": 361,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 361,
        "endColumn": 40
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase } from \"./supabase\";\nimport type { User } from \"../types\";\nimport type { SubscriptionTier } from \"../types/premium\";\nimport { ErrorHandler } from \"./error-handler\";\n\nexport interface PremiumFeature {\n  id: string;\n  name: string;\n  description: string;\n  category: \"alarm\" | \"voice\" | \"analytics\" | \"customization\" | \"ai\";\n}\n\nexport interface SubscriptionPlan {\n  name: string;\n  description: string;\n  monthlyPrice: number;\n  yearlyPrice: number;\n  features: string[];\n  popular?: boolean;\n}\n\nexport class PremiumService {\n  private static instance: PremiumService;\n\n  private constructor() {}\n\n  static getInstance(): PremiumService {\n    if (!PremiumService.instance) {\n      PremiumService.instance = new PremiumService();\n    }\n    return PremiumService.instance;\n  }\n\n  // Premium features configuration\n  private premiumFeatures: PremiumFeature[] = [\n    // Nuclear Mode\n    {\n      id: 'nuclear_mode',\n      name: 'Nuclear Mode',\n      description: 'Extreme difficulty alarm challenges that are nearly impossible to ignore',\n      requiredTier: 'premium',\n      category: 'alarm'\n    },\n\n    // Custom Voices\n    {\n      id: 'custom_voices',\n      name: 'Custom Voice Library',\n      description: 'Access to premium AI-generated voices and celebrity-style voices',\n      requiredTier: 'premium',\n      category: 'voice'\n    },\n    {\n      id: 'voice_cloning',\n      name: 'Voice Cloning',\n      description: 'Clone your own voice or upload custom voice recordings',\n      requiredTier: 'ultimate',\n      category: 'voice'\n    },\n    {\n      id: 'extra_personalities',\n      name: 'Extra Personalities',\n      description: 'Access to 20+ additional alarm personalities and mood variations',\n      requiredTier: 'premium',\n      category: 'voice'\n    },\n\n    // Advanced Features\n    {\n      id: 'advanced_analytics',\n      name: 'Advanced Analytics',\n      description: 'Detailed sleep insights, performance tracking, and AI recommendations',\n      requiredTier: 'premium',\n      category: 'analytics'\n    },\n    {\n      id: 'unlimited_alarms',\n      name: 'Unlimited Alarms',\n      description: 'Create unlimited alarms (free users limited to 10)',\n      requiredTier: 'premium',\n      category: 'alarm'\n    },\n    {\n      id: 'smart_scheduling',\n      name: 'AI Smart Scheduling',\n      description: 'AI-powered optimal wake time suggestions based on sleep patterns',\n      requiredTier: 'premium',\n      category: 'ai'\n    },\n    {\n      id: 'theme_store',\n      name: 'Premium Themes',\n      description: 'Access to premium themes and unlimited customization options',\n      requiredTier: 'premium',\n      category: 'customization'\n    },\n    {\n      id: 'priority_support',\n      name: 'Priority Support',\n      description: '24/7 premium support with faster response times',\n      requiredTier: 'premium',\n      category: 'ai'\n    },\n\n    // Ultimate Features\n    {\n      id: 'white_label',\n      name: 'White Label',\n      description: 'Remove branding and customize the app for your organization',\n      requiredTier: 'ultimate',\n      category: 'customization'\n    },\n    {\n      id: 'api_access',\n      name: 'API Access',\n      description: 'Full API access for integrations and custom automations',\n      requiredTier: 'ultimate',\n      category: 'ai'\n    }\n  ];\n\n  // Subscription plans\n  private subscriptionPlans: SubscriptionPlan[] = [\n    {\n      tier: 'free',\n      name: 'Free',\n      description: 'Perfect for getting started with smart alarms',\n      monthlyPrice: 0,\n      yearlyPrice: 0,\n      features: [\n        'Up to 10 alarms',\n        'Basic voice moods',\n        'Standard themes',\n        'Basic analytics',\n        'Community support'\n      ]\n    },\n    {\n      tier: 'premium',\n      name: 'Premium',\n      description: 'Unlock advanced features and premium content',\n      monthlyPrice: 9.99,\n      yearlyPrice: 99.99,\n      popular: true,\n      features: [\n        'Nuclear Mode',\n        'Custom voice library',\n        'Extra personalities (20+)',\n        'Unlimited alarms',\n        'Advanced analytics',\n        'AI smart scheduling',\n        'Premium themes',\n        'Priority support',\n        'All free features'\n      ]\n    },\n    {\n      tier: 'ultimate',\n      name: 'Ultimate',\n      description: 'Complete access with advanced customization',\n      monthlyPrice: 19.99,\n      yearlyPrice: 199.99,\n      features: [\n        'Voice cloning',\n        'White label options',\n        'API access',\n        'Custom integrations',\n        'Dedicated support',\n        'All premium features'\n      ]\n    }\n  ];\n\n  /**\n   * Check if user has access to a specific feature\n   */\n  hasFeatureAccess(userTier: SubscriptionTier, featureId: string): boolean {\n    const feature = this.premiumFeatures.find((f) => f.id === featureId);\n    if (!feature) {\n      return true; // If feature doesn't exist in our premium list, it's free\n    }\n\n    return this.hasMinimumTier(userTier, feature.requiredTier);\n  }\n\n  /**\n   * Check if user has minimum required subscription tier\n   */\n  hasMinimumTier(\n    userTier: SubscriptionTier,\n    requiredTier: SubscriptionTier\n  ): boolean {\n    const tierHierarchy = {\n      free: 0,\n      premium: 1,\n      ultimate: 2,\n    };\n\n    return tierHierarchy[userTier] >= tierHierarchy[requiredTier];\n  }\n\n  /**\n   * Get user's current subscription tier\n   */\n  async getUserTier(userId: string): Promise<SubscriptionTier> {\n    try {\n      const { data, error } = await supabase\n        .from('users')\n        .select('subscription_tier')\n        .eq('id', userId)\n        .single();\n\n      if (error) {\n        ErrorHandler.handleError(error, 'Failed to get user subscription tier');\n        return 'free'; // Default to free on error\n      }\n\n      return data?.subscription_tier || 'free';\n    } catch (error) {\n      ErrorHandler.handleError(\n        error instanceof Error ? error : new Error(String(error)),\n        'Error checking user subscription tier'\n      );\n      return 'free';\n    }\n  }\n\n  /**\n   * Update user's subscription tier\n   */\n  async updateUserTier(\n    userId: string,\n  ): Promise<boolean> {\n    try {\n      const { error } = await supabase\n        .from('users')\n        .update({\n          subscription_tier: newTier,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', userId);\n\n      if (error) {\n        ErrorHandler.handleError(error, 'Failed to update user subscription tier');\n        return false;\n      }\n\n      return true;\n    } catch (error) {\n      ErrorHandler.handleError(\n        error instanceof Error ? error : new Error(String(error)),\n        'Error updating user subscription tier'\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Get available features for a subscription tier\n   */\n  getAvailableFeatures(tier: SubscriptionTier): PremiumFeature[] {\n    return this.premiumFeatures.filter((feature) =>\n      this.hasMinimumTier(tier, feature.requiredTier),\n    );\n  }\n\n  /**\n   * Get locked features for a subscription tier\n   */\n  getLockedFeatures(tier: SubscriptionTier): PremiumFeature[] {\n    return this.premiumFeatures.filter(\n      (feature) => !this.hasMinimumTier(tier, feature.requiredTier),\n    );\n  }\n\n  /**\n   * Get all subscription plans\n   */\n  getSubscriptionPlans(): SubscriptionPlan[] {\n    return this.subscriptionPlans;\n  }\n\n  /**\n   * Get specific subscription plan\n   */\n  getSubscriptionPlan(tier: SubscriptionTier): SubscriptionPlan | undefined {\n    return this.subscriptionPlans.find((plan) => plan.tier === tier);\n  }\n\n  /**\n   * Check if user can perform action (with limit checking)\n   */\n  async canPerformAction(\n    userId: string,\n    action: \"create_alarm\" | \"use_voice\" | \"access_analytics\",\n  ): Promise<{\n    allowed: boolean;\n    reason?: string;\n  }> {\n    const userTier = await this.getUserTier(userId);\n\n    switch (action) {\n      case 'create_alarm': {\n        if (userTier === 'free') {\n          // Check alarm count for free users\n          const { data, error } = await supabase\n            .from('alarms')\n            .select('id')\n            .eq('user_id', userId);\n\n          if (error) {\n            return { allowed: false, reason: 'Error checking alarm count' };\n          }\n\n          if (data && data.length >= 10) {\n            return {\n              allowed: false,\n              reason: 'Free users are limited to 10 alarms',\n              upgradeRequired: 'premium'\n            };\n          }\n        }\n        return { allowed: true };\n      }\n\n      case 'use_voice': {\n        // All tiers can use basic voices, premium checks are per-voice\n        return { allowed: true };\n      }\n\n      case 'access_analytics': {\n        if (userTier === 'free') {\n          return {\n            allowed: false,\n            reason: 'Advanced analytics require Premium subscription',\n            upgradeRequired: 'premium'\n          };\n        }\n        return { allowed: true };\n      }\n\n      default:\n        return { allowed: true };\n    }\n  }\n\n  /**\n   * Generate upgrade URL for payment processing\n   */\n  generateUpgradeUrl(\n    userId: string,\n    targetTier: SubscriptionTier\n  ): string {\n    // In a real app, this would integrate with Stripe, Paddle, or similar\n    const plan = this.getSubscriptionPlan(targetTier);\n    if (!plan) {\n      return '/pricing';\n    }\n\n    // For demo purposes, return a mock URL\n    return `/upgrade?from=${currentTier}&to=${targetTier}&user=${userId}&price=${plan.monthlyPrice}`;\n  }\n\n  /**\n   * Check feature access and return upgrade info if needed\n   */\n  async checkFeatureAccess(userId: string, featureId: string): Promise<{\n    hasAccess: boolean;\n    upgradeUrl?: string;\n    feature?: PremiumFeature;\n  }> {\n    const userTier = await this.getUserTier(userId);\n    const hasAccess = this.hasFeatureAccess(userTier, featureId);\n    const feature = this.premiumFeatures.find(f => f.id === featureId);\n\n    if (!hasAccess && feature) {\n      return {\n        hasAccess: false,\n        upgradeUrl: this.generateUpgradeUrl(userId, feature.requiredTier),\n        feature\n      };\n    }\n\n    return {\n      hasAccess: true,\n      feature\n    };\n  }\n\n  /**\n   * Get user's subscription status and limits\n   */\n  async getSubscriptionStatus(userId: string): Promise<{\n    tier: SubscriptionTier;\n    plan: PremiumFeature;\n    limits: {\n      alarmCount: { current: number; max: number | null };\n      voicesAccess: { basic: boolean; premium: boolean; ultimate: boolean };\n      featuresUnlocked: string[];\n      featuresLocked: string[];\n    };\n  }> {\n    const tier = await this.getUserTier(userId);\n    const plan = this.getSubscriptionPlan(tier)!;\n\n    // Get current alarm count\n    const { data: alarms } = await supabase\n      .from('alarms')\n      .select('id')\n      .eq('user_id', userId);\n\n    const alarmCount = alarms?.length || 0;\n    const maxAlarms = tier === 'free' ? 10 : null; // null means unlimited\n\n    const unlockedFeatures = this.getFeaturesForTier(tier);\n    const lockedFeatures = this.getLockedFeatures(tier);\n\n    return {\n      tier,\n      plan,\n      limits: {\n        alarmCount: {\n          current: alarmCount,\n          max: maxAlarms\n        },\n        voicesAccess: {\n          basic: true,\n          premium: this.hasMinimumTier(tier, 'premium'),\n          ultimate: this.hasMinimumTier(tier, 'ultimate')\n        },\n        featuresUnlocked: unlockedFeatures.map(f => f.id),\n        featuresLocked: lockedFeatures.map(f => f.id)\n      }\n    };\n  }\n}\n\nexport const premiumService = PremiumService.getInstance();",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/pwa-manager.ts",
    "messages": [
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\-.",
        "line": 374,
        "column": 17,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 374,
        "endColumn": 18,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [10866, 10867], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [10866, 10866], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "interface BeforeInstallPromptEvent extends Event {\n  prompt(): Promise<void>;\n  userChoice: Promise<{ outcome: 'accepted' | 'dismissed' }>;\n}\n\ninterface PWAInstallationState {\n  isInstallable: boolean;\n  isInstalled: boolean;\n  installPrompt: BeforeInstallPromptEvent | null;\n  hasShownPrompt: boolean;\n}\n\ninterface PWACapabilities {\n  serviceWorker: boolean;\n  pushNotifications: boolean;\n  backgroundSync: boolean;\n  offlineStorage: boolean;\n  installPrompt: boolean;\n  standalone: boolean;\n}\n\nexport class PWAManager {\n  private static instance: PWAManager;\n  private state: PWAInstallationState = {\n    isInstallable: false,\n    isInstalled: false,\n    installPrompt: null,\n    hasShownPrompt: false,\n  };\n\n  private capabilities: PWACapabilities = {\n    serviceWorker: false,\n    pushNotifications: false,\n    backgroundSync: false,\n    offlineStorage: false,\n    installPrompt: false,\n    standalone: false,\n  };\n\n  private eventListeners: Map<string, Function[]> = new Map();\n  private serviceWorkerRegistration: ServiceWorkerRegistration | null = null;\n\n  constructor() {\n    this.initializePWA();\n  }\n\n  static getInstance(): PWAManager {\n    if (!PWAManager.instance) {\n      PWAManager.instance = new PWAManager();\n    }\n    return PWAManager.instance;\n  }\n\n  // Initialize PWA features\n  private async initializePWA() {\n    console.log('[PWA] Initializing PWA Manager');\n\n    // Check capabilities\n    await this.checkCapabilities();\n\n    // Register service worker\n    await this.registerServiceWorker();\n\n    // Setup install prompt\n    this.setupInstallPrompt();\n\n    // Check if already installed\n    this.checkInstallationStatus();\n\n    // Setup message handling\n    this.setupServiceWorkerMessaging();\n\n    console.log('[PWA] PWA Manager initialized', {\n      capabilities: this.capabilities,\n      state: this.state,\n    });\n  }\n\n  // Check PWA capabilities\n  private async checkCapabilities() {\n    this.capabilities = {\n      serviceWorker: 'serviceWorker' in navigator,\n      pushNotifications: 'PushManager' in window && 'Notification' in window,\n      backgroundSync: 'serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype,\n      offlineStorage: 'localStorage' in window && 'indexedDB' in window,\n      installPrompt: 'BeforeInstallPromptEvent' in window ||\n                    navigator.userAgent.includes('Chrome') ||\n                    navigator.userAgent.includes('Edge'),\n      standalone: window.matchMedia('(display-mode: standalone)').matches ||\n                 window.matchMedia('(display-mode: fullscreen)').matches ||\n                 (window.navigator as any).standalone === true,\n    };\n  }\n\n  // Register service worker\n  private async registerServiceWorker() {\n    if (!this.capabilities.serviceWorker) {\n      console.warn('[PWA] Service Worker not supported');\n      return;\n    }\n\n    try {\n      const registration = await navigator.serviceWorker.register('/sw-mobile-enhanced.js', {\n        scope: '/',\n        updateViaCache: 'none', // Always check for updates\n      });\n\n      this.serviceWorkerRegistration = registration;\n\n      // Handle updates\n      registration.addEventListener('updatefound', () => {\n        const newWorker = registration.installing;\n        if (newWorker) {\n          newWorker.addEventListener('statechange', () => {\n            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n              this.emit('sw-update-available', { registration });\n            }\n          });\n        }\n      });\n\n      // Check for existing update\n      if (registration.waiting) {\n        this.emit('sw-update-available', { registration });\n      }\n\n      console.log('[PWA] Service Worker registered successfully');\n      this.emit('sw-registered', { registration });\n\n    } catch (error) {\n      console.error('[PWA] Service Worker registration failed:', error);\n      this.emit('sw-registration-failed', { error });\n    }\n  }\n\n  // Setup install prompt handling\n  private setupInstallPrompt() {\n    window.addEventListener('beforeinstallprompt', (event) => {\n      console.log('[PWA] Install prompt available');\n      event.preventDefault();\n\n      this.state.isInstallable = true;\n      this.state.installPrompt = event as BeforeInstallPromptEvent;\n\n      this.emit('installable', { prompt: this.state.installPrompt });\n    });\n\n    window.addEventListener('appinstalled', () => {\n      console.log('[PWA] App installed');\n      this.state.isInstalled = true;\n      this.state.isInstallable = false;\n      this.state.installPrompt = null;\n\n      this.emit('installed');\n    });\n  }\n\n  // Check if app is already installed\n  private checkInstallationStatus() {\n    this.state.isInstalled = this.capabilities.standalone;\n\n    if (this.state.isInstalled) {\n      console.log('[PWA] App is running as installed PWA');\n      this.emit('already-installed');\n    }\n  }\n\n  // Setup service worker messaging\n  private setupServiceWorkerMessaging() {\n    if (!this.capabilities.serviceWorker) return;\n\n    navigator.serviceWorker.addEventListener('message', (event) => {\n      const { type, data } = event.data;\n\n      switch (type) {\n        case 'SYNC_COMPLETE':\n          this.emit('sync-complete', data);\n          break;\n        case 'ALARM_TRIGGERED':\n          this.emit('alarm-triggered', data);\n          break;\n        case 'ALARM_DISMISSED':\n          this.emit('alarm-dismissed', data);\n          break;\n        case 'ALARM_SNOOZED':\n          this.emit('alarm-snoozed', data);\n          break;\n        case 'NETWORK_STATUS':\n          this.emit('network-status', data);\n          break;\n        default:\n          console.log('[PWA] Unknown SW message:', type, data);\n      }\n    });\n  }\n\n  // Public API Methods\n\n  // Show install prompt\n  async showInstallPrompt(): Promise<boolean> {\n    if (!this.state.isInstallable || !this.state.installPrompt) {\n      console.warn('[PWA] Install prompt not available');\n      return false;\n    }\n\n    try {\n      await this.state.installPrompt.prompt();\n      const choiceResult = await this.state.installPrompt.userChoice;\n\n      this.state.hasShownPrompt = true;\n\n      if (choiceResult.outcome === 'accepted') {\n        console.log('[PWA] User accepted install prompt');\n        this.emit('install-accepted');\n        return true;\n      } else {\n        console.log('[PWA] User dismissed install prompt');\n        this.emit('install-dismissed');\n        return false;\n      }\n    } catch (error) {\n      console.error('[PWA] Install prompt failed:', error);\n      this.emit('install-error', { error });\n      return false;\n    }\n  }\n\n  // Check if install prompt should be shown\n  shouldShowInstallPrompt(): boolean {\n    return this.state.isInstallable &&\n           !this.state.hasShownPrompt &&\n           !this.state.isInstalled;\n  }\n\n  // Force service worker update\n  async updateServiceWorker(): Promise<void> {\n    if (!this.serviceWorkerRegistration) {\n      throw new Error('Service Worker not registered');\n    }\n\n    try {\n      await this.serviceWorkerRegistration.update();\n\n      if (this.serviceWorkerRegistration.waiting) {\n        // Tell the waiting service worker to skip waiting\n        this.serviceWorkerRegistration.waiting.postMessage({ type: 'SKIP_WAITING' });\n        window.location.reload();\n      }\n    } catch (error) {\n      console.error('[PWA] Service Worker update failed:', error);\n      throw error;\n    }\n  }\n\n  // Request push notification permission\n  async requestNotificationPermission(): Promise<NotificationPermission> {\n    if (!this.capabilities.pushNotifications) {\n      throw new Error('Push notifications not supported');\n    }\n\n    try {\n      const permission = await Notification.requestPermission();\n      this.emit('notification-permission-changed', { permission });\n      return permission;\n    } catch (error) {\n      console.error('[PWA] Notification permission request failed:', error);\n      throw error;\n    }\n  }\n\n  // Subscribe to push notifications\n  async subscribeToPushNotifications(): Promise<PushSubscription | null> {\n    if (!this.serviceWorkerRegistration || !this.capabilities.pushNotifications) {\n      throw new Error('Push notifications not available');\n    }\n\n    if (Notification.permission !== 'granted') {\n      const permission = await this.requestNotificationPermission();\n      if (permission !== 'granted') {\n        return null;\n      }\n    }\n\n    try {\n      const subscription = await this.serviceWorkerRegistration.pushManager.subscribe({\n        userVisibleOnly: true,\n        applicationServerKey: this.urlBase64ToUint8Array(\n          process.env.VITE_VAPID_PUBLIC_KEY || ''\n        ),\n      });\n\n      this.emit('push-subscribed', { subscription });\n      return subscription;\n    } catch (error) {\n      console.error('[PWA] Push subscription failed:', error);\n      throw error;\n    }\n  }\n\n  // Get current push subscription\n  async getPushSubscription(): Promise<PushSubscription | null> {\n    if (!this.serviceWorkerRegistration) {\n      return null;\n    }\n\n    try {\n      return await this.serviceWorkerRegistration.pushManager.getSubscription();\n    } catch (error) {\n      console.error('[PWA] Failed to get push subscription:', error);\n      return null;\n    }\n  }\n\n  // Check if app is offline\n  isOffline(): boolean {\n    return !navigator.onLine;\n  }\n\n  // Get PWA capabilities\n  getCapabilities(): PWACapabilities {\n    return { ...this.capabilities };\n  }\n\n  // Get PWA state\n  getState(): PWAInstallationState {\n    return { ...this.state };\n  }\n\n  // Send message to service worker\n  sendMessageToSW(message: any): void {\n    if (!this.capabilities.serviceWorker || !navigator.serviceWorker.controller) {\n      console.warn('[PWA] Cannot send message: Service Worker not available');\n      return;\n    }\n\n    navigator.serviceWorker.controller.postMessage(message);\n  }\n\n  // Event handling\n  on(event: string, callback: Function): void {\n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, []);\n    }\n    this.eventListeners.get(event)!.push(callback);\n  }\n\n  off(event: string, callback: Function): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      const index = listeners.indexOf(callback);\n      if (index > -1) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n\n  private emit(event: string, data?: any): void {\n    const listeners = this.eventListeners.get(event);\n    if (listeners) {\n      listeners.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`[PWA] Event listener error for ${event}:`, error);\n        }\n      });\n    }\n  }\n\n  // Utility functions\n  private urlBase64ToUint8Array(base64String: string): Uint8Array {\n    const padding = '='.repeat((4 - base64String.length % 4) % 4);\n    const base64 = (base64String + padding)\n      .replace(/\\-/g, '+')\n      .replace(/_/g, '/');\n\n    const rawData = window.atob(base64);\n    const outputArray = new Uint8Array(rawData.length);\n\n    for (let i = 0; i < rawData.length; ++i) {\n      outputArray[i] = rawData.charCodeAt(i);\n    }\n    return outputArray;\n  }\n\n  // Cleanup\n  destroy(): void {\n    this.eventListeners.clear();\n    this.serviceWorkerRegistration = null;\n  }\n}\n\n// Create singleton instance\nexport const pwaManager = PWAManager.getInstance();",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/security.ts",
    "messages": [
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\[.",
        "line": 332,
        "column": 32,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 332,
        "endColumn": 33,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [9155, 9156], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [9155, 9155], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      },
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\?.",
        "line": 332,
        "column": 49,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 332,
        "endColumn": 50,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [9172, 9173], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [9172, 9172], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Security Service for Smart Alarm App\n// Provides encryption, decryption, and security utilities\n\nimport CryptoJS from 'crypto-js';\nimport DOMPurify from 'dompurify';\nimport zxcvbn from 'zxcvbn';\n\nexport interface PasswordStrength {\n  score: number; // 0-4, where 4 is strongest\n  feedback: {\n    warning: string;\n    suggestions: string[];\n  };\n  crack_times_display: {\n    offline_slow_hashing_1e4_per_second: string;\n    offline_fast_hashing_1e10_per_second: string;\n    online_no_throttling_10_per_second: string;\n    online_throttling_100_per_hour: string;\n  };\n}\n\nclass SecurityService {\n  private static instance: SecurityService;\n  private encryptionKey: string | null = null;\n  private readonly STORAGE_PREFIX = 'saa_'; // Smart Alarm App prefix\n  private readonly KEY_ITERATIONS = 10000; // PBKDF2 iterations\n  private readonly SALT_LENGTH = 16; // bytes\n  private readonly IV_LENGTH = 16; // bytes\n\n  private constructor() {\n    this.initializeEncryptionKey();\n  }\n\n  static getInstance(): SecurityService {\n    if (!SecurityService.instance) {\n      SecurityService.instance = new SecurityService();\n    }\n    return SecurityService.instance;\n  }\n\n  /**\n   * Initialize encryption key from user session or generate new one\n   */\n  private initializeEncryptionKey(): void {\n    // In a real app, this key would be derived from user authentication\n    // For now, we'll use a device-specific key stored securely\n    let deviceKey = localStorage.getItem(`${this.STORAGE_PREFIX}device_key`);\n\n    if (!deviceKey) {\n      // Generate a new device-specific key\n      deviceKey = CryptoJS.lib.WordArray.random(256/8).toString();\n      localStorage.setItem(`${this.STORAGE_PREFIX}device_key`, deviceKey);\n    }\n\n    this.encryptionKey = deviceKey;\n  }\n\n  /**\n   * Generate a cryptographically secure random salt\n   */\n  private generateSalt(): string {\n    return CryptoJS.lib.WordArray.random(this.SALT_LENGTH).toString();\n  }\n\n  /**\n   * Generate a cryptographically secure random IV\n   */\n  private generateIV(): string {\n    return CryptoJS.lib.WordArray.random(this.IV_LENGTH).toString();\n  }\n\n  /**\n   * Derive encryption key from password using PBKDF2\n   */\n  private deriveKey(password: string, salt: string): string {\n    return CryptoJS.PBKDF2(password, salt, {\n      keySize: 256/32,\n      iterations: this.KEY_ITERATIONS,\n      hasher: CryptoJS.algo.SHA256\n    }).toString();\n  }\n\n  /**\n   * Encrypt sensitive data before storage\n   */\n  encryptData(data: any): string {\n    try {\n      if (!this.encryptionKey) {\n        throw new Error('Encryption key not initialized');\n      }\n\n      const dataString = JSON.stringify(data);\n      const salt = this.generateSalt();\n      const iv = this.generateIV();\n\n      const key = this.deriveKey(this.encryptionKey, salt);\n\n      const encrypted = CryptoJS.AES.encrypt(dataString, key, {\n        iv: CryptoJS.enc.Hex.parse(iv),\n        mode: CryptoJS.mode.CBC,\n        padding: CryptoJS.pad.Pkcs7\n      });\n\n      // Combine salt + iv + encrypted data\n      const result = {\n        salt,\n        iv,\n        data: encrypted.toString(),\n        timestamp: new Date().toISOString()\n      };\n\n      return btoa(JSON.stringify(result)); // Base64 encode the result\n    } catch (error) {\n      console.error('[SecurityService] Encryption failed:', error);\n      throw new Error('Data encryption failed');\n    }\n  }\n\n  /**\n   * Decrypt sensitive data after retrieval\n   */\n  decryptData(encryptedData: string): any {\n    try {\n      if (!this.encryptionKey) {\n        throw new Error('Encryption key not initialized');\n      }\n\n      const decoded = JSON.parse(atob(encryptedData));\n      const { salt, iv, data } = decoded;\n\n      const key = this.deriveKey(this.encryptionKey, salt);\n\n      const decrypted = CryptoJS.AES.decrypt(data, key, {\n        iv: CryptoJS.enc.Hex.parse(iv),\n        mode: CryptoJS.mode.CBC,\n        padding: CryptoJS.pad.Pkcs7\n      });\n\n      const decryptedString = decrypted.toString(CryptoJS.enc.Utf8);\n\n      if (!decryptedString) {\n        throw new Error('Decryption failed - invalid data or key');\n      }\n\n      return JSON.parse(decryptedString);\n    } catch (error) {\n      console.error('[SecurityService] Decryption failed:', error);\n      throw new Error('Data decryption failed');\n    }\n  }\n\n  /**\n   * Securely store encrypted data in localStorage\n   */\n  secureStorageSet(key: string, data: any): void {\n    try {\n      const encrypted = this.encryptData(data);\n      localStorage.setItem(`${this.STORAGE_PREFIX}${key}`, encrypted);\n    } catch (error) {\n      console.error('[SecurityService] Secure storage set failed:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Securely retrieve and decrypt data from localStorage\n   */\n  secureStorageGet(key: string): any {\n    try {\n      const encrypted = localStorage.getItem(`${this.STORAGE_PREFIX}${key}`);\n      if (!encrypted) {\n        return null;\n      }\n      return this.decryptData(encrypted);\n    } catch (error) {\n      console.error('[SecurityService] Secure storage get failed:', error);\n      // Return null instead of throwing to handle corrupted data gracefully\n      return null;\n    }\n  }\n\n  /**\n   * Securely remove data from localStorage\n   */\n  secureStorageRemove(key: string): void {\n    localStorage.removeItem(`${this.STORAGE_PREFIX}${key}`);\n  }\n\n  /**\n   * Clear all secure storage data\n   */\n  clearSecureStorage(): void {\n    const keys = Object.keys(localStorage);\n    keys.forEach(key => {\n      if (key.startsWith(this.STORAGE_PREFIX)) {\n        localStorage.removeItem(key);\n      }\n    });\n  }\n\n  /**\n   * Sanitize HTML input to prevent XSS attacks\n   */\n  sanitizeHtml(input: string): string {\n    if (typeof input !== 'string') {\n      return '';\n    }\n\n    return DOMPurify.sanitize(input, {\n      ALLOWED_TAGS: [], // No HTML tags allowed\n      ALLOWED_ATTR: [],\n      KEEP_CONTENT: true, // Keep text content, remove tags\n      SANITIZE_NAMED_PROPS: true,\n      SANITIZE_DOM: true\n    });\n  }\n\n  /**\n   * Advanced input sanitization with custom rules\n   */\n  sanitizeInput(input: string, options?: {\n    allowBasicFormatting?: boolean;\n    maxLength?: number;\n    stripEmoji?: boolean;\n  }): string {\n    if (typeof input !== 'string') {\n      return '';\n    }\n\n    const opts = {\n      allowBasicFormatting: false,\n      maxLength: 1000,\n      stripEmoji: false,\n      ...options\n    };\n\n    let sanitized = input.trim();\n\n    // Remove potentially dangerous patterns\n    sanitized = sanitized.replace(/javascript:/gi, '');\n    sanitized = sanitized.replace(/vbscript:/gi, '');\n    sanitized = sanitized.replace(/data:text\\/html/gi, '');\n    sanitized = sanitized.replace(/on\\w+\\s*=/gi, '');\n\n    // Use DOMPurify for HTML sanitization\n    if (opts.allowBasicFormatting) {\n      sanitized = DOMPurify.sanitize(sanitized, {\n        ALLOWED_TAGS: ['b', 'i', 'em', 'strong'],\n        ALLOWED_ATTR: [],\n        KEEP_CONTENT: true\n      });\n    } else {\n      sanitized = DOMPurify.sanitize(sanitized, {\n        ALLOWED_TAGS: [],\n        ALLOWED_ATTR: [],\n        KEEP_CONTENT: true\n      });\n    }\n\n    // Remove emoji if requested\n    if (opts.stripEmoji) {\n      sanitized = sanitized.replace(/[\\u{1F600}-\\u{1F64F}]|[\\u{1F300}-\\u{1F5FF}]|[\\u{1F680}-\\u{1F6FF}]|[\\u{2600}-\\u{26FF}]|[\\u{2700}-\\u{27BF}]/gu, '');\n    }\n\n    // Normalize whitespace\n    sanitized = sanitized.replace(/\\s+/g, ' ').trim();\n\n    // Limit length\n    if (sanitized.length > opts.maxLength) {\n      sanitized = sanitized.substring(0, opts.maxLength).trim();\n    }\n\n    return sanitized;\n  }\n\n  /**\n   * Check password strength using zxcvbn\n   */\n  checkPasswordStrength(password: string): PasswordStrength {\n    if (!password || typeof password !== 'string') {\n      return {\n        score: 0,\n        feedback: {\n          warning: 'Password is required',\n          suggestions: ['Enter a password']\n        },\n        crack_times_display: {\n          offline_slow_hashing_1e4_per_second: 'instantly',\n          offline_fast_hashing_1e10_per_second: 'instantly',\n          online_no_throttling_10_per_second: 'instantly',\n          online_throttling_100_per_hour: 'instantly'\n        }\n      };\n    }\n\n    const result = zxcvbn(password);\n    return {\n      score: result.score,\n      feedback: result.feedback,\n      crack_times_display: result.crack_times_display\n    };\n  }\n\n  /**\n   * Validate password against security requirements\n   */\n  validatePasswordSecurity(password: string): {\n    isValid: boolean;\n    errors: string[];\n    strength: PasswordStrength\n  } {\n    const errors: string[] = [];\n    const strength = this.checkPasswordStrength(password);\n\n    // Basic requirements\n    if (!password || password.length < 12) {\n      errors.push('Password must be at least 12 characters long');\n    }\n\n    if (!/(?=.*[a-z])/.test(password)) {\n      errors.push('Password must contain at least one lowercase letter');\n    }\n\n    if (!/(?=.*[A-Z])/.test(password)) {\n      errors.push('Password must contain at least one uppercase letter');\n    }\n\n    if (!/(?=.*\\d)/.test(password)) {\n      errors.push('Password must contain at least one number');\n    }\n\n    if (!/(?=.*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\?])/.test(password)) {\n      errors.push('Password must contain at least one special character');\n    }\n\n    // Check for common patterns\n    if (/(.)\\1{2,}/.test(password)) {\n      errors.push('Password should not contain repeated characters');\n    }\n\n    // zxcvbn strength check\n    if (strength.score < 3) {\n      errors.push(`Password is too weak. ${strength.feedback.warning}`);\n      errors.push(...strength.feedback.suggestions);\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      strength\n    };\n  }\n\n  /**\n   * Generate secure random password\n   */\n  generateSecurePassword(length = 16): string {\n    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()_+-=[]{}|;:,.<>?';\n    const array = new Uint8Array(length);\n    crypto.getRandomValues(array);\n\n    let password = '';\n    for (let i = 0; i < length; i++) {\n      password += charset[array[i] % charset.length];\n    }\n\n    return password;\n  }\n\n  /**\n   * Hash data using SHA-256\n   */\n  hashData(data: string): string {\n    return CryptoJS.SHA256(data).toString();\n  }\n\n  /**\n   * Generate CSRF token\n   */\n  generateCSRFToken(): string {\n    return CryptoJS.lib.WordArray.random(256/8).toString();\n  }\n\n  /**\n   * Validate CSRF token\n   */\n  validateCSRFToken(token: string, expectedToken: string): boolean {\n    if (!token || !expectedToken) {\n      return false;\n    }\n    // Use constant-time comparison to prevent timing attacks\n    return CryptoJS.enc.Hex.stringify(CryptoJS.SHA256(token)) ===\n           CryptoJS.enc.Hex.stringify(CryptoJS.SHA256(expectedToken));\n  }\n\n  /**\n   * Check if data has been tampered with using HMAC\n   */\n  generateDataSignature(data: any): string {\n    if (!this.encryptionKey) {\n      throw new Error('Encryption key not initialized');\n    }\n\n    const dataString = JSON.stringify(data);\n    return CryptoJS.HmacSHA256(dataString, this.encryptionKey).toString();\n  }\n\n  /**\n   * Verify data signature\n   */\n  verifyDataSignature(data: any, signature: string): boolean {\n    try {\n      const expectedSignature = this.generateDataSignature(data);\n      return signature === expectedSignature;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Rate limiting helper (client-side)\n   */\n  checkRateLimit(action: string, maxAttempts: number, windowMs: number): boolean {\n    const key = `rate_limit_${action}`;\n    const now = Date.now();\n\n    let attempts = this.secureStorageGet(key) || [];\n\n    // Remove old attempts outside the window\n    attempts = attempts.filter((timestamp: number) => now - timestamp < windowMs);\n\n    if (attempts.length >= maxAttempts) {\n      return false; // Rate limit exceeded\n    }\n\n    // Add current attempt\n    attempts.push(now);\n    this.secureStorageSet(key, attempts);\n\n    return true; // Within rate limit\n  }\n\n  /**\n   * Clear rate limit data for an action\n   */\n  clearRateLimit(action: string): void {\n    const key = `rate_limit_${action}`;\n    this.secureStorageRemove(key);\n  }\n}\n\nexport default SecurityService.getInstance();",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/smart-notification-service.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'alarmOrNotification' is not defined.",
        "line": 155,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 155,
        "endColumn": 52
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'alarmOrNotification' is not defined.",
        "line": 156,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 156,
        "endColumn": 50
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'alarmOrNotification' is not defined.",
        "line": 163,
        "column": 19,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 163,
        "endColumn": 38
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'alarmOrNotification' is not defined.",
        "line": 163,
        "column": 46,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 163,
        "endColumn": 65
      }
    ],
    "suppressedMessages": [],
    "errorCount": 4,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference lib=\"dom\" />\nimport { Capacitor } from \"@capacitor/core\";\nimport {\n  LocalNotifications,\n  ScheduleOptions,\n  DeliveredNotifications,\n} from \"@capacitor/local-notifications\";\n\n/**\n * Smart Notification System with Adaptive Timing\n *\n * Features:\n * - Adaptive notification timing based on user behavior\n * - Context-aware notifications (Do Not Disturb integration)\n * - Progressive notification escalation\n * - Battery-optimized scheduling\n * - Sleep schedule integration\n * - Location-based notification adjustments\n */\n\nexport interface NotificationContext {\n  userActivity: 'active' | 'idle' | 'sleeping' | 'driving' | 'meeting';\n  batteryLevel: number;\n  isCharging: boolean;\n  doNotDisturb: boolean;\n  location?: {\n    isHome: boolean;\n    isWork: boolean;\n    isMoving: boolean;\n  };\n  timeOfDay: 'morning' | 'afternoon' | 'evening' | 'night';\n  connectivity: 'online' | 'offline';\n}\n\nexport interface SmartNotificationConfig {\n  adaptiveEnabled: boolean;\n  respectDoNotDisturb: boolean;\n  batteryOptimization: boolean;\n  locationAware: boolean;\n  progressiveEscalation: boolean;\n  sleepScheduleIntegration: boolean;\n  maxNotificationsPerHour: number;\n  quietHoursStart: string; // HH:mm\n  quietHoursEnd: string; // HH:mm\n  emergencyOverride: boolean;\n  vibrationPatterns: {\n    gentle: number[];\n    normal: number[];\n    urgent: number[];\n  };\n  soundProfiles: {\n    morning: string;\n    work: string;\n    evening: string;\n    night: string;\n  };\n}\n\nexport interface AdaptiveNotification {\n  id: string;\n  type: 'alarm' | 'reminder' | 'optimization' | 'insight' | 'emergency';\n  priority: 'low' | 'normal' | 'high' | 'urgent';\n  title: string;\n  body: string;\n  scheduledTime: Date;\n  adaptedTime?: Date;\n  context: NotificationContext;\n  escalationLevel: number;\n  maxEscalations: number;\n  isDelivered: boolean;\n  deliveryAttempts: number;\n  adaptationReason?: string;\n  userResponse?: 'dismissed' | 'snoozed' | 'ignored';\n  responseTime?: number;\n}\n\nclass SmartNotificationService {\n  private static instance: SmartNotificationService;\n  private isInitialized = false;\n  private config: SmartNotificationConfig;\n  private scheduledNotifications: Map<string, AdaptiveNotification> = new Map();\n  private userBehaviorPatterns: Map<string, any> = new Map();\n  private currentContext: NotificationContext;\n  private adaptationHistory: Array<{\n    originalTime: Date;\n    adaptedTime: Date;\n    reason: string;\n    effectiveness: number;\n    timestamp: Date;\n  }> = [];\n\n  private constructor() {\n    this.config = this.getDefaultConfig();\n    this.currentContext = this.getDefaultContext();\n  }\n\n  public static getInstance(): SmartNotificationService {\n    if (!SmartNotificationService.instance) {\n      SmartNotificationService.instance = new SmartNotificationService();\n    }\n    return SmartNotificationService.instance;\n  }\n\n  /**\n   * Initialize the smart notification system\n   */\n  public async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      if (Capacitor.isNativePlatform()) {\n        // Request notification permissions\n        const permResult = await LocalNotifications.requestPermissions();\n        if (permResult.display !== 'granted') {\n          throw new Error('Notification permissions not granted');\n        }\n\n        // Set up notification listeners\n        await LocalNotifications.addListener('localNotificationReceived', (notification) => {\n          this.handleNotificationReceived(notification);\n        });\n\n        await LocalNotifications.addListener('localNotificationActionPerformed', (action) => {\n          this.handleNotificationAction(action);\n        });\n      }\n\n      // Load saved configuration and patterns\n      await this.loadConfiguration();\n      await this.loadUserBehaviorPatterns();\n\n      // Start context monitoring\n      this.startContextMonitoring();\n\n      this.isInitialized = true;\n    } catch (error) {\n      console.error('Failed to initialize SmartNotificationService:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Schedule a smart notification with adaptive timing\n   */\n  public async scheduleAdaptiveNotification(\n    baseTime: Date,\n    type: 'alarm' | 'reminder' | 'optimization' | 'insight' = 'alarm'\n  ): Promise<string> {\n    const notificationId = `smart_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    const notification: AdaptiveNotification = {\n      id: notificationId,\n      type,\n      priority: type === 'alarm' ? 'urgent' : 'normal',\n      title: this.generateTitle(alarmOrNotification, type),\n      body: this.generateBody(alarmOrNotification, type),\n      scheduledTime: baseTime,\n      context: await this.getCurrentContext(),\n      escalationLevel: 0,\n      maxEscalations: type === 'alarm' ? 5 : 2,\n      isDelivered: false,\n      deliveryAttempts: 0,\n      ...('id' in alarmOrNotification ? {} : alarmOrNotification)\n    };\n\n    // Apply adaptive timing\n    const adaptedTime = await this.calculateAdaptiveTime(notification);\n    notification.adaptedTime = adaptedTime;\n\n    // Store the notification\n    this.scheduledNotifications.set(notificationId, notification);\n\n    // Schedule the platform notification\n    await this.scheduleNativeNotification(notification);\n\n    // Save state\n    await this.saveScheduledNotifications();\n\n    return notificationId;\n  }\n\n  /**\n   * Calculate adaptive timing based on context and user patterns\n   */\n  private async calculateAdaptiveTime(notification: AdaptiveNotification): Promise<Date> {\n    let adaptedTime = new Date(notification.scheduledTime);\n    const adaptations: string[] = [];\n\n    if (!this.config.adaptiveEnabled) {\n      return adaptedTime;\n    }\n\n    // 1. Respect quiet hours\n    if (this.isInQuietHours(adaptedTime)) {\n      if (notification.priority === 'urgent' && this.config.emergencyOverride) {\n        adaptations.push('Emergency override - quiet hours ignored');\n      } else {\n        const quietEnd = this.parseTimeString(this.config.quietHoursEnd);\n        adaptedTime = new Date(adaptedTime);\n        adaptedTime.setHours(quietEnd.hours, quietEnd.minutes, 0, 0);\n        if (adaptedTime < notification.scheduledTime) {\n          adaptedTime.setDate(adaptedTime.getDate() + 1);\n        }\n        adaptations.push(`Delayed to after quiet hours (${this.config.quietHoursEnd})`);\n      }\n    }\n\n    // 2. Check Do Not Disturb\n    if (this.config.respectDoNotDisturb && notification.context.doNotDisturb) {\n      if (notification.priority !== 'urgent') {\n        adaptedTime = new Date(adaptedTime.getTime() + 30 * 60 * 1000); // Delay by 30 minutes\n        adaptations.push('Delayed due to Do Not Disturb mode');\n      }\n    }\n\n    // 3. Battery optimization\n    if (this.config.batteryOptimization && notification.context.batteryLevel < 20 && !notification.context.isCharging) {\n      if (notification.type !== 'alarm') {\n        adaptedTime = new Date(adaptedTime.getTime() + 15 * 60 * 1000); // Delay by 15 minutes\n        adaptations.push('Delayed for battery optimization');\n      }\n    }\n\n    // 4. User activity context\n    const activityAdjustment = this.getActivityBasedAdjustment(notification.context.userActivity, notification.type);\n    if (activityAdjustment !== 0) {\n      adaptedTime = new Date(adaptedTime.getTime() + activityAdjustment);\n      adaptations.push(`Adjusted ${activityAdjustment > 0 ? '+' : ''}${Math.round(activityAdjustment / 60000)} min for ${notification.context.userActivity} activity`);\n    }\n\n    // 5. Location-based adjustments\n    if (this.config.locationAware && notification.context.location) {\n      const locationAdjustment = this.getLocationBasedAdjustment(notification.context.location, notification.type);\n      if (locationAdjustment !== 0) {\n        adaptedTime = new Date(adaptedTime.getTime() + locationAdjustment);\n        adaptations.push(`Location-based adjustment: ${Math.round(locationAdjustment / 60000)} min`);\n      }\n    }\n\n    // 6. Historical pattern analysis\n    const patternAdjustment = this.getPatternBasedAdjustment(notification);\n    if (patternAdjustment !== 0) {\n      adaptedTime = new Date(adaptedTime.getTime() + patternAdjustment);\n      adaptations.push(`Pattern-based adjustment: ${Math.round(patternAdjustment / 60000)} min`);\n    }\n\n    // 7. Rate limiting\n    const rateLimitAdjustment = await this.getRateLimitAdjustment(adaptedTime);\n    if (rateLimitAdjustment !== 0) {\n      adaptedTime = new Date(adaptedTime.getTime() + rateLimitAdjustment);\n      adaptations.push(`Rate limit adjustment: ${Math.round(rateLimitAdjustment / 60000)} min`);\n    }\n\n    // Store adaptation reasoning\n    if (adaptations.length > 0) {\n      notification.adaptationReason = adaptations.join('; ');\n      this.recordAdaptation(notification.scheduledTime, adaptedTime, notification.adaptationReason);\n    }\n\n    return adaptedTime;\n  }\n\n  /**\n   * Get activity-based timing adjustments\n   */\n  private getActivityBasedAdjustment(activity: string, type: string): number {\n    const adjustments: Record<string, Record<string, number>> = {\n      'sleeping': {\n        'alarm': 0, // Never delay alarms for sleep\n        'reminder': 4 * 60 * 60 * 1000, // 4 hours delay\n        'optimization': 8 * 60 * 60 * 1000, // 8 hours delay\n        'insight': 8 * 60 * 60 * 1000\n      },\n      'driving': {\n        'alarm': 0,\n        'reminder': 15 * 60 * 1000, // 15 minutes delay\n        'optimization': 30 * 60 * 1000, // 30 minutes delay\n        'insight': 30 * 60 * 1000\n      },\n      'meeting': {\n        'alarm': 0,\n        'reminder': 60 * 60 * 1000, // 1 hour delay\n        'optimization': 2 * 60 * 60 * 1000, // 2 hours delay\n        'insight': 2 * 60 * 60 * 1000\n      },\n      'active': {\n        'alarm': 0,\n        'reminder': 0,\n        'optimization': 0,\n        'insight': 0\n      },\n      'idle': {\n        'alarm': 0,\n        'reminder': 0,\n        'optimization': -5 * 60 * 1000, // Deliver 5 minutes earlier when idle\n        'insight': -5 * 60 * 1000\n      }\n    };\n\n    return adjustments[activity]?.[type] || 0;\n  }\n\n  /**\n   * Get location-based timing adjustments\n   */\n  private getLocationBasedAdjustment(location: any, type: string): number {\n    let adjustment = 0;\n\n    // Deliver earlier when moving (might lose connectivity)\n    if (location.isMoving && type !== 'alarm') {\n      adjustment -= 10 * 60 * 1000; // 10 minutes earlier\n    }\n\n    // Adjust based on location type\n    if (location.isWork && type === 'optimization') {\n      adjustment += 30 * 60 * 1000; // Delay optimization notifications at work\n    }\n\n    if (location.isHome && type === 'insight') {\n      adjustment -= 5 * 60 * 1000; // Deliver insights earlier at home\n    }\n\n    return adjustment;\n  }\n\n  /**\n   * Get pattern-based adjustments using historical data\n   */\n  private getPatternBasedAdjustment(notification: AdaptiveNotification): number {\n    const patternKey = `${notification.type}_${notification.context.timeOfDay}`;\n    const pattern = this.userBehaviorPatterns.get(patternKey);\n\n    if (!pattern || pattern.samples < 5) {\n      return 0; // Need at least 5 samples for pattern analysis\n    }\n\n    // Calculate optimal timing based on user response patterns\n    const optimalDelay = pattern.averageResponseTime - pattern.averageDeliveryDelay;\n    return Math.max(-30 * 60 * 1000, Math.min(30 * 60 * 1000, optimalDelay));\n  }\n\n  /**\n   * Check rate limiting and adjust timing\n   */\n  private async getRateLimitAdjustment(proposedTime: Date): Promise<number> {\n    const hourStart = new Date(proposedTime);\n    hourStart.setMinutes(0, 0, 0);\n    const hourEnd = new Date(hourStart);\n    hourEnd.setHours(hourEnd.getHours() + 1);\n\n    const notificationsInHour = Array.from(this.scheduledNotifications.values()).filter(n => {\n      const time = n.adaptedTime || n.scheduledTime;\n      return time >= hourStart && time < hourEnd && !n.isDelivered;\n    });\n\n    if (notificationsInHour.length >= this.config.maxNotificationsPerHour) {\n      // Find next available slot\n      const nextSlot = new Date(hourEnd);\n      return nextSlot.getTime() - proposedTime.getTime();\n    }\n\n    return 0;\n  }\n\n  /**\n   * Schedule native platform notification\n   */\n  private async scheduleNativeNotification(notification: AdaptiveNotification): Promise<void> {\n    if (!Capacitor.isNativePlatform()) {\n      console.log('Web notification scheduling not implemented');\n      return;\n    }\n\n    const deliveryTime = notification.adaptedTime || notification.scheduledTime;\n    const vibrationPattern = this.getVibrationPattern(notification.priority);\n    const soundProfile = this.getSoundProfile(notification.context.timeOfDay);\n\n    const scheduleOptions: ScheduleOptions = {\n      notifications: [{\n        title: notification.title,\n        body: notification.body,\n        id: parseInt(notification.id.replace(/[^0-9]/g, '').slice(-8)) || Math.floor(Math.random() * 1000000),\n        schedule: { at: deliveryTime },\n        sound: soundProfile,\n        attachments: notification.type === 'alarm' ? [{ id: 'alarm', url: 'public/sounds/alarm.wav' }] : undefined,\n        actionTypeId: notification.type,\n        extra: {\n          notificationId: notification.id,\n          type: notification.type,\n          priority: notification.priority,\n          escalationLevel: notification.escalationLevel\n        }\n      }]\n    };\n\n    await LocalNotifications.schedule(scheduleOptions);\n  }\n\n  /**\n   * Handle progressive notification escalation\n   */\n  private async escalateNotification(notificationId: string): Promise<void> {\n    const notification = this.scheduledNotifications.get(notificationId);\n    if (!notification || notification.escalationLevel >= notification.maxEscalations) {\n      return;\n    }\n\n    notification.escalationLevel++;\n    notification.priority = this.getEscalatedPriority(notification.priority);\n\n    // Schedule next escalation\n    const escalationDelay = this.getEscalationDelay(notification.escalationLevel, notification.type);\n    const nextTime = new Date(Date.now() + escalationDelay);\n\n    await this.scheduleNativeNotification({\n      ...notification,\n      scheduledTime: nextTime,\n      title: `${notification.title} (${notification.escalationLevel}/${notification.maxEscalations})`,\n      body: notification.escalationLevel === notification.maxEscalations\n        ? `${notification.body} - Final reminder!`\n        : `${notification.body} - Reminder ${notification.escalationLevel}`\n    });\n  }\n\n  /**\n   * Monitor device context for adaptive notifications\n   */\n  private startContextMonitoring(): void {\n    // Update context every 5 minutes\n    setInterval(async () => {\n      this.currentContext = await this.getCurrentContext();\n    }, 5 * 60 * 1000);\n\n    // Monitor device events\n    document.addEventListener('visibilitychange', () => {\n      this.currentContext.userActivity = document.hidden ? 'idle' : 'active';\n    });\n\n    // Battery monitoring (if supported)\n    if ('getBattery' in navigator) {\n      (navigator as any).getBattery().then((battery: any) => {\n        const updateBatteryInfo = () => {\n          this.currentContext.batteryLevel = Math.round(battery.level * 100);\n          this.currentContext.isCharging = battery.charging;\n        };\n\n        updateBatteryInfo();\n        battery.addEventListener('chargingchange', updateBatteryInfo);\n        battery.addEventListener('levelchange', updateBatteryInfo);\n      });\n    }\n  }\n\n  /**\n   * Record user behavior for pattern analysis\n   */\n  public recordUserResponse(\n    notificationId: string,\n    response: 'dismissed' | 'snoozed' | 'ignored',\n    responseTime: number\n  ): void {\n    const notification = this.scheduledNotifications.get(notificationId);\n    if (!notification) return;\n\n    notification.userResponse = response;\n    notification.responseTime = responseTime;\n\n    // Update behavior patterns\n    const patternKey = `${notification.type}_${notification.context.timeOfDay}`;\n    const existingPattern = this.userBehaviorPatterns.get(patternKey) || {\n      samples: 0,\n      averageResponseTime: 0,\n      averageDeliveryDelay: 0,\n      dismissalRate: 0,\n      snoozeRate: 0,\n      ignoreRate: 0\n    };\n\n    const newSamples = existingPattern.samples + 1;\n    const deliveryDelay = (notification.adaptedTime || notification.scheduledTime).getTime() - notification.scheduledTime.getTime();\n\n    existingPattern.samples = newSamples;\n    existingPattern.averageResponseTime = (existingPattern.averageResponseTime * (newSamples - 1) + responseTime) / newSamples;\n    existingPattern.averageDeliveryDelay = (existingPattern.averageDeliveryDelay * (newSamples - 1) + deliveryDelay) / newSamples;\n\n    // Update response rates\n    const responses = { 'dismissed': 0, 'snoozed': 0, 'ignored': 0 };\n    responses[response] = 1;\n\n    existingPattern.dismissalRate = (existingPattern.dismissalRate * (newSamples - 1) + responses.dismissed) / newSamples;\n    existingPattern.snoozeRate = (existingPattern.snoozeRate * (newSamples - 1) + responses.snoozed) / newSamples;\n    existingPattern.ignoreRate = (existingPattern.ignoreRate * (newSamples - 1) + responses.ignored) / newSamples;\n\n    this.userBehaviorPatterns.set(patternKey, existingPattern);\n    this.saveUserBehaviorPatterns();\n  }\n\n  /**\n   * Get adaptive notification statistics\n   */\n  public getAdaptiveStats(): any {\n    const total = this.scheduledNotifications.size;\n    const adapted = Array.from(this.scheduledNotifications.values()).filter(n => n.adaptedTime).length;\n    const delivered = Array.from(this.scheduledNotifications.values()).filter(n => n.isDelivered).length;\n\n    const responseRates = {\n      dismissed: 0,\n      snoozed: 0,\n      ignored: 0\n    };\n\n    let totalResponses = 0;\n    this.scheduledNotifications.forEach(n => {\n      if (n.userResponse) {\n        responseRates[n.userResponse]++;\n        totalResponses++;\n      }\n    });\n\n    Object.keys(responseRates).forEach(key => {\n      responseRates[key as keyof typeof responseRates] = totalResponses > 0\n        ? (responseRates[key as keyof typeof responseRates] / totalResponses) * 100\n        : 0;\n    });\n\n    return {\n      total,\n      adapted,\n      adaptationRate: total > 0 ? (adapted / total) * 100 : 0,\n      delivered,\n      deliveryRate: total > 0 ? (delivered / total) * 100 : 0,\n      responseRates,\n      patternCount: this.userBehaviorPatterns.size,\n      adaptationHistory: this.adaptationHistory.length\n    };\n  }\n\n  /**\n   * Update configuration\n   */\n  public async updateConfig(config: Partial<SmartNotificationConfig>): Promise<void> {\n    this.config = { ...this.config, ...config };\n    await this.saveConfiguration();\n  }\n\n  /**\n   * Helper methods\n   */\n  private generateTitle(alarm: any, type: string): string {\n    if (type === 'alarm' && 'label' in alarm) {\n      return `‚è∞ ${alarm.label}`;\n    }\n\n    const titles = {\n      alarm: '‚è∞ Wake Up Time!',\n      reminder: 'üîî Reminder',\n      optimization: 'üí° Smart Suggestion',\n      insight: 'üìä Sleep Insight'\n    };\n\n    return titles[type] || 'üîî Notification';\n  }\n\n  private generateBody(alarm: any, type: string): string {\n    if (type === 'alarm' && 'label' in alarm) {\n      return `Time to wake up! ${alarm.label}`;\n    }\n\n    const bodies = {\n      alarm: 'Good morning! Time to start your day.',\n      reminder: 'You have a scheduled reminder.',\n      optimization: 'We found a way to improve your sleep schedule.',\n      insight: 'Here\\'s what we learned about your sleep patterns.'\n    };\n\n    return bodies[type] || 'You have a new notification.';\n  }\n\n  private getVibrationPattern(priority: string): number[] {\n    return this.config.vibrationPatterns[priority as keyof typeof this.config.vibrationPatterns]\n      || this.config.vibrationPatterns.normal;\n  }\n\n  private getSoundProfile(timeOfDay: string): string {\n    return this.config.soundProfiles[timeOfDay as keyof typeof this.config.soundProfiles]\n      || this.config.soundProfiles.morning;\n  }\n\n  private isInQuietHours(time: Date): boolean {\n    const timeStr = `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;\n    const start = this.config.quietHoursStart;\n    const end = this.config.quietHoursEnd;\n\n    if (start < end) {\n      return timeStr >= start && timeStr <= end;\n    } else {\n      return timeStr >= start || timeStr <= end;\n    }\n  }\n\n  private parseTimeString(timeStr: string): { hours: number; minutes: number } {\n    const [hours, minutes] = timeStr.split(':').map(Number);\n    return { hours, minutes };\n  }\n\n  private getEscalatedPriority(currentPriority: string): 'low' | 'normal' | 'high' | 'urgent' {\n    const escalation = { low: 'normal', normal: 'high', high: 'urgent', urgent: 'urgent' };\n    return escalation[currentPriority as keyof typeof escalation] as any;\n  }\n\n  private getEscalationDelay(level: number, type: string): number {\n    const baseDelays = {\n      alarm: [5 * 60 * 1000, 10 * 60 * 1000, 15 * 60 * 1000], // 5, 10, 15 minutes\n      reminder: [30 * 60 * 1000, 60 * 60 * 1000], // 30 minutes, 1 hour\n      optimization: [4 * 60 * 60 * 1000], // 4 hours\n      insight: [24 * 60 * 60 * 1000] // 24 hours\n    };\n\n    const delays = baseDelays[type] || baseDelays.reminder;\n    return delays[Math.min(level - 1, delays.length - 1)] || delays[delays.length - 1];\n  }\n\n  private recordAdaptation(originalTime: Date, adaptedTime: Date, reason: string): void {\n    this.adaptationHistory.push({\n      originalTime,\n      adaptedTime,\n      reason,\n      effectiveness: 0, // Will be updated when user responds\n      timestamp: new Date()\n    });\n\n    // Keep only last 1000 adaptations\n    if (this.adaptationHistory.length > 1000) {\n      this.adaptationHistory = this.adaptationHistory.slice(-1000);\n    }\n  }\n\n  private async getCurrentContext(): Promise<NotificationContext> {\n    // This would integrate with device APIs in a real implementation\n    const now = new Date();\n    const hour = now.getHours();\n\n    return {\n      userActivity: document.hidden ? 'idle' : 'active',\n      batteryLevel: this.currentContext?.batteryLevel || 100,\n      isCharging: this.currentContext?.isCharging || false,\n      doNotDisturb: false, // Would integrate with system DND\n      timeOfDay: hour < 12 ? 'morning' : hour < 17 ? 'afternoon' : hour < 21 ? 'evening' : 'night',\n      connectivity: navigator.onLine ? 'online' : 'offline'\n    };\n  }\n\n  private getDefaultConfig(): SmartNotificationConfig {\n    return {\n      adaptiveEnabled: true,\n      respectDoNotDisturb: true,\n      batteryOptimization: true,\n      locationAware: true,\n      progressiveEscalation: true,\n      sleepScheduleIntegration: true,\n      maxNotificationsPerHour: 3,\n      quietHoursStart: '22:00',\n      quietHoursEnd: '07:00',\n      emergencyOverride: true,\n      vibrationPatterns: {\n        gentle: [500, 200, 500],\n        normal: [1000, 500, 1000],\n        urgent: [500, 200, 500, 200, 1000, 300, 1000]\n      },\n      soundProfiles: {\n        morning: 'gentle_wake',\n        work: 'professional',\n        evening: 'soft_chime',\n        night: 'quiet_tone'\n      }\n    };\n  }\n\n  private getDefaultContext(): NotificationContext {\n    return {\n      userActivity: 'active',\n      batteryLevel: 100,\n      isCharging: false,\n      doNotDisturb: false,\n      timeOfDay: 'morning',\n      connectivity: 'online'\n    };\n  }\n\n  // Notification event handlers\n  private handleNotificationReceived(notification: any): void {\n    const adaptiveNotification = this.scheduledNotifications.get(notification.extra?.notificationId);\n    if (adaptiveNotification) {\n      adaptiveNotification.isDelivered = true;\n      adaptiveNotification.deliveryAttempts++;\n    }\n  }\n\n  private handleNotificationAction(action: any): void {\n    const notificationId = action.notification.extra?.notificationId;\n    if (notificationId) {\n      const responseTime = Date.now() - action.notification.schedule.at.getTime();\n\n      let response: 'dismissed' | 'snoozed' | 'ignored' = 'dismissed';\n      if (action.actionId === 'snooze') {\n        response = 'snoozed';\n      }\n\n      this.recordUserResponse(notificationId, response, responseTime);\n\n      if (response === 'snoozed') {\n        this.scheduleSnooze(notificationId);\n      }\n    }\n  }\n\n  private async scheduleSnooze(notificationId: string): Promise<void> {\n    const notification = this.scheduledNotifications.get(notificationId);\n    if (!notification) return;\n\n    const snoozeTime = new Date(Date.now() + 5 * 60 * 1000); // 5 minutes default\n\n    await this.scheduleNativeNotification({\n      ...notification,\n      scheduledTime: snoozeTime,\n      title: `${notification.title} (Snoozed)`,\n      escalationLevel: Math.min(notification.escalationLevel + 1, notification.maxEscalations)\n    });\n  }\n\n  // Persistence methods\n  private async saveConfiguration(): Promise<void> {\n    if (typeof localStorage !== 'undefined') {\n      localStorage.setItem('smart_notification_config', JSON.stringify(this.config));\n    }\n  }\n\n  private async loadConfiguration(): Promise<void> {\n    if (typeof localStorage !== 'undefined') {\n      const saved = localStorage.getItem('smart_notification_config');\n      if (saved) {\n        this.config = { ...this.config, ...JSON.parse(saved) };\n      }\n    }\n  }\n\n  private async saveUserBehaviorPatterns(): Promise<void> {\n    if (typeof localStorage !== 'undefined') {\n      const patterns = Object.fromEntries(this.userBehaviorPatterns);\n      localStorage.setItem('notification_behavior_patterns', JSON.stringify(patterns));\n    }\n  }\n\n  private async loadUserBehaviorPatterns(): Promise<void> {\n    if (typeof localStorage !== 'undefined') {\n      const saved = localStorage.getItem('notification_behavior_patterns');\n      if (saved) {\n        const patterns = JSON.parse(saved);\n        this.userBehaviorPatterns = new Map(Object.entries(patterns));\n      }\n    }\n  }\n\n  private async saveScheduledNotifications(): Promise<void> {\n    if (typeof localStorage !== 'undefined') {\n      const notifications = Object.fromEntries(this.scheduledNotifications);\n      localStorage.setItem('scheduled_adaptive_notifications', JSON.stringify(notifications, (key, value) => {\n        if (value instanceof Date) {\n          return { __type: 'Date', value: value.toISOString() };\n        }\n        return value;\n      }));\n    }\n  }\n}\n\nexport default SmartNotificationService;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/subscription.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SubscriptionTier' is not defined.",
        "line": 89,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 89,
        "endColumn": 69
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SubscriptionLimits' is not defined.",
        "line": 106,
        "column": 58,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 106,
        "endColumn": 76
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { supabase, createClient } from './supabase';\nimport type {\n  Subscription,\n  SubscriptionStatus,\n  PremiumFeatureAccess,\n  PremiumUsage,\n  FeatureLimits,\n  SUBSCRIPTION_LIMITS,\n  SUBSCRIPTION_PLANS\n} from '../types';\nimport { ErrorHandler } from './error-handler';\n\ninterface SubscriptionCheckResult {\n  hasAccess: boolean;\n  reason?: string;\n  upgradeRequired?: boolean;\n  currentUsage?: number;\n  limit?: number;\n}\n\nexport class SubscriptionService {\n  private static cache = new Map<string, any>();\n  private static cacheExpiry = new Map<string, number>();\n  private static readonly CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n\n  private static isAvailable = createClient() !== null;\n\n  /**\n   * Get user's current subscription\n   */\n  static async getUserSubscription(userId: string): Promise<Subscription | null> {\n    if (!this.isAvailable) {\n      return null;\n    }\n\n    const cacheKey = `subscription_${userId}`;\n    const cached = this.getCachedData<Subscription>(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    try {\n      const { data, error } = await supabase\n        .from('subscriptions')\n        .select('*')\n        .eq('user_id', userId)\n        .eq('status', 'active')\n        .single();\n\n      if (error && error.code !== 'PGRST116') { // PGRST116 is \"no rows returned\"\n        throw new Error(`Failed to get subscription: ${error.message}`);\n      }\n\n      const subscription = data ? {\n        id: data.id,\n        userId: data.user_id,\n        tier: data.tier,\n        status: data.status,\n        currentPeriodStart: new Date(data.current_period_start),\n        currentPeriodEnd: new Date(data.current_period_end),\n        trialEnd: data.trial_end ? new Date(data.trial_end) : undefined,\n        cancelAtPeriodEnd: data.cancel_at_period_end,\n        canceledAt: data.canceled_at ? new Date(data.canceled_at) : undefined,\n        createdAt: new Date(data.created_at),\n        updatedAt: new Date(data.updated_at),\n        stripeCustomerId: data.stripe_customer_id,\n        stripeSubscriptionId: data.stripe_subscription_id,\n        stripePriceId: data.stripe_price_id\n      } as Subscription : null;\n\n      if (subscription) {\n        this.setCachedData(cacheKey, subscription);\n      }\n\n      return subscription;\n    } catch (error) {\n      ErrorHandler.handleError(\n        error instanceof Error ? error : new Error(String(error)),\n        'Failed to get user subscription',\n        { context: 'getUserSubscription', userId }\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Get user's subscription tier\n   */\n  static async getUserTier(userId: string): Promise<SubscriptionTier> {\n    const subscription = await this.getUserSubscription(userId);\n    return subscription?.tier || 'free';\n  }\n\n  /**\n   * Get user's feature access permissions\n   */\n  static async getFeatureAccess(userId: string): Promise<PremiumFeatureAccess> {\n    const tier = await this.getUserTier(userId);\n    const plan = SUBSCRIPTION_PLANS.find(p => p.tier === tier);\n    return plan?.featureAccess || SUBSCRIPTION_PLANS[0].featureAccess; // Default to free tier\n  }\n\n  /**\n   * Get user's feature limits\n   */\n  static async getFeatureLimits(userId: string): Promise<SubscriptionLimits> {\n    const tier = await this.getUserTier(userId);\n    return SUBSCRIPTION_LIMITS[tier];\n  }\n\n  /**\n   * Check if user has access to a specific feature\n   */\n  static async hasFeatureAccess(\n    userId: string,\n    feature: keyof PremiumFeatureAccess\n  ): Promise<boolean> {\n    const featureAccess = await this.getFeatureAccess(userId);\n    return featureAccess[feature];\n  }\n\n  /**\n   * Check if user can use a feature based on usage limits\n   */\n  static async checkFeatureUsage(\n    userId: string,\n    feature: 'elevenlabsApiCalls' | 'aiInsightsGenerated' | 'customVoiceMessages'\n  ): Promise<SubscriptionCheckResult> {\n    const tier = await this.getUserTier(userId);\n    const limits = this.getFeatureLimits(tier);\n    const usage = await this.getCurrentUsage(userId);\n\n    let currentUsage: number = 0;\n    let limit: number = 0;\n\n    switch (feature) {\n      case 'elevenlabsApiCalls':\n        currentUsage = usage?.elevenlabsApiCalls || 0;\n        limit = limits.elevenlabsCallsPerMonth;\n        break;\n      case 'aiInsightsGenerated':\n        currentUsage = usage?.aiInsightsGenerated || 0;\n        limit = limits.aiInsightsPerDay;\n        break;\n      case 'customVoiceMessages':\n        currentUsage = usage?.customVoiceMessages || 0;\n        limit = limits.customVoiceMessagesPerDay;\n        break;\n    }\n\n    if (limit === -1) { // Unlimited\n      return { hasAccess: true };\n    }\n\n    if (currentUsage >= limit) {\n      return {\n        hasAccess: false,\n        reason: `Daily/monthly limit exceeded`,\n        upgradeRequired: true,\n        currentUsage,\n        limit\n      };\n    }\n\n    return { hasAccess: true, currentUsage, limit };\n  }\n\n  /**\n   * Get current month's usage for a user\n   */\n  static async getCurrentUsage(userId: string): Promise<PremiumUsage | null> {\n    if (!this.isAvailable) {\n      return null;\n    }\n\n    const currentMonth = new Date().toISOString().slice(0, 7); // YYYY-MM format\n    const cacheKey = `usage_${userId}_${currentMonth}`;\n    const cached = this.getCachedData<PremiumUsage>(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    try {\n      const { data, error } = await supabase\n        .from('premium_usage')\n        .select('*')\n        .eq('user_id', userId)\n        .eq('month', currentMonth)\n        .single();\n\n      if (error && error.code !== 'PGRST116') {\n        throw new Error(`Failed to get usage: ${error.message}`);\n      }\n\n      const usage = data ? {\n        userId: data.user_id,\n        month: data.month,\n        elevenlabsApiCalls: data.elevenlabs_api_calls,\n        aiInsightsGenerated: data.ai_insights_generated,\n        customVoiceMessages: data.custom_voice_messages,\n        premiumThemesUsed: data.premium_themes_used,\n        lastUpdated: new Date(data.last_updated)\n      } as PremiumUsage : null;\n\n      if (usage) {\n        this.setCachedData(cacheKey, usage, 1 * 60 * 1000); // Cache for 1 minute for usage data\n      }\n\n      return usage;\n    } catch (error) {\n      ErrorHandler.handleError(\n        error instanceof Error ? error : new Error(String(error)),\n        'Failed to get usage data',\n        { context: 'getCurrentUsage', userId }\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Increment usage for a specific feature\n   */\n  static async incrementUsage(\n    userId: string,\n    feature: 'elevenlabsApiCalls' | 'aiInsightsGenerated' | 'customVoiceMessages',\n    increment: number = 1\n  ): Promise<void> {\n    if (!this.isAvailable) {\n      return;\n    }\n\n    const currentMonth = new Date().toISOString().slice(0, 7);\n\n    try {\n      const { error } = await supabase.rpc('increment_premium_usage', {\n        p_user_id: userId,\n        p_month: currentMonth,\n        p_feature: feature,\n        p_increment: increment\n      });\n\n      if (error) {\n        throw new Error(`Failed to increment usage: ${error.message}`);\n      }\n\n      // Invalidate cache\n      const cacheKey = `usage_${userId}_${currentMonth}`;\n      this.invalidateCache(cacheKey);\n    } catch (error) {\n      ErrorHandler.handleError(\n        error instanceof Error ? error : new Error(String(error)),\n        'Failed to increment usage',\n        { context: 'incrementUsage', userId, feature, increment }\n      );\n    }\n  }\n\n  /**\n   * Create or update a subscription\n   */\n  static async upsertSubscription(subscription: Subscription): Promise<void> {\n    if (!this.isAvailable) {\n      return;\n    }\n\n    try {\n      const { error } = await supabase\n        .from('subscriptions')\n        .upsert([{\n          id: subscription.id,\n          user_id: subscription.userId,\n          tier: subscription.tier,\n          status: subscription.status,\n          current_period_start: subscription.currentPeriodStart.toISOString(),\n          current_period_end: subscription.currentPeriodEnd.toISOString(),\n          trial_end: subscription.trialEnd?.toISOString(),\n          cancel_at_period_end: subscription.cancelAtPeriodEnd,\n          canceled_at: subscription.canceledAt?.toISOString(),\n          created_at: subscription.createdAt.toISOString(),\n          updated_at: subscription.updatedAt.toISOString(),\n          stripe_customer_id: subscription.stripeCustomerId,\n          stripe_subscription_id: subscription.stripeSubscriptionId,\n          stripe_price_id: subscription.stripePriceId\n        }]);\n\n      if (error) {\n        throw new Error(`Failed to upsert subscription: ${error.message}`);\n      }\n\n      // Invalidate cache\n      this.invalidateCache(`subscription_${subscription.userId}`);\n    } catch (error) {\n      ErrorHandler.handleError(\n        error instanceof Error ? error : new Error(String(error)),\n        'Failed to upsert subscription',\n        { context: 'upsertSubscription', subscriptionId: subscription.id }\n      );\n    }\n  }\n\n  /**\n   * Cancel a subscription\n   */\n  static async cancelSubscription(userId: string, cancelAtPeriodEnd: boolean = true): Promise<void> {\n    if (!this.isAvailable) {\n      return;\n    }\n\n    try {\n      const updates: any = {\n        cancel_at_period_end: cancelAtPeriodEnd,\n        updated_at: new Date().toISOString()\n      };\n\n      if (!cancelAtPeriodEnd) {\n        updates.status = 'canceled';\n        updates.canceled_at = new Date().toISOString();\n      }\n\n      const { error } = await supabase\n        .from('subscriptions')\n        .update(updates)\n        .eq('user_id', userId)\n        .eq('status', 'active');\n\n      if (error) {\n        throw new Error(`Failed to cancel subscription: ${error.message}`);\n      }\n\n      // Invalidate cache\n      this.invalidateCache(`subscription_${userId}`);\n    } catch (error) {\n      ErrorHandler.handleError(\n        error instanceof Error ? error : new Error(String(error)),\n        'Failed to cancel subscription',\n        { context: 'cancelSubscription', userId }\n      );\n    }\n  }\n\n  /**\n   * Get subscription analytics for admin\n   */\n  static async getSubscriptionAnalytics(): Promise<{\n    totalSubscriptions: number;\n    monthlyRevenue: number;\n    churnRate: number;\n  } | null> {\n    if (!this.isAvailable) {\n      return null;\n    }\n\n    try {\n      const { data, error } = await supabase.rpc('get_subscription_analytics');\n\n      if (error) {\n        throw new Error(`Failed to get subscription analytics: ${error.message}`);\n      }\n\n      return data;\n    } catch (error) {\n      ErrorHandler.handleError(\n        error instanceof Error ? error : new Error(String(error)),\n        'Failed to get subscription analytics',\n        { context: 'getSubscriptionAnalytics' }\n      );\n      return null;\n    }\n  }\n\n  /**\n   * Check if user is in trial period\n   */\n  static async isUserInTrial(userId: string): Promise<boolean> {\n    const subscription = await this.getUserSubscription(userId);\n    if (!subscription?.trialEnd) {\n      return false;\n    }\n\n    return new Date() < subscription.trialEnd;\n  }\n\n  /**\n   * Get days remaining in trial\n   */\n  static async getTrialDaysRemaining(userId: string): Promise<number> {\n    const subscription = await this.getUserSubscription(userId);\n    if (!subscription?.trialEnd) {\n      return 0;\n    }\n\n    const now = new Date();\n    const trialEnd = subscription.trialEnd;\n    const diffTime = trialEnd.getTime() - now.getTime();\n    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n\n    return Math.max(0, diffDays);\n  }\n\n  // Cache management methods\n  private static setCachedData<T>(key: string, data: T, duration?: number): void {\n    this.cache.set(key, data);\n    this.cacheExpiry.set(key, Date.now() + (duration || this.CACHE_DURATION));\n  }\n\n  private static getCachedData<T>(key: string): T | null {\n    const expiry = this.cacheExpiry.get(key);\n    if (!expiry || Date.now() > expiry) {\n      this.cache.delete(key);\n      this.cacheExpiry.delete(key);\n      return null;\n    }\n    return this.cache.get(key) || null;\n  }\n\n  private static invalidateCache(key: string): void {\n    this.cache.delete(key);\n    this.cacheExpiry.delete(key);\n  }\n\n  /**\n   * Clear all cached data\n   */\n  static clearCache(): void {\n    this.cache.clear();\n    this.cacheExpiry.clear();\n  }\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/voice-biometrics.ts",
    "messages": [
      {
        "ruleId": "no-async-promise-executor",
        "severity": 2,
        "message": "Promise executor functions should not be async.",
        "line": 138,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "async",
        "endLine": 138,
        "endColumn": 29
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Voice Biometrics Service for Relife Smart Alarm\n// Advanced voice authentication, training, and biometric analysis\n\nimport type { User } from '../types';\nimport { ErrorHandler } from './error-handler';\nimport PerformanceMonitor from './performance-monitor';\nimport { SupabaseService } from './supabase';\n\nexport interface VoicePrint {\n  userId: string;\n  features: {\n    fundamentalFrequency: number[];\n    formants: number[][];\n    spectralCentroid: number[];\n    mfcc: number[][]; // Mel-frequency cepstral coefficients\n    voiceQuality: {\n      jitter: number;\n      shimmer: number;\n      harmonicsRatio: number;\n    };\n  };\n  confidence: number;\n  recordedAt: Date;\n  language: string;\n  accent: string;\n  emotion: 'neutral' | 'happy' | 'sad' | 'angry' | 'excited' | 'tired';\n}\n\nexport interface VoiceTrainingSession {\n  userId: string;\n  sessionId: string;\n  phrases: string[];\n  recordings: AudioBuffer[];\n  quality: number;\n  duration: number;\n  completedAt: Date;\n  improvements: string[];\n}\n\nexport interface VoiceAuthentication {\n  userId: string;\n  authenticated: boolean;\n  confidence: number;\n  matchedFeatures: string[];\n  riskLevel: 'low' | 'medium' | 'high';\n  timestamp: Date;\n}\n\nexport interface VoiceMoodAnalysis {\n  detectedMood: 'happy' | 'sad' | 'angry' | 'excited' | 'tired' | 'neutral';\n  confidence: number;\n  energyLevel: number;\n  stressLevel: number;\n  recommendations: string[];\n}\n\nclass VoiceBiometricsService {\n  private static instance: VoiceBiometricsService;\n  private performanceMonitor = PerformanceMonitor.getInstance();\n  private audioContext: AudioContext | null = null;\n  private voicePrints = new Map<string, VoicePrint[]>();\n  private trainingData = new Map<string, VoiceTrainingSession[]>();\n  private isRecording = false;\n  private mediaRecorder: MediaRecorder | null = null;\n\n  private constructor() {\n    this.initializeAudioContext();\n  }\n\n  static getInstance(): VoiceBiometricsService {\n    if (!VoiceBiometricsService.instance) {\n      VoiceBiometricsService.instance = new VoiceBiometricsService();\n    }\n    return VoiceBiometricsService.instance;\n  }\n\n  /**\n   * Initialize audio context for voice analysis\n   */\n  private async initializeAudioContext(): Promise<void> {\n    try {\n      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n\n      if (this.audioContext.state === 'suspended') {\n        await this.audioContext.resume();\n      }\n    } catch (error) {\n      console.error('Failed to initialize audio context:', error);\n    }\n  }\n\n  /**\n   * Start voice training session for user\n   */\n  async startVoiceTraining(\n    userId: string,\n    trainingPhrases: string[] = this.getDefaultTrainingPhrases()\n  ): Promise<string> {\n    try {\n      const sessionId = this.generateSessionId();\n\n      const session: VoiceTrainingSession = {\n        userId,\n        sessionId,\n        phrases: trainingPhrases,\n        recordings: [],\n        quality: 0,\n        duration: 0,\n        completedAt: new Date(),\n        improvements: []\n      };\n\n      // Initialize training session\n      const userSessions = this.trainingData.get(userId) || [];\n      userSessions.push(session);\n      this.trainingData.set(userId, userSessions);\n\n      this.performanceMonitor.trackCustomMetric('voice_training_started', 1);\n\n      return sessionId;\n    } catch (error) {\n      ErrorHandler.handleError(\n        error as Error,\n        'Failed to start voice training',\n        { userId }\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Record voice sample for training or authentication\n   */\n  async recordVoiceSample(\n    duration: number = 5000,\n    phrase?: string\n  ): Promise<AudioBuffer> {\n    return new Promise(async (resolve, reject) => {\n      try {\n        if (!this.audioContext) {\n          await this.initializeAudioContext();\n        }\n\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: {\n            sampleRate: 44100,\n            channelCount: 1,\n            echoCancellation: true,\n            noiseSuppression: true,\n            autoGainControl: false\n          }\n        });\n\n        const chunks: Blob[] = [];\n        this.mediaRecorder = new MediaRecorder(stream, {\n          mimeType: 'audio/webm;codecs=opus'\n        });\n\n        this.mediaRecorder.ondataavailable = event => {\n          if (event.data.size > 0) {\n            chunks.push(event.data);\n          }\n        };\n\n        this.mediaRecorder.onstop = async () => {\n          try {\n            const blob = new Blob(chunks, { type: 'audio/webm' });\n            const arrayBuffer = await blob.arrayBuffer();\n            const audioBuffer = await this.audioContext!.decodeAudioData(arrayBuffer);\n\n            stream.getTracks().forEach(track => track.stop());\n            resolve(audioBuffer);\n          } catch (error) {\n            reject(error);\n          }\n        };\n\n        this.mediaRecorder.start();\n        this.isRecording = true;\n\n        // Stop recording after specified duration\n        setTimeout(() => {\n          if (this.mediaRecorder && this.isRecording) {\n            this.mediaRecorder.stop();\n            this.isRecording = false;\n          }\n        }, duration);\n\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Analyze voice sample and extract biometric features\n   */\n  async analyzeVoiceSample(audioBuffer: AudioBuffer, userId: string): Promise<VoicePrint> {\n    try {\n      const startTime = performance.now();\n\n      if (!this.audioContext) {\n        throw new Error('Audio context not initialized');\n      }\n\n      const audioData = audioBuffer.getChannelData(0);\n      const sampleRate = audioBuffer.sampleRate;\n\n      // Extract voice features\n      const fundamentalFrequency = this.extractFundamentalFrequency(audioData, sampleRate);\n      const formants = this.extractFormants(audioData, sampleRate);\n      const spectralCentroid = this.extractSpectralCentroid(audioData, sampleRate);\n      const mfcc = this.extractMFCC(audioData, sampleRate);\n      const voiceQuality = this.analyzeVoiceQuality(audioData, sampleRate);\n\n      // Detect language and accent patterns\n      const language = await this.detectLanguage(audioData);\n      const accent = await this.detectAccent(audioData, language);\n\n      // Analyze emotional state\n      const emotion = this.analyzeEmotion(audioData, sampleRate);\n\n      const voicePrint: VoicePrint = {\n        userId,\n        features: {\n          fundamentalFrequency,\n          formants,\n          spectralCentroid,\n          mfcc,\n          voiceQuality\n        },\n        confidence: this.calculateConfidence(audioData),\n        recordedAt: new Date(),\n        language,\n        accent,\n        emotion\n      };\n\n      // Store voice print\n      const userPrints = this.voicePrints.get(userId) || [];\n      userPrints.push(voicePrint);\n\n      // Keep only last 10 voice prints\n      if (userPrints.length > 10) {\n        userPrints.splice(0, userPrints.length - 10);\n      }\n\n      this.voicePrints.set(userId, userPrints);\n\n      // Store in database\n      await this.storeVoicePrint(voicePrint);\n\n      const duration = performance.now() - startTime;\n      this.performanceMonitor.trackCustomMetric('voice_analysis_duration', duration);\n\n      return voicePrint;\n\n    } catch (error) {\n      ErrorHandler.handleError(\n        error as Error,\n        'Voice analysis failed',\n        { userId }\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Authenticate user using voice biometrics\n   */\n  async authenticateUser(audioBuffer: AudioBuffer, expectedUserId: string): Promise<VoiceAuthentication> {\n    try {\n      const voicePrint = await this.analyzeVoiceSample(audioBuffer, expectedUserId);\n      const storedPrints = this.voicePrints.get(expectedUserId) || [];\n\n      if (storedPrints.length === 0) {\n        return {\n          userId: expectedUserId,\n          authenticated: false,\n          confidence: 0,\n          matchedFeatures: [],\n          riskLevel: 'high',\n          timestamp: new Date()\n        };\n      }\n\n      // Compare with stored voice prints\n      const similarities = storedPrints.map(stored => this.compareVoicePrints(voicePrint, stored));\n      const maxSimilarity = Math.max(...similarities);\n      const averageSimilarity = similarities.reduce((sum, sim) => sum + sim, 0) / similarities.length;\n\n      const matchedFeatures = this.identifyMatchedFeatures(voicePrint, storedPrints);\n\n      // Authentication logic\n      const authenticated = maxSimilarity > 0.8 && averageSimilarity > 0.65;\n      const confidence = (maxSimilarity * 0.6 + averageSimilarity * 0.4) * 100;\n\n      const riskLevel = this.assessRiskLevel(confidence, matchedFeatures);\n\n      const authentication: VoiceAuthentication = {\n        userId: expectedUserId,\n        authenticated,\n        confidence,\n        matchedFeatures,\n        riskLevel,\n        timestamp: new Date()\n      };\n\n      // Log authentication attempt\n      await this.logAuthenticationAttempt(authentication);\n\n      this.performanceMonitor.trackCustomMetric('voice_authentication_attempt', 1);\n\n      return authentication;\n\n    } catch (error) {\n      ErrorHandler.handleError(\n        error as Error,\n        'Voice authentication failed',\n        { userId: expectedUserId }\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Analyze voice for mood detection\n   */\n  async analyzeMood(audioBuffer: AudioBuffer): Promise<VoiceMoodAnalysis> {\n    try {\n      const audioData = audioBuffer.getChannelData(0);\n      const sampleRate = audioBuffer.sampleRate;\n\n      // Extract mood-related features\n      const energy = this.calculateEnergyLevel(audioData);\n      const pitch = this.extractFundamentalFrequency(audioData, sampleRate);\n      const spectralFeatures = this.extractSpectralFeatures(audioData, sampleRate);\n\n      // Analyze prosodic features\n      const prosody = this.analyzeProsody(audioData, sampleRate);\n\n      // Mood classification\n      const detectedMood = this.classifyMood(energy, pitch, spectralFeatures, prosody);\n      const confidence = this.calculateMoodConfidence(energy, pitch, spectralFeatures);\n\n      // Calculate stress level\n      const stressLevel = this.calculateStressLevel(audioData, sampleRate);\n\n      // Generate recommendations\n      const recommendations = this.generateMoodRecommendations(detectedMood, energy, stressLevel);\n\n      return {\n        detectedMood,\n        confidence,\n        energyLevel: energy,\n        stressLevel,\n        recommendations\n      };\n\n    } catch (error) {\n      console.error('Mood analysis failed:', error);\n      return {\n        detectedMood: 'neutral',\n        confidence: 0,\n        energyLevel: 0.5,\n        stressLevel: 0.5,\n        recommendations: ['Unable to analyze mood at this time']\n      };\n    }\n  }\n\n  /**\n   * Get user's voice training progress\n   */\n  async getTrainingProgress(userId: string): Promise<{\n    sessionsCompleted: number;\n    totalSamples: number;\n    averageQuality: number;\n    improvements: string[];\n    nextSteps: string[];\n  }> {\n    try {\n      const sessions = this.trainingData.get(userId) || [];\n      const voicePrints = this.voicePrints.get(userId) || [];\n\n      const sessionsCompleted = sessions.length;\n      const totalSamples = voicePrints.length;\n      const averageQuality = voicePrints.reduce((sum, print) => sum + print.confidence, 0) / totalSamples || 0;\n\n      const allImprovements = sessions.flatMap(session => session.improvements);\n      const improvements = [...new Set(allImprovements)];\n\n      const nextSteps = this.generateTrainingNextSteps(sessions, voicePrints);\n\n      return {\n        sessionsCompleted,\n        totalSamples,\n        averageQuality,\n        improvements,\n        nextSteps\n      };\n\n    } catch (error) {\n      console.error('Failed to get training progress:', error);\n      return {\n        sessionsCompleted: 0,\n        totalSamples: 0,\n        averageQuality: 0,\n        improvements: [],\n        nextSteps: ['Start voice training to improve accuracy']\n      };\n    }\n  }\n\n  /**\n   * Extract fundamental frequency (pitch)\n   */\n  private extractFundamentalFrequency(audioData: Float32Array, sampleRate: number): number[] {\n    const windowSize = 1024;\n    const hopSize = 512;\n    const frequencies: number[] = [];\n\n    for (let i = 0; i < audioData.length - windowSize; i += hopSize) {\n      const window = audioData.slice(i, i + windowSize);\n      const frequency = this.autocorrelationPitch(window, sampleRate);\n      if (frequency > 50 && frequency < 800) { // Valid vocal range\n        frequencies.push(frequency);\n      }\n    }\n\n    return frequencies;\n  }\n\n  /**\n   * Autocorrelation-based pitch detection\n   */\n  private autocorrelationPitch(buffer: Float32Array, sampleRate: number): number {\n    const minPeriod = Math.floor(sampleRate / 800); // 800 Hz max\n    const maxPeriod = Math.floor(sampleRate / 50);  // 50 Hz min\n\n    let bestPeriod = 0;\n    let bestCorrelation = 0;\n\n    for (let period = minPeriod; period < maxPeriod; period++) {\n      let correlation = 0;\n\n      for (let i = 0; i < buffer.length - period; i++) {\n        correlation += buffer[i] * buffer[i + period];\n      }\n\n      if (correlation > bestCorrelation) {\n        bestCorrelation = correlation;\n        bestPeriod = period;\n      }\n    }\n\n    return bestPeriod > 0 ? sampleRate / bestPeriod : 0;\n  }\n\n  /**\n   * Extract formant frequencies\n   */\n  private extractFormants(audioData: Float32Array, sampleRate: number): number[][] {\n    // Simplified formant extraction using FFT peaks\n    const formants: number[][] = [];\n    const windowSize = 1024;\n    const hopSize = 512;\n\n    for (let i = 0; i < audioData.length - windowSize; i += hopSize) {\n      const window = audioData.slice(i, i + windowSize);\n      const spectrum = this.fft(window);\n      const peaks = this.findSpectralPeaks(spectrum, sampleRate);\n      formants.push(peaks.slice(0, 4)); // First 4 formants\n    }\n\n    return formants;\n  }\n\n  /**\n   * Extract MFCC features\n   */\n  private extractMFCC(audioData: Float32Array, sampleRate: number): number[][] {\n    const mfccs: number[][] = [];\n    const windowSize = 1024;\n    const hopSize = 512;\n    const numMFCC = 13;\n\n    for (let i = 0; i < audioData.length - windowSize; i += hopSize) {\n      const window = audioData.slice(i, i + windowSize);\n      const mfcc = this.computeMFCC(window, sampleRate, numMFCC);\n      mfccs.push(mfcc);\n    }\n\n    return mfccs;\n  }\n\n  /**\n   * Analyze voice quality metrics\n   */\n  private analyzeVoiceQuality(audioData: Float32Array, sampleRate: number): {\n    jitter: number;\n    shimmer: number;\n    harmonicsRatio: number;\n  } {\n    const pitch = this.extractFundamentalFrequency(audioData, sampleRate);\n\n    // Calculate jitter (pitch period variation)\n    const jitter = pitch.length > 1 ?\n      this.calculateStandardDeviation(pitch) / this.calculateMean(pitch) : 0;\n\n    // Calculate shimmer (amplitude variation)\n    const amplitudes = this.extractAmplitudeEnvelope(audioData);\n    const shimmer = amplitudes.length > 1 ?\n      this.calculateStandardDeviation(amplitudes) / this.calculateMean(amplitudes) : 0;\n\n    // Calculate harmonics-to-noise ratio\n    const harmonicsRatio = this.calculateHarmonicsRatio(audioData, sampleRate);\n\n    return { jitter, shimmer, harmonicsRatio };\n  }\n\n  /**\n   * Compare two voice prints for similarity\n   */\n  private compareVoicePrints(print1: VoicePrint, print2: VoicePrint): number {\n    let similarity = 0;\n    let weights = 0;\n\n    // Compare fundamental frequency\n    if (print1.features.fundamentalFrequency.length > 0 && print2.features.fundamentalFrequency.length > 0) {\n      const f1Mean = this.calculateMean(print1.features.fundamentalFrequency);\n      const f2Mean = this.calculateMean(print2.features.fundamentalFrequency);\n      const freqSimilarity = 1 - Math.abs(f1Mean - f2Mean) / Math.max(f1Mean, f2Mean);\n      similarity += freqSimilarity * 0.3;\n      weights += 0.3;\n    }\n\n    // Compare MFCC features\n    if (print1.features.mfcc.length > 0 && print2.features.mfcc.length > 0) {\n      const mfccSimilarity = this.compareMFCCFeatures(print1.features.mfcc, print2.features.mfcc);\n      similarity += mfccSimilarity * 0.4;\n      weights += 0.4;\n    }\n\n    // Compare voice quality\n    const qualitySimilarity = this.compareVoiceQuality(\n      print1.features.voiceQuality,\n      print2.features.voiceQuality\n    );\n    similarity += qualitySimilarity * 0.3;\n    weights += 0.3;\n\n    return weights > 0 ? similarity / weights : 0;\n  }\n\n  /**\n   * Utility methods\n   */\n  private getDefaultTrainingPhrases(): string[] {\n    return [\n      \"Good morning, this is my voice training session.\",\n      \"My name is unique and this is how I sound.\",\n      \"I am recording my voice for biometric authentication.\",\n      \"The quick brown fox jumps over the lazy dog.\",\n      \"She sells seashells by the seashore.\",\n      \"How much wood would a woodchuck chuck if a woodchuck could chuck wood?\",\n      \"Peter Piper picked a peck of pickled peppers.\",\n      \"Red leather, yellow leather, repeat rapidly.\",\n      \"Unique New York, truly rural, toy boat.\",\n      \"I need to wake up on time every morning.\"\n    ];\n  }\n\n  private generateSessionId(): string {\n    return `voice_training_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private calculateConfidence(audioData: Float32Array): number {\n    const rms = Math.sqrt(audioData.reduce((sum, sample) => sum + sample * sample, 0) / audioData.length);\n    const snr = this.estimateSignalToNoiseRatio(audioData);\n    const duration = audioData.length / 44100;\n\n    let confidence = 0.5;\n\n    // Adjust based on signal strength\n    if (rms > 0.01) confidence += 0.2;\n    if (rms > 0.05) confidence += 0.1;\n\n    // Adjust based on SNR\n    if (snr > 10) confidence += 0.15;\n    if (snr > 20) confidence += 0.05;\n\n    // Adjust based on duration\n    if (duration > 2) confidence += 0.1;\n    if (duration > 4) confidence += 0.05;\n\n    return Math.min(1.0, confidence);\n  }\n\n  private async detectLanguage(audioData: Float32Array): Promise<string> {\n    // Simplified language detection based on spectral characteristics\n    const spectralFeatures = this.extractSpectralFeatures(audioData, 44100);\n\n    // This would normally use a trained model\n    // For now, return English as default\n    return 'en-US';\n  }\n\n  private async detectAccent(audioData: Float32Array, language: string): Promise<string> {\n    // Simplified accent detection\n    // In production, this would use ML models\n    return 'General American';\n  }\n\n  private analyzeEmotion(audioData: Float32Array, sampleRate: number): VoicePrint['emotion'] {\n    const energy = this.calculateEnergyLevel(audioData);\n    const pitch = this.extractFundamentalFrequency(audioData, sampleRate);\n    const pitchMean = pitch.length > 0 ? this.calculateMean(pitch) : 0;\n\n    // Simple emotion classification based on energy and pitch\n    if (energy > 0.7 && pitchMean > 200) return 'excited';\n    if (energy > 0.6 && pitchMean > 180) return 'happy';\n    if (energy < 0.3 && pitchMean < 150) return 'sad';\n    if (energy > 0.8 && pitchMean > 220) return 'angry';\n    if (energy < 0.4) return 'tired';\n\n    return 'neutral';\n  }\n\n  // Additional utility methods would be implemented here...\n  private fft(signal: Float32Array): Float32Array {\n    // Simplified FFT implementation\n    return signal;\n  }\n\n  private findSpectralPeaks(spectrum: Float32Array, sampleRate: number): number[] {\n    // Find spectral peaks for formant detection\n    return [500, 1500, 2500, 3500]; // Placeholder formant values\n  }\n\n  private computeMFCC(window: Float32Array, sampleRate: number, numMFCC: number): number[] {\n    // Simplified MFCC computation\n    return new Array(numMFCC).fill(0).map(() => Math.random() * 0.1 - 0.05);\n  }\n\n  private extractAmplitudeEnvelope(audioData: Float32Array): number[] {\n    const windowSize = 1024;\n    const envelope: number[] = [];\n\n    for (let i = 0; i < audioData.length - windowSize; i += windowSize) {\n      const window = audioData.slice(i, i + windowSize);\n      const rms = Math.sqrt(window.reduce((sum, sample) => sum + sample * sample, 0) / window.length);\n      envelope.push(rms);\n    }\n\n    return envelope;\n  }\n\n  private calculateHarmonicsRatio(audioData: Float32Array, sampleRate: number): number {\n    // Simplified harmonics-to-noise ratio calculation\n    const signal = this.calculateEnergyLevel(audioData);\n    const noise = this.estimateNoiseLevel(audioData);\n    return signal > 0 ? signal / Math.max(noise, 0.001) : 0;\n  }\n\n  private calculateMean(values: number[]): number {\n    return values.length > 0 ? values.reduce((sum, val) => sum + val, 0) / values.length : 0;\n  }\n\n  private calculateStandardDeviation(values: number[]): number {\n    if (values.length === 0) return 0;\n    const mean = this.calculateMean(values);\n    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;\n    return Math.sqrt(variance);\n  }\n\n  private estimateSignalToNoiseRatio(audioData: Float32Array): number {\n    const signal = this.calculateEnergyLevel(audioData);\n    const noise = this.estimateNoiseLevel(audioData);\n    return signal > 0 && noise > 0 ? 20 * Math.log10(signal / noise) : 0;\n  }\n\n  private calculateEnergyLevel(audioData: Float32Array): number {\n    const rms = Math.sqrt(audioData.reduce((sum, sample) => sum + sample * sample, 0) / audioData.length);\n    return Math.min(1.0, rms * 10); // Normalized energy level\n  }\n\n  private estimateNoiseLevel(audioData: Float32Array): number {\n    // Simple noise estimation using minimum energy windows\n    const windowSize = 1024;\n    const energies: number[] = [];\n\n    for (let i = 0; i < audioData.length - windowSize; i += windowSize) {\n      const window = audioData.slice(i, i + windowSize);\n      const energy = window.reduce((sum, sample) => sum + sample * sample, 0) / window.length;\n      energies.push(energy);\n    }\n\n    energies.sort((a, b) => a - b);\n    return Math.sqrt(energies[Math.floor(energies.length * 0.1)]); // 10th percentile as noise estimate\n  }\n\n  private extractSpectralFeatures(audioData: Float32Array, sampleRate: number): any {\n    return {\n      spectralCentroid: this.extractSpectralCentroid(audioData, sampleRate),\n      spectralRolloff: this.calculateSpectralRolloff(audioData, sampleRate),\n      spectralFlux: this.calculateSpectralFlux(audioData, sampleRate)\n    };\n  }\n\n  private extractSpectralCentroid(audioData: Float32Array, sampleRate: number): number[] {\n    // Simplified spectral centroid calculation\n    return [1500, 1600, 1400, 1550]; // Placeholder values\n  }\n\n  private calculateSpectralRolloff(audioData: Float32Array, sampleRate: number): number {\n    return 3000; // Placeholder value\n  }\n\n  private calculateSpectralFlux(audioData: Float32Array, sampleRate: number): number {\n    return 0.5; // Placeholder value\n  }\n\n  private analyzeProsody(audioData: Float32Array, sampleRate: number): any {\n    const pitch = this.extractFundamentalFrequency(audioData, sampleRate);\n    const energy = this.extractAmplitudeEnvelope(audioData);\n\n    return {\n      pitchVariation: pitch.length > 1 ? this.calculateStandardDeviation(pitch) : 0,\n      energyVariation: energy.length > 1 ? this.calculateStandardDeviation(energy) : 0,\n      speakingRate: this.estimateSpeakingRate(audioData, sampleRate)\n    };\n  }\n\n  private classifyMood(energy: number, pitch: number[], spectralFeatures: any, prosody: any): VoiceMoodAnalysis['detectedMood'] {\n    const avgPitch = this.calculateMean(pitch);\n    const pitchVariation = prosody.pitchVariation;\n\n    if (energy > 0.7 && avgPitch > 200 && pitchVariation > 30) return 'excited';\n    if (energy > 0.5 && avgPitch > 180 && pitchVariation > 20) return 'happy';\n    if (energy < 0.3 && avgPitch < 150) return 'sad';\n    if (energy > 0.8 && pitchVariation > 40) return 'angry';\n    if (energy < 0.4 && prosody.speakingRate < 0.5) return 'tired';\n\n    return 'neutral';\n  }\n\n  private calculateMoodConfidence(energy: number, pitch: number[], spectralFeatures: any): number {\n    // Simple confidence calculation based on feature clarity\n    const pitchStability = pitch.length > 1 ? 1 - (this.calculateStandardDeviation(pitch) / this.calculateMean(pitch)) : 0;\n    const energyLevel = Math.min(1.0, energy);\n\n    return (pitchStability * 0.5 + energyLevel * 0.5) * 100;\n  }\n\n  private calculateStressLevel(audioData: Float32Array, sampleRate: number): number {\n    const pitch = this.extractFundamentalFrequency(audioData, sampleRate);\n    const energy = this.calculateEnergyLevel(audioData);\n    const pitchVariation = pitch.length > 1 ? this.calculateStandardDeviation(pitch) / this.calculateMean(pitch) : 0;\n\n    // Higher pitch variation and energy typically indicate stress\n    const stressIndicators = (pitchVariation * 0.6) + (energy * 0.4);\n    return Math.min(1.0, stressIndicators);\n  }\n\n  private generateMoodRecommendations(mood: VoiceMoodAnalysis['detectedMood'], energy: number, stress: number): string[] {\n    const recommendations: string[] = [];\n\n    switch (mood) {\n      case 'tired':\n        recommendations.push('Consider a gentler alarm tone');\n        recommendations.push('Try going to bed earlier tonight');\n        break;\n      case 'stressed':\n      case 'angry':\n        recommendations.push('Use calming voice tones');\n        recommendations.push('Consider stress reduction techniques');\n        break;\n      case 'sad':\n        recommendations.push('Use encouraging, uplifting messages');\n        recommendations.push('Consider motivational alarm content');\n        break;\n      case 'excited':\n      case 'happy':\n        recommendations.push('Current settings seem to work well');\n        recommendations.push('Maintain current sleep schedule');\n        break;\n      default:\n        recommendations.push('Voice analysis complete');\n    }\n\n    if (stress > 0.7) {\n      recommendations.push('High stress detected - consider relaxation exercises');\n    }\n\n    return recommendations;\n  }\n\n  private estimateSpeakingRate(audioData: Float32Array, sampleRate: number): number {\n    // Simplified speaking rate estimation\n    const duration = audioData.length / sampleRate;\n    const energy = this.extractAmplitudeEnvelope(audioData);\n    const activeSpeech = energy.filter(e => e > 0.1).length;\n\n    return activeSpeech / duration; // Rough estimate of speech activity per second\n  }\n\n  private identifyMatchedFeatures(print1: VoicePrint, storedPrints: VoicePrint[]): string[] {\n    const features: string[] = [];\n\n    // This would compare specific features and identify matches\n    features.push('fundamental_frequency');\n    features.push('voice_quality');\n\n    return features;\n  }\n\n  private assessRiskLevel(confidence: number, matchedFeatures: string[]): VoiceAuthentication['riskLevel'] {\n    if (confidence > 90 && matchedFeatures.length > 3) return 'low';\n    if (confidence > 70 && matchedFeatures.length > 2) return 'medium';\n    return 'high';\n  }\n\n  private compareMFCCFeatures(mfcc1: number[][], mfcc2: number[][]): number {\n    // Simplified MFCC comparison\n    return Math.random() * 0.3 + 0.5; // Placeholder similarity\n  }\n\n  private compareVoiceQuality(quality1: any, quality2: any): number {\n    const jitterSim = 1 - Math.abs(quality1.jitter - quality2.jitter) / Math.max(quality1.jitter, quality2.jitter, 0.01);\n    const shimmerSim = 1 - Math.abs(quality1.shimmer - quality2.shimmer) / Math.max(quality1.shimmer, quality2.shimmer, 0.01);\n    const harmonicsSim = 1 - Math.abs(quality1.harmonicsRatio - quality2.harmonicsRatio) / Math.max(quality1.harmonicsRatio, quality2.harmonicsRatio, 0.01);\n\n    return (jitterSim + shimmerSim + harmonicsSim) / 3;\n  }\n\n  private generateTrainingNextSteps(sessions: VoiceTrainingSession[], prints: VoicePrint[]): string[] {\n    const steps: string[] = [];\n\n    if (sessions.length === 0) {\n      steps.push('Complete your first voice training session');\n    } else if (sessions.length < 3) {\n      steps.push('Complete more training sessions for better accuracy');\n    } else if (prints.length < 10) {\n      steps.push('Record more voice samples in different environments');\n    } else {\n      steps.push('Voice training is complete - excellent accuracy achieved');\n    }\n\n    return steps;\n  }\n\n  private async storeVoicePrint(voicePrint: VoicePrint): Promise<void> {\n    try {\n      const { error } = await SupabaseService.getInstance().client\n        .from('voice_prints')\n        .insert({\n          user_id: voicePrint.userId,\n          features: voicePrint.features,\n          confidence: voicePrint.confidence,\n          language: voicePrint.language,\n          accent: voicePrint.accent,\n          emotion: voicePrint.emotion,\n          recorded_at: voicePrint.recordedAt.toISOString()\n        });\n\n      if (error) throw error;\n    } catch (error) {\n      console.error('Failed to store voice print:', error);\n    }\n  }\n\n  private async logAuthenticationAttempt(auth: VoiceAuthentication): Promise<void> {\n    try {\n      const { error } = await SupabaseService.getInstance().client\n        .from('voice_authentication_logs')\n        .insert({\n          user_id: auth.userId,\n          authenticated: auth.authenticated,\n          confidence: auth.confidence,\n          matched_features: auth.matchedFeatures,\n          risk_level: auth.riskLevel,\n          timestamp: auth.timestamp.toISOString()\n        });\n\n      if (error) throw error;\n    } catch (error) {\n      console.error('Failed to log authentication attempt:', error);\n    }\n  }\n}\n\nexport default VoiceBiometricsService;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/voice-pro.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SpeechRecognition' is not defined.",
        "line": 63,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 63,
        "endColumn": 48
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SpeechRecognitionEvent' is not defined.",
        "line": 539,
        "column": 41,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 539,
        "endColumn": 63
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SpeechRecognitionErrorEvent' is not defined.",
        "line": 559,
        "column": 40,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 559,
        "endColumn": 67
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference types=\"node\" />\n/// <reference lib=\"dom\" />\nimport type { Alarm, VoiceMood } from \"../types\";\nimport { formatTime } from \"../utils\";\n\n// Enhanced voice configuration types\nexport interface VoiceProvider {\n  id: string;\n  name: string;\n  type: 'web-speech' | 'elevenlabs' | 'google-cloud' | 'azure' | 'amazon-polly';\n  premium: boolean;\n  languages: string[];\n  voices: VoiceOption[];\n}\n\nexport interface VoiceOption {\n  id: string;\n  name: string;\n  gender: 'male' | 'female' | 'neutral';\n  accent?: string;\n  preview?: string; // URL to preview audio\n  quality: 'standard' | 'high' | 'premium';\n  category: 'natural' | 'expressive' | 'professional' | 'casual';\n}\n\nexport interface VoiceSettings {\n  provider: string;\n  voiceId: string;\n  speed: number; // 0.5 - 2.0\n  pitch: number; // 0.5 - 2.0\n  volume: number; // 0.0 - 1.0\n  stability?: number; // For ElevenLabs (0.0 - 1.0)\n  clarity?: number; // For ElevenLabs (0.0 - 1.0)\n  style?: number; // For some providers (0.0 - 1.0)\n}\n\nexport interface CachedVoiceMessage {\n  id: string;\n  alarmId: string;\n  voiceMood: VoiceMood;\n  audioUrl: string;\n  text: string;\n  duration: number;\n  createdAt: Date;\n  expiresAt: Date;\n  provider: string;\n  settings: VoiceSettings;\n}\n\nexport interface RecognitionResult {\n  transcript: string;\n  confidence: number;\n  isFinal: boolean;\n  intent?: 'dismiss' | 'snooze' | 'unknown';\n  entities?: { [key: string]: string };\n}\n\nexport class VoiceProService {\n  private static audioCache = new Map<string, CachedVoiceMessage>();\n  private static isInitialized = false;\n  private static currentUtterance: SpeechSynthesisUtterance | null = null;\n  private static repeatInterval: number | null = null;\n  private static recognition: SpeechRecognition | null = null;\n\n  // Provider configurations\n  private static providers: VoiceProvider[] = [\n    {\n      id: 'web-speech',\n      name: 'Browser Speech',\n      type: 'web-speech',\n      premium: false,\n      languages: ['en-US', 'en-GB', 'es-ES', 'fr-FR', 'de-DE', 'it-IT', 'ja-JP', 'ko-KR', 'zh-CN'],\n      voices: [] // Populated dynamically\n    },\n    {\n      id: 'elevenlabs',\n      name: 'ElevenLabs',\n      type: 'elevenlabs',\n      premium: true,\n      languages: ['en-US', 'en-GB', 'es-ES', 'fr-FR', 'de-DE', 'it-IT', 'pl-PL', 'pt-BR'],\n      voices: [\n        { id: '21m00Tcm4TlvDq8ikWAM', name: 'Rachel', gender: 'female', quality: 'premium', category: 'natural' },\n        { id: 'AZnzlk1XvdvUeBnXmlld', name: 'Domi', gender: 'female', quality: 'premium', category: 'expressive' },\n        { id: 'EXAVITQu4vr4xnSDxMaL', name: 'Bella', gender: 'female', quality: 'premium', category: 'professional' },\n        { id: 'ErXwobaYiN019PkySvjV', name: 'Antoni', gender: 'male', quality: 'premium', category: 'natural' },\n        { id: 'VR6AewLTigWG4xSOukaG', name: 'Arnold', gender: 'male', quality: 'premium', category: 'expressive' },\n        { id: 'pNInz6obpgDQGcFmaJgB', name: 'Adam', gender: 'male', quality: 'premium', category: 'professional' },\n        { id: 'yoZ06aMxZJJ28mfd3POQ', name: 'Sam', gender: 'neutral', quality: 'premium', category: 'casual' }\n      ]\n    }\n  ];\n\n  // Voice mood to voice ID mapping for different providers\n  private static moodVoiceMappings: { [mood in VoiceMood]: { [provider: string]: string } } = {\n    'drill-sergeant': {\n      'elevenlabs': 'VR6AewLTigWG4xSOukaG', // Arnold - expressive male\n      'web-speech': 'male'\n    },\n    'sweet-angel': {\n      'elevenlabs': '21m00Tcm4TlvDq8ikWAM', // Rachel - natural female\n      'web-speech': 'female'\n    },\n    'anime-hero': {\n      'elevenlabs': 'AZnzlk1XvdvUeBnXmlld', // Domi - expressive female\n      'web-speech': 'female'\n    },\n    'savage-roast': {\n      'elevenlabs': 'ErXwobaYiN019PkySvjV', // Antoni - natural male\n      'web-speech': 'male'\n    },\n    'motivational': {\n      'elevenlabs': 'pNInz6obpgDQGcFmaJgB', // Adam - professional male\n      'web-speech': 'male'\n    },\n    'gentle': {\n      'elevenlabs': 'EXAVITQu4vr4xnSDxMaL', // Bella - professional female\n      'web-speech': 'female'\n    }\n  };\n\n  static async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      // Initialize web speech voices\n      await this.loadWebSpeechVoices();\n\n      // Check for premium voice service API keys\n      const elevenLabsKey = localStorage.getItem('elevenlabs_api_key');\n      if (elevenLabsKey) {\n        await this.validateElevenLabsKey(elevenLabsKey);\n      }\n\n      // Initialize voice recognition\n      this.initializeRecognition();\n\n      // Load cached voice messages from IndexedDB\n      await this.loadCachedMessages();\n\n      this.isInitialized = true;\n      console.log('Voice Pro service initialized successfully');\n    } catch (error) {\n      console.error('Error initializing Voice Pro service:', error);\n      this.isInitialized = true; // Continue with fallback\n    }\n  }\n\n  private static async loadWebSpeechVoices(): Promise<void> {\n    if (!('speechSynthesis' in window)) return;\n\n    // Wait for voices to load\n    if (speechSynthesis.getVoices().length === 0) {\n      await new Promise<void>(resolve => {\n        const checkVoices = () => {\n          if (speechSynthesis.getVoices().length > 0) {\n            resolve();\n          } else {\n            setTimeout(checkVoices, 100);\n          }\n        };\n        speechSynthesis.addEventListener('voiceschanged', () => resolve(), { once: true });\n        checkVoices();\n      });\n    }\n\n    // Update web speech provider with available voices\n    const webProvider = this.providers.find(p => p.id === 'web-speech');\n    if (webProvider) {\n      const voices = speechSynthesis.getVoices();\n      webProvider.voices = voices.map((voice, index) => ({\n        id: voice.voiceURI || `voice_${index}`,\n        name: voice.name,\n        gender: this.detectGender(voice.name),\n        quality: voice.localService ? 'high' : 'standard',\n        category: 'natural' as const\n      }));\n    }\n  }\n\n  private static detectGender(voiceName: string): 'male' | 'female' | 'neutral' {\n    const name = voiceName.toLowerCase();\n    const femaleIndicators = ['female', 'woman', 'samantha', 'victoria', 'karen', 'zira', 'susan', 'fiona'];\n    const maleIndicators = ['male', 'man', 'david', 'mark', 'daniel', 'alex', 'james'];\n\n    if (femaleIndicators.some(indicator => name.includes(indicator))) return 'female';\n    if (maleIndicators.some(indicator => name.includes(indicator))) return 'male';\n    return 'neutral';\n  }\n\n  private static async validateElevenLabsKey(apiKey: string): Promise<boolean> {\n    try {\n      const response = await fetch('https://api.elevenlabs.io/v1/user', {\n        headers: {\n          'xi-api-key': apiKey\n        }\n      });\n      return response.ok;\n    } catch (error) {\n      console.error('Error validating ElevenLabs API key:', error);\n      return false;\n    }\n  }\n\n  private static initializeRecognition(): void {\n    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {\n      console.warn('Speech recognition not supported');\n      return;\n    }\n\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n    this.recognition = new SpeechRecognition();\n\n    this.recognition.continuous = true;\n    this.recognition.interimResults = true;\n    this.recognition.maxAlternatives = 3;\n    this.recognition.lang = 'en-US';\n  }\n\n  private static async loadCachedMessages(): Promise<void> {\n    try {\n      // Load cached messages from IndexedDB (implementation would go here)\n      // For now, using localStorage as fallback\n      const cached = localStorage.getItem('voice_cache');\n      if (cached) {\n        const messages: CachedVoiceMessage[] = JSON.parse(cached);\n        messages.forEach(msg => {\n          if (new Date() < msg.expiresAt) {\n            this.audioCache.set(this.getCacheKey(msg.alarmId, msg.voiceMood), msg);\n          }\n        });\n        console.log(`Loaded ${messages.length} cached voice messages`);\n      }\n    } catch (error) {\n      console.error('Error loading cached messages:', error);\n    }\n  }\n\n  static async generateAlarmMessage(alarm: Alarm, forceRegenerate = false): Promise<string | null> {\n    await this.initialize();\n\n    const cacheKey = this.getCacheKey(alarm.id, alarm.voiceMood);\n\n    // Check cache first (unless forcing regeneration)\n    if (!forceRegenerate && this.audioCache.has(cacheKey)) {\n      const cached = this.audioCache.get(cacheKey)!;\n      if (new Date() < cached.expiresAt) {\n        return cached.audioUrl;\n      } else {\n        this.audioCache.delete(cacheKey);\n      }\n    }\n\n    try {\n      const message = this.generateMessageText(alarm);\n      const settings = this.getVoiceSettingsForMood(alarm.voiceMood);\n\n      // Try premium providers first, fall back to web speech\n      const providers = ['elevenlabs', 'web-speech'];\n\n      for (const providerId of providers) {\n        try {\n          const audioUrl = await this.generateSpeech(message, settings, providerId);\n          if (audioUrl) {\n            // Cache the result\n            const cachedMessage: CachedVoiceMessage = {\n              id: this.generateId(),\n              alarmId: alarm.id,\n              voiceMood: alarm.voiceMood,\n              audioUrl,\n              text: message,\n              duration: this.estimateDuration(message),\n              createdAt: new Date(),\n              expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000), // 24 hours\n              provider: providerId,\n              settings\n            };\n\n            this.audioCache.set(cacheKey, cachedMessage);\n            await this.persistCache();\n\n            return audioUrl;\n          }\n        } catch (error) {\n          console.error(`Error generating speech with ${providerId}:`, error);\n          continue; // Try next provider\n        }\n      }\n    } catch (error) {\n      console.error('Error generating alarm message:', error);\n    }\n\n    return null;\n  }\n\n  private static async generateSpeech(text: string, settings: VoiceSettings, providerId: string): Promise<string | null> {\n    switch (providerId) {\n      case 'elevenlabs':\n        return await this.generateElevenLabsSpeech(text, settings);\n      case 'web-speech':\n        return await this.generateWebSpeech(text, settings);\n      default:\n        return null;\n    }\n  }\n\n  private static async generateElevenLabsSpeech(text: string, settings: VoiceSettings): Promise<string | null> {\n    const apiKey = localStorage.getItem('elevenlabs_api_key');\n    if (!apiKey) {\n      throw new Error('ElevenLabs API key not found');\n    }\n\n    try {\n      const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${settings.voiceId}`, {\n        method: 'POST',\n        headers: {\n          'Accept': 'audio/mpeg',\n          'Content-Type': 'application/json',\n          'xi-api-key': apiKey\n        },\n        body: JSON.stringify({\n          text,\n          model_id: 'eleven_monolingual_v1',\n          voice_settings: {\n            stability: settings.stability || 0.5,\n            similarity_boost: settings.clarity || 0.5,\n            style: settings.style || 0.0,\n            use_speaker_boost: true\n          }\n        })\n      });\n\n      if (!response.ok) {\n        throw new Error(`ElevenLabs API error: ${response.status}`);\n      }\n\n      const audioBlob = await response.blob();\n      return URL.createObjectURL(audioBlob);\n    } catch (error) {\n      console.error('ElevenLabs generation failed:', error);\n      return null;\n    }\n  }\n\n  private static async generateWebSpeech(text: string, settings: VoiceSettings): Promise<string | null> {\n    if (!('speechSynthesis' in window)) {\n      return null;\n    }\n\n    // For web speech, we can't generate audio URLs, so we return a special identifier\n    // The actual speech will be played directly using speechSynthesis.speak()\n    return `web-speech:${btoa(text)}:${JSON.stringify(settings)}`;\n  }\n\n  static async playAlarmMessage(alarm: Alarm): Promise<boolean> {\n    await this.initialize();\n\n    try {\n      const audioUrl = await this.generateAlarmMessage(alarm);\n      if (!audioUrl) {\n        return false;\n      }\n\n      if (audioUrl.startsWith('web-speech:')) {\n        // Handle web speech directly\n        return await this.playWebSpeech(audioUrl);\n      } else {\n        // Handle audio URL (from premium providers)\n        return await this.playAudioUrl(audioUrl);\n      }\n    } catch (error) {\n      console.error('Error playing alarm message:', error);\n      return false;\n    }\n  }\n\n  private static async playWebSpeech(encodedData: string): Promise<boolean> {\n    try {\n      const parts = encodedData.split(':');\n      const text = atob(parts[1]);\n      const settings: VoiceSettings = JSON.parse(parts[2]);\n\n      speechSynthesis.cancel(); // Stop any existing speech\n\n      const utterance = new SpeechSynthesisUtterance(text);\n      this.configureWebSpeechUtterance(utterance, settings);\n\n      return new Promise(resolve => {\n        utterance.onend = () => resolve(true);\n        utterance.onerror = () => resolve(false);\n\n        speechSynthesis.speak(utterance);\n        this.currentUtterance = utterance;\n\n        // Fallback timeout\n        setTimeout(() => resolve(false), 15000);\n      });\n    } catch (error) {\n      console.error('Error playing web speech:', error);\n      return false;\n    }\n  }\n\n  private static async playAudioUrl(url: string): Promise<boolean> {\n    try {\n      const audio = new Audio(url);\n\n      return new Promise(resolve => {\n        audio.onended = () => resolve(true);\n        audio.onerror = () => resolve(false);\n        audio.oncanplaythrough = () => {\n          audio.play().catch(() => resolve(false));\n        };\n\n        audio.load();\n\n        // Fallback timeout\n        setTimeout(() => {\n          audio.pause();\n          resolve(false);\n        }, 30000);\n      });\n    } catch (error) {\n      console.error('Error playing audio URL:', error);\n      return false;\n    }\n  }\n\n  static async startRepeatingAlarmMessage(alarm: Alarm, intervalMs: number = 30000): Promise<() => void> {\n    await this.initialize();\n\n    let isActive = true;\n\n    const playMessage = async () => {\n      if (!isActive) return;\n\n      try {\n        await this.playAlarmMessage(alarm);\n      } catch (error) {\n        console.error('Error playing repeating message:', error);\n      }\n    };\n\n    // Play immediately\n    playMessage();\n\n    // Set up interval for repeated playback\n    this.repeatInterval = setInterval(() => {\n      if (isActive) {\n        playMessage();\n      } else {\n        clearInterval(this.repeatInterval!);\n        this.repeatInterval = null;\n      }\n    }, intervalMs);\n\n    // Return stop function\n    return () => {\n      isActive = false;\n      if (this.repeatInterval) {\n        clearInterval(this.repeatInterval);\n        this.repeatInterval = null;\n      }\n      this.stopSpeech();\n    };\n  }\n\n  static generateMessageText(alarm: Alarm): string {\n    const time = formatTime(alarm.time);\n    const label = alarm.label;\n\n    const templates = {\n      'drill-sergeant': [\n        `WAKE UP SOLDIER! It's ${time}! ${label}! NO EXCUSES!`,\n        `DROP AND GIVE ME TWENTY! It's ${time} and time for ${label}!`,\n        `MOVE IT MOVE IT! ${time} means ${label} time! GET UP NOW!`,\n        `ATTENTION! ${time} HOURS! Time for ${label}! MOVE YOUR BODY!`,\n        `RISE AND GRIND WARRIOR! It's ${time}! ${label} awaits! NO SNOOZING!`\n      ],\n      'sweet-angel': [\n        `Good morning sunshine! It's ${time} and time for ${label}. Have a beautiful day!`,\n        `Rise and shine, dear! It's ${time}. Time to start your wonderful day with ${label}.`,\n        `Sweet dreams are over! It's ${time} and your ${label} awaits. You've got this!`,\n        `Hello beautiful! It's ${time}. Time to embrace the day with ${label}. Sending you love!`,\n        `Wake up sweetie! It's ${time} and ${label} is calling. You're amazing!`\n      ],\n      'anime-hero': [\n        `The power of friendship compels you! It's ${time}! Time for ${label}! Believe in yourself!`,\n        `Your destiny awaits! It's ${time} and ${label} is calling! Never give up!`,\n        `Transform and roll out! It's ${time}! Time to conquer ${label} with the power of determination!`,\n        `The world needs you! It's ${time}! ${label} is your quest! Fight on!`,\n        `Unlock your true potential! It's ${time}! ${label} will make you stronger! Plus ultra!`\n      ],\n      'savage-roast': [\n        `Oh look, sleeping beauty finally decided to join us. It's ${time} and your ${label} is waiting.`,\n        `Well well well, it's ${time}. Time for ${label}. Hope you enjoyed your beauty sleep because you need it.`,\n        `Rise and grind, sunshine. It's ${time} and ${label} won't do itself. Time to adult.`,\n        `Congratulations on being fashionably late to ${time}. Your ${label} is judging you.`,\n        `Hey sleepyhead, it's ${time}. ${label} called, it wants to know if you're still interested.`\n      ],\n      'motivational': [\n        `Champions rise early! It's ${time} and time for ${label}! Today is your day to shine!`,\n        `Success starts now! It's ${time}! Your ${label} is the first step to greatness!`,\n        `Winners don't snooze! It's ${time}! Time to crush ${label} and own this day!`,\n        `Every legend started with an alarm! It's ${time}! ${label} is your moment!`,\n        `The grind starts now! It's ${time}! ${label} is calling your name! Let's go!`\n      ],\n      'gentle': [\n        `Good morning! It's ${time}. Take your time, but please remember ${label} when you're ready.`,\n        `Gentle wake-up call: it's ${time}. Your ${label} is waiting, but no rush.`,\n        `Sweet morning! It's ${time} and time for ${label}. Hope you slept well.`,\n        `Peaceful morning! It's ${time}. ${label} is gently calling. Rest well, then rise.`,\n        `Soft reminder: it's ${time}. ${label} is here when you're ready. Take care.`\n      ]\n    };\n\n    const moodTemplates = templates[alarm.voiceMood] || templates['motivational'];\n    const randomIndex = Math.floor(Math.random() * moodTemplates.length);\n\n    return moodTemplates[randomIndex];\n  }\n\n  static async startVoiceRecognition(\n    onResult: (result: RecognitionResult) => void,\n    onError?: (error: string) => void\n  ): Promise<() => void> {\n    await this.initialize();\n\n    if (!this.recognition) {\n      onError?.('Speech recognition not supported');\n      return () => {};\n    }\n\n    let isActive = true;\n\n    this.recognition.onstart = () => {\n      console.log('Voice recognition started');\n    };\n\n    this.recognition.onresult = (event: SpeechRecognitionEvent) => {\n      if (!isActive) return;\n\n      for (let i = event.resultIndex; i < event.results.length; i++) {\n        const result = event.results[i];\n        const transcript = result[0].transcript.toLowerCase().trim();\n        const confidence = result[0].confidence;\n\n        const recognitionResult: RecognitionResult = {\n          transcript,\n          confidence,\n          isFinal: result.isFinal,\n          intent: this.parseIntent(transcript),\n          entities: this.extractEntities(transcript)\n        };\n\n        onResult(recognitionResult);\n      }\n    };\n\n    this.recognition.onerror = (event: SpeechRecognitionErrorEvent) => {\n      console.error('Speech recognition error:', event.error);\n      onError?.(event.error);\n    };\n\n    this.recognition.onend = () => {\n      if (isActive) {\n        // Auto-restart recognition if still active\n        setTimeout(() => {\n          if (isActive && this.recognition) {\n            try {\n              this.recognition.start();\n            } catch (error) {\n              console.error('Error restarting recognition:', error);\n            }\n          }\n        }, 1000);\n      }\n    };\n\n    try {\n      this.recognition.start();\n    } catch (error) {\n      console.error('Error starting recognition:', error);\n      onError?.('Failed to start recognition');\n    }\n\n    // Return stop function\n    return () => {\n      isActive = false;\n      if (this.recognition) {\n        this.recognition.stop();\n      }\n    };\n  }\n\n  private static parseIntent(transcript: string): 'dismiss' | 'snooze' | 'unknown' {\n    const dismissWords = ['stop', 'dismiss', 'turn off', 'shut up', 'quiet', 'cancel', 'end', 'off'];\n    const snoozeWords = ['snooze', 'five more minutes', 'later', 'wait', 'sleep', 'more time'];\n\n    if (dismissWords.some(word => transcript.includes(word))) {\n      return 'dismiss';\n    }\n    if (snoozeWords.some(word => transcript.includes(word))) {\n      return 'snooze';\n    }\n    return 'unknown';\n  }\n\n  private static extractEntities(transcript: string): { [key: string]: string } {\n    const entities: { [key: string]: string } = {};\n\n    // Extract time mentions\n    const timeMatch = transcript.match(/(\\d+)\\s*(minute|minutes|hour|hours)/i);\n    if (timeMatch) {\n      entities.duration = timeMatch[0];\n    }\n\n    return entities;\n  }\n\n  private static getVoiceSettingsForMood(mood: VoiceMood): VoiceSettings {\n    const baseSettings: { [mood in VoiceMood]: Partial<VoiceSettings> } = {\n      'drill-sergeant': {\n        speed: 1.3,\n        pitch: 0.7,\n        volume: 1.0,\n        stability: 0.8,\n        clarity: 0.9\n      },\n      'sweet-angel': {\n        speed: 0.9,\n        pitch: 1.3,\n        volume: 0.8,\n        stability: 0.6,\n        clarity: 0.8\n      },\n      'anime-hero': {\n        speed: 1.2,\n        pitch: 1.2,\n        volume: 1.0,\n        stability: 0.4,\n        clarity: 0.9\n      },\n      'savage-roast': {\n        speed: 1.0,\n        pitch: 0.9,\n        volume: 0.9,\n        stability: 0.7,\n        clarity: 0.7\n      },\n      'motivational': {\n        speed: 1.1,\n        pitch: 1.0,\n        volume: 1.0,\n        stability: 0.8,\n        clarity: 0.9\n      },\n      'gentle': {\n        speed: 0.8,\n        pitch: 1.1,\n        volume: 0.6,\n        stability: 0.9,\n        clarity: 0.6\n      }\n    };\n\n    const defaultProvider = localStorage.getItem('preferred_voice_provider') || 'elevenlabs';\n    const voiceMapping = this.moodVoiceMappings[mood];\n    const voiceId = voiceMapping[defaultProvider] || voiceMapping['elevenlabs'];\n\n    return {\n      provider: defaultProvider,\n      voiceId,\n      ...baseSettings[mood]\n    } as VoiceSettings;\n  }\n\n  private static configureWebSpeechUtterance(utterance: SpeechSynthesisUtterance, settings: VoiceSettings): void {\n    const voices = speechSynthesis.getVoices();\n\n    utterance.rate = settings.speed;\n    utterance.pitch = settings.pitch;\n    utterance.volume = settings.volume;\n\n    // Try to find the preferred voice\n    if (settings.voiceId && settings.voiceId !== 'male' && settings.voiceId !== 'female') {\n      const voice = voices.find(v => v.voiceURI === settings.voiceId || v.name === settings.voiceId);\n      if (voice) {\n        utterance.voice = voice;\n        return;\n      }\n    }\n\n    // Fallback to gender-based selection\n    const gender = settings.voiceId as 'male' | 'female';\n    if (gender === 'female') {\n      const femaleVoice = voices.find(voice =>\n        this.detectGender(voice.name) === 'female'\n      );\n      if (femaleVoice) utterance.voice = femaleVoice;\n    } else if (gender === 'male') {\n      const maleVoice = voices.find(voice =>\n        this.detectGender(voice.name) === 'male'\n      );\n      if (maleVoice) utterance.voice = maleVoice;\n    }\n  }\n\n  static stopSpeech(): void {\n    if ('speechSynthesis' in window) {\n      speechSynthesis.cancel();\n    }\n    this.currentUtterance = null;\n\n    if (this.repeatInterval) {\n      clearInterval(this.repeatInterval);\n      this.repeatInterval = null;\n    }\n  }\n\n  static async testVoice(mood: VoiceMood): Promise<void> {\n    await this.initialize();\n\n    const testAlarm: Alarm = {\n      id: 'test',\n      time: '07:00',\n      label: 'Morning Workout',\n      enabled: true,\n      days: [1, 2, 3, 4, 5],\n      voiceMood: mood,\n      snoozeCount: 0,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n\n    await this.playAlarmMessage(testAlarm);\n  }\n\n  static getProviders(): VoiceProvider[] {\n    return this.providers;\n  }\n\n  static getVoicesForMood(mood: VoiceMood): VoiceOption[] {\n    const mapping = this.moodVoiceMappings[mood];\n    const voices: VoiceOption[] = [];\n\n    Object.entries(mapping).forEach(([providerId, voiceId]) => {\n      const provider = this.providers.find(p => p.id === providerId);\n      if (provider) {\n        const voice = provider.voices.find(v => v.id === voiceId);\n        if (voice) {\n          voices.push(voice);\n        }\n      }\n    });\n\n    return voices;\n  }\n\n  static async clearCache(): Promise<void> {\n    this.audioCache.clear();\n    localStorage.removeItem('voice_cache');\n\n    // Clear blob URLs to free memory\n    this.audioCache.forEach(cached => {\n      if (cached.audioUrl.startsWith('blob:')) {\n        URL.revokeObjectURL(cached.audioUrl);\n      }\n    });\n  }\n\n  static async setApiKey(provider: string, apiKey: string): Promise<boolean> {\n    try {\n      localStorage.setItem(`${provider}_api_key`, apiKey);\n\n      // Validate the key\n      if (provider === 'elevenlabs') {\n        return await this.validateElevenLabsKey(apiKey);\n      }\n\n      return true;\n    } catch (error) {\n      console.error('Error setting API key:', error);\n      return false;\n    }\n  }\n\n  // Helper methods\n  private static getCacheKey(alarmId: string, voiceMood: VoiceMood): string {\n    return `${alarmId}_${voiceMood}`;\n  }\n\n  private static generateId(): string {\n    return Math.random().toString(36).substring(2) + Date.now().toString(36);\n  }\n\n  private static estimateDuration(text: string): number {\n    // Rough estimation: ~150 words per minute for speech\n    const words = text.split(' ').length;\n    return Math.ceil((words / 150) * 60 * 1000); // milliseconds\n  }\n\n  private static async persistCache(): Promise<void> {\n    try {\n      const cacheData = Array.from(this.audioCache.values());\n      localStorage.setItem('voice_cache', JSON.stringify(cacheData));\n    } catch (error) {\n      console.error('Error persisting cache:', error);\n    }\n  }\n}\n\n// Export main service\nexport const VoiceService = VoiceProService;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/services/voice-recognition.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SpeechRecognition' is not defined.",
        "line": 22,
        "column": 31,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 22,
        "endColumn": 48
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { VoiceProService, RecognitionResult } from './voice-pro';\n\nexport interface VoiceCommand {\n  command: string;\n  confidence: number;\n  intent: 'dismiss' | 'snooze' | 'unknown';\n  entities: { [key: string]: string };\n  timestamp: Date;\n}\n\nexport interface RecognitionConfig {\n  language: string;\n  continuous: boolean;\n  interimResults: boolean;\n  maxAlternatives: number;\n  confidenceThreshold: number;\n  noiseReduction: boolean;\n  adaptiveThreshold: boolean;\n}\n\nexport class VoiceRecognitionService {\n  private static recognition: SpeechRecognition | null = null;\n  private static isListening = false;\n  private static config: RecognitionConfig = {\n    language: 'en-US',\n    continuous: true,\n    interimResults: true,\n    maxAlternatives: 3,\n    confidenceThreshold: 0.6,\n    noiseReduction: true,\n    adaptiveThreshold: true\n  };\n\n  // Enhanced command patterns with context awareness\n  private static commandPatterns = {\n    dismiss: {\n      exact: [\n        'stop', 'stop alarm', 'turn off', 'turn off alarm', 'dismiss', 'dismiss alarm',\n        'shut up', 'quiet', 'silence', 'cancel', 'cancel alarm', 'end', 'end alarm',\n        'off', 'alarm off', 'no more', 'enough', 'wake up', 'im up', \"i'm up\",\n        'ok', 'okay', 'alright', 'fine', 'done', 'finished'\n      ],\n      patterns: [\n        /^(stop|turn off|shut up|dismiss|cancel|end)\\s*(the\\s*)?(alarm|ringing)?$/i,\n        /^(ok|okay|alright|fine)\\s*(i'm?\\s*)?(up|awake|ready)$/i,\n        /^(enough|no more)\\s*(alarm|noise|sound)?$/i,\n        /^(silence|quiet)\\s*(please|now)?$/i\n      ]\n    },\n    snooze: {\n      exact: [\n        'snooze', 'snooze alarm', 'five more minutes', 'five minutes', '5 minutes',\n        'five more', '5 more', 'later', 'wait', 'sleep', 'more time',\n        'not yet', 'too early', 'few more minutes', 'bit longer', 'little longer',\n        'postpone', 'delay', 'reschedule'\n      ],\n      patterns: [\n        /^(snooze|postpone|delay)\\s*(the\\s*)?(alarm|for)?$/i,\n        /^(\\d+|five|ten|fifteen)\\s*(more\\s*)?(minutes?)$/i,\n        /^(later|wait|sleep)\\s*(please|a bit|some more)?$/i,\n        /^(not yet|too early)\\s*(please)?$/i,\n        /^(few|bit|little)\\s*(more\\s*)?(minutes?|time)$/i\n      ]\n    }\n  };\n\n  // Context-aware thresholds\n  private static confidenceThresholds = {\n    dismiss: 0.65, // Higher threshold for dismissing\n    snooze: 0.60,  // Lower threshold for snoozing\n    unknown: 0.40  // Fallback threshold\n  };\n\n  // Adaptive learning data\n  private static commandHistory: VoiceCommand[] = [];\n  private static userPreferences = {\n    preferredCommands: new Map<string, number>(),\n    avgConfidence: new Map<string, number>(),\n    timeOfDayPatterns: new Map<string, string[]>()\n  };\n\n  static async initialize(config?: Partial<RecognitionConfig>): Promise<boolean> {\n    try {\n      if (config) {\n        this.config = { ...this.config, ...config };\n      }\n\n      // Load user preferences\n      await this.loadUserPreferences();\n\n      return true;\n    } catch (error) {\n      console.error('Error initializing voice recognition:', error);\n      return false;\n    }\n  }\n\n  static async startListening(\n    onCommand: (command: VoiceCommand) => void,\n    onInterim?: (transcript: string, confidence: number) => void,\n    onError?: (error: string) => void\n  ): Promise<() => void> {\n    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {\n      onError?.('Speech recognition not supported in this browser');\n      return () => {};\n    }\n\n    // Initialize voice recognition through VoiceProService\n    const stopRecognition = await VoiceProService.startVoiceRecognition(\n      (result: RecognitionResult) => {\n        this.processRecognitionResult(result, onCommand, onInterim);\n      },\n      onError\n    );\n\n    this.isListening = true;\n    return () => {\n      this.isListening = false;\n      stopRecognition();\n    };\n  }\n\n  private static processRecognitionResult(\n    result: RecognitionResult,\n    onCommand: (command: VoiceCommand) => void,\n    onInterim?: (transcript: string, confidence: number) => void\n  ): void {\n    const { transcript, confidence, isFinal } = result;\n\n    // Handle interim results\n    if (!isFinal && onInterim) {\n      onInterim(transcript, confidence);\n      return;\n    }\n\n    // Only process final results with sufficient confidence\n    const minConfidence = this.getAdaptiveConfidence(transcript);\n    if (!isFinal || confidence < minConfidence) {\n      return;\n    }\n\n    // Enhanced command parsing\n    const command = this.parseEnhancedCommand(transcript, confidence);\n\n    if (command.intent !== 'unknown') {\n      // Log successful command\n      this.logCommand(command);\n\n      // Update user preferences\n      this.updateUserPreferences(command);\n\n      // Execute command\n      onCommand(command);\n    }\n  }\n\n  private static parseEnhancedCommand(transcript: string, confidence: number): VoiceCommand {\n    const cleanTranscript = transcript.toLowerCase().trim();\n\n    // Try exact matches first\n    for (const [intent, patterns] of Object.entries(this.commandPatterns)) {\n      const intentKey = intent as 'dismiss' | 'snooze';\n\n      // Check exact matches\n      if (patterns.exact.some(exact => cleanTranscript === exact || cleanTranscript.endsWith(exact))) {\n        return {\n          command: transcript,\n          confidence: Math.min(confidence * 1.1, 1.0), // Boost confidence for exact matches\n          intent: intentKey,\n          entities: this.extractEntities(cleanTranscript),\n          timestamp: new Date()\n        };\n      }\n\n      // Check pattern matches\n      for (const pattern of patterns.patterns) {\n        if (pattern.test(cleanTranscript)) {\n          return {\n            command: transcript,\n            confidence: Math.min(confidence * 1.05, 1.0), // Slight confidence boost for patterns\n            intent: intentKey,\n            entities: this.extractEntities(cleanTranscript),\n            timestamp: new Date()\n          };\n        }\n      }\n    }\n\n    // Fuzzy matching for common variations\n    const fuzzyMatch = this.performFuzzyMatching(cleanTranscript);\n    if (fuzzyMatch) {\n      return {\n        command: transcript,\n        confidence: confidence * 0.9, // Slightly reduce confidence for fuzzy matches\n        intent: fuzzyMatch.intent,\n        entities: this.extractEntities(cleanTranscript),\n        timestamp: new Date()\n      };\n    }\n\n    // Check user's historical preferences\n    const historicalMatch = this.checkHistoricalPatterns(cleanTranscript);\n    if (historicalMatch) {\n      return {\n        command: transcript,\n        confidence: confidence * 0.85, // Reduce confidence for historical matches\n        intent: historicalMatch,\n        entities: this.extractEntities(cleanTranscript),\n        timestamp: new Date()\n      };\n    }\n\n    return {\n      command: transcript,\n      confidence,\n      intent: 'unknown',\n      entities: {},\n      timestamp: new Date()\n    };\n  }\n\n  private static performFuzzyMatching(transcript: string): { intent: 'dismiss' | 'snooze' } | null {\n    const dismissWords = ['stop', 'off', 'end', 'done', 'up', 'awake', 'ready'];\n    const snoozeWords = ['more', 'minutes', 'later', 'wait', 'sleep', 'postpone'];\n\n    const words = transcript.split(' ');\n    let dismissScore = 0;\n    let snoozeScore = 0;\n\n    words.forEach(word => {\n      dismissWords.forEach(dismissWord => {\n        if (this.calculateSimilarity(word, dismissWord) > 0.7) {\n          dismissScore += 1;\n        }\n      });\n\n      snoozeWords.forEach(snoozeWord => {\n        if (this.calculateSimilarity(word, snoozeWord) > 0.7) {\n          snoozeScore += 1;\n        }\n      });\n    });\n\n    if (dismissScore > snoozeScore && dismissScore > 0) {\n      return { intent: 'dismiss' };\n    } else if (snoozeScore > dismissScore && snoozeScore > 0) {\n      return { intent: 'snooze' };\n    }\n\n    return null;\n  }\n\n  private static calculateSimilarity(str1: string, str2: string): number {\n    const longer = str1.length > str2.length ? str1 : str2;\n    const shorter = str1.length > str2.length ? str2 : str1;\n\n    if (longer.length === 0) return 1.0;\n\n    const editDistance = this.calculateLevenshteinDistance(longer, shorter);\n    return (longer.length - editDistance) / longer.length;\n  }\n\n  private static calculateLevenshteinDistance(str1: string, str2: string): number {\n    const matrix = [];\n\n    for (let i = 0; i <= str2.length; i++) {\n      matrix[i] = [i];\n    }\n\n    for (let j = 0; j <= str1.length; j++) {\n      matrix[0][j] = j;\n    }\n\n    for (let i = 1; i <= str2.length; i++) {\n      for (let j = 1; j <= str1.length; j++) {\n        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n          matrix[i][j] = matrix[i - 1][j - 1];\n        } else {\n          matrix[i][j] = Math.min(\n            matrix[i - 1][j - 1] + 1,\n            matrix[i][j - 1] + 1,\n            matrix[i - 1][j] + 1\n          );\n        }\n      }\n    }\n\n    return matrix[str2.length][str1.length];\n  }\n\n  private static checkHistoricalPatterns(transcript: string): 'dismiss' | 'snooze' | null {\n    const userCommands = this.userPreferences.preferredCommands;\n    let bestMatch: { intent: 'dismiss' | 'snooze'; score: number } | null = null;\n\n    userCommands.forEach((count, command) => {\n      const similarity = this.calculateSimilarity(transcript, command);\n      if (similarity > 0.8) {\n        const intent = this.commandHistory.find(h => h.command.toLowerCase().includes(command))?.intent;\n        if (intent && intent !== 'unknown') {\n          const score = similarity * (count / 100); // Weight by usage frequency\n          if (!bestMatch || score > bestMatch.score) {\n            bestMatch = { intent, score };\n          }\n        }\n      }\n    });\n\n    return bestMatch && bestMatch.score > 0.5 ? bestMatch.intent : null;\n  }\n\n  private static extractEntities(transcript: string): { [key: string]: string } {\n    const entities: { [key: string]: string } = {};\n\n    // Extract time mentions\n    const timePatterns = [\n      /(\\d+)\\s*(minute|minutes|min|mins)/i,\n      /(\\d+)\\s*(hour|hours|hr|hrs)/i,\n      /(five|ten|fifteen|twenty|thirty)\\s*(minutes?|mins?)/i\n    ];\n\n    timePatterns.forEach(pattern => {\n      const match = transcript.match(pattern);\n      if (match) {\n        entities.duration = match[0];\n        entities.durationValue = match[1];\n        entities.durationUnit = match[2];\n      }\n    });\n\n    // Extract emotional context\n    const emotionalWords = ['please', 'sorry', 'tired', 'sleepy', 'stressed', 'busy'];\n    emotionalWords.forEach(word => {\n      if (transcript.toLowerCase().includes(word)) {\n        entities.emotional_context = entities.emotional_context\n          ? `${entities.emotional_context}, ${word}`\n          : word;\n      }\n    });\n\n    // Extract politeness indicators\n    const politenessWords = ['please', 'thanks', 'thank you', 'sorry'];\n    const politeness = politenessWords.some(word => transcript.toLowerCase().includes(word));\n    if (politeness) {\n      entities.politeness = 'polite';\n    }\n\n    return entities;\n  }\n\n  private static getAdaptiveConfidence(transcript: string): number {\n    const baseThreshold = this.config.confidenceThreshold;\n\n    if (!this.config.adaptiveThreshold) {\n      return baseThreshold;\n    }\n\n    // Lower threshold for familiar commands\n    const similarCommands = this.commandHistory.filter(cmd =>\n      this.calculateSimilarity(cmd.command.toLowerCase(), transcript.toLowerCase()) > 0.8\n    );\n\n    if (similarCommands.length > 0) {\n      const avgHistoricalConfidence = similarCommands.reduce((sum, cmd) => sum + cmd.confidence, 0) / similarCommands.length;\n      return Math.max(baseThreshold - 0.1, avgHistoricalConfidence - 0.1);\n    }\n\n    // Higher threshold during typically noisy times\n    const currentHour = new Date().getHours();\n    if (currentHour >= 22 || currentHour <= 6) {\n      return baseThreshold + 0.05; // Slightly higher threshold at night\n    }\n\n    return baseThreshold;\n  }\n\n  private static logCommand(command: VoiceCommand): void {\n    this.commandHistory.push(command);\n\n    // Keep only last 100 commands\n    if (this.commandHistory.length > 100) {\n      this.commandHistory = this.commandHistory.slice(-100);\n    }\n\n    console.log('Voice command processed:', {\n      command: command.command,\n      intent: command.intent,\n      confidence: command.confidence.toFixed(2),\n      entities: command.entities\n    });\n  }\n\n  private static updateUserPreferences(command: VoiceCommand): void {\n    const commandKey = command.command.toLowerCase();\n\n    // Update command frequency\n    const currentCount = this.userPreferences.preferredCommands.get(commandKey) || 0;\n    this.userPreferences.preferredCommands.set(commandKey, currentCount + 1);\n\n    // Update average confidence\n    const currentAvg = this.userPreferences.avgConfidence.get(commandKey) || command.confidence;\n    const newAvg = (currentAvg + command.confidence) / 2;\n    this.userPreferences.avgConfidence.set(commandKey, newAvg);\n\n    // Update time-of-day patterns\n    const hour = command.timestamp.getHours();\n    const timeSlot = this.getTimeSlot(hour);\n    const currentPatterns = this.userPreferences.timeOfDayPatterns.get(timeSlot) || [];\n    if (!currentPatterns.includes(command.intent)) {\n      currentPatterns.push(command.intent);\n      this.userPreferences.timeOfDayPatterns.set(timeSlot, currentPatterns);\n    }\n\n    // Persist preferences\n    this.saveUserPreferences();\n  }\n\n  private static getTimeSlot(hour: number): string {\n    if (hour >= 5 && hour < 12) return 'morning';\n    if (hour >= 12 && hour < 17) return 'afternoon';\n    if (hour >= 17 && hour < 22) return 'evening';\n    return 'night';\n  }\n\n  private static async loadUserPreferences(): Promise<void> {\n    try {\n      const preferences = localStorage.getItem('voice_recognition_preferences');\n      if (preferences) {\n        const data = JSON.parse(preferences);\n        this.userPreferences.preferredCommands = new Map(data.preferredCommands || []);\n        this.userPreferences.avgConfidence = new Map(data.avgConfidence || []);\n        this.userPreferences.timeOfDayPatterns = new Map(data.timeOfDayPatterns || []);\n      }\n    } catch (error) {\n      console.error('Error loading user preferences:', error);\n    }\n  }\n\n  private static saveUserPreferences(): void {\n    try {\n      const data = {\n        preferredCommands: Array.from(this.userPreferences.preferredCommands.entries()),\n        avgConfidence: Array.from(this.userPreferences.avgConfidence.entries()),\n        timeOfDayPatterns: Array.from(this.userPreferences.timeOfDayPatterns.entries())\n      };\n      localStorage.setItem('voice_recognition_preferences', JSON.stringify(data));\n    } catch (error) {\n      console.error('Error saving user preferences:', error);\n    }\n  }\n\n  static getRecognitionStats(): {\n    totalCommands: number;\n    avgConfidence: number;\n    mostUsedCommands: { command: string; count: number; avgConfidence: number }[];\n    intentDistribution: { [intent: string]: number };\n  } {\n    const totalCommands = this.commandHistory.length;\n    const avgConfidence = totalCommands > 0\n      ? this.commandHistory.reduce((sum, cmd) => sum + cmd.confidence, 0) / totalCommands\n      : 0;\n\n    // Most used commands\n    const commandCounts = new Map<string, number>();\n    const commandConfidence = new Map<string, number[]>();\n\n    this.commandHistory.forEach(cmd => {\n      const command = cmd.command.toLowerCase();\n      commandCounts.set(command, (commandCounts.get(command) || 0) + 1);\n\n      if (!commandConfidence.has(command)) {\n        commandConfidence.set(command, []);\n      }\n      commandConfidence.get(command)!.push(cmd.confidence);\n    });\n\n    const mostUsedCommands = Array.from(commandCounts.entries())\n      .map(([command, count]) => ({\n        command,\n        count,\n        avgConfidence: commandConfidence.get(command)!.reduce((a, b) => a + b, 0) / count\n      }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 10);\n\n    // Intent distribution\n    const intentDistribution: { [intent: string]: number } = {};\n    this.commandHistory.forEach(cmd => {\n      intentDistribution[cmd.intent] = (intentDistribution[cmd.intent] || 0) + 1;\n    });\n\n    return {\n      totalCommands,\n      avgConfidence,\n      mostUsedCommands,\n      intentDistribution\n    };\n  }\n\n  static clearHistory(): void {\n    this.commandHistory = [];\n    this.userPreferences.preferredCommands.clear();\n    this.userPreferences.avgConfidence.clear();\n    this.userPreferences.timeOfDayPatterns.clear();\n    localStorage.removeItem('voice_recognition_preferences');\n  }\n\n  static updateConfig(newConfig: Partial<RecognitionConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n  }\n\n  static getConfig(): RecognitionConfig {\n    return { ...this.config };\n  }\n\n  static isCurrentlyListening(): boolean {\n    return this.isListening;\n  }\n}\n\nexport default VoiceRecognitionService;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/themes/premium-themes.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'Theme' is not defined.",
        "line": 931,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 931,
        "endColumn": 35
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'Theme' is not defined.",
        "line": 949,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 949,
        "endColumn": 34
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'Theme' is not defined.",
        "line": 967,
        "column": 30,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 967,
        "endColumn": 35
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'Theme' is not defined.",
        "line": 985,
        "column": 33,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 985,
        "endColumn": 38
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'ThemePreset' is not defined.",
        "line": 999,
        "column": 6,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 999,
        "endColumn": 17
      }
    ],
    "suppressedMessages": [],
    "errorCount": 5,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Premium Theme Configurations\n * Beautiful, sophisticated themes with advanced features\n */\n\nimport { ThemeConfig } from '../types';\n\n// Premium Theme: Ocean Breeze - Calming blues and teals\nexport const oceanBreezeTheme: ThemeConfig = {\n  id: 'ocean-breeze',\n  name: 'ocean-breeze',\n  displayName: 'Ocean Breeze',\n  description: 'Calming oceanic theme with smooth gradients and gentle transitions',\n  category: 'premium',\n  isCustom: false,\n  isPremium: true,\n  colors: {\n    primary: {\n      50: '#ecfeff',\n      100: '#cffafe',\n      200: '#a5f3fc',\n      300: '#67e8f9',\n      400: '#22d3ee',\n      500: '#06b6d4',\n      600: '#0891b2',\n      700: '#0e7490',\n      800: '#155e75',\n      900: '#164e63',\n      950: '#083344'\n    },\n    secondary: {\n      50: '#f0f9ff',\n      100: '#e0f2fe',\n      200: '#bae6fd',\n      300: '#7dd3fc',\n      400: '#38bdf8',\n      500: '#0ea5e9',\n      600: '#0284c7',\n      700: '#0369a1',\n      800: '#075985',\n      900: '#0c4a6e',\n      950: '#082f49'\n    },\n    accent: {\n      50: '#fff7ed',\n      100: '#ffedd5',\n      200: '#fed7aa',\n      300: '#fdba74',\n      400: '#fb923c',\n      500: '#f97316',\n      600: '#ea580c',\n      700: '#c2410c',\n      800: '#9a3412',\n      900: '#7c2d12',\n      950: '#431407'\n    },\n    neutral: {\n      50: '#fafafa',\n      100: '#f4f4f5',\n      200: '#e4e4e7',\n      300: '#d4d4d8',\n      400: '#a1a1aa',\n      500: '#71717a',\n      600: '#52525b',\n      700: '#3f3f46',\n      800: '#27272a',\n      900: '#18181b',\n      950: '#09090b'\n    },\n    background: {\n      primary: '#f8fcff',\n      secondary: '#ffffff',\n      tertiary: '#f1f9fe',\n      elevated: '#ffffff',\n      overlay: 'rgba(6, 182, 212, 0.05)',\n      glass: 'rgba(255, 255, 255, 0.9)',\n      gradient: 'linear-gradient(135deg, #f8fcff 0%, #e0f2fe 100%)'\n    },\n    text: {\n      primary: '#0c4a6e',\n      secondary: '#075985',\n      tertiary: '#0891b2',\n      inverse: '#ffffff',\n      muted: '#64748b',\n      disabled: '#94a3b8'\n    },\n    border: {\n      primary: '#e0f2fe',\n      secondary: '#bae6fd',\n      focus: '#06b6d4',\n      error: '#ef4444',\n      success: '#10b981',\n      warning: '#f59e0b'\n    }\n  },\n  typography: {\n    fontFamily: {\n      sans: '\"Inter\", system-ui, -apple-system, sans-serif',\n      serif: '\"Playfair Display\", Georgia, serif',\n      mono: '\"JetBrains Mono\", Consolas, monospace',\n      display: '\"Cal Sans\", \"Inter\", sans-serif'\n    },\n    fontSize: {\n      xs: '0.75rem',\n      sm: '0.875rem',\n      base: '1rem',\n      lg: '1.125rem',\n      xl: '1.25rem',\n      '2xl': '1.5rem',\n      '3xl': '1.875rem',\n      '4xl': '2.25rem',\n      '5xl': '3rem',\n      '6xl': '3.75rem'\n    },\n    fontWeight: {\n      thin: 100,\n      extralight: 200,\n      light: 300,\n      normal: 400,\n      medium: 500,\n      semibold: 600,\n      bold: 700,\n      extrabold: 800,\n      black: 900\n    },\n    lineHeight: {\n      tight: 1.25,\n      normal: 1.5,\n      relaxed: 1.625,\n      loose: 2\n    },\n    letterSpacing: {\n      tight: '-0.025em',\n      normal: '0em',\n      wide: '0.025em'\n    }\n  },\n  spacing: {\n    scale: 1,\n    sizes: {\n      0: '0px',\n      1: '0.25rem',\n      2: '0.5rem',\n      3: '0.75rem',\n      4: '1rem',\n      5: '1.25rem',\n      6: '1.5rem',\n      8: '2rem',\n      10: '2.5rem',\n      12: '3rem',\n      16: '4rem',\n      20: '5rem',\n      24: '6rem',\n      32: '8rem',\n      40: '10rem',\n      48: '12rem',\n      56: '14rem',\n      64: '16rem'\n    },\n    borderRadius: {\n      none: '0px',\n      sm: '0.125rem',\n      base: '0.375rem',\n      md: '0.5rem',\n      lg: '0.75rem',\n      xl: '1rem',\n      '2xl': '1.5rem',\n      '3xl': '2rem',\n      full: '9999px'\n    }\n  },\n  animations: {\n    enabled: true,\n    duration: {\n      fast: '200ms',\n      normal: '350ms',\n      slow: '500ms'\n    },\n    easing: {\n      linear: 'linear',\n      ease: 'ease',\n      easeIn: 'cubic-bezier(0.4, 0, 1, 1)',\n      easeOut: 'cubic-bezier(0, 0, 0.2, 1)',\n      easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',\n      bounce: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)',\n      elastic: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'\n    },\n    scale: 1.1\n  },\n  effects: {\n    shadows: {\n      sm: '0 1px 2px 0 rgba(6, 182, 212, 0.05)',\n      base: '0 1px 3px 0 rgba(6, 182, 212, 0.1), 0 1px 2px -1px rgba(6, 182, 212, 0.1)',\n      md: '0 4px 6px -1px rgba(6, 182, 212, 0.1), 0 2px 4px -2px rgba(6, 182, 212, 0.1)',\n      lg: '0 10px 15px -3px rgba(6, 182, 212, 0.1), 0 4px 6px -4px rgba(6, 182, 212, 0.1)',\n      xl: '0 20px 25px -5px rgba(6, 182, 212, 0.1), 0 8px 10px -6px rgba(6, 182, 212, 0.1)',\n      '2xl': '0 25px 50px -12px rgba(6, 182, 212, 0.25)',\n      inner: 'inset 0 2px 4px 0 rgba(6, 182, 212, 0.1)',\n      none: '0 0 #0000'\n    },\n    blur: {\n      sm: '4px',\n      base: '8px',\n      md: '12px',\n      lg: '16px',\n      xl: '24px',\n      '2xl': '40px',\n      '3xl': '64px'\n    },\n    opacity: {\n      disabled: 0.5,\n      hover: 0.9,\n      focus: 0.95,\n      overlay: 0.95\n    },\n    gradients: {\n      primary: 'linear-gradient(135deg, #06b6d4 0%, #0891b2 50%, #0e7490 100%)',\n      secondary: 'linear-gradient(135deg, #0ea5e9 0%, #0284c7 50%, #0369a1 100%)',\n      accent: 'linear-gradient(135deg, #f97316 0%, #ea580c 50%, #c2410c 100%)',\n      background: 'linear-gradient(135deg, #f8fcff 0%, #e0f2fe 50%, #bae6fd 100%)',\n      surface: 'linear-gradient(135deg, rgba(255,255,255,0.9) 0%, rgba(224,242,254,0.6) 100%)'\n    }\n  },\n  accessibility: {\n    focusRingWidth: '2px',\n    focusRingColor: '#06b6d4',\n    focusRingOffset: '2px',\n    focusRingOpacity: 0.5,\n    contrastMode: 'normal',\n    reducedMotion: false,\n    preferColorScheme: 'light'\n  }\n};\n\n// Premium Theme: Sunset Glow - Warm oranges and purples\nexport const sunsetGlowTheme: ThemeConfig = {\n  id: 'sunset-glow',\n  name: 'sunset-glow',\n  displayName: 'Sunset Glow',\n  description: 'Warm and energizing theme inspired by beautiful sunsets',\n  category: 'premium',\n  isCustom: false,\n  isPremium: true,\n  colors: {\n    primary: {\n      50: '#fff7ed',\n      100: '#ffedd5',\n      200: '#fed7aa',\n      300: '#fdba74',\n      400: '#fb923c',\n      500: '#f97316',\n      600: '#ea580c',\n      700: '#c2410c',\n      800: '#9a3412',\n      900: '#7c2d12',\n      950: '#431407'\n    },\n    secondary: {\n      50: '#fdf4ff',\n      100: '#fae8ff',\n      200: '#f5d0fe',\n      300: '#f0abfc',\n      400: '#e879f9',\n      500: '#d946ef',\n      600: '#c026d3',\n      700: '#a21caf',\n      800: '#86198f',\n      900: '#701a75',\n      950: '#4a044e'\n    },\n    accent: {\n      50: '#fff1f2',\n      100: '#ffe4e6',\n      200: '#fecdd3',\n      300: '#fda4af',\n      400: '#fb7185',\n      500: '#f43f5e',\n      600: '#e11d48',\n      700: '#be123c',\n      800: '#9f1239',\n      900: '#881337',\n      950: '#4c0519'\n    },\n    neutral: {\n      50: '#fafaf9',\n      100: '#f5f5f4',\n      200: '#e7e5e4',\n      300: '#d6d3d1',\n      400: '#a8a29e',\n      500: '#78716c',\n      600: '#57534e',\n      700: '#44403c',\n      800: '#292524',\n      900: '#1c1917',\n      950: '#0c0a09'\n    },\n    background: {\n      primary: '#fffbf8',\n      secondary: '#fef7f0',\n      tertiary: '#fed7aa',\n      elevated: '#ffffff',\n      overlay: 'rgba(249, 115, 22, 0.05)',\n      glass: 'rgba(255, 255, 255, 0.85)',\n      gradient: 'linear-gradient(135deg, #fffbf8 0%, #fef7f0 50%, #fed7aa 100%)'\n    },\n    text: {\n      primary: '#7c2d12',\n      secondary: '#9a3412',\n      tertiary: '#c2410c',\n      inverse: '#ffffff',\n      muted: '#78716c',\n      disabled: '#a8a29e'\n    },\n    border: {\n      primary: '#fed7aa',\n      secondary: '#fdba74',\n      focus: '#f97316',\n      error: '#ef4444',\n      success: '#10b981',\n      warning: '#f59e0b'\n    }\n  },\n  typography: {\n    fontFamily: {\n      sans: '\"Poppins\", system-ui, -apple-system, sans-serif',\n      serif: '\"Crimson Text\", Georgia, serif',\n      mono: '\"Source Code Pro\", Consolas, monospace',\n      display: '\"Playfair Display\", serif'\n    },\n    fontSize: {\n      xs: '0.75rem',\n      sm: '0.875rem',\n      base: '1rem',\n      lg: '1.125rem',\n      xl: '1.25rem',\n      '2xl': '1.5rem',\n      '3xl': '1.875rem',\n      '4xl': '2.25rem',\n      '5xl': '3rem',\n      '6xl': '3.75rem'\n    },\n    fontWeight: {\n      thin: 100,\n      extralight: 200,\n      light: 300,\n      normal: 400,\n      medium: 500,\n      semibold: 600,\n      bold: 700,\n      extrabold: 800,\n      black: 900\n    },\n    lineHeight: {\n      tight: 1.25,\n      normal: 1.5,\n      relaxed: 1.625,\n      loose: 2\n    },\n    letterSpacing: {\n      tight: '-0.025em',\n      normal: '0em',\n      wide: '0.05em'\n    }\n  },\n  spacing: {\n    scale: 1.1,\n    sizes: {\n      0: '0px',\n      1: '0.25rem',\n      2: '0.5rem',\n      3: '0.75rem',\n      4: '1rem',\n      5: '1.25rem',\n      6: '1.5rem',\n      8: '2rem',\n      10: '2.5rem',\n      12: '3rem',\n      16: '4rem',\n      20: '5rem',\n      24: '6rem',\n      32: '8rem',\n      40: '10rem',\n      48: '12rem',\n      56: '14rem',\n      64: '16rem'\n    },\n    borderRadius: {\n      none: '0px',\n      sm: '0.25rem',\n      base: '0.5rem',\n      md: '0.75rem',\n      lg: '1rem',\n      xl: '1.25rem',\n      '2xl': '1.75rem',\n      '3xl': '2.5rem',\n      full: '9999px'\n    }\n  },\n  animations: {\n    enabled: true,\n    duration: {\n      fast: '150ms',\n      normal: '300ms',\n      slow: '600ms'\n    },\n    easing: {\n      linear: 'linear',\n      ease: 'ease',\n      easeIn: 'cubic-bezier(0.55, 0.085, 0.68, 0.53)',\n      easeOut: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',\n      easeInOut: 'cubic-bezier(0.445, 0.05, 0.55, 0.95)',\n      bounce: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)',\n      elastic: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)'\n    },\n    scale: 1.05\n  },\n  effects: {\n    shadows: {\n      sm: '0 1px 2px 0 rgba(249, 115, 22, 0.1)',\n      base: '0 1px 3px 0 rgba(249, 115, 22, 0.15), 0 1px 2px -1px rgba(249, 115, 22, 0.1)',\n      md: '0 4px 6px -1px rgba(249, 115, 22, 0.15), 0 2px 4px -2px rgba(249, 115, 22, 0.1)',\n      lg: '0 10px 15px -3px rgba(249, 115, 22, 0.15), 0 4px 6px -4px rgba(249, 115, 22, 0.1)',\n      xl: '0 20px 25px -5px rgba(249, 115, 22, 0.15), 0 8px 10px -6px rgba(249, 115, 22, 0.1)',\n      '2xl': '0 25px 50px -12px rgba(249, 115, 22, 0.3)',\n      inner: 'inset 0 2px 4px 0 rgba(249, 115, 22, 0.1)',\n      none: '0 0 #0000'\n    },\n    blur: {\n      sm: '4px',\n      base: '8px',\n      md: '12px',\n      lg: '16px',\n      xl: '24px',\n      '2xl': '40px',\n      '3xl': '64px'\n    },\n    opacity: {\n      disabled: 0.4,\n      hover: 0.85,\n      focus: 0.9,\n      overlay: 0.9\n    },\n    gradients: {\n      primary: 'linear-gradient(135deg, #f97316 0%, #ea580c 50%, #c2410c 100%)',\n      secondary: 'linear-gradient(135deg, #d946ef 0%, #c026d3 50%, #a21caf 100%)',\n      accent: 'linear-gradient(135deg, #f43f5e 0%, #e11d48 50%, #be123c 100%)',\n      background: 'linear-gradient(135deg, #fffbf8 0%, #fef7f0 30%, #fed7aa 70%, #fdba74 100%)',\n      surface: 'linear-gradient(135deg, rgba(255,255,255,0.85) 0%, rgba(254,247,240,0.8) 100%)'\n    }\n  },\n  accessibility: {\n    focusRingWidth: '2px',\n    focusRingColor: '#f97316',\n    focusRingOffset: '2px',\n    focusRingOpacity: 0.6,\n    contrastMode: 'normal',\n    reducedMotion: false,\n    preferColorScheme: 'light'\n  }\n};\n\n// Premium Theme: Forest Dream - Nature-inspired greens\nexport const forestDreamTheme: ThemeConfig = {\n  id: 'forest-dream',\n  name: 'forest-dream',\n  displayName: 'Forest Dream',\n  description: 'Peaceful nature theme with rich greens and earthy tones',\n  category: 'premium',\n  isCustom: false,\n  isPremium: true,\n  colors: {\n    primary: {\n      50: '#f0fdf4',\n      100: '#dcfce7',\n      200: '#bbf7d0',\n      300: '#86efac',\n      400: '#4ade80',\n      500: '#22c55e',\n      600: '#16a34a',\n      700: '#15803d',\n      800: '#166534',\n      900: '#14532d',\n      950: '#052e16'\n    },\n    secondary: {\n      50: '#f7fee7',\n      100: '#ecfccb',\n      200: '#d9f99d',\n      300: '#bef264',\n      400: '#a3e635',\n      500: '#84cc16',\n      600: '#65a30d',\n      700: '#4d7c0f',\n      800: '#3f6212',\n      900: '#365314',\n      950: '#1a2e05'\n    },\n    accent: {\n      50: '#fefce8',\n      100: '#fef9c3',\n      200: '#fef08a',\n      300: '#fde047',\n      400: '#facc15',\n      500: '#eab308',\n      600: '#ca8a04',\n      700: '#a16207',\n      800: '#854d0e',\n      900: '#713f12',\n      950: '#422006'\n    },\n    neutral: {\n      50: '#fafaf9',\n      100: '#f5f5f4',\n      200: '#e7e5e4',\n      300: '#d6d3d1',\n      400: '#a8a29e',\n      500: '#78716c',\n      600: '#57534e',\n      700: '#44403c',\n      800: '#292524',\n      900: '#1c1917',\n      950: '#0c0a09'\n    },\n    background: {\n      primary: '#fdfffe',\n      secondary: '#f0fdf4',\n      tertiary: '#dcfce7',\n      elevated: '#ffffff',\n      overlay: 'rgba(34, 197, 94, 0.03)',\n      glass: 'rgba(240, 253, 244, 0.9)',\n      gradient: 'linear-gradient(135deg, #fdfffe 0%, #f0fdf4 50%, #dcfce7 100%)'\n    },\n    text: {\n      primary: '#14532d',\n      secondary: '#166534',\n      tertiary: '#15803d',\n      inverse: '#ffffff',\n      muted: '#78716c',\n      disabled: '#a8a29e'\n    },\n    border: {\n      primary: '#dcfce7',\n      secondary: '#bbf7d0',\n      focus: '#22c55e',\n      error: '#ef4444',\n      success: '#22c55e',\n      warning: '#eab308'\n    }\n  },\n  typography: {\n    fontFamily: {\n      sans: '\"Nunito Sans\", system-ui, -apple-system, sans-serif',\n      serif: '\"Lora\", Georgia, serif',\n      mono: '\"Fira Code\", Consolas, monospace',\n      display: '\"Fredoka One\", cursive'\n    },\n    fontSize: {\n      xs: '0.75rem',\n      sm: '0.875rem',\n      base: '1rem',\n      lg: '1.125rem',\n      xl: '1.25rem',\n      '2xl': '1.5rem',\n      '3xl': '1.875rem',\n      '4xl': '2.25rem',\n      '5xl': '3rem',\n      '6xl': '3.75rem'\n    },\n    fontWeight: {\n      thin: 100,\n      extralight: 200,\n      light: 300,\n      normal: 400,\n      medium: 500,\n      semibold: 600,\n      bold: 700,\n      extrabold: 800,\n      black: 900\n    },\n    lineHeight: {\n      tight: 1.3,\n      normal: 1.6,\n      relaxed: 1.75,\n      loose: 2.1\n    },\n    letterSpacing: {\n      tight: '-0.02em',\n      normal: '0em',\n      wide: '0.03em'\n    }\n  },\n  spacing: {\n    scale: 1,\n    sizes: {\n      0: '0px',\n      1: '0.25rem',\n      2: '0.5rem',\n      3: '0.75rem',\n      4: '1rem',\n      5: '1.25rem',\n      6: '1.5rem',\n      8: '2rem',\n      10: '2.5rem',\n      12: '3rem',\n      16: '4rem',\n      20: '5rem',\n      24: '6rem',\n      32: '8rem',\n      40: '10rem',\n      48: '12rem',\n      56: '14rem',\n      64: '16rem'\n    },\n    borderRadius: {\n      none: '0px',\n      sm: '0.1875rem',\n      base: '0.375rem',\n      md: '0.5625rem',\n      lg: '0.875rem',\n      xl: '1.125rem',\n      '2xl': '1.5rem',\n      '3xl': '2.25rem',\n      full: '9999px'\n    }\n  },\n  animations: {\n    enabled: true,\n    duration: {\n      fast: '180ms',\n      normal: '320ms',\n      slow: '480ms'\n    },\n    easing: {\n      linear: 'linear',\n      ease: 'ease',\n      easeIn: 'cubic-bezier(0.32, 0, 0.67, 0)',\n      easeOut: 'cubic-bezier(0.33, 1, 0.68, 1)',\n      easeInOut: 'cubic-bezier(0.65, 0, 0.35, 1)',\n      bounce: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)',\n      elastic: 'cubic-bezier(0.68, 0, 0.265, 1.55)'\n    },\n    scale: 1.03\n  },\n  effects: {\n    shadows: {\n      sm: '0 1px 2px 0 rgba(34, 197, 94, 0.08)',\n      base: '0 1px 3px 0 rgba(34, 197, 94, 0.12), 0 1px 2px -1px rgba(34, 197, 94, 0.08)',\n      md: '0 4px 6px -1px rgba(34, 197, 94, 0.12), 0 2px 4px -2px rgba(34, 197, 94, 0.08)',\n      lg: '0 10px 15px -3px rgba(34, 197, 94, 0.12), 0 4px 6px -4px rgba(34, 197, 94, 0.08)',\n      xl: '0 20px 25px -5px rgba(34, 197, 94, 0.12), 0 8px 10px -6px rgba(34, 197, 94, 0.08)',\n      '2xl': '0 25px 50px -12px rgba(34, 197, 94, 0.25)',\n      inner: 'inset 0 2px 4px 0 rgba(34, 197, 94, 0.08)',\n      none: '0 0 #0000'\n    },\n    blur: {\n      sm: '4px',\n      base: '8px',\n      md: '12px',\n      lg: '16px',\n      xl: '24px',\n      '2xl': '40px',\n      '3xl': '64px'\n    },\n    opacity: {\n      disabled: 0.45,\n      hover: 0.88,\n      focus: 0.93,\n      overlay: 0.92\n    },\n    gradients: {\n      primary: 'linear-gradient(135deg, #22c55e 0%, #16a34a 50%, #15803d 100%)',\n      secondary: 'linear-gradient(135deg, #84cc16 0%, #65a30d 50%, #4d7c0f 100%)',\n      accent: 'linear-gradient(135deg, #eab308 0%, #ca8a04 50%, #a16207 100%)',\n      background: 'linear-gradient(135deg, #fdfffe 0%, #f0fdf4 40%, #dcfce7 80%, #bbf7d0 100%)',\n      surface: 'linear-gradient(135deg, rgba(240,253,244,0.9) 0%, rgba(220,252,231,0.7) 100%)'\n    }\n  },\n  accessibility: {\n    focusRingWidth: '2px',\n    focusRingColor: '#22c55e',\n    focusRingOffset: '2px',\n    focusRingOpacity: 0.7,\n    contrastMode: 'normal',\n    reducedMotion: false,\n    preferColorScheme: 'light'\n  }\n};\n\n// Premium Theme: Midnight Cosmos - Deep space theme\nexport const midnightCosmosTheme: ThemeConfig = {\n  id: 'midnight-cosmos',\n  name: 'midnight-cosmos',\n  displayName: 'Midnight Cosmos',\n  description: 'Mysterious dark theme inspired by the cosmos',\n  category: 'premium',\n  isCustom: false,\n  isPremium: true,\n  colors: {\n    primary: {\n      50: '#eef2ff',\n      100: '#e0e7ff',\n      200: '#c7d2fe',\n      300: '#a5b4fc',\n      400: '#818cf8',\n      500: '#6366f1',\n      600: '#4f46e5',\n      700: '#4338ca',\n      800: '#3730a3',\n      900: '#312e81',\n      950: '#1e1b4b'\n    },\n    secondary: {\n      50: '#f0f9ff',\n      100: '#e0f2fe',\n      200: '#bae6fd',\n      300: '#7dd3fc',\n      400: '#38bdf8',\n      500: '#0ea5e9',\n      600: '#0284c7',\n      700: '#0369a1',\n      800: '#075985',\n      900: '#0c4a6e',\n      950: '#082f49'\n    },\n    accent: {\n      50: '#fdf4ff',\n      100: '#fae8ff',\n      200: '#f5d0fe',\n      300: '#f0abfc',\n      400: '#e879f9',\n      500: '#d946ef',\n      600: '#c026d3',\n      700: '#a21caf',\n      800: '#86198f',\n      900: '#701a75',\n      950: '#4a044e'\n    },\n    neutral: {\n      50: '#f8fafc',\n      100: '#f1f5f9',\n      200: '#e2e8f0',\n      300: '#cbd5e1',\n      400: '#94a3b8',\n      500: '#64748b',\n      600: '#475569',\n      700: '#334155',\n      800: '#1e293b',\n      900: '#0f172a',\n      950: '#020617'\n    },\n    background: {\n      primary: '#020617',\n      secondary: '#0f172a',\n      tertiary: '#1e293b',\n      elevated: '#334155',\n      overlay: 'rgba(99, 102, 241, 0.08)',\n      glass: 'rgba(15, 23, 42, 0.8)',\n      gradient: 'linear-gradient(135deg, #020617 0%, #0f172a 50%, #1e293b 100%)'\n    },\n    text: {\n      primary: '#f8fafc',\n      secondary: '#e2e8f0',\n      tertiary: '#cbd5e1',\n      inverse: '#020617',\n      muted: '#94a3b8',\n      disabled: '#64748b'\n    },\n    border: {\n      primary: '#334155',\n      secondary: '#475569',\n      focus: '#6366f1',\n      error: '#ef4444',\n      success: '#10b981',\n      warning: '#f59e0b'\n    }\n  },\n  typography: {\n    fontFamily: {\n      sans: '\"Space Grotesk\", system-ui, -apple-system, sans-serif',\n      serif: '\"Merriweather\", Georgia, serif',\n      mono: '\"JetBrains Mono\", Consolas, monospace',\n      display: '\"Orbitron\", monospace'\n    },\n    fontSize: {\n      xs: '0.75rem',\n      sm: '0.875rem',\n      base: '1rem',\n      lg: '1.125rem',\n      xl: '1.25rem',\n      '2xl': '1.5rem',\n      '3xl': '1.875rem',\n      '4xl': '2.25rem',\n      '5xl': '3rem',\n      '6xl': '3.75rem'\n    },\n    fontWeight: {\n      thin: 100,\n      extralight: 200,\n      light: 300,\n      normal: 400,\n      medium: 500,\n      semibold: 600,\n      bold: 700,\n      extrabold: 800,\n      black: 900\n    },\n    lineHeight: {\n      tight: 1.25,\n      normal: 1.5,\n      relaxed: 1.625,\n      loose: 2\n    },\n    letterSpacing: {\n      tight: '-0.025em',\n      normal: '0em',\n      wide: '0.025em'\n    }\n  },\n  spacing: {\n    scale: 1,\n    sizes: {\n      0: '0px',\n      1: '0.25rem',\n      2: '0.5rem',\n      3: '0.75rem',\n      4: '1rem',\n      5: '1.25rem',\n      6: '1.5rem',\n      8: '2rem',\n      10: '2.5rem',\n      12: '3rem',\n      16: '4rem',\n      20: '5rem',\n      24: '6rem',\n      32: '8rem',\n      40: '10rem',\n      48: '12rem',\n      56: '14rem',\n      64: '16rem'\n    },\n    borderRadius: {\n      none: '0px',\n      sm: '0.125rem',\n      base: '0.25rem',\n      md: '0.375rem',\n      lg: '0.5rem',\n      xl: '0.75rem',\n      '2xl': '1rem',\n      '3xl': '1.5rem',\n      full: '9999px'\n    }\n  },\n  animations: {\n    enabled: true,\n    duration: {\n      fast: '200ms',\n      normal: '400ms',\n      slow: '600ms'\n    },\n    easing: {\n      linear: 'linear',\n      ease: 'ease',\n      easeIn: 'cubic-bezier(0.4, 0, 1, 1)',\n      easeOut: 'cubic-bezier(0, 0, 0.2, 1)',\n      easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',\n      bounce: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)',\n      elastic: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'\n    },\n    scale: 1.08\n  },\n  effects: {\n    shadows: {\n      sm: '0 1px 2px 0 rgba(99, 102, 241, 0.1)',\n      base: '0 1px 3px 0 rgba(99, 102, 241, 0.15), 0 1px 2px -1px rgba(99, 102, 241, 0.1)',\n      md: '0 4px 6px -1px rgba(99, 102, 241, 0.15), 0 2px 4px -2px rgba(99, 102, 241, 0.1)',\n      lg: '0 10px 15px -3px rgba(99, 102, 241, 0.15), 0 4px 6px -4px rgba(99, 102, 241, 0.1)',\n      xl: '0 20px 25px -5px rgba(99, 102, 241, 0.15), 0 8px 10px -6px rgba(99, 102, 241, 0.1)',\n      '2xl': '0 25px 50px -12px rgba(99, 102, 241, 0.35)',\n      inner: 'inset 0 2px 4px 0 rgba(99, 102, 241, 0.1)',\n      none: '0 0 #0000',\n      glow: '0 0 20px rgba(99, 102, 241, 0.4)'\n    },\n    blur: {\n      sm: '4px',\n      base: '8px',\n      md: '12px',\n      lg: '16px',\n      xl: '24px',\n      '2xl': '40px',\n      '3xl': '64px'\n    },\n    opacity: {\n      disabled: 0.3,\n      hover: 0.9,\n      focus: 0.95,\n      overlay: 0.85\n    },\n    gradients: {\n      primary: 'linear-gradient(135deg, #6366f1 0%, #4f46e5 50%, #4338ca 100%)',\n      secondary: 'linear-gradient(135deg, #0ea5e9 0%, #0284c7 50%, #0369a1 100%)',\n      accent: 'linear-gradient(135deg, #d946ef 0%, #c026d3 50%, #a21caf 100%)',\n      background: 'linear-gradient(135deg, #020617 0%, #0f172a 30%, #1e293b 70%, #334155 100%)',\n      surface: 'linear-gradient(135deg, rgba(15,23,42,0.8) 0%, rgba(30,41,59,0.6) 100%)',\n      cosmic: 'radial-gradient(ellipse at center, rgba(99,102,241,0.15) 0%, rgba(15,23,42,0.8) 70%)'\n    }\n  },\n  accessibility: {\n    focusRingWidth: '2px',\n    focusRingColor: '#6366f1',\n    focusRingOffset: '2px',\n    focusRingOpacity: 0.8,\n    contrastMode: 'high',\n    reducedMotion: false,\n    preferColorScheme: 'dark'\n  }\n};\n\n// Export all premium themes\nexport const PREMIUM_THEMES = {\n  'ocean-breeze': oceanBreezeTheme,\n  'sunset-glow': sunsetGlowTheme,\n  'forest-dream': forestDreamTheme,\n  'midnight-cosmos': midnightCosmosTheme\n} as const;\n\nexport const PREMIUM_THEME_PRESETS = [\n  {\n    id: 'ocean-breeze',\n    name: 'Ocean Breeze',\n    description: 'Calming oceanic theme with smooth gradients',\n    theme: 'ocean-breeze' as Theme,\n    personalization: {},\n    preview: {\n      primaryColor: '#06b6d4',\n      backgroundColor: '#f8fcff',\n      textColor: '#0c4a6e',\n      cardColor: '#ffffff',\n      accentColor: '#f97316'\n    },\n    tags: ['premium', 'calm', 'professional'],\n    isDefault: false,\n    isPremium: true,\n    popularityScore: 85\n  },\n  {\n    id: 'sunset-glow',\n    name: 'Sunset Glow',\n    description: 'Warm and energizing sunset-inspired theme',\n    theme: 'sunset-glow' as Theme,\n    personalization: {},\n    preview: {\n      primaryColor: '#f97316',\n      backgroundColor: '#fffbf8',\n      textColor: '#7c2d12',\n      cardColor: '#fef7f0',\n      accentColor: '#d946ef'\n    },\n    tags: ['premium', 'warm', 'energetic'],\n    isDefault: false,\n    isPremium: true,\n    popularityScore: 92\n  },\n  {\n    id: 'forest-dream',\n    name: 'Forest Dream',\n    description: 'Peaceful nature theme with rich greens',\n    theme: 'forest-dream' as Theme,\n    personalization: {},\n    preview: {\n      primaryColor: '#22c55e',\n      backgroundColor: '#fdfffe',\n      textColor: '#14532d',\n      cardColor: '#f0fdf4',\n      accentColor: '#eab308'\n    },\n    tags: ['premium', 'nature', 'peaceful'],\n    isDefault: false,\n    isPremium: true,\n    popularityScore: 78\n  },\n  {\n    id: 'midnight-cosmos',\n    name: 'Midnight Cosmos',\n    description: 'Mysterious cosmic dark theme',\n    theme: 'midnight-cosmos' as Theme,\n    personalization: {},\n    preview: {\n      primaryColor: '#6366f1',\n      backgroundColor: '#020617',\n      textColor: '#f8fafc',\n      cardColor: '#0f172a',\n      accentColor: '#d946ef'\n    },\n    tags: ['premium', 'dark', 'cosmic', 'mysterious'],\n    isDefault: false,\n    isPremium: true,\n    popularityScore: 88\n  }\n] as ThemePreset[];",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/types/browser-apis.d.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'ExtendableEvent' is not defined.",
        "line": 7,
        "column": 14,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 7,
        "endColumn": 29
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'ExtendableEvent' is not defined.",
        "line": 8,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 8,
        "endColumn": 30
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'FetchEvent' is not defined.",
        "line": 9,
        "column": 12,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 9,
        "endColumn": 22
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'PushEvent' is not defined.",
        "line": 10,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 10,
        "endColumn": 20
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'NotificationEvent' is not defined.",
        "line": 11,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 11,
        "endColumn": 41
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'NotificationEvent' is not defined.",
        "line": 12,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 12,
        "endColumn": 41
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'ExtendableEvent' is not defined.",
        "line": 71,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 71,
        "endColumn": 44
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'BufferSource' is not defined.",
        "line": 90,
        "column": 26,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 90,
        "endColumn": 38
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'IDBObjectStoreParameters' is not defined.",
        "line": 190,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 190,
        "endColumn": 69
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'IDBTransactionMode' is not defined.",
        "line": 192,
        "column": 53,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 192,
        "endColumn": 71
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'IDBDatabaseEventMap' is not defined.",
        "line": 194,
        "column": 36,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 194,
        "endColumn": 55
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'IDBDatabaseEventMap' is not defined.",
        "line": 196,
        "column": 39,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 196,
        "endColumn": 58
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'AddEventListenerOptions' is not defined.",
        "line": 197,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 197,
        "endColumn": 48
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'RegistrationOptions' is not defined.",
        "line": 252,
        "column": 43,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 252,
        "endColumn": 62
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'ServiceWorkerContainerEventMap' is not defined.",
        "line": 255,
        "column": 38,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 255,
        "endColumn": 68
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'ServiceWorkerContainerEventMap' is not defined.",
        "line": 257,
        "column": 52,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 257,
        "endColumn": 82
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'AddEventListenerOptions' is not defined.",
        "line": 258,
        "column": 27,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 258,
        "endColumn": 50
      }
    ],
    "suppressedMessages": [],
    "errorCount": 17,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Browser API Type Definitions\n// Comprehensive type definitions for Browser APIs used in the application\n\n// Service Worker types\ninterface ServiceWorkerEventMap {\n  'message': MessageEvent;\n  'install': ExtendableEvent;\n  'activate': ExtendableEvent;\n  'fetch': FetchEvent;\n  'push': PushEvent;\n  'notificationclick': NotificationEvent;\n  'notificationclose': NotificationEvent;\n  'sync': SyncEvent;\n}\n\n// Enhanced Service Worker Registration\ninterface EnhancedServiceWorkerRegistration extends ServiceWorkerRegistration {\n  sync?: SyncManager;\n  periodicSync?: PeriodicSyncManager;\n}\n\n// Notification API extensions\ninterface NotificationOptions {\n  dir?: 'auto' | 'ltr' | 'rtl';\n  lang?: string;\n  badge?: string;\n  body?: string;\n  tag?: string;\n  icon?: string;\n  image?: string;\n  data?: any;\n  vibrate?: number[];\n  renotify?: boolean;\n  silent?: boolean;\n  sound?: string;\n  noscreen?: boolean;\n  sticky?: boolean;\n  actions?: NotificationAction[];\n  timestamp?: number;\n}\n\ninterface NotificationAction {\n  action: string;\n  title: string;\n  icon?: string;\n}\n\n// Storage API types\ninterface StorageEstimate {\n  quota?: number;\n  usage?: number;\n  usageDetails?: {\n    indexedDB?: number;\n    caches?: number;\n    serviceWorkerRegistrations?: number;\n  };\n}\n\ninterface StorageManager {\n  estimate(): Promise<StorageEstimate>;\n  persist(): Promise<boolean>;\n  persisted(): Promise<boolean>;\n}\n\n// Background Sync API\ninterface SyncManager {\n  register(tag: string): Promise<void>;\n  getTags(): Promise<string[]>;\n}\n\ninterface SyncEvent extends ExtendableEvent {\n  tag: string;\n  lastChance: boolean;\n}\n\n// Periodic Background Sync API\ninterface PeriodicSyncManager {\n  register(tag: string, options?: PeriodicSyncOptions): Promise<void>;\n  unregister(tag: string): Promise<void>;\n  getTags(): Promise<string[]>;\n}\n\ninterface PeriodicSyncOptions {\n  minInterval?: number;\n}\n\n// Push API types\ninterface PushSubscriptionOptions {\n  userVisibleOnly?: boolean;\n  applicationServerKey?: BufferSource | string | null;\n}\n\ninterface PushSubscription {\n  readonly endpoint: string;\n  readonly expirationTime: number | null;\n  readonly options: PushSubscriptionOptions;\n  getKey(name: PushEncryptionKeyName): ArrayBuffer | null;\n  toJSON(): PushSubscriptionJSON;\n  unsubscribe(): Promise<boolean>;\n}\n\ninterface PushSubscriptionJSON {\n  endpoint?: string;\n  expirationTime?: number | null;\n  keys?: Record<string, string>;\n}\n\ntype PushEncryptionKeyName = 'p256dh' | 'auth';\n\n// Web Share API\ninterface ShareData {\n  title?: string;\n  text?: string;\n  url?: string;\n  files?: File[];\n}\n\ninterface Navigator {\n  share?(data: ShareData): Promise<void>;\n  canShare?(data: ShareData): boolean;\n}\n\n// Vibration API\ninterface Navigator {\n  vibrate?(pattern: number | number[]): boolean;\n}\n\n// Wake Lock API\ninterface WakeLockSentinel {\n  readonly type: 'screen';\n  release(): Promise<void>;\n  addEventListener(type: 'release', listener: () => void): void;\n  removeEventListener(type: 'release', listener: () => void): void;\n}\n\ninterface WakeLock {\n  request(type: 'screen'): Promise<WakeLockSentinel>;\n}\n\ninterface Navigator {\n  wakeLock?: WakeLock;\n}\n\n// Permissions API\ninterface PermissionStatus extends EventTarget {\n  readonly name: PermissionName;\n  readonly state: 'granted' | 'denied' | 'prompt';\n  onchange: ((this: PermissionStatus, ev: Event) => any) | null;\n}\n\ninterface Permissions {\n  query(permissionDescriptor: PermissionDescriptor): Promise<PermissionStatus>;\n}\n\ninterface PermissionDescriptor {\n  name: PermissionName;\n}\n\ntype PermissionName = \n  | 'camera'\n  | 'microphone'\n  | 'notifications'\n  | 'push'\n  | 'geolocation'\n  | 'accelerometer'\n  | 'ambient-light-sensor'\n  | 'background-sync'\n  | 'clipboard-read'\n  | 'clipboard-write'\n  | 'gyroscope'\n  | 'magnetometer'\n  | 'persistent-storage';\n\ninterface Navigator {\n  permissions?: Permissions;\n}\n\n// Broadcast Channel API\ndeclare class BroadcastChannel extends EventTarget {\n  constructor(name: string);\n  readonly name: string;\n  onmessage: ((this: BroadcastChannel, ev: MessageEvent) => any) | null;\n  onmessageerror: ((this: BroadcastChannel, ev: MessageEvent) => any) | null;\n  close(): void;\n  postMessage(message: any): void;\n}\n\n// IndexedDB enhanced types\ninterface IDBDatabase {\n  createObjectStore(name: string, options?: IDBObjectStoreParameters): IDBObjectStore;\n  deleteObjectStore(name: string): void;\n  transaction(storeNames: string | string[], mode?: IDBTransactionMode): IDBTransaction;\n  close(): void;\n  addEventListener<K extends keyof IDBDatabaseEventMap>(\n    type: K,\n    listener: (this: IDBDatabase, ev: IDBDatabaseEventMap[K]) => any,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n}\n\n// Device Memory API\ninterface Navigator {\n  deviceMemory?: number;\n}\n\n// Network Information API\ninterface Connection {\n  readonly effectiveType: '2g' | '3g' | '4g' | 'slow-2g';\n  readonly type: 'bluetooth' | 'cellular' | 'ethernet' | 'none' | 'wifi' | 'wimax' | 'other' | 'unknown';\n  readonly downlink: number;\n  readonly downlinkMax: number;\n  readonly rtt: number;\n  readonly saveData: boolean;\n  addEventListener(type: 'change', listener: () => void): void;\n  removeEventListener(type: 'change', listener: () => void): void;\n}\n\ninterface Navigator {\n  connection?: Connection;\n}\n\n// Screen Wake Lock API\ninterface ScreenWakeLock {\n  request(): Promise<WakeLockSentinel>;\n}\n\ninterface Navigator {\n  wakeLock?: ScreenWakeLock;\n}\n\n// Declare global extensions\ndeclare global {\n  interface Window {\n    BroadcastChannel: typeof BroadcastChannel;\n  }\n  \n  interface Navigator {\n    storage?: StorageManager;\n    serviceWorker: ServiceWorkerContainer;\n    share?: (data: ShareData) => Promise<void>;\n    canShare?: (data: ShareData) => boolean;\n    vibrate?: (pattern: number | number[]) => boolean;\n    wakeLock?: WakeLock;\n    permissions?: Permissions;\n    connection?: Connection;\n    deviceMemory?: number;\n  }\n  \n  interface ServiceWorkerContainer {\n    ready: Promise<ServiceWorkerRegistration>;\n    controller: ServiceWorker | null;\n    register(scriptURL: string, options?: RegistrationOptions): Promise<ServiceWorkerRegistration>;\n    getRegistration(scope?: string): Promise<ServiceWorkerRegistration | undefined>;\n    getRegistrations(): Promise<ServiceWorkerRegistration[]>;\n    addEventListener<K extends keyof ServiceWorkerContainerEventMap>(\n      type: K,\n      listener: (this: ServiceWorkerContainer, ev: ServiceWorkerContainerEventMap[K]) => any,\n      options?: boolean | AddEventListenerOptions\n    ): void;\n  }\n  \n  const BroadcastChannel: {\n    prototype: BroadcastChannel;\n    new(name: string): BroadcastChannel;\n  };\n}\n\nexport {};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/types/index.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SubscriptionStatus' is not defined.",
        "line": 209,
        "column": 24,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 209,
        "endColumn": 42
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SubscriptionStatus' is not defined.",
        "line": 3549,
        "column": 11,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 3549,
        "endColumn": 29
      },
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SubscriptionTier' is not defined.",
        "line": 3651,
        "column": 45,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 3651,
        "endColumn": 61
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Import premium types\nexport * from './premium';\n\n// Import browser API types\nexport * from './browser-apis';\n\n// Email Campaign Types\nexport type PersonaType =\n  | 'struggling_sam'     // Free-focused users\n  | 'busy_ben'           // Efficiency-driven professionals\n  | 'professional_paula' // Feature-rich seekers\n  | 'enterprise_emma'    // Team-oriented decision makers\n  | 'student_sarah'      // Budget-conscious students\n  | 'lifetime_larry';    // One-time payment preferrers\n\nexport interface PersonaProfile {\n  id: PersonaType;\n  displayName: string;\n  description: string;\n  primaryColor: string;\n  messagingTone:\n    | \"supportive\"\n    | \"efficient\"\n    | \"sophisticated\"\n    | \"business_focused\"\n    | \"casual\"\n    | \"value_focused\";\n  ctaStyle:\n    | \"friendly\"\n    | \"urgent\"\n    | \"professional\"\n    | \"corporate\"\n    | \"youthful\"\n    | \"exclusive\";\n  targetPlan:\n    | \"free\"\n    | \"basic\"\n    | \"premium\"\n    | \"pro\"\n    | \"student\"\n    | \"lifetime\";\n}\n\nexport interface PersonaDetectionResult {\n  persona: PersonaType;\n  confidence: number; // 0-1 scale\n  factors: PersonaDetectionFactor[];\n  updatedAt: Date;\n  previousPersona?: PersonaType;\n}\n\nexport interface PersonaDetectionFactor {\n  factor: string;\n  weight: number;\n  value: string | number | boolean;\n  influence: number;\n}\n\nexport interface EmailCampaign {\n  id: string;\n  name: string;\n  persona: PersonaType;\n  status: 'draft' | 'active' | 'paused' | 'completed';\n  sequences: EmailSequence[];\n  metrics: CampaignMetrics;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface EmailSequence {\n  id: string;\n  campaignId: string;\n  order: number;\n  name: string;\n  subject: string;\n  delayHours: number;\n  targetAction: string;\n  successMetrics: {\n    openRateTarget: number;\n    clickRateTarget: number;\n    conversionRateTarget?: number;\n  };\n}\n\nexport interface CampaignMetrics {\n  totalSent: number;\n  totalOpened: number;\n  totalClicked: number;\n  totalConverted: number;\n  openRate: number;\n  clickRate: number;\n  conversionRate: number;\n  lastUpdated: Date;\n}\n\nexport interface EmailPreferences {\n  userId: string;\n  subscribed: boolean;\n  preferences: {\n    marketing: boolean;\n    product_updates: boolean;\n    educational_content: boolean;\n  };\n  frequency: 'immediate' | 'daily' | 'weekly' | 'monthly';\n  lastUpdated: Date;\n}\n\n// Enhanced Alarm interface combining both apps\nexport interface Alarm {\n  id: string;\n  userId: string;\n  time: string; // HH:MM format\n  label: string;\n  title?: string; // Additional title field for enhanced functionality\n  description?: string; // Description field for alarm details\n  enabled: boolean; // from Smart Alarm App\n  isActive: boolean; // from Enhanced Battles (same as enabled)\n  days: number[]; // 0-6, Sunday = 0 (Smart Alarm format)\n  dayNames: DayOfWeek[]; // Enhanced Battles format for compatibility\n  recurringDays?: DayOfWeek[]; // Alternative recurring days format\n  voiceMood: VoiceMood;\n  sound: string; // Enhanced Battles sound system\n  soundType?: 'built-in' | 'custom' | 'voice-only'; // Type of sound to use\n  customSoundId?: string; // ID of custom sound if soundType is 'custom'\n  difficulty: AlarmDifficulty; // Enhanced Battles difficulty\n  snoozeEnabled: boolean;\n  snoozeInterval: number; // minutes\n  snoozeCount: number;\n  maxSnoozes?: number;\n  lastTriggered?: Date;\n  createdAt: Date | string;\n  updatedAt: Date | string;\n  // Battle system integration\n  battleId?: string;\n  weatherEnabled?: boolean;\n  nuclearChallenges?: string[];\n  smartFeatures?: SmartAlarmSettings;\n  // Advanced scheduling properties\n  recurrencePattern?: RecurrencePattern;\n  conditionalRules?: ConditionalRule[];\n  locationTriggers?: LocationTrigger[];\n  calendarIntegration?: CalendarIntegration;\n  seasonalAdjustments?: SeasonalAdjustment[];\n  smartOptimizations?: SmartOptimization[];\n  dependencies?: AlarmDependency[];\n}\n\nexport type VoiceMood =\n  | 'drill-sergeant'\n  | 'sweet-angel'\n  | 'anime-hero'\n  | 'savage-roast'\n  | 'motivational'\n  | 'gentle'\n  // Premium-only personalities (Pro+ subscription required)\n  | 'demon-lord'\n  | 'ai-robot'\n  | 'comedian'\n  | 'philosopher';\n\nexport interface VoiceMoodConfig {\n  id: VoiceMood;\n  name: string;\n  description: string;\n  icon: string;\n  color: string;\n  sample: string;\n}\n\n// Enhanced Battles alarm types\nexport type DayOfWeek = 'monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday';\nexport type AlarmDifficulty = 'easy' | 'medium' | 'hard' | 'extreme' | 'nuclear';\n\nexport interface AlarmInstance {\n  id: string;\n  alarmId: string;\n  scheduledTime: string; // ISO date string\n  actualWakeTime?: string; // ISO date string\n  status: 'pending' | 'snoozed' | 'dismissed' | 'completed' | 'missed';\n  snoozeCount: number;\n  battleId?: string;\n}\n\nexport interface AlarmEvent {\n  id: string;\n  alarmId: string;\n  firedAt: Date;\n  dismissed: boolean;\n  snoozed: boolean;\n  userAction: 'dismissed' | 'snoozed' | 'ignored';\n  dismissMethod?: 'voice' | 'button' | 'shake';\n}\n\n// Enhanced User interface combining both apps\nexport interface User {\n  id: string;\n  email: string; // from Smart Alarm App\n  name?: string; // Smart Alarm App\n  username: string; // Enhanced Battles\n  displayName: string; // Enhanced Battles\n  avatar?: string;\n  level: number;\n  experience: number;\n  joinDate: string;\n  lastActive: string;\n  preferences: UserPreferences;\n  settings?: UserSettings; // Enhanced Battles settings\n  stats?: UserStats; // Enhanced Battles stats\n  subscriptionStatus?: SubscriptionStatus; // Detailed subscription info\n  createdAt: Date | string;\n  // Premium subscription fields\n  subscription?: import('./premium').Subscription;\n  stripeCustomerId?: string;\n  trialEndsAt?: Date;\n  premiumFeatures?: string[]; // Array of feature IDs user has access to\n  featureAccess?: PremiumFeatureAccess;\n  usage?: PremiumUsage;\n}\n\nexport interface UserStats {\n  totalBattles: number;\n  wins: number;\n  losses: number;\n  winRate: number;\n  currentStreak: number;\n  longestStreak: number;\n  averageWakeTime: string;\n  totalAlarmsSet: number;\n  alarmsCompleted: number;\n  snoozeCount: number;\n}\n\n// Enhanced User Preferences combining both apps\nexport interface UserPreferences {\n  // Enhanced Theme & Personalization\n  personalization: PersonalizationSettings;\n\n  // Smart Alarm App preferences\n  notificationsEnabled: boolean;\n  soundEnabled: boolean;\n  voiceDismissalSensitivity: number; // 1-10\n  defaultVoiceMood: VoiceMood;\n  hapticFeedback: boolean;\n  snoozeMinutes: number;\n  maxSnoozes: number;\n  rewardsEnabled: boolean;\n  aiInsightsEnabled: boolean;\n  personalizedMessagesEnabled: boolean;\n  shareAchievements: boolean;\n\n  // Enhanced Battles preferences\n  battleNotifications?: boolean;\n  friendRequests?: boolean;\n  trashTalkEnabled?: boolean;\n  autoJoinBattles?: boolean;\n  smartFeaturesEnabled?: boolean;\n  fitnessIntegration?: boolean;\n  locationChallenges?: boolean;\n  photoChallenges?: boolean;\n\n  // Legacy support (deprecated, use personalization.theme instead)\n  theme?: 'light' | 'dark' | 'auto' | 'system';\n  gameTheme?: Theme;\n}\n\nexport interface NotificationPermission {\n  granted: boolean;\n  requestedAt?: Date;\n  deniedAt?: Date;\n}\n\nexport interface MicrophonePermission {\n  granted: boolean;\n  requestedAt?: Date;\n  deniedAt?: Date;\n}\n\n/**\n * Main application state interface that defines the complete state structure\n * for the Smart Alarm application. This interface ensures type safety across\n * all application components and provides a centralized state management contract.\n *\n * @interface AppState\n * @since 1.0.0\n *\n * @example\n * ```typescript\n * const [appState, setAppState] = useState<AppState>(INITIAL_APP_STATE);\n *\n * // Access user data\n * if (appState.user) {\n *   console.log(`Welcome ${appState.user.name}`);\n * }\n *\n * // Check current theme\n * const isDarkMode = appState.currentTheme === 'dark';\n * ```\n */\nexport interface AppState {\n  /**\n   * Currently authenticated user object or null if not logged in.\n   * Contains user profile information, preferences, and subscription details.\n   */\n  user: User | null;\n\n  /**\n   * Array of all user's alarms including enabled/disabled states.\n   * This is the primary data structure for alarm management.\n   */\n  alarms: Alarm[];\n\n  /**\n   * Currently active/ringing alarm or null if no alarm is active.\n   * Used to determine if the alarm ringing UI should be displayed.\n   */\n  activeAlarm: Alarm | null;\n\n  /**\n   * System permissions required for alarm functionality.\n   * Tracks notification and microphone access permissions.\n   */\n  permissions: {\n    /** Notification permission state for alarm alerts */\n    notifications: NotificationPermission;\n    /** Microphone permission state for voice dismissal */\n    microphone: MicrophonePermission;\n  };\n\n  /**\n   * Whether the user is currently in the onboarding flow.\n   * Controls display of welcome screens and initial setup.\n   */\n  isOnboarding: boolean;\n\n  /**\n   * Current active view/screen in the application.\n   * Determines which main component to render.\n   */\n  currentView: 'dashboard' | 'alarms' | 'advanced-scheduling' | 'gaming' | 'settings' | 'alarm-ringing' | 'pricing';\n\n  /**\n   * Optional rewards and gamification system state.\n   * Includes user level, experience points, and unlocked rewards.\n   */\n  rewardSystem?: RewardSystem;\n\n  // Enhanced Theme & Personalization\n\n  /**\n   * Currently active theme identifier.\n   * Determines the overall visual appearance of the application.\n   * @example 'light', 'dark', 'high-contrast'\n   */\n  currentTheme: Theme;\n\n  /**\n   * Complete theme configuration object for the current theme.\n   * Contains detailed styling information including colors, typography, and effects.\n   */\n  themeConfig: ThemeConfig;\n\n  /**\n   * User's personalization settings and preferences.\n   * Includes accessibility settings, UI preferences, and customizations.\n   */\n  personalization: PersonalizationSettings;\n\n  /**\n   * Array of available theme presets that users can choose from.\n   * Includes both built-in and custom themes.\n   */\n  availableThemes: ThemePreset[];\n\n  /**\n   * Optional theme store for advanced theme management.\n   * Contains featured themes, categories, and community themes.\n   */\n  themeStore?: ThemeStore;\n\n  // Enhanced Battles state\n\n  /**\n   * Array of currently active gaming battles the user is participating in.\n   * Used for competitive alarm challenges and social features.\n   */\n  activeBattles?: Battle[];\n\n  /**\n   * List of user's friends with their gaming statistics.\n   * Enables social features and friend challenges.\n   */\n  friends?: FriendWithStats[];\n\n  /**\n   * User's unlocked achievements and progress tracking.\n   * Provides gamification and motivation through milestone recognition.\n   */\n  achievements?: Achievement[];\n\n  /**\n   * Active tournaments the user can participate in.\n   * Larger-scale competitive events with multiple participants.\n   */\n  tournaments?: Tournament[];\n\n  /**\n   * Teams the user belongs to for group challenges.\n   * Enables collaborative alarm goals and team-based competitions.\n   */\n  teams?: Team[];\n\n  /**\n   * Current gaming season information and leaderboards.\n   * Provides seasonal context for competitions and rewards.\n   */\n  currentSeason?: Season;\n\n  // Legacy support (deprecated)\n\n  /**\n   * @deprecated Use `currentTheme` instead\n   * Legacy theme property maintained for backward compatibility.\n   * Will be removed in a future version.\n   */\n  theme?: Theme;\n}\n\n// Enhanced Alarm Form Data\nexport interface AlarmFormData {\n  time: string;\n  label: string;\n  days: number[];\n  voiceMood: VoiceMood;\n  // Enhanced Battles additions\n  difficulty?: AlarmDifficulty;\n  sound?: string;\n  snoozeEnabled?: boolean;\n  snoozeInterval?: number;\n  weatherEnabled?: boolean;\n  battleEnabled?: boolean;\n}\n\nexport interface VoiceRecognitionResult {\n  transcript: string;\n  confidence: number;\n  isValidResponse: boolean;\n}\n\n// Rewards System Types\nexport interface Reward {\n  id: string;\n  type: 'achievement' | 'streak' | 'milestone' | 'habit_boost' | 'niche_mastery';\n  title: string;\n  description: string;\n  icon: string;\n  category: RewardCategory;\n  rarity: 'common' | 'rare' | 'epic' | 'legendary';\n  points: number;\n  unlockedAt: Date;\n  progress?: RewardProgress;\n  aiInsight?: string;\n  personalizedMessage?: string;\n}\n\nexport type RewardCategory =\n  | 'consistency'\n  | 'early_riser'\n  | 'night_owl'\n  | 'productivity'\n  | 'wellness'\n  | 'social'\n  | 'explorer'\n  | 'master'\n  | 'challenger';\n\nexport interface RewardProgress {\n  current: number;\n  target: number;\n  percentage: number;\n  nextMilestone?: string;\n}\n\nexport interface UserHabit {\n  id: string;\n  pattern: 'morning_routine' | 'evening_routine' | 'workout_time' | 'work_schedule' | 'weekend_vibes' | 'custom';\n  frequency: number; // times per week\n  consistency: number; // 0-1 score\n  improvement: number; // trend score\n  niche: UserNiche;\n  lastAnalyzed: Date;\n}\n\nexport interface UserNiche {\n  primary: 'fitness' | 'work' | 'study' | 'creative' | 'family' | 'health' | 'social' | 'spiritual';\n  secondary?: UserNiche['primary'];\n  confidence: number; // AI confidence 0-1\n  traits: string[]; // AI-detected personality traits\n  preferences: {\n    morningPerson: boolean;\n    weekendSleeper: boolean;\n    consistentSchedule: boolean;\n    voiceMoodPreference: VoiceMood[];\n  };\n}\n\nexport interface AIInsight {\n  id: string;\n  type: 'habit_analysis' | 'improvement_suggestion' | 'pattern_recognition' | 'reward_recommendation';\n  title: string;\n  message: string;\n  confidence: number;\n  actionable: boolean;\n  suggestedActions?: string[];\n  createdAt: Date;\n  priority: 'low' | 'medium' | 'high';\n}\n\nexport interface RewardSystem {\n  totalPoints: number;\n  level: number;\n  currentStreak: number;\n  longestStreak: number;\n  unlockedRewards: Reward[];\n  availableRewards: Reward[];\n  habits: UserHabit[];\n  niche: UserNiche;\n  aiInsights: AIInsight[];\n  lastAnalysis: Date;\n  // Enhanced Battles integration\n  achievements?: Achievement[];\n  dailyChallenges?: DailyChallenge[];\n  weeklyChallenges?: WeeklyChallenge[];\n  experienceHistory?: ExperienceGain[];\n  levelRewards?: LevelReward[];\n}\n\n// ============================================================================\n// STRUGGLING SAM OPTIMIZATION TYPES - Gamification & Social Proof\n// ============================================================================\n\n// User Streak System\nexport interface UserStreak {\n  id: string;\n  userId: string;\n  currentStreak: number;\n  longestStreak: number;\n  lastWakeUpDate: string; // YYYY-MM-DD\n  streakType: 'daily_wakeup' | 'weekly_consistency' | 'monthly_progress';\n  freezesUsed: number;\n  maxFreezes: number;\n  multiplier: number; // streak bonus multiplier\n  milestones: StreakMilestone[];\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface StreakMilestone {\n  id: string;\n  streakDays: number;\n  title: string;\n  description: string;\n  reward: StreakReward;\n  unlockedAt?: Date;\n  celebrated: boolean;\n}\n\nexport interface StreakReward {\n  type: 'badge' | 'experience' | 'feature_unlock' | 'discount' | 'social_share';\n  value: string | number;\n  description: string;\n  iconUrl?: string;\n}\n\n// Achievement System for Struggling Sam\nexport interface SamAchievement {\n  id: string;\n  userId: string;\n  achievementType: SamAchievementType;\n  title: string;\n  description: string;\n  iconUrl: string;\n  rarity: 'common' | 'rare' | 'epic' | 'legendary';\n  unlockedAt: Date;\n  shared: boolean;\n  progress?: AchievementProgress;\n  requirements: AchievementRequirement[];\n  socialProofText: string; // Text for sharing\n}\n\nexport type SamAchievementType =\n  | 'early_bird' // 5 consecutive days\n  | 'consistent_riser' // 14 days\n  | 'morning_champion' // 30 days\n  | 'streak_warrior' // 50 days\n  | 'habit_master' // 100 days\n  | 'social_butterfly' // share 3 achievements\n  | 'community_helper' // join 5 challenges\n  | 'comeback_kid' // recover from streak break\n  | 'weekend_warrior' // wake up early on weekends\n  | 'month_perfectionist'; // perfect month\n\n// Social Proof System\nexport interface SocialProofData {\n  id: string;\n  type: SocialProofType;\n  content: string;\n  timestamp: Date;\n  isRealTime: boolean;\n  userSegment?: PersonaType;\n  engagement?: SocialEngagement;\n}\n\nexport type SocialProofType =\n  | 'user_count' // \"47 people started their morning routine in the last hour\"\n  | 'success_story' // Real user testimonials\n  | 'achievement_unlock' // \"John just unlocked Early Bird badge!\"\n  | 'streak_milestone' // \"Sarah reached a 30-day streak!\"\n  | 'community_activity' // \"15 people joined challenges today\"\n  | 'upgrade_social_proof' // \"Join 15,420+ users who upgraded\"\n  | 'peer_comparison'; // \"Users like you average 25-day streaks\"\n\nexport interface SocialEngagement {\n  views: number;\n  clicks: number;\n  shares: number;\n  conversionRate: number;\n  lastUpdated: Date;\n}\n\n// Social Challenges\nexport interface SocialChallenge {\n  id: string;\n  creatorId: string;\n  title: string;\n  description: string;\n  challengeType: SocialChallengeType;\n  difficulty: 'easy' | 'medium' | 'hard';\n  duration: number; // days\n  maxParticipants: number;\n  currentParticipants: number;\n  participants: ChallengeParticipant[];\n  startDate: Date;\n  endDate: Date;\n  status: 'draft' | 'active' | 'completed' | 'cancelled';\n  rewards: SocialChallengeReward[];\n  leaderboard: ChallengeLeaderboard[];\n  socialProofMetrics: SocialProofMetrics;\n  createdAt: Date;\n}\n\nexport type SocialChallengeType =\n  | 'streak_competition' // Who can maintain longest streak\n  | 'early_wake_challenge' // Wake up before specific time\n  | 'consistency_challenge' // Wake up same time daily\n  | 'group_motivation' // Support each other\n  | 'habit_building' // Build new morning routine\n  | 'peer_accountability'; // Check in with each other\n\nexport interface ChallengeParticipant {\n  userId: string;\n  user: Pick<User, 'id' | 'username' | 'displayName' | 'avatar'>;\n  joinedAt: Date;\n  progress: number; // 0-100\n  currentStreak: number;\n  lastActivity: Date;\n  rank: number;\n  isActive: boolean;\n}\n\nexport interface SocialChallengeReward {\n  type: 'badge' | 'experience' | 'streak_freeze' | 'premium_trial' | 'discount';\n  value: string | number;\n  description: string;\n  eligibleRanks: number[]; // which ranks get this reward\n}\n\nexport interface ChallengeLeaderboard {\n  rank: number;\n  userId: string;\n  username: string;\n  score: number;\n  progress: number;\n  streak: number;\n  lastActivity: Date;\n}\n\nexport interface SocialProofMetrics {\n  totalParticipants: number;\n  activeParticipants: number;\n  completionRate: number;\n  shareCount: number;\n  engagementScore: number;\n}\n\n// Smart Upgrade Prompts for Struggling Sam\nexport interface SmartUpgradePrompt {\n  id: string;\n  userId: string;\n  triggerType: UpgradeTriggerType;\n  promptType: UpgradePromptType;\n  title: string;\n  description: string;\n  benefits: string[];\n  socialProof: string;\n  discount?: UpgradeDiscount;\n  urgency: UpgradeUrgency;\n  context: UpgradeContext;\n  isShown: boolean;\n  shownAt?: Date;\n  clickedAt?: Date;\n  convertedAt?: Date;\n  dismissedAt?: Date;\n  createdAt: Date;\n}\n\nexport type UpgradeTriggerType =\n  | 'streak_milestone' // Day 7, 14, 21, 30\n  | 'achievement_unlock' // After unlocking achievement\n  | 'social_sharing' // After sharing achievement\n  | 'challenge_completion' // After completing challenge\n  | 'habit_formation' // After consistent behavior\n  | 'feature_limitation' // When hitting free limits\n  | 'peer_influence'; // When friends upgrade\n\nexport type UpgradePromptType =\n  | 'celebration_offer' // \"Celebrate your 7-day streak with Premium!\"\n  | 'feature_unlock' // \"Unlock advanced features you've earned\"\n  | 'social_proof' // \"Join friends who upgraded for better results\"\n  | 'limited_time' // \"Special offer ending soon\"\n  | 'habit_milestone' // \"You've built the habit, now supercharge it\"\n  | 'gentle_nudge'; // Soft, supportive messaging\n\nexport interface UpgradeDiscount {\n  percentage: number;\n  duration: number; // hours\n  code?: string;\n  reason: string; // \"Streak celebration discount\"\n}\n\nexport interface UpgradeUrgency {\n  level: 'low' | 'medium' | 'high';\n  message: string;\n  expiresAt?: Date;\n}\n\nexport interface UpgradeContext {\n  streakDays: number;\n  recentAchievements: string[];\n  socialActivity: boolean;\n  engagementLevel: 'low' | 'medium' | 'high';\n  previousPromptsSeen: number;\n  daysSinceLastPrompt: number;\n}\n\n// A/B Testing Framework\nexport interface ABTestGroup {\n  id: string;\n  name: string;\n  description: string;\n  percentage: number; // 0-100\n  isControl: boolean;\n  features: ABTestFeature[];\n  status: 'active' | 'paused' | 'completed';\n  startDate: Date;\n  endDate?: Date;\n  results?: ABTestResults;\n}\n\nexport interface ABTestFeature {\n  featureId: string;\n  variant: string;\n  enabled: boolean;\n  configuration: Record<string, any>;\n}\n\nexport interface ABTestResults {\n  totalUsers: number;\n  conversionRate: number;\n  significanceLevel: number;\n  confidenceInterval: [number, number];\n  metrics: ABTestMetrics;\n  isWinner: boolean;\n  lastUpdated: Date;\n}\n\nexport interface ABTestMetrics {\n  streakEngagement: number;\n  achievementUnlocks: number;\n  socialSharing: number;\n  upgradeConversion: number;\n  retentionRate: number;\n  timeToConvert: number; // days\n}\n\n// User Assignment to A/B Tests\nexport interface UserABTest {\n  userId: string;\n  testId: string;\n  groupId: string;\n  assignedAt: Date;\n  isActive: boolean;\n  hasConverted: boolean;\n  convertedAt?: Date;\n  metrics: UserABTestMetrics;\n}\n\nexport interface UserABTestMetrics {\n  sessionsCount: number;\n  featuresUsed: string[];\n  engagementScore: number;\n  retentionDays: number;\n  lastActivity: Date;\n}\n\n// Habit Celebration System\nexport interface HabitCelebration {\n  id: string;\n  userId: string;\n  celebrationType: CelebrationType;\n  trigger: CelebrationTrigger;\n  title: string;\n  message: string;\n  animation: CelebrationAnimation;\n  rewards: CelebrationReward[];\n  socialShare: CelebrationSocialShare;\n  isShown: boolean;\n  shownAt?: Date;\n  sharedAt?: Date;\n  createdAt: Date;\n}\n\nexport type CelebrationType =\n  | 'streak_milestone' // 3, 7, 14, 30 days\n  | 'achievement_unlock' // New badge earned\n  | 'challenge_complete' // Finished social challenge\n  | 'comeback_success' // Recovered from streak break\n  | 'weekend_success' // Maintained streak over weekend\n  | 'monthly_perfect'; // Perfect month completed\n\nexport interface CelebrationTrigger {\n  type: 'streak_reached' | 'achievement_earned' | 'challenge_won' | 'milestone_hit';\n  value: number;\n  context: Record<string, any>;\n}\n\nexport interface CelebrationAnimation {\n  type: 'confetti' | 'fireworks' | 'pulse' | 'bounce' | 'glow';\n  duration: number; // milliseconds\n  intensity: 'subtle' | 'moderate' | 'intense';\n  colors: string[];\n}\n\nexport interface CelebrationReward {\n  type: 'badge' | 'experience' | 'streak_freeze' | 'discount' | 'social_unlock';\n  value: string | number;\n  description: string;\n  immediate: boolean;\n}\n\nexport interface CelebrationSocialShare {\n  enabled: boolean;\n  defaultMessage: string;\n  imageUrl?: string;\n  hashtags: string[];\n  platforms: ('twitter' | 'facebook' | 'instagram' | 'linkedin')[];\n}\n\n// Success Stories & Testimonials\nexport interface SuccessStory {\n  id: string;\n  userId?: string; // Anonymous if null\n  userName: string;\n  userAvatar?: string;\n  title: string;\n  story: string;\n  beforeAfter: BeforeAfterStats;\n  tags: string[];\n  verified: boolean;\n  featured: boolean;\n  likes: number;\n  shares: number;\n  createdAt: Date;\n  persona: PersonaType;\n  conversionImpact: number; // conversion lift when shown\n}\n\nexport interface BeforeAfterStats {\n  before: {\n    wakeUpTime: string;\n    consistency: number; // 0-100\n    energy: number; // 1-10\n  };\n  after: {\n    wakeUpTime: string;\n    consistency: number;\n    energy: number;\n    streakDays: number;\n  };\n  improvement: {\n    consistencyImprovement: number;\n    energyImprovement: number;\n    timeImprovement: number; // minutes earlier\n  };\n}\n\n// Community Statistics for Social Proof\nexport interface CommunityStats {\n  totalUsers: number;\n  activeToday: number;\n  totalStreaks: number;\n  averageStreak: number;\n  achievementsUnlocked: number;\n  challengesActive: number;\n  successRate: number;\n  lastUpdated: Date;\n  realtimeActivity: RealtimeActivity[];\n}\n\nexport interface RealtimeActivity {\n  id: string;\n  type: 'streak_started' | 'achievement_unlocked' | 'challenge_joined' | 'milestone_reached';\n  message: string;\n  timestamp: Date;\n  anonymous: boolean;\n}\n\n// ============================================================================\n// PREMIUM SUBSCRIPTION TYPES - Subscription & Feature Gating\n// ============================================================================\n\n// Note: SubscriptionTier, SubscriptionStatus, and PremiumFeature are now defined in premium.ts\n\n// Note: SubscriptionPlan interface defined later in file with more comprehensive properties\n\n// Detailed subscription status interface\nexport interface SubscriptionDetails {\n  isActive: boolean;\n  expiresAt?: string; // ISO date string\n  renewsAt?: string; // ISO date string\n  cancelledAt?: string; // ISO date string\n  paymentMethod?: PaymentMethod;\n  billingCycle: 'monthly' | 'yearly';\n  trialEndsAt?: string; // ISO date string\n  isTrialActive?: boolean;\n  features: SubscriptionFeatureAccess;\n  limits: SubscriptionLimits;\n  nextBillingAmount?: number;\n  currency: string;\n}\n\n// Payment method information\nexport interface PaymentMethod {\n  type: 'card' | 'paypal' | 'apple_pay' | 'google_pay';\n  last4?: string; // last 4 digits for cards\n  brand?: string; // visa, mastercard, etc.\n  expiryMonth?: number;\n  expiryYear?: number;\n  isDefault: boolean;\n}\n\n// Feature access details\nexport interface SubscriptionFeatureAccess {\n  nuclearMode: boolean;\n  customVoices: boolean;\n  voiceCloning: boolean;\n  extraPersonalities: boolean;\n  advancedAnalytics: boolean;\n  unlimitedAlarms: boolean;\n  smartScheduling: boolean;\n  premiumThemes: boolean;\n  prioritySupport: boolean;\n  whiteLabel: boolean;\n  apiAccess: boolean;\n}\n\n// Subscription limits\nexport interface SubscriptionLimits {\n  maxAlarms: number | null; // null means unlimited\n  maxCustomVoices: number | null;\n  maxThemes: number | null;\n  apiCallsPerMonth: number | null;\n  storageQuotaMB: number | null;\n  cloudBackups: number | null;\n}\n\n// Subscription usage tracking\nexport interface SubscriptionUsage {\n  currentAlarms: number;\n  currentCustomVoices: number;\n  apiCallsThisMonth: number;\n  storageUsedMB: number;\n  lastUpdated: string;\n}\n\n// Premium upgrade options\nexport interface UpgradeOption {\n  discount?: number; // percentage\n  promoCode?: string;\n  urgency?: 'low' | 'medium' | 'high';\n  benefits: string[];\n  testimonials?: CustomerTestimonial[];\n}\n\n// Customer testimonials for upgrade prompts\nexport interface CustomerTestimonial {\n  id: string;\n  customerName: string;\n  customerTitle?: string;\n  content: string;\n  rating: number; // 1-5\n  verified: boolean;\n}\n\n// Nuclear mode specific types\nexport interface NuclearModeChallenge {\n  id: string;\n  type: NuclearChallengeType;\n  title: string;\n  description: string;\n  difficulty: number; // 1-10\n  timeLimit?: number; // seconds\n  attempts: number;\n  maxAttempts: number;\n  instructions: string[];\n  successCriteria: string;\n  failureConsequence: string;\n  hints?: string[];\n  configuration: NuclearChallengeConfig;\n}\n\nexport type NuclearChallengeType =\n  | 'multi_step_math'\n  | 'memory_sequence'\n  | 'physical_movement'\n  | 'barcode_scan'\n  | 'photo_proof'\n  | 'voice_recognition'\n  | 'typing_challenge'\n  | 'pattern_matching'\n  | 'location_verification'\n  | 'qr_code_hunt'\n  | 'shake_intensity'\n  | 'sound_matching'\n  | 'color_sequence'\n  | 'puzzle_solving'\n  | 'riddle_answer';\n\nexport interface NuclearChallengeConfig {\n  mathComplexity?: 'basic' | 'advanced' | 'expert';\n  sequenceLength?: number;\n  movementType?: 'shake' | 'walk' | 'jump' | 'spin';\n  barcodeRequired?: string; // specific barcode to scan\n  photoType?: 'selfie' | 'environment' | 'specific_object';\n  voicePhrase?: string;\n  typingText?: string;\n  typingSpeed?: number; // WPM required\n  patternSize?: number;\n  locationRadius?: number; // meters\n  qrCodes?: string[]; // QR code content\n  shakeThreshold?: number;\n  soundFile?: string;\n  colorCount?: number;\n  puzzleComplexity?: 'easy' | 'medium' | 'hard';\n  riddleCategory?: string;\n}\n\n// Nuclear mode session tracking\nexport interface NuclearModeSession {\n  id: string;\n  alarmId: string;\n  userId: string;\n  startedAt: string;\n  completedAt?: string;\n  challenges: NuclearChallengeAttempt[];\n  totalAttempts: number;\n  successfulChallenges: number;\n  failedChallenges: number;\n  sessionDuration: number; // seconds\n  difficulty: number; // 1-10\n  result: 'completed' | 'failed' | 'abandoned';\n  performance: NuclearPerformance;\n}\n\nexport interface NuclearChallengeAttempt {\n  challengeId: string;\n  challenge: NuclearModeChallenge;\n  attemptNumber: number;\n  startedAt: string;\n  completedAt?: string;\n  successful: boolean;\n  timeToComplete?: number; // seconds\n  hintsUsed: number;\n  errorsMade: number;\n  details?: Record<string, any>; // challenge-specific data\n}\n\nexport interface NuclearPerformance {\n  overallScore: number; // 0-100\n  speed: number; // 0-100\n  accuracy: number; // 0-100\n  persistence: number; // 0-100\n  improvement: number; // compared to previous sessions\n  rank: number; // among all nuclear mode users\n  achievements: string[]; // achievement IDs unlocked\n}\n\n// Premium voice system types\nexport interface PremiumVoice {\n  id: string;\n  name: string;\n  description: string;\n  mood: VoiceMood;\n  category: PremiumVoiceCategory;\n  language: string;\n  accent?: string;\n  gender: 'male' | 'female' | 'neutral' | 'custom';\n  ageRange: string; // e.g., \"young adult\", \"middle-aged\"\n  personality: VoicePersonality;\n  samples: VoiceSample[];\n  isCustom: boolean;\n  createdBy?: string; // user ID for custom voices\n  tags: string[];\n  popularity: number;\n  rating: number; // 1-5\n  downloadCount: number;\n  features: VoiceFeatures;\n}\n\nexport type PremiumVoiceCategory =\n  | 'celebrity_style'\n  | 'professional'\n  | 'entertainment'\n  | 'motivational'\n  | 'soothing'\n  | 'energetic'\n  | 'character'\n  | 'custom'\n  | 'ai_generated';\n\nexport interface VoicePersonality {\n  energy: number; // 1-10\n  friendliness: number; // 1-10\n  authority: number; // 1-10\n  humor: number; // 1-10\n  empathy: number; // 1-10\n  directness: number; // 1-10\n}\n\nexport interface VoiceSample {\n  id: string;\n  text: string;\n  audioUrl: string;\n  duration: number; // seconds\n  context: 'wake_up' | 'motivation' | 'challenge' | 'success' | 'failure';\n}\n\nexport interface VoiceFeatures {\n  supportsSSML: boolean; // Speech Synthesis Markup Language\n  supportsEmotions: boolean;\n  supportsSpeedControl: boolean;\n  supportsPitchControl: boolean;\n  supportsBreathing: boolean;\n  supportsWhisper: boolean;\n  supportsEmphasis: boolean;\n  maxTextLength: number;\n}\n\n// Voice cloning (Ultimate tier feature)\nexport interface VoiceCloneRequest {\n  id: string;\n  userId: string;\n  name: string;\n  description?: string;\n  sourceType: 'upload' | 'record' | 'import';\n  audioFiles: VoiceCloneFile[];\n  status: VoiceCloneStatus;\n  progress: number; // 0-100\n  estimatedCompletion?: string;\n  createdAt: string;\n  completedAt?: string;\n  result?: VoiceCloneResult;\n  settings: VoiceCloneSettings;\n}\n\nexport type VoiceCloneStatus =\n  | 'pending'\n  | 'processing'\n  | 'training'\n  | 'completed'\n  | 'failed'\n  | 'cancelled';\n\nexport interface VoiceCloneFile {\n  id: string;\n  fileName: string;\n  fileSize: number;\n  duration: number; // seconds\n  uploadedAt: string;\n  processed: boolean;\n  quality: 'low' | 'medium' | 'high' | 'excellent';\n  transcription?: string;\n}\n\nexport interface VoiceCloneResult {\n  voiceId: string;\n  quality: number; // 1-10\n  similarity: number; // 1-10 compared to source\n  naturalness: number; // 1-10\n  clarity: number; // 1-10\n  recommendations: string[];\n  limitationsWarning?: string;\n}\n\nexport interface VoiceCloneSettings {\n  enhanceQuality: boolean;\n  removeNoise: boolean;\n  normalizeVolume: boolean;\n  targetLanguage: string;\n  voiceGender?: 'preserve' | 'male' | 'female' | 'neutral';\n  speedAdjustment: number; // -50 to +50\n  pitchAdjustment: number; // -50 to +50\n  addEmotions: boolean;\n}\n\n// Premium analytics types\nexport interface PremiumAnalytics {\n  userId: string;\n  period: AnalyticsPeriod;\n  sleepInsights: SleepInsights;\n  wakeUpPatterns: WakeUpPatterns;\n  performanceMetrics: PerformanceMetrics;\n  recommendations: AnalyticsRecommendation[];\n  trends: AnalyticsTrend[];\n  comparisons: AnalyticsComparison;\n  goals: AnalyticsGoal[];\n  achievements: AnalyticsAchievement[];\n  exportOptions: AnalyticsExportOption[];\n}\n\nexport type AnalyticsPeriod = 'week' | 'month' | 'quarter' | 'year' | 'custom';\n\nexport interface SleepInsights {\n  averageSleepDuration: number; // hours\n  sleepQualityScore: number; // 1-10\n  consistencyScore: number; // 1-10\n  optimalBedtime: string;\n  optimalWakeTime: string;\n  sleepDebt: number; // hours\n  weekendCatchUp: number; // hours\n  sleepEfficiency: number; // percentage\n  factors: SleepFactorAnalysis[];\n}\n\nexport interface SleepFactorAnalysis {\n  factor: string;\n  impact: 'positive' | 'negative' | 'neutral';\n  strength: number; // 1-10\n  frequency: number; // how often it occurs\n  recommendation: string;\n}\n\nexport interface WakeUpPatterns {\n  averageWakeTime: string;\n  consistencyScore: number; // 1-10\n  weekdayPattern: TimePattern;\n  weekendPattern: TimePattern;\n  seasonalTrends: SeasonalTrend[];\n  moodCorrelations: MoodCorrelation[];\n}\n\nexport interface TimePattern {\n  average: string;\n  earliest: string;\n  latest: string;\n  variance: number; // minutes\n  trend: 'improving' | 'declining' | 'stable';\n}\n\nexport interface SeasonalTrend {\n  season: 'spring' | 'summer' | 'fall' | 'winter';\n  averageWakeTime: string;\n  sleepDuration: number;\n  qualityScore: number;\n}\n\nexport interface MoodCorrelation {\n  mood: WakeUpMood;\n  frequency: number; // percentage\n  averageWakeTime: string;\n  sleepDuration: number;\n  factorsInfluencing: string[];\n}\n\nexport interface PerformanceMetrics {\n  wakeUpSuccessRate: number; // percentage\n  averageSnoozeCount: number;\n  challengeSuccessRate: number; // percentage\n  improvementRate: number; // percentage month over month\n  streakMetrics: StreakMetrics;\n  difficultyProgression: DifficultyProgression;\n}\n\nexport interface StreakMetrics {\n  currentStreak: number;\n  longestStreak: number;\n  averageStreakLength: number;\n  streakBreakReasons: StreakBreakReason[];\n}\n\nexport interface StreakBreakReason {\n  reason: string;\n  frequency: number; // percentage\n  impact: 'minor' | 'moderate' | 'major';\n}\n\nexport interface DifficultyProgression {\n  currentLevel: AlarmDifficulty;\n  recommendedNext: AlarmDifficulty;\n  readinessScore: number; // 1-10\n  skillAreas: SkillArea[];\n}\n\nexport interface SkillArea {\n  area: string;\n  currentLevel: number; // 1-10\n  improvement: number; // change from last period\n  exercises: string[];\n}\n\nexport interface AnalyticsRecommendation {\n  id: string;\n  type: 'sleep' | 'wake_time' | 'difficulty' | 'routine' | 'health';\n  priority: 'low' | 'medium' | 'high' | 'urgent';\n  title: string;\n  description: string;\n  expectedImpact: string;\n  timeToSeeResults: string;\n  actionSteps: string[];\n  basedOn: string[]; // data sources\n  confidence: number; // 1-10\n}\n\nexport interface AnalyticsTrend {\n  metric: string;\n  direction: 'improving' | 'declining' | 'stable';\n  magnitude: number; // how significant\n  timeframe: string;\n  prediction: string;\n  factors: string[];\n}\n\nexport interface AnalyticsComparison {\n  personalBest: Record<string, number>;\n  lastPeriod: Record<string, number>;\n  peerAverage: Record<string, number>;\n  globalAverage: Record<string, number>;\n  ranking: AnalyticsRanking;\n}\n\nexport interface AnalyticsRanking {\n  overall: number; // percentile\n  consistency: number;\n  improvement: number;\n  longevity: number; // how long using the app\n}\n\nexport interface AnalyticsGoal {\n  id: string;\n  type: 'consistency' | 'wake_time' | 'sleep_duration' | 'difficulty' | 'custom';\n  title: string;\n  target: number;\n  current: number;\n  progress: number; // percentage\n  deadline?: string;\n  reward?: string;\n  status: 'active' | 'completed' | 'paused' | 'failed';\n}\n\nexport interface AnalyticsAchievement {\n  id: string;\n  title: string;\n  description: string;\n  unlockedAt: string;\n  rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';\n  category: string;\n  value: number;\n}\n\nexport interface AnalyticsExportOption {\n  format: 'pdf' | 'csv' | 'json' | 'xlsx';\n  title: string;\n  description: string;\n  dataIncluded: string[];\n  premium: boolean;\n}\n\n// ============================================================================\n// ENHANCED BATTLES TYPES - Gaming & Competition Features\n// ============================================================================\n\n// Enhanced Theme & Personalization Types\nexport type Theme =\n  | 'light'\n  | 'dark'\n  | 'auto'\n  | 'system'\n  | 'high-contrast'\n  | 'minimalist'\n  | 'colorful'\n  | 'nature'\n  | 'ocean'\n  | 'sunset'\n  | 'forest'\n  | 'cosmic'\n  | 'gradient'\n  | 'neon'\n  | 'pastel'\n  | 'monochrome'\n  | 'gaming'\n  | 'professional'\n  | 'retro'\n  | 'cyberpunk'\n  | 'spring'\n  | 'summer'\n  | 'autumn'\n  | 'winter'\n  | 'focus'\n  | 'ocean-breeze'\n  | 'sunset-glow'\n  | 'forest-dream'\n  | 'midnight-cosmos'\n  | 'custom';\n\nexport interface ThemeConfig {\n  id: string;\n  name: string;\n  displayName: string;\n  description: string;\n  category: ThemeCategory;\n  colors: ThemeColors;\n  typography: ThemeTypography;\n  spacing: ThemeSpacing;\n  animations: ThemeAnimations;\n  effects: ThemeEffects;\n  accessibility: ThemeAccessibility;\n  previewImage?: string;\n  isCustom: boolean;\n  isPremium: boolean;\n  createdBy?: string;\n  createdAt?: Date;\n  popularity?: number;\n  rating?: number;\n}\n\nexport type ThemeCategory = 'system' | 'nature' | 'abstract' | 'gradient' | 'accessibility' | 'premium' | 'custom';\n\nexport interface ThemeColors {\n  // Base colors\n  primary: ColorPalette;\n  secondary: ColorPalette;\n  accent: ColorPalette;\n  neutral: ColorPalette;\n\n  // Semantic colors\n  success: ColorPalette;\n  warning: ColorPalette;\n  error: ColorPalette;\n  info: ColorPalette;\n\n  // Background colors\n  background: {\n    primary: string;\n    secondary: string;\n    tertiary: string;\n    overlay: string;\n    modal: string;\n    card: string;\n  };\n\n  // Text colors\n  text: {\n    primary: string;\n    secondary: string;\n    tertiary: string;\n    inverse: string;\n    disabled: string;\n    link: string;\n  };\n\n  // Border colors\n  border: {\n    primary: string;\n    secondary: string;\n    focus: string;\n    hover: string;\n    active: string;\n  };\n\n  // Surface colors\n  surface: {\n    elevated: string;\n    depressed: string;\n    interactive: string;\n    disabled: string;\n  };\n}\n\nexport interface ColorPalette {\n  50: string;\n  100: string;\n  200: string;\n  300: string;\n  400: string;\n  500: string; // base color\n  600: string;\n  700: string;\n  800: string;\n  900: string;\n  950: string;\n}\n\nexport interface ThemeTypography {\n  fontFamily: {\n    primary: string;\n    secondary: string;\n    monospace: string;\n  };\n  fontSize: {\n    xs: string;\n    sm: string;\n    base: string;\n    lg: string;\n    xl: string;\n    '2xl': string;\n    '3xl': string;\n    '4xl': string;\n    '5xl': string;\n  };\n  fontWeight: {\n    light: number;\n    normal: number;\n    medium: number;\n    semibold: number;\n    bold: number;\n    extrabold: number;\n  };\n  lineHeight: {\n    tight: number;\n    normal: number;\n    relaxed: number;\n    loose: number;\n  };\n  letterSpacing: {\n    tight: string;\n    normal: string;\n    wide: string;\n  };\n}\n\nexport interface ThemeSpacing {\n  scale: number; // base scale multiplier\n  sizes: {\n    0: string;\n    1: string;\n    2: string;\n    3: string;\n    4: string;\n    5: string;\n    6: string;\n    8: string;\n    10: string;\n    12: string;\n    16: string;\n    20: string;\n    24: string;\n    32: string;\n    40: string;\n    48: string;\n    56: string;\n    64: string;\n  };\n  borderRadius: {\n    none: string;\n    sm: string;\n    base: string;\n    md: string;\n    lg: string;\n    xl: string;\n    '2xl': string;\n    '3xl': string;\n    full: string;\n  };\n}\n\nexport interface ThemeAnimations {\n  enabled: boolean;\n  duration: {\n    fast: string;\n    normal: string;\n    slow: string;\n  };\n  easing: {\n    linear: string;\n    ease: string;\n    easeIn: string;\n    easeOut: string;\n    easeInOut: string;\n    bounce: string;\n    elastic: string;\n  };\n  scale: number; // global animation speed multiplier\n}\n\nexport interface ThemeEffects {\n  shadows: {\n    sm: string;\n    base: string;\n    md: string;\n    lg: string;\n    xl: string;\n    '2xl': string;\n    inner: string;\n    none: string;\n  };\n  blur: {\n    sm: string;\n    base: string;\n    md: string;\n    lg: string;\n    xl: string;\n    '2xl': string;\n    '3xl': string;\n  };\n  opacity: {\n    disabled: number;\n    hover: number;\n    focus: number;\n    overlay: number;\n  };\n  gradients: {\n    primary: string;\n    secondary: string;\n    accent: string;\n    background: string;\n  };\n}\n\nexport interface ThemeAccessibility {\n  contrastRatio: 'AA' | 'AAA' | 'custom';\n  reduceMotion: boolean;\n  highContrast: boolean;\n  largeFonts: boolean;\n  focusVisible: boolean;\n  reducedTransparency: boolean;\n}\n\nexport interface PersonalizationSettings {\n  theme: Theme;\n  customTheme?: CustomThemeConfig;\n  colorPreferences: ColorPreferences;\n  typographyPreferences: TypographyPreferences;\n  motionPreferences: MotionPreferences;\n  soundPreferences: SoundPreferences;\n  layoutPreferences: LayoutPreferences;\n  accessibilityPreferences: AccessibilityPreferences;\n  lastUpdated: Date;\n  syncAcrossDevices: boolean;\n}\n\nexport interface CustomThemeConfig extends ThemeConfig {\n  baseTheme: Theme; // theme this custom theme is based on\n  customizations: ThemeCustomizations;\n  isShared: boolean;\n  sharedWith?: string[]; // user IDs\n}\n\nexport interface ThemeCustomizations {\n  colors?: Partial<ThemeColors>;\n  typography?: Partial<ThemeTypography>;\n  spacing?: Partial<ThemeSpacing>;\n  animations?: Partial<ThemeAnimations>;\n  effects?: Partial<ThemeEffects>;\n  overrides?: CSSCustomProperties;\n}\n\nexport interface CSSCustomProperties {\n  [key: string]: string | number;\n}\n\nexport interface ColorPreferences {\n  favoriteColors: string[];\n  avoidColors: string[];\n  colorblindFriendly: boolean;\n  highContrastMode: boolean;\n  customAccentColor?: string;\n  saturationLevel: number; // 0-100\n  brightnessLevel: number; // 0-100\n  warmthLevel: number; // 0-100 (warm to cool)\n}\n\nexport interface TypographyPreferences {\n  preferredFontSize: 'small' | 'medium' | 'large' | 'extra-large';\n  fontSizeScale: number; // multiplier for base font size\n  preferredFontFamily: 'system' | 'sans-serif' | 'serif' | 'monospace' | 'custom';\n  customFontFamily?: string;\n  lineHeightPreference: 'compact' | 'comfortable' | 'relaxed';\n  letterSpacingPreference: 'tight' | 'normal' | 'wide';\n  fontWeight: 'light' | 'normal' | 'medium' | 'bold';\n  dyslexiaFriendly: boolean;\n}\n\nexport interface MotionPreferences {\n  enableAnimations: boolean;\n  animationSpeed: 'slow' | 'normal' | 'fast';\n  reduceMotion: boolean;\n  preferCrossfade: boolean;\n  enableParallax: boolean;\n  enableHoverEffects: boolean;\n  enableFocusAnimations: boolean;\n}\n\nexport interface SoundPreferences {\n  enableSounds: boolean;\n  soundVolume: number; // 0-100\n  soundTheme: SoundTheme;\n  customSounds: CustomSoundMapping;\n  muteOnFocus: boolean;\n  hapticFeedback: boolean;\n  spatialAudio: boolean;\n}\n\nexport type SoundTheme =\n  | 'default'\n  | 'nature'\n  | 'electronic'\n  | 'retro'\n  | 'minimal'\n  | 'energetic'\n  | 'calm'\n  | 'ambient'\n  | 'cinematic'\n  | 'futuristic'\n  | 'meditation'\n  | 'workout'\n  | 'fantasy'\n  | 'horror'\n  | 'cyberpunk'\n  | 'lofi'\n  | 'classical'\n  | 'jazz'\n  | 'rock'\n  | 'custom';\n\nexport interface CustomSoundMapping {\n  [action: string]: string; // action -> sound file URL\n}\n\nexport interface LayoutPreferences {\n  density: 'compact' | 'comfortable' | 'spacious';\n  navigation: 'bottom' | 'side' | 'top';\n  cardStyle: 'flat' | 'elevated' | 'outlined';\n  borderRadius: 'sharp' | 'rounded' | 'circular';\n  showLabels: boolean;\n  showIcons: boolean;\n  iconSize: 'small' | 'medium' | 'large';\n  gridColumns: number;\n  listSpacing: 'tight' | 'normal' | 'loose';\n}\n\nexport interface AccessibilityPreferences {\n  screenReaderOptimized: boolean;\n  keyboardNavigationOnly: boolean;\n  highContrastMode: boolean;\n  largeTargets: boolean; // make clickable areas larger\n  reducedTransparency: boolean;\n  boldText: boolean;\n  underlineLinks: boolean;\n  flashingElementsReduced: boolean;\n  colorOnlyIndicators: boolean; // avoid using color as only indicator\n  focusIndicatorStyle: 'outline' | 'highlight' | 'glow';\n}\n\nexport interface ThemePreset {\n  id: string;\n  name: string;\n  description: string;\n  theme: Theme;\n  personalization: Partial<PersonalizationSettings>;\n  preview: ThemePreview;\n  tags: string[];\n  isDefault: boolean;\n  isPremium: boolean;\n  createdBy?: string;\n  popularityScore: number;\n}\n\nexport interface ThemePreview {\n  primaryColor: string;\n  backgroundColor: string;\n  textColor: string;\n  cardColor: string;\n  accentColor: string;\n  gradientPreview?: string;\n  thumbnailUrl?: string;\n}\n\nexport interface ThemeStore {\n  featured: ThemePreset[];\n  categories: ThemeStoreCategory[];\n  userThemes: CustomThemeConfig[];\n  sharedThemes: CustomThemeConfig[];\n  recentlyUsed: Theme[];\n  trending: ThemePreset[];\n}\n\nexport interface ThemeStoreCategory {\n  id: string;\n  name: string;\n  description: string;\n  icon: string;\n  themes: ThemePreset[];\n  count: number;\n}\n\nexport interface ThemeUsageAnalytics {\n  mostUsedThemes: { theme: Theme; usage: number }[];\n  timeSpentPerTheme: { theme: Theme; timeMs: number }[];\n  switchFrequency: number; // switches per day\n  favoriteColors: string[];\n  accessibilityFeatureUsage: { feature: string; enabled: boolean }[];\n  customizationActivity: ThemeCustomizationEvent[];\n}\n\nexport interface ThemeCustomizationEvent {\n  id: string;\n  type: 'color_change' | 'font_change' | 'layout_change' | 'accessibility_change';\n  property: string;\n  oldValue: any;\n  newValue: any;\n  timestamp: Date;\n  revertedAt?: Date;\n}\n\nexport interface ThemeExportData {\n  version: string;\n  exportedAt: Date;\n  themes: CustomThemeConfig[];\n  personalization: PersonalizationSettings;\n  metadata: {\n    appVersion: string;\n    platform: string;\n    userId?: string;\n  };\n}\n\nexport interface ThemeImportResult {\n  success: boolean;\n  importedThemes: string[]; // theme IDs\n  skippedThemes: string[];\n  errors: string[];\n  warnings: string[];\n  conflictResolution?: 'overwrite' | 'rename' | 'skip';\n}\n\n// Battle Types\nexport type BattleType = 'speed' | 'consistency' | 'tasks' | 'bragging' | 'group' | 'tournament' | 'team';\nexport type BattleStatus = 'pending' | 'active' | 'completed' | 'cancelled' | 'registration';\n\nexport interface Battle {\n  id: string;\n  type: BattleType;\n  participants: BattleParticipant[];\n  creatorId: string;\n  status: BattleStatus;\n  startTime: string; // ISO date string\n  endTime: string; // ISO date string\n  settings: BattleSettings;\n  winner?: string; // userId\n  createdAt: string;\n  // Enhanced battle fields\n  tournamentId?: string;\n  teamId?: string;\n  seasonId?: string;\n  maxParticipants?: number;\n  minParticipants?: number;\n  entryFee?: number; // XP cost to join\n  prizePool?: BattlePrize;\n}\n\nexport interface BattlePrize {\n  experience: number;\n  title?: string;\n  badge?: string;\n  seasonPoints?: number;\n}\n\nexport interface BattleParticipant {\n  userId: string;\n  user: User;\n  joinedAt: string;\n  progress: number; // 0-100\n  completedAt?: string;\n  stats: BattleParticipantStats;\n}\n\nexport interface BattleParticipantStats {\n  wakeTime?: string;\n  tasksCompleted: number;\n  snoozeCount: number;\n  score: number;\n}\n\nexport interface BattleSettings {\n  duration: string; // ISO duration string (e.g., \"PT24H\" for 24 hours)\n  maxParticipants?: number;\n  difficulty?: AlarmDifficulty; // difficulty level for the battle\n  tasks?: BattleTask[];\n  speedTarget?: string; // time string for speed battles\n  consistencyDays?: number; // for consistency battles\n  allowLateJoins?: boolean; // whether to allow participants to join after battle starts\n}\n\nexport interface BattleTask {\n  id: string;\n  description: string;\n  completed: boolean;\n  completedAt?: string;\n}\n\n// Community & Social Types\nexport interface Friendship {\n  id: string;\n  userId: string;\n  friendId: string;\n  status: 'pending' | 'accepted' | 'blocked';\n  createdAt: string;\n  acceptedAt?: string;\n}\n\nexport interface FriendWithStats extends User {\n  stats: UserStats;\n  friendship: Friendship;\n  isOnline: boolean;\n  activeBattles: number;\n}\n\nexport interface TrashTalkMessage {\n  id: string;\n  battleId: string;\n  userId: string;\n  user: User;\n  message: string;\n  timestamp: string;\n}\n\n// Achievement & Gamification Types\nexport interface Achievement {\n  id: string;\n  name: string;\n  description: string;\n  category: AchievementCategory;\n  type: AchievementType;\n  rarity: AchievementRarity;\n  iconUrl: string;\n  unlockedAt?: string;\n  progress?: AchievementProgress;\n  rewards: AchievementReward[];\n  requirements: AchievementRequirement[];\n}\n\nexport type AchievementCategory = 'wakeup' | 'battles' | 'social' | 'consistency' | 'challenges' | 'special';\nexport type AchievementType = 'milestone' | 'streak' | 'challenge' | 'social' | 'seasonal' | 'rare';\nexport type AchievementRarity = 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary';\n\nexport interface AchievementProgress {\n  current: number;\n  target: number;\n  percentage: number;\n}\n\nexport interface AchievementReward {\n  type: 'experience' | 'title' | 'badge' | 'avatar' | 'theme' | 'sound';\n  value: number | string;\n  description: string;\n}\n\nexport interface AchievementRequirement {\n  type: 'battles_won' | 'streak_days' | 'early_wake' | 'friends_added' | 'tournaments_won' | 'tasks_completed';\n  value: number;\n  description: string;\n}\n\nexport interface DailyChallenge {\n  id: string;\n  date: string; // YYYY-MM-DD\n  name: string;\n  description: string;\n  type: ChallengeType;\n  difficulty: ChallengeDifficulty;\n  target: number;\n  progress: number;\n  rewards: ChallengeReward[];\n  completed: boolean;\n  completedAt?: string;\n  expiresAt: string;\n}\n\nexport type ChallengeType = 'wake_early' | 'no_snooze' | 'battle_win' | 'friend_challenge' | 'task_master' | 'consistency' | 'social';\nexport type ChallengeDifficulty = 'easy' | 'medium' | 'hard' | 'expert';\n\nexport interface ChallengeReward {\n  type: 'experience' | 'badge' | 'title' | 'bonus_xp';\n  value: number | string;\n  description: string;\n}\n\nexport interface WeeklyChallenge extends DailyChallenge {\n  weekStart: string; // YYYY-MM-DD\n  dailyProgress: DailyChallengeProgress[];\n}\n\nexport interface DailyChallengeProgress {\n  date: string;\n  completed: boolean;\n  progress: number;\n}\n\nexport interface LevelReward {\n  level: number;\n  experience: number;\n  rewards: LevelRewardItem[];\n  unlocked: boolean;\n  unlockedAt?: string;\n}\n\nexport interface LevelRewardItem {\n  type: 'title' | 'badge' | 'avatar' | 'theme' | 'sound' | 'feature';\n  name: string;\n  description: string;\n  value: string;\n  rarity: AchievementRarity;\n}\n\nexport interface ExperienceGain {\n  id: string;\n  userId: string;\n  amount: number;\n  source: ExperienceSource;\n  description: string;\n  multiplier?: number;\n  timestamp: string;\n}\n\nexport type ExperienceSource = 'alarm_complete' | 'battle_win' | 'battle_participate' | 'challenge_complete' | 'achievement_unlock' | 'streak_bonus' | 'friend_referral' | 'daily_login';\n\nexport interface StreakBonus {\n  days: number;\n  multiplier: number;\n  bonusXP: number;\n  title?: string;\n  badge?: string;\n}\n\nexport interface PlayerLevel {\n  current: number;\n  experience: number;\n  experienceToNext: number;\n  experienceTotal: number;\n  progress: number; // 0-100 to next level\n}\n\n// Tournament Types\nexport interface Tournament {\n  id: string;\n  name: string;\n  description: string;\n  type: 'single-elimination' | 'round-robin' | 'swiss';\n  status: 'registration' | 'active' | 'completed';\n  participants: TournamentParticipant[];\n  maxParticipants: number;\n  rounds: TournamentRound[];\n  currentRound: number;\n  winner?: string;\n  prizePool: BattlePrize[];\n  startTime: string;\n  endTime: string;\n  entryFee: number;\n  seasonId?: string;\n  createdAt: string;\n}\n\nexport interface TournamentParticipant {\n  userId: string;\n  user: User;\n  registeredAt: string;\n  eliminated: boolean;\n  currentRound: number;\n  wins: number;\n  losses: number;\n}\n\nexport interface TournamentRound {\n  id: string;\n  roundNumber: number;\n  battles: Battle[];\n  status: 'pending' | 'active' | 'completed';\n  startTime: string;\n  endTime: string;\n}\n\n// Team Types\nexport interface Team {\n  id: string;\n  name: string;\n  description: string;\n  captainId: string;\n  members: TeamMember[];\n  maxMembers: number;\n  isPublic: boolean;\n  stats: TeamStats;\n  createdAt: string;\n  seasonId?: string;\n}\n\nexport interface TeamMember {\n  userId: string;\n  user: User;\n  role: 'captain' | 'member';\n  joinedAt: string;\n  contribution: TeamContribution;\n}\n\nexport interface TeamContribution {\n  battlesParticipated: number;\n  battlesWon: number;\n  totalScore: number;\n  averagePerformance: number;\n}\n\nexport interface TeamStats {\n  totalBattles: number;\n  wins: number;\n  losses: number;\n  winRate: number;\n  rank: number;\n  seasonPoints: number;\n  averageScore: number;\n}\n\n// Gaming Season Types\nexport interface GameSeason {\n  id: string;\n  name: string;\n  description: string;\n  status: 'upcoming' | 'active' | 'completed';\n  startDate: string;\n  endDate: string;\n  type: 'individual' | 'team' | 'mixed';\n  leaderboard: GameSeasonRanking[];\n  tournaments: Tournament[];\n  rewards: GameSeasonReward[];\n  theme: string;\n  rules: string[];\n}\n\nexport interface GameSeasonRanking {\n  rank: number;\n  userId?: string;\n  teamId?: string;\n  entity: User | Team;\n  points: number;\n  battlesWon: number;\n  totalBattles: number;\n  change: number; // position change from last update\n}\n\nexport interface GameSeasonReward {\n  rank: number;\n  experience: number;\n  title?: string;\n  badge?: string;\n  exclusiveContent?: string;\n}\n\n// Smart Features Types\nexport interface SmartAlarmSettings {\n  weatherEnabled: boolean;\n  locationEnabled: boolean;\n  fitnessEnabled: boolean;\n  smartWakeWindow: number; // minutes before alarm to start smart wake\n  adaptiveDifficulty: boolean;\n  contextualTasks: boolean;\n  environmentalAdjustments: boolean;\n}\n\nexport interface WeatherAlarm extends Alarm {\n  weatherEnabled: boolean;\n  weatherConditions: WeatherCondition[];\n  weatherActions: WeatherAction[];\n}\n\nexport interface WeatherCondition {\n  type: 'rain' | 'snow' | 'sunny' | 'cloudy' | 'windy' | 'hot' | 'cold';\n  operator: 'equals' | 'greater_than' | 'less_than';\n  value?: number; // for temperature conditions\n}\n\nexport interface WeatherAction {\n  condition: WeatherCondition;\n  action: 'adjust_time' | 'change_sound' | 'add_task' | 'send_notification';\n  value: string | number;\n  description: string;\n}\n\nexport interface WeatherData {\n  temperature: number;\n  condition: string;\n  humidity: number;\n  windSpeed: number;\n  forecast: WeatherForecast[];\n  location: string;\n  lastUpdated: string;\n}\n\nexport interface WeatherForecast {\n  time: string;\n  temperature: number;\n  condition: string;\n  precipitation: number;\n}\n\n// ===== ADVANCED ALARM SCHEDULING TYPES =====\n\n// Enhanced Alarm with Advanced Scheduling\nexport interface AdvancedAlarm {\n  scheduleType: ScheduleType;\n  recurrencePattern?: RecurrencePattern;\n  conditionalRules?: ConditionalRule[];\n  locationTriggers?: LocationTrigger[];\n  calendarIntegration?: CalendarIntegration;\n  timeZone?: string;\n  seasonalAdjustments?: SeasonalAdjustment[];\n  smartOptimizations?: SmartOptimization[];\n  dependencies?: AlarmDependency[];\n}\n\n// Schedule Types\nexport type ScheduleType =\n  | 'once'\n  | 'daily'\n  | 'weekly'\n  | 'monthly'\n  | 'yearly'\n  | 'custom'\n  | 'conditional'\n  | 'dynamic';\n\n// Advanced Recurrence Patterns\nexport interface RecurrencePattern {\n  type: RecurrenceType;\n  interval: number; // every N days/weeks/months\n  daysOfWeek?: number[]; // 0-6 for weekly patterns\n  daysOfMonth?: number[]; // 1-31 for monthly patterns\n  weeksOfMonth?: number[]; // 1-5 for monthly patterns (first week, second week, etc.)\n  monthsOfYear?: number[]; // 1-12 for yearly patterns\n  endDate?: Date;\n  endAfterOccurrences?: number;\n  exceptions?: Date[]; // dates to skip\n  customPattern?: CustomPattern;\n}\n\nexport type RecurrenceType =\n  | 'daily'\n  | 'weekly'\n  | 'biweekly'\n  | 'monthly'\n  | 'quarterly'\n  | 'yearly'\n  | 'workdays'\n  | 'weekends'\n  | 'custom';\n\nexport interface CustomPattern {\n  name: string;\n  description: string;\n  dates: string[]; // specific dates in ISO format\n  intervals: number[]; // days from start date\n  businessDaysOnly?: boolean;\n  skipHolidays?: boolean;\n}\n\n// Conditional Scheduling\nexport interface ConditionalRule {\n  id: string;\n  name: string;\n  condition: AlarmCondition;\n  action: AlarmAction;\n  priority: number;\n  isActive: boolean;\n}\n\nexport interface AlarmCondition {\n  type: ConditionType;\n  operator: ConditionOperator;\n  value: any;\n  source?: string; // API endpoint, calendar, etc.\n}\n\nexport type ConditionType =\n  | 'weather'\n  | 'calendar_event'\n  | 'sleep_quality'\n  | 'day_of_week'\n  | 'date_range'\n  | 'time_since_last'\n  | 'fitness_metric'\n  | 'location'\n  | 'battery_level'\n  | 'do_not_disturb'\n  | 'custom';\n\nexport type ConditionOperator =\n  | 'equals'\n  | 'not_equals'\n  | 'greater_than'\n  | 'less_than'\n  | 'contains'\n  | 'between'\n  | 'exists'\n  | 'not_exists';\n\nexport interface AlarmAction {\n  type: ActionType;\n  value: any;\n  parameters?: Record<string, any>;\n}\n\nexport type ActionType =\n  | 'adjust_time'\n  | 'change_sound'\n  | 'change_difficulty'\n  | 'skip_alarm'\n  | 'add_task'\n  | 'send_notification'\n  | 'delay_by'\n  | 'change_volume'\n  | 'change_voice_mood'\n  | 'trigger_other_alarm'\n  | 'enable_alarm'\n  | 'disable_alarm';\n\n// Location-Based Alarms\nexport interface LocationTrigger {\n  id: string;\n  name: string;\n  type: LocationTriggerType;\n  location: Location;\n  radius: number; // meters\n  action: LocationAction;\n  isActive: boolean;\n}\n\nexport type LocationTriggerType =\n  | 'enter_location'\n  | 'exit_location'\n  | 'arrive_home'\n  | 'leave_home'\n  | 'arrive_work'\n  | 'leave_work';\n\nexport interface LocationAction {\n  type: 'enable_alarm' | 'disable_alarm' | 'adjust_time' | 'notification';\n  parameters: Record<string, any>;\n}\n\n// Calendar Integration\nexport interface CalendarIntegration {\n  provider: CalendarProvider;\n  calendarId?: string;\n  eventTypes?: string[];\n  lookAheadMinutes: number;\n  adjustmentRules: CalendarAdjustmentRule[];\n  isActive: boolean;\n}\n\nexport type CalendarProvider =\n  | 'google'\n  | 'outlook'\n  | 'apple'\n  | 'ics_url'\n  | 'caldav';\n\nexport interface CalendarAdjustmentRule {\n  eventType: string;\n  adjustment: number; // minutes before event\n  action: 'set_alarm' | 'adjust_existing' | 'skip_if_conflict';\n}\n\n// Seasonal & Dynamic Adjustments\nexport interface SeasonalAdjustment {\n  season: Season;\n  adjustmentMinutes: number;\n  startDate: string; // MM-DD format\n  endDate: string; // MM-DD format\n  isActive: boolean;\n}\n\nexport type Season = 'spring' | 'summer' | 'fall' | 'winter';\n\n// Smart Optimizations\nexport interface SmartOptimization {\n  type: OptimizationType;\n  isEnabled: boolean;\n  parameters: OptimizationParameters;\n  lastApplied?: Date;\n  effectiveness?: number; // 0-1 score\n}\n\nexport type OptimizationType =\n  | 'sleep_cycle'\n  | 'sunrise_sunset'\n  | 'traffic_conditions'\n  | 'weather_forecast'\n  | 'energy_levels'\n  | 'workout_schedule'\n  | 'social_patterns';\n\nexport interface OptimizationParameters {\n  sensitivity: number; // 0-1, how aggressively to optimize\n  maxAdjustment: number; // max minutes to adjust\n  learningEnabled: boolean;\n  preferences: Record<string, any>;\n}\n\n// Alarm Dependencies\nexport interface AlarmDependency {\n  type: DependencyType;\n  targetAlarmId?: string;\n  condition: string;\n  action: string;\n}\n\nexport type DependencyType =\n  | 'sequential'\n  | 'conditional'\n  | 'alternative'\n  | 'backup';\n\n// Advanced Scheduling Configuration\nexport interface SchedulingConfig {\n  timeZone: string;\n  defaultWakeWindow: number;\n  enableSmartAdjustments: boolean;\n  maxDailyAdjustment: number;\n  learningMode: boolean;\n  privacyMode: boolean;\n  backupAlarms: boolean;\n  advancedLogging: boolean;\n}\n\n// Scheduling Statistics\nexport interface SchedulingStats {\n  totalScheduledAlarms: number;\n  successfulWakeUps: number;\n  averageAdjustment: number;\n  mostEffectiveOptimization: OptimizationType;\n  patternRecognition: PatternInsight[];\n  recommendations: SchedulingRecommendation[];\n}\n\nexport interface PatternInsight {\n  pattern: string;\n  frequency: number;\n  confidence: number;\n  suggestion: string;\n}\n\nexport interface SchedulingRecommendation {\n  type: 'optimization' | 'pattern' | 'health' | 'efficiency';\n  title: string;\n  description: string;\n  impact: 'low' | 'medium' | 'high';\n  action: string;\n}\n\n// Sunrise/Sunset Based Scheduling\nexport interface SunSchedule {\n  type: 'sunrise' | 'sunset';\n  offset: number; // minutes before/after\n  location: Location;\n  seasonalAdjustment: boolean;\n}\n\n// Bulk Scheduling Operations\nexport interface BulkScheduleOperation {\n  operation: 'create' | 'update' | 'delete' | 'duplicate';\n  alarmIds?: string[];\n  dateRange?: { start: Date; end: Date };\n  filters?: ScheduleFilter[];\n  alarms?: Alarm[]; // For bulk create operations\n  updateData?: Partial<Alarm>; // For bulk update operations\n}\n\nexport interface ScheduleFilter {\n  field: string;\n  operator: ConditionOperator;\n  value: any;\n}\n\n// Schedule Import/Export Types\nexport interface ScheduleExport {\n  version: string;\n  exportDate: string;\n  alarms: Alarm[];\n  settings: SchedulingConfig;\n  metadata: {\n    totalAlarms: number;\n    timezone: string;\n  };\n}\n\nexport interface ScheduleImport {\n  data: ScheduleExport;\n  options: {\n    overwriteExisting: boolean;\n    preserveIds: boolean;\n    adjustTimeZones: boolean;\n  };\n}\n\n// Import/Export Scheduling\nexport interface ScheduleExport {\n  version: string;\n  exportDate: string;\n  settings: SchedulingConfig;\n  metadata: Record<string, any>;\n}\n\nexport interface ScheduleImport {\n  source: 'backup' | 'template' | 'migration';\n  data: ScheduleExport;\n  options: ImportOptions;\n}\n\nexport interface ImportOptions {\n  overwriteExisting: boolean;\n  preserveIds: boolean;\n  adjustTimeZones: boolean;\n  skipInvalid: boolean;\n}\n\n// Location Challenge Types\nexport interface LocationChallenge {\n  id: string;\n  name: string;\n  description: string;\n  type: LocationChallengeType;\n  targetLocation: Location;\n  radius: number; // meters\n  timeLimit?: number; // minutes\n  rewards: ChallengeReward[];\n  status: 'active' | 'completed' | 'failed' | 'expired';\n  startedAt?: string;\n  completedAt?: string;\n  progress: LocationProgress;\n}\n\nexport type LocationChallengeType = 'visit_place' | 'stay_duration' | 'distance_from_home' | 'elevation_gain' | 'speed_challenge';\n\nexport interface Location {\n  latitude: number;\n  longitude: number;\n  address?: string;\n  name?: string;\n}\n\n// Missing types for ConditionalRule\nexport interface ConditionalRule {\n  id: string;\n  name: string;\n  type: 'weather' | 'calendar' | 'sleep_quality' | 'day_of_week' | 'time_since_last';\n  conditions: any;\n  action: {\n    type: 'disable_alarm' | 'enable_alarm' | 'adjust_time' | 'change_sound' | 'change_difficulty';\n    parameters?: any;\n  };\n  isActive: boolean;\n  priority?: number;\n}\n\n// Missing WakeUpMood type\nexport type WakeUpMood = 'energetic' | 'peaceful' | 'motivated' | 'groggy' | 'refreshed' | 'tired';\n\nexport interface LocationProgress {\n  currentLocation?: Location;\n  distanceToTarget?: number;\n  timeInRadius?: number;\n  elevationGained?: number;\n  averageSpeed?: number;\n}\n\n// Fitness Integration Types\nexport interface FitnessIntegration {\n  id: string;\n  userId: string;\n  provider: FitnessProvider;\n  isConnected: boolean;\n  lastSync: string;\n  permissions: FitnessPermission[];\n  data: FitnessData;\n}\n\nexport type FitnessProvider = 'apple_health' | 'google_fit' | 'fitbit' | 'garmin' | 'strava' | 'polar';\nexport type FitnessPermission = 'steps' | 'sleep' | 'heart_rate' | 'activity' | 'distance' | 'calories';\n\nexport interface FitnessData {\n  steps: number;\n  sleepHours: number;\n  heartRate?: number;\n  activeMinutes: number;\n  distance: number; // meters\n  caloriesBurned: number;\n  date: string;\n}\n\nexport interface FitnessChallenge extends DailyChallenge {\n  fitnessType: FitnessPermission;\n  targetValue: number;\n  currentValue: number;\n  unit: string;\n  integration: FitnessProvider;\n}\n\n// Enhanced Settings Types\nexport interface UserSettings {\n  theme: Theme;\n  notifications: NotificationSettings;\n  privacy: PrivacySettings;\n  alarm: AlarmSettings;\n}\n\nexport interface NotificationSettings {\n  pushEnabled: boolean;\n  battleChallenges: boolean;\n  friendRequests: boolean;\n  achievements: boolean;\n  reminders: boolean;\n  trashTalk: boolean;\n}\n\nexport interface PrivacySettings {\n  profileVisible: boolean;\n  statsVisible: boolean;\n  onlineStatus: boolean;\n  allowFriendRequests: boolean;\n}\n\nexport interface AlarmSettings {\n  defaultSound: string;\n  defaultSnoozeInterval: number;\n  maxSnoozeCount: number;\n  vibrationEnabled: boolean;\n  gradualVolumeIncrease: boolean;\n}\n\n// Media & Content Types\nexport interface CustomSound {\n  id: string;\n  name: string;\n  description?: string;\n  fileName: string;\n  fileUrl: string;\n  duration: number; // seconds\n  category: SoundCategory;\n  tags: string[];\n  isCustom: boolean;\n  uploadedBy?: string;\n  uploadedAt?: string;\n  downloads?: number;\n  rating?: number;\n}\n\nexport type SoundCategory = 'nature' | 'music' | 'voice' | 'mechanical' | 'ambient' | 'energetic' | 'calm' | 'custom';\n\n// Sound selection types\nexport interface SoundOption {\n  id: string;\n  name: string;\n  type: 'built-in' | 'custom' | 'voice-only';\n  category?: SoundCategory;\n  preview?: string; // URL or identifier for preview\n  customSound?: CustomSound; // Full custom sound data if type is 'custom'\n}\n\nexport interface SoundLibrary {\n  builtInSounds: SoundOption[];\n  customSounds: CustomSound[];\n  voiceOnlyMode: SoundOption;\n}\n\nexport interface Playlist {\n  id: string;\n  name: string;\n  description?: string;\n  sounds: PlaylistSound[];\n  isPublic: boolean;\n  createdBy: string;\n  createdAt: string;\n  updatedAt: string;\n  tags: string[];\n  playCount: number;\n  likeCount: number;\n  shareCount: number;\n}\n\nexport interface PlaylistSound {\n  soundId: string;\n  sound: CustomSound;\n  order: number;\n  fadeIn?: number; // seconds\n  fadeOut?: number; // seconds\n  volume?: number; // 0-1\n}\n\nexport interface MotivationalQuote {\n  id: string;\n  text: string;\n  author?: string;\n  category: QuoteCategory;\n  tags: string[];\n  isCustom: boolean;\n  submittedBy?: string;\n  submittedAt?: string;\n  likes: number;\n  uses: number;\n}\n\nexport type QuoteCategory = 'motivation' | 'inspiration' | 'success' | 'health' | 'productivity' | 'mindfulness' | 'humor' | 'custom';\n\nexport interface PhotoChallenge {\n  id: string;\n  name: string;\n  description: string;\n  category: PhotoChallengeCategory;\n  difficulty: ChallengeDifficulty;\n  prompts: PhotoPrompt[];\n  timeLimit?: number; // minutes\n  rewards: ChallengeReward[];\n  examples?: PhotoExample[];\n  createdBy: string;\n  createdAt: string;\n  popularity: number;\n  completionRate: number;\n}\n\nexport type PhotoChallengeCategory = 'selfie' | 'environment' | 'task_proof' | 'creative' | 'location' | 'fitness' | 'food' | 'pets';\n\nexport interface PhotoPrompt {\n  id: string;\n  text: string;\n  optional: boolean;\n  hints?: string[];\n  validationRules?: PhotoValidationRule[];\n}\n\nexport interface PhotoValidationRule {\n  type: 'face_detection' | 'object_detection' | 'location_check' | 'timestamp_check' | 'lighting_check';\n  parameters: Record<string, any>;\n  required: boolean;\n}\n\nexport interface PhotoExample {\n  id: string;\n  imageUrl: string;\n  description: string;\n  rating: number;\n}\n\n// Quest & Ranking Types\nexport interface Quest {\n  id: string;\n  title: string;\n  description: string;\n  type: QuestType;\n  target: number;\n  progress: number;\n  reward: QuestReward;\n  expiresAt?: string;\n  completedAt?: string;\n}\n\nexport type QuestType = 'daily' | 'weekly' | 'monthly' | 'achievement';\n\nexport interface QuestReward {\n  experience: number;\n  title?: string;\n  badge?: string;\n}\n\nexport interface RankingEntry {\n  rank: number;\n  user: User;\n  score: number;\n  change: number; // position change since last period\n}\n\nexport interface Rankings {\n  global: RankingEntry[];\n  friends: RankingEntry[];\n  weekly: RankingEntry[];\n  monthly: RankingEntry[];\n}\n\n// Notification Types (Enhanced)\nexport interface Notification {\n  id: string;\n  userId: string;\n  type: NotificationType;\n  title: string;\n  message: string;\n  isRead: boolean;\n  data?: Record<string, any>;\n  createdAt: string;\n}\n\nexport type NotificationType = 'battle_challenge' | 'battle_result' | 'friend_request' | 'achievement' | 'quest_complete' | 'reminder';\n\n// API Response Types\n// AI & ML Types for Enhanced Features\nexport interface AIOptimization {\n  id: string;\n  userId: string;\n  type: 'sleep_pattern' | 'wake_time' | 'mood_prediction' | 'task_scheduling' | 'difficulty_adjustment';\n  suggestion: string;\n  confidence: number; // 0-1\n  impact: 'low' | 'medium' | 'high';\n  appliedAt?: Date;\n  results?: AIOptimizationResult;\n  createdAt: Date;\n  isEnabled: boolean;\n  lastOptimized?: Date;\n}\n\nexport interface AIOptimizationResult {\n  improvementPercentage: number;\n  userSatisfaction: number; // 1-10\n  metricsChanged: Record<string, number>;\n  followUpNeeded: boolean;\n}\n\nexport interface AIRecommendation {\n  id: string;\n  userId: string;\n  category: 'alarm' | 'routine' | 'challenge' | 'social' | 'wellness';\n  title: string;\n  description: string;\n  actionable: boolean;\n  priority: 'low' | 'medium' | 'high' | 'urgent';\n  confidence: number;\n  estimatedBenefit: string;\n  implementationSteps: string[];\n  basedOn: AIRecommendationSource[];\n  expiresAt?: Date;\n  acceptedAt?: Date;\n  rejectedAt?: Date;\n  createdAt: Date;\n  type: 'sleep_pattern' | 'wake_time' | 'mood_prediction' | 'task_scheduling' | 'difficulty_adjustment';\n  appliedAt?: Date;\n  impact: 'low' | 'medium' | 'high';\n  action: string;\n}\n\nexport interface AIRecommendationSource {\n  type: 'sleep_data' | 'behavior_pattern' | 'performance_metrics' | 'user_preferences' | 'community_trends';\n  dataPoints: number;\n  timeRange: string;\n  relevance: number; // 0-1\n}\n\nexport interface PersonalizedChallenge {\n  id: string;\n  userId: string;\n  title: string;\n  description: string;\n  type: 'habit_building' | 'skill_improvement' | 'wellness' | 'productivity' | 'social';\n  difficulty: ChallengeDifficulty;\n  duration: number; // days\n  personalizedFactors: PersonalizationFactor[];\n  tasks: ChallengeTask[];\n  progress: ChallengeProgress;\n  rewards: ChallengeReward[];\n  aiInsights: string[];\n  adaptations: ChallengeAdaptation[];\n  status: 'draft' | 'active' | 'paused' | 'completed' | 'abandoned';\n  startedAt?: Date;\n  completedAt?: Date;\n  createdAt: Date;\n  expectedSuccessRate: number; // 0-1\n  personalizedFor: string[];\n}\n\nexport interface PersonalizationFactor {\n  type: 'user_niche' | 'sleep_pattern' | 'skill_level' | 'availability' | 'motivation_style';\n  value: string | number;\n  weight: number; // influence on challenge design\n}\n\nexport interface ChallengeTask {\n  id: string;\n  title: string;\n  description: string;\n  type: 'daily' | 'weekly' | 'milestone' | 'optional';\n  difficulty: number; // 1-10\n  estimatedTime: number; // minutes\n  dependencies: string[]; // task IDs\n  completed: boolean;\n  completedAt?: Date;\n  evidence?: TaskEvidence[];\n}\n\nexport interface TaskEvidence {\n  type: 'photo' | 'text' | 'location' | 'time_tracking' | 'peer_verification';\n  data: any;\n  verifiedAt: Date;\n  verificationSource: 'user' | 'ai' | 'peer' | 'sensor';\n}\n\nexport interface ChallengeProgress {\n  totalTasks: number;\n  completedTasks: number;\n  currentStreak: number;\n  longestStreak: number;\n  completionRate: number; // 0-1\n  consistency: number; // 0-1\n  engagement: number; // 0-1\n  lastActivity: Date;\n}\n\nexport interface ChallengeAdaptation {\n  id: string;\n  reason: 'difficulty_adjustment' | 'time_constraint' | 'motivation_boost' | 'personalization_update';\n  originalValue: any;\n  newValue: any;\n  appliedAt: Date;\n  impact: string;\n}\n\nexport interface SmartAutomation {\n  id: string;\n  userId: string;\n  name: string;\n  type: 'alarm_optimization' | 'routine_adjustment' | 'challenge_creation' | 'reminder_timing';\n  triggers: AutomationTrigger[];\n  actions: AutomationAction[];\n  conditions: AutomationCondition[];\n  isActive: boolean;\n  learningEnabled: boolean;\n  performanceMetrics: AutomationMetrics;\n  lastTriggered?: Date;\n  createdAt: Date;\n  updatedAt: Date;\n  isEnabled: boolean;\n  description: string;\n  executionCount: number;\n  lastExecuted?: Date;\n}\n\nexport interface AutomationTrigger {\n  type: 'time' | 'location' | 'behavior' | 'performance' | 'external_api';\n  parameters: Record<string, any>;\n  sensitivity: number; // 0-1\n}\n\nexport interface AutomationAction {\n  type: 'adjust_alarm' | 'send_notification' | 'create_challenge' | 'update_settings' | 'log_data';\n  parameters: Record<string, any>;\n  priority: number;\n  reversible: boolean;\n  delay?: number;\n}\n\nexport interface AutomationCondition {\n  type: 'time_range' | 'user_state' | 'weather' | 'calendar' | 'performance_threshold';\n  operator: 'equals' | 'greater_than' | 'less_than' | 'contains' | 'in_range';\n  value: any;\n  required: boolean;\n}\n\nexport interface AutomationMetrics {\n  totalTriggers: number;\n  successfulActions: number;\n  userOverrides: number;\n  averageResponseTime: number;\n  satisfactionScore: number; // 1-10\n  lastEvaluated: Date;\n}\n\nexport interface SleepPattern {\n  id: string;\n  userId: string;\n  date: string; // YYYY-MM-DD\n  bedTime: string; // HH:MM\n  sleepTime?: string; // HH:MM (actual sleep start)\n  wakeTime: string; // HH:MM\n  totalSleepHours: number;\n  sleepQuality: number; // 1-10\n  sleepStages?: SleepStage[];\n  interruptions: SleepInterruption[];\n  factors: SleepFactor[];\n  mood: WakeUpMood;\n  energyLevel: number; // 1-10\n  notes?: string;\n  source: 'manual' | 'fitness_tracker' | 'phone_sensors' | 'smart_alarm';\n  aiAnalysis?: SleepAnalysis;\n  createdAt: Date;\n  sleepDuration: number; // minutes\n  sleepEfficiency: number; // 0-1\n  deepSleepPercentage: number; // 0-100\n  remSleepPercentage: number; // 0-100\n}\n\nexport interface SleepStage {\n  type: 'light' | 'deep' | 'rem' | 'awake';\n  startTime: string;\n  duration: number; // minutes\n  quality: number; // 0-1\n}\n\nexport interface SleepInterruption {\n  time: string;\n  type: 'noise' | 'light' | 'movement' | 'bathroom' | 'stress' | 'unknown';\n  duration: number; // minutes\n  impact: 'low' | 'medium' | 'high';\n}\n\nexport interface SleepFactor {\n  type: 'caffeine' | 'alcohol' | 'exercise' | 'stress' | 'screen_time' | 'meal_timing' | 'room_temperature';\n  value: string | number;\n  timing: string; // when the factor occurred\n  impact: 'positive' | 'negative' | 'neutral';\n}\n\nexport interface SleepAnalysis {\n  pattern: 'consistent' | 'irregular' | 'improving' | 'declining';\n  recommendations: string[];\n  riskFactors: string[];\n  optimalBedtime: string;\n  optimalWakeTime: string;\n  confidenceLevel: number; // 0-1\n  trendsDetected: SleepTrend[];\n}\n\nexport interface SleepTrend {\n  metric: 'sleep_duration' | 'bedtime_consistency' | 'wake_time_consistency' | 'sleep_quality';\n  direction: 'improving' | 'declining' | 'stable';\n  magnitude: number; // how significant the trend is\n  timeframe: string; // e.g., \"last 2 weeks\"\n}\n\nexport interface WakeUpBehavior {\n  id: string;\n  userId: string;\n  alarmId: string;\n  date: string;\n  scheduledWakeTime: string;\n  actualWakeTime: string;\n  dismissMethod: 'voice' | 'button' | 'shake' | 'photo' | 'math' | 'barcode';\n  snoozeCount: number;\n  snoozeDuration: number; // total minutes snoozed\n  difficulty: AlarmDifficulty;\n  completionTime: number; // seconds to dismiss alarm\n  mood: WakeUpMood;\n  energyLevel: number; // 1-10\n  readiness: number; // 1-10 how ready they felt\n  challenges: WakeUpChallenge[];\n  context: WakeUpContext;\n  performance: WakeUpPerformance;\n  createdAt: Date;\n  alarmTime: string; // HH:MM\n  environment: 'home' | 'travel' | 'other';\n}\n\nexport interface WakeUpChallenge {\n  type: 'math' | 'photo' | 'voice' | 'memory' | 'physical' | 'location';\n  difficulty: number; // 1-10\n  attempts: number;\n  successful: boolean;\n  timeToComplete: number; // seconds\n  details?: Record<string, any>;\n}\n\nexport interface WakeUpContext {\n  weather: string;\n  temperature: number;\n  dayOfWeek: string;\n  sleepHours: number;\n  stressLevel?: number; // 1-10\n  calendarEvents?: number; // events scheduled for the day\n  location?: 'home' | 'travel' | 'other';\n}\n\nexport interface WakeUpPerformance {\n  responseTime: number; // seconds from alarm to first interaction\n  accuracy: number; // for challenges requiring correctness\n  persistence: number; // how long they kept trying vs giving up\n  consistency: number; // compared to their usual performance\n}\n\nexport type WakeUpMood =\n  | 'excellent'\n  | 'good'\n  | 'okay'\n  | 'tired'\n  | 'groggy'\n  | 'irritated'\n  | 'refreshed'\n  | 'energetic'\n  | 'anxious'\n  | 'peaceful'\n  | 'neutral'\n  | 'grumpy';\n\nexport interface BattlePerformanceData {\n  battleId: string;\n  userId: string;\n  performance: BattlePerformanceMetrics;\n  comparison: BattleComparison;\n  improvement: BattleImprovement;\n  streaks: BattleStreaks;\n  achievements: string[]; // achievement IDs unlocked\n  analysis: BattleAnalysis;\n  createdAt: Date;\n  date: string; // YYYY-MM-DD\n  result: 'win' | 'loss' | 'draw';\n  score: number;\n  battleType: 'solo' | 'multiplayer' | 'tournament';\n  difficulty: 'easy' | 'medium' | 'hard' | 'extreme';\n  mistakes: number;\n  mood: WakeUpMood;\n}\n\nexport interface BattlePerformanceMetrics {\n  wakeTimeScore: number; // 0-100\n  consistencyScore: number; // 0-100\n  challengeScore: number; // 0-100\n  socialScore: number; // 0-100\n  overallScore: number; // 0-100\n  rank: number;\n  percentile: number; // 0-100\n}\n\nexport interface BattleComparison {\n  vsPersonalBest: number; // percentage difference\n  vsFriends: number; // average rank among friends\n  vsGlobal: number; // global percentile\n  improvements: string[]; // areas that improved\n  weaknesses: string[]; // areas that declined\n}\n\nexport interface BattleImprovement {\n  shortTerm: ImprovementMetric; // last 7 days\n  mediumTerm: ImprovementMetric; // last 30 days\n  longTerm: ImprovementMetric; // last 90 days\n  suggestions: ImprovementSuggestion[];\n}\n\nexport interface ImprovementMetric {\n  scoreChange: number;\n  rankChange: number;\n  streakChange: number;\n  consistencyChange: number;\n}\n\nexport interface ImprovementSuggestion {\n  area: 'wake_time' | 'consistency' | 'challenges' | 'social';\n  suggestion: string;\n  expectedImpact: 'low' | 'medium' | 'high';\n  difficulty: 'easy' | 'medium' | 'hard';\n  timeToSeeResults: string; // e.g., \"1-2 weeks\"\n}\n\nexport interface BattleStreaks {\n  current: StreakData;\n  longest: StreakData;\n  recent: StreakData[]; // last 10 streaks\n}\n\nexport interface StreakData {\n  length: number;\n  type: 'win' | 'participation' | 'consistency' | 'improvement';\n  startDate: string;\n  endDate?: string;\n  averageScore: number;\n}\n\nexport interface BattleAnalysis {\n  strengths: string[];\n  weaknesses: string[];\n  patterns: BattlePattern[];\n  recommendations: string[];\n  riskFactors: string[];\n  motivationProfile: MotivationProfile;\n}\n\nexport interface BattlePattern {\n  type: 'day_of_week' | 'time_of_day' | 'battle_type' | 'opponent_type';\n  pattern: string;\n  strength: number; // 0-1 how strong the pattern is\n  impact: 'positive' | 'negative' | 'neutral';\n}\n\nexport interface MotivationProfile {\n  primaryDriver: 'competition' | 'achievement' | 'social' | 'personal_growth';\n  competitiveness: number; // 1-10\n  socialInfluence: number; // 1-10\n  intrinsicMotivation: number; // 1-10\n  extrinsicMotivation: number; // 1-10\n  riskTolerance: number; // 1-10\n}\n\nexport interface LearningData {\n  id: string;\n  userId: string;\n  subject: 'user_behavior' | 'performance_patterns' | 'preferences' | 'optimal_settings';\n  dataPoints: LearningDataPoint[];\n  insights: LearningInsight[];\n  confidence: number; // 0-1\n  lastUpdated: Date;\n  isActive: boolean; // whether this learning is being applied\n  validationResults?: ValidationResult[];\n}\n\nexport interface LearningDataPoint {\n  timestamp: Date;\n  context: Record<string, any>;\n  outcome: Record<string, any>;\n  success: boolean;\n  weight: number; // importance of this data point\n}\n\nexport interface LearningInsight {\n  type: 'correlation' | 'trend' | 'anomaly' | 'optimal_value' | 'trigger_condition';\n  description: string;\n  confidence: number; // 0-1\n  strength: number; // 0-1 how strong the pattern is\n  actionable: boolean;\n  recommendedAction?: string;\n}\n\nexport interface ValidationResult {\n  date: Date;\n  hypothesis: string;\n  predicted: any;\n  actual: any;\n  accuracy: number; // 0-1\n  method: 'a_b_test' | 'holdout' | 'cross_validation' | 'user_feedback';\n}\n\nexport interface ApiResponse<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  message?: string;\n}\n\nexport interface PaginatedResponse<T> extends ApiResponse<T[]> {\n  pagination: {\n    page: number;\n    limit: number;\n    total: number;\n    totalPages: number;\n  };\n}\n\n// ============================================================================\n// CLOUDFLARE WORKERS TYPES - Edge Computing & Storage\n// ============================================================================\n\n// Cloudflare D1 Database Types\nexport interface D1Database {\n  prepare(query: string): D1PreparedStatement;\n  dump(): Promise<ArrayBuffer>;\n  batch(statements: D1PreparedStatement[]): Promise<D1Result[]>;\n  exec(query: string): Promise<D1ExecResult>;\n}\n\nexport interface D1PreparedStatement {\n  bind(...values: any[]): D1PreparedStatement;\n  first<T = any>(colName?: string): Promise<T | null>;\n  run(): Promise<D1Result>;\n  all<T = any>(): Promise<D1Result<T>>;\n  raw<T = any>(): Promise<T[]>;\n}\n\nexport interface D1Result<T = Record<string, any>> {\n  results?: T[];\n  success: boolean;\n  meta: {\n    duration: number;\n    size_after?: number;\n    rows_read?: number;\n    rows_written?: number;\n    last_row_id?: number;\n    changed_db?: boolean;\n    changes?: number;\n  };\n}\n\nexport interface D1ExecResult {\n  count: number;\n  duration: number;\n}\n\n// Cloudflare KV Namespace Types\nexport interface KVNamespace {\n  get(key: string, options?: KVGetOptions): Promise<string | null>;\n  get(key: string, type: 'text'): Promise<string | null>;\n  get(key: string, type: 'json'): Promise<any>;\n  get(key: string, type: 'arrayBuffer'): Promise<ArrayBuffer | null>;\n  get(key: string, type: 'stream'): Promise<ReadableStream | null>;\n  put(key: string, value: string | ArrayBuffer | ReadableStream, options?: KVPutOptions): Promise<void>;\n  delete(key: string): Promise<void>;\n  list(options?: KVListOptions): Promise<KVListResult>;\n  getWithMetadata<Metadata = any>(key: string, options?: KVGetWithMetadataOptions): Promise<KVGetWithMetadataResult<string, Metadata>>;\n  getWithMetadata<Metadata = any>(key: string, type: 'text'): Promise<KVGetWithMetadataResult<string, Metadata>>;\n  getWithMetadata<Metadata = any>(key: string, type: 'json'): Promise<KVGetWithMetadataResult<any, Metadata>>;\n  getWithMetadata<Metadata = any>(key: string, type: 'arrayBuffer'): Promise<KVGetWithMetadataResult<ArrayBuffer, Metadata>>;\n  getWithMetadata<Metadata = any>(key: string, type: 'stream'): Promise<KVGetWithMetadataResult<ReadableStream, Metadata>>;\n}\n\nexport interface KVGetOptions {\n  cacheTtl?: number;\n}\n\nexport interface KVGetWithMetadataOptions {\n  cacheTtl?: number;\n}\n\nexport interface KVPutOptions {\n  expiration?: number;\n  expirationTtl?: number;\n  metadata?: any;\n}\n\nexport interface KVListOptions {\n  prefix?: string;\n  limit?: number;\n  cursor?: string;\n}\n\nexport interface KVListResult {\n  keys: KVKey[];\n  list_complete: boolean;\n  cursor?: string;\n}\n\nexport interface KVKey {\n  name: string;\n  expiration?: number;\n  metadata?: any;\n}\n\nexport interface KVGetWithMetadataResult<Value, Metadata> {\n  value: Value | null;\n  metadata: Metadata | null;\n}\n\n// Cloudflare R2 Bucket Types\nexport interface R2Bucket {\n  head(key: string): Promise<R2Object | null>;\n  get(key: string, options?: R2GetOptions): Promise<R2ObjectBody | null>;\n  put(key: string, value: ReadableStream | ArrayBuffer | string, options?: R2PutOptions): Promise<R2Object>;\n  delete(key: string | string[]): Promise<void>;\n  list(options?: R2ListOptions): Promise<R2Objects>;\n  createMultipartUpload(key: string, options?: R2CreateMultipartUploadOptions): Promise<R2MultipartUpload>;\n}\n\nexport interface R2Object {\n  key: string;\n  version: string;\n  size: number;\n  etag: string;\n  httpEtag: string;\n  uploaded: Date;\n  httpMetadata?: R2HTTPMetadata;\n  customMetadata?: Record<string, string>;\n  range?: R2Range;\n  checksums?: R2Checksums;\n}\n\nexport interface R2ObjectBody extends R2Object {\n  body: ReadableStream;\n  bodyUsed: boolean;\n  arrayBuffer(): Promise<ArrayBuffer>;\n  text(): Promise<string>;\n  json<T = any>(): Promise<T>;\n  blob(): Promise<Blob>;\n}\n\nexport interface R2GetOptions {\n  onlyIf?: R2Conditional;\n  range?: R2Range;\n}\n\nexport interface R2PutOptions {\n  onlyIf?: R2Conditional;\n  httpMetadata?: R2HTTPMetadata;\n  customMetadata?: Record<string, string>;\n  md5?: ArrayBuffer | string;\n  sha1?: ArrayBuffer | string;\n  sha256?: ArrayBuffer | string;\n  sha384?: ArrayBuffer | string;\n  sha512?: ArrayBuffer | string;\n}\n\nexport interface R2ListOptions {\n  limit?: number;\n  prefix?: string;\n  cursor?: string;\n  delimiter?: string;\n  startAfter?: string;\n  include?: ('httpMetadata' | 'customMetadata')[];\n}\n\nexport interface R2Objects {\n  objects: R2Object[];\n  truncated: boolean;\n  cursor?: string;\n  delimitedPrefixes: string[];\n}\n\nexport interface R2HTTPMetadata {\n  contentType?: string;\n  contentLanguage?: string;\n  contentDisposition?: string;\n  contentEncoding?: string;\n  cacheControl?: string;\n  cacheExpiry?: Date;\n}\n\nexport interface R2Range {\n  offset?: number;\n  length?: number;\n  suffix?: number;\n}\n\nexport interface R2Conditional {\n  etagMatches?: string;\n  etagDoesNotMatch?: string;\n  uploadedBefore?: Date;\n  uploadedAfter?: Date;\n}\n\nexport interface R2Checksums {\n  md5?: ArrayBuffer;\n  sha1?: ArrayBuffer;\n  sha256?: ArrayBuffer;\n  sha384?: ArrayBuffer;\n  sha512?: ArrayBuffer;\n}\n\nexport interface R2MultipartUpload {\n  key: string;\n  uploadId: string;\n  abort(): Promise<void>;\n  complete(uploadedParts: R2UploadedPart[]): Promise<R2Object>;\n  uploadPart(partNumber: number, value: ReadableStream | ArrayBuffer | string): Promise<R2UploadedPart>;\n}\n\nexport interface R2UploadedPart {\n  partNumber: number;\n  etag: string;\n}\n\nexport interface R2CreateMultipartUploadOptions {\n  httpMetadata?: R2HTTPMetadata;\n  customMetadata?: Record<string, string>;\n}\n\n// Media Library and Content Types\nexport interface MediaLibrary {\n  id: string;\n  userId: string;\n  sounds: CustomSound[];\n  playlists: Playlist[];\n  quotes: MotivationalQuote[];\n  storage: StorageInfo;\n  cacheSettings: CacheSettings;\n  compressionSettings: CompressionSettings;\n}\n\nexport interface ContentPreferences {\n  audioQuality: 'low' | 'medium' | 'high';\n  autoDownload: boolean;\n  storageLimit: number; // in MB\n  cacheEnabled: boolean;\n  offlineMode: boolean;\n}\n\nexport interface StorageInfo {\n  used: number; // in MB\n  available: number; // in MB\n  total: number; // in MB\n}\n\nexport interface CacheSettings {\n  enabled: boolean;\n  maxSize: number; // in MB\n  ttl: number; // in seconds\n}\n\nexport interface CompressionSettings {\n  enabled: boolean;\n  quality: number; // 0-100\n  format: 'mp3' | 'aac' | 'ogg';\n}\n\nexport interface ContextualTask {\n  id: string;\n  title: string;\n  description: string;\n  category: 'productivity' | 'health' | 'social' | 'learning';\n  difficulty: 'easy' | 'medium' | 'hard';\n  estimatedTime: number; // in minutes\n  context: TaskContext;\n  rewards: TaskReward[];\n  completed: boolean;\n}\n\nexport interface TaskContext {\n  location?: string;\n  timeOfDay?: 'morning' | 'afternoon' | 'evening' | 'night';\n  weatherCondition?: string;\n  userMood?: string;\n  availableTime?: number; // in minutes\n}\n\nexport interface TaskReward {\n  type: 'experience' | 'achievement' | 'item';\n  value: number | string;\n  description: string;\n}\n\n// Premium Subscription Types (using consolidated definitions above)\n\nexport interface Subscription {\n  id: string;\n  userId: string;\n  status: SubscriptionStatus;\n  currentPeriodStart: Date;\n  currentPeriodEnd: Date;\n  trialEnd?: Date;\n  cancelAtPeriodEnd: boolean;\n  canceledAt?: Date;\n  createdAt: Date;\n  updatedAt: Date;\n  // Payment provider specific fields\n  stripeCustomerId?: string;\n  stripeSubscriptionId?: string;\n  stripePriceId?: string;\n}\n\nexport interface PremiumFeatureAccess {\n  // Voice Features\n  elevenlabsVoices: boolean;\n  customVoiceMessages: boolean;\n  voiceCloning: boolean;\n  premiumPersonalities: boolean; // Access to demon-lord, ai-robot, comedian, philosopher\n\n  // AI Features\n  advancedAIInsights: boolean;\n  personalizedChallenges: boolean;\n  smartRecommendations: boolean;\n  behaviorAnalysis: boolean;\n\n  // Customization\n  premiumThemes: boolean;\n  customSounds: boolean;\n  advancedPersonalization: boolean;\n  unlimitedCustomization: boolean;\n\n  // Scheduling\n  advancedScheduling: boolean;\n  smartScheduling: boolean;\n  locationBasedAlarms: boolean;\n  weatherIntegration: boolean;\n\n  // Battle System\n  exclusiveBattleModes: boolean;\n  customBattleRules: boolean;\n  advancedStats: boolean;\n  leaderboardFeatures: boolean;\n  nuclearMode: boolean; // Ultra-extreme battle mode for Pro+ users\n\n  // Content\n  premiumSoundLibrary: boolean;\n  exclusiveContent: boolean;\n  adFree: boolean;\n  prioritySupport: boolean;\n}\n\nexport interface SubscriptionPlan {\n  id: string;\n  name: string;\n  price: number;\n  monthlyPrice: number;\n  yearlyPrice: number;\n  currency: string;\n  interval: 'month' | 'year' | 'lifetime';\n  features: string[];\n  featureAccess: PremiumFeatureAccess;\n  popular?: boolean;\n  description?: string;\n  stripePriceId?: string;\n  savings?: number;\n  trialDays?: number;\n}\n\nexport interface PaymentMethod {\n  id: string;\n  type: 'card' | 'paypal' | 'google_pay' | 'apple_pay';\n  last4?: string;\n  brand?: string;\n  expiryMonth?: number;\n  expiryYear?: number;\n  isDefault: boolean;\n  stripePaymentMethodId?: string;\n}\n\nexport interface PremiumUsage {\n  userId: string;\n  month: string; // YYYY-MM format\n  elevenlabsApiCalls: number;\n  aiInsightsGenerated: number;\n  customVoiceMessages: number;\n  premiumThemesUsed: string[];\n  lastUpdated: Date;\n}\n\n// Premium Feature Limits\nexport interface FeatureLimits {\n  elevenlabsCallsPerMonth: number;\n  aiInsightsPerDay: number;\n  customVoiceMessagesPerDay: number;\n  customSoundsStorage: number; // in MB\n  themesAllowed: number;\n  battlesPerDay: number;\n}\n\n// Default feature limits by tier\nexport const DEFAULT_FEATURE_LIMITS: Record<SubscriptionTier, FeatureLimits> = {\n  free: {\n    elevenlabsCallsPerMonth: 0,\n    aiInsightsPerDay: 3,\n    customVoiceMessagesPerDay: 0,\n    customSoundsStorage: 0,\n    themesAllowed: 3,\n    battlesPerDay: 5\n  },\n  premium: {\n    elevenlabsCallsPerMonth: 100,\n    aiInsightsPerDay: 10,\n    customVoiceMessagesPerDay: 5,\n    customSoundsStorage: 50,\n    themesAllowed: 10,\n    battlesPerDay: 20\n  },\n  pro: {\n    elevenlabsCallsPerMonth: 500,\n    aiInsightsPerDay: 25,\n    customVoiceMessagesPerDay: 20,\n    customSoundsStorage: 200,\n    themesAllowed: -1, // unlimited\n    battlesPerDay: -1 // unlimited\n  },\n  ultimate: {\n    elevenlabsCallsPerMonth: 1000,\n    aiInsightsPerDay: -1, // unlimited\n    customVoiceMessagesPerDay: -1, // unlimited\n    customSoundsStorage: 500,\n    themesAllowed: -1, // unlimited\n    battlesPerDay: -1 // unlimited\n  },\n  lifetime: {\n    elevenlabsCallsPerMonth: 1000,\n    aiInsightsPerDay: -1, // unlimited\n    customVoiceMessagesPerDay: -1, // unlimited\n    customSoundsStorage: 500,\n    themesAllowed: -1, // unlimited\n    battlesPerDay: -1 // unlimited\n  }\n};\n\nexport const SUBSCRIPTION_PLANS: SubscriptionPlan[] = [\n  {\n    id: 'free',\n    name: 'Free',\n    tier: 'free',\n    price: 0,\n    currency: 'USD',\n    interval: 'month',\n    features: [\n      '3 AI insights per day',\n      'Basic themes',\n      '5 battles per day',\n      'Standard voice options',\n      'Basic customization'\n    ],\n    featureAccess: {\n      elevenlabsVoices: false,\n      customVoiceMessages: false,\n      voiceCloning: false,\n      premiumPersonalities: false,\n      advancedAIInsights: false,\n      personalizedChallenges: false,\n      smartRecommendations: false,\n      behaviorAnalysis: false,\n      premiumThemes: false,\n      customSounds: false,\n      advancedPersonalization: false,\n      unlimitedCustomization: false,\n      advancedScheduling: false,\n      smartScheduling: false,\n      locationBasedAlarms: false,\n      weatherIntegration: false,\n      exclusiveBattleModes: false,\n      customBattleRules: false,\n      advancedStats: false,\n      leaderboardFeatures: false,\n      nuclearMode: false,\n      premiumSoundLibrary: false,\n      exclusiveContent: false,\n      adFree: false,\n      prioritySupport: false\n    }\n  },\n  {\n    id: 'premium',\n    name: 'Premium',\n    tier: 'premium',\n    price: 4.99,\n    currency: 'USD',\n    interval: 'month',\n    popular: true,\n    features: [\n      '100 ElevenLabs voice calls/month',\n      '10 AI insights per day',\n      '5 custom voice messages/day',\n      'Premium themes',\n      '20 battles per day',\n      'Premium sound library',\n      'Advanced customization',\n      'Ad-free experience'\n    ],\n    featureAccess: {\n      elevenlabsVoices: true,\n      customVoiceMessages: true,\n      voiceCloning: false,\n      premiumPersonalities: false,\n      advancedAIInsights: true,\n      personalizedChallenges: true,\n      smartRecommendations: true,\n      behaviorAnalysis: true,\n      premiumThemes: true,\n      customSounds: true,\n      advancedPersonalization: true,\n      unlimitedCustomization: false,\n      advancedScheduling: true,\n      smartScheduling: false,\n      locationBasedAlarms: true,\n      weatherIntegration: true,\n      exclusiveBattleModes: true,\n      customBattleRules: false,\n      advancedStats: true,\n      leaderboardFeatures: true,\n      nuclearMode: false, // Premium tier doesn't get nuclear mode\n      premiumSoundLibrary: true,\n      exclusiveContent: true,\n      adFree: true,\n      prioritySupport: false\n    },\n    stripePriceId: 'price_premium_monthly'\n  },\n  {\n    id: 'pro',\n    name: 'Pro',\n    tier: 'pro',\n    price: 9.99,\n    currency: 'USD',\n    interval: 'month',\n    features: [\n      '500 ElevenLabs voice calls/month',\n      '25 AI insights per day',\n      '20 custom voice messages/day',\n      'Voice cloning',\n      'Unlimited battles',\n      'Nuclear Mode battle difficulty',\n      'Custom battle rules',\n      'Smart scheduling',\n      'Unlimited customization',\n      'Priority support'\n    ],\n    featureAccess: {\n      elevenlabsVoices: true,\n      customVoiceMessages: true,\n      voiceCloning: true,\n      advancedAIInsights: true,\n      personalizedChallenges: true,\n      smartRecommendations: true,\n      behaviorAnalysis: true,\n      premiumThemes: true,\n      customSounds: true,\n      advancedPersonalization: true,\n      unlimitedCustomization: true,\n      advancedScheduling: true,\n      smartScheduling: true,\n      locationBasedAlarms: true,\n      weatherIntegration: true,\n      exclusiveBattleModes: true,\n      customBattleRules: true,\n      advancedStats: true,\n      leaderboardFeatures: true,\n      nuclearMode: true, // Pro and Lifetime tiers get nuclear mode access\n      premiumSoundLibrary: true,\n      exclusiveContent: true,\n      adFree: true,\n      prioritySupport: true\n    },\n    stripePriceId: 'price_pro_monthly'\n  },\n  {\n    id: 'lifetime',\n    name: 'Lifetime',\n    tier: 'lifetime',\n    price: 99.99,\n    currency: 'USD',\n    interval: 'lifetime',\n    features: [\n      '1000 ElevenLabs voice calls/month',\n      'Unlimited AI insights',\n      'Unlimited custom voice messages',\n      'All premium features',\n      'Lifetime updates',\n      'Priority support'\n    ],\n    featureAccess: {\n      elevenlabsVoices: true,\n      customVoiceMessages: true,\n      voiceCloning: true,\n      advancedAIInsights: true,\n      personalizedChallenges: true,\n      smartRecommendations: true,\n      behaviorAnalysis: true,\n      premiumThemes: true,\n      customSounds: true,\n      advancedPersonalization: true,\n      unlimitedCustomization: true,\n      advancedScheduling: true,\n      smartScheduling: true,\n      locationBasedAlarms: true,\n      weatherIntegration: true,\n      exclusiveBattleModes: true,\n      customBattleRules: true,\n      advancedStats: true,\n      leaderboardFeatures: true,\n      nuclearMode: true, // Pro and Lifetime tiers get nuclear mode access\n      premiumSoundLibrary: true,\n      exclusiveContent: true,\n      adFree: true,\n      prioritySupport: true\n    },\n    stripePriceId: 'price_lifetime'\n  }\n];",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/types/premium.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-namespace",
        "severity": 2,
        "message": "ES2015 module syntax is preferred over namespaces.",
        "line": 618,
        "column": 8,
        "nodeType": "TSModuleDeclaration",
        "messageId": "moduleSyntaxIsPreferred",
        "endLine": 622,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Premium Subscription Types for Relife Alarm App\n// Comprehensive monetization system with subscription tiers, payments, and feature gating\n\nexport type SubscriptionTier =\n  | \"free\"\n  | \"basic\"\n  | \"student\"\n  | \"premium\"\n  | \"pro\"\n  | \"ultimate\"\n  | \"lifetime\";\nexport type SubscriptionStatus =\n  | \"active\"\n  | \"canceled\"\n  | \"past_due\"\n  | \"unpaid\"\n  | \"trialing\"\n  | \"incomplete\"\n  | \"incomplete_expired\";\nexport type BillingInterval = \"month\" | \"year\" | \"lifetime\";\nexport type PaymentStatus =\n  | \"succeeded\"\n  | \"pending\"\n  | \"failed\"\n  | \"canceled\"\n  | \"requires_action\"\n  | \"processing\";\nexport type RefundStatus = \"pending\" | \"succeeded\" | \"failed\" | \"canceled\";\n\n// Core Subscription Interface\nexport interface Subscription {\n  id: string;\n  userId: string;\n  planId?: string; // ID of the subscription plan\n  tier: SubscriptionTier; // Subscription tier\n  stripeSubscriptionId?: string;\n  stripeCustomerId?: string;\n  status: SubscriptionStatus;\n  billingInterval: BillingInterval;\n  amount: number; // in cents\n  currency: string;\n  currentPeriodStart: Date;\n  currentPeriodEnd: Date;\n  trialStart?: Date;\n  trialEnd?: Date;\n  cancelAtPeriodEnd: boolean;\n  canceledAt?: Date;\n  endedAt?: Date;\n  createdAt: Date;\n  updatedAt: Date;\n  metadata?: Record<string, any>;\n}\n\n// Subscription Plans\nexport interface SubscriptionPlan {\n  id: string;\n  name: string;\n  displayName: string;\n  description: string;\n  tier: SubscriptionTier;\n  tagline?: string;\n  features: PremiumFeature[];\n  limits: PlanLimits;\n  pricing: PlanPricing;\n  stripePriceId: string;\n  stripeProductId: string;\n  isPopular?: boolean;\n  isRecommended?: boolean;\n  sortOrder: number;\n  isActive: boolean;\n  trialDays?: number;\n  setupFee?: number;\n  discountEligible: boolean;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface PlanPricing {\n  monthly: {\n    amount: number; // in cents\n    currency: string;\n    stripePriceId: string;\n  };\n  yearly: {\n    amount: number; // in cents\n    currency: string;\n    stripePriceId: string;\n    discountPercentage?: number;\n  };\n  lifetime?: {\n    amount: number; // in cents\n    currency: string;\n    stripePriceId: string;\n  };\n}\n\nexport interface PlanLimits {\n  maxAlarms: number;\n  maxBattles: number;\n  maxCustomSounds: number;\n  maxVoiceProfiles: number;\n  maxThemes: number;\n  maxTeamMembers: number;\n  maxCalendarIntegrations: number;\n  maxSmartFeatures: number;\n  apiCallsPerMonth: number;\n  storageGB: number;\n  supportTier: 'community' | 'email' | 'priority' | 'dedicated';\n  advancedAnalytics: boolean;\n  whiteLabel: boolean;\n}\n\n// Premium Features\nexport interface PremiumFeature {\n  id: string;\n  name: string;\n  description: string;\n  category: PremiumFeatureCategory;\n  icon: string;\n  isCore: boolean; // Core features are always available in the tier\n  isAddon?: boolean; // Add-on features can be purchased separately\n  addonPrice?: number;\n  comingSoon?: boolean;\n}\n\nexport type PremiumFeatureCategory =\n  | 'alarms'\n  | 'battles'\n  | 'voice'\n  | 'themes'\n  | 'integrations'\n  | 'analytics'\n  | 'ai'\n  | 'collaboration'\n  | 'automation'\n  | 'customization';\n\n// Payment & Billing\nexport interface PaymentMethod {\n  id: string;\n  userId: string;\n  stripePaymentMethodId: string;\n  type: 'card' | 'bank_account' | 'paypal' | 'apple_pay' | 'google_pay';\n  isDefault: boolean;\n  card?: {\n    brand: string;\n    last4: string;\n    expMonth: number;\n    expYear: number;\n    country?: string;\n  };\n  billingDetails: {\n    name?: string;\n    email?: string;\n    phone?: string;\n    address?: {\n      line1?: string;\n      line2?: string;\n      city?: string;\n      state?: string;\n      postalCode?: string;\n      country?: string;\n    };\n  };\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface Invoice {\n  id: string;\n  userId: string;\n  subscriptionId: string;\n  stripeInvoiceId: string;\n  stripeCustomerId?: string;\n  status: PaymentStatus;\n  amount: number; // in cents\n  tax?: number; // in cents\n  total: number; // in cents\n  currency: string;\n  dueDate: Date;\n  paidAt?: Date;\n  periodStart: Date;\n  periodEnd: Date;\n  description?: string;\n  downloadUrl?: string;\n  receiptUrl?: string;\n  items: InvoiceItem[];\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface InvoiceItem {\n  id: string;\n  description: string;\n  amount: number; // in cents\n  quantity: number;\n  periodStart?: Date;\n  periodEnd?: Date;\n  planId?: string;\n}\n\nexport interface Payment {\n  id: string;\n  userId: string;\n  subscriptionId?: string;\n  invoiceId?: string;\n  stripePaymentIntentId: string;\n  stripeChargeId?: string;\n  amount: number; // in cents\n  currency: string;\n  status: PaymentStatus;\n  paymentMethod: string; // payment method type\n  description?: string;\n  receiptUrl?: string;\n  failureReason?: string;\n  refunded: boolean;\n  refundedAmount?: number;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface Refund {\n  id: string;\n  userId: string;\n  paymentId: string;\n  stripeRefundId: string;\n  amount: number; // in cents\n  currency: string;\n  reason: 'duplicate' | 'fraudulent' | 'requested_by_customer' | 'expired_uncaptured_charge';\n  status: RefundStatus;\n  description?: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Usage & Analytics\nexport interface FeatureUsage {\n  id: string;\n  userId: string;\n  subscriptionId: string;\n  feature: string;\n  usageCount: number;\n  limitCount: number;\n  resetDate: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface BillingUsage {\n  userId: string;\n  subscriptionId: string;\n  period: {\n    start: Date;\n    end: Date;\n  };\n  usage: {\n    [feature: string]: {\n      used: number;\n      limit: number;\n      percentage: number;\n    };\n  };\n  overageCharges: {\n    feature: string;\n    units: number;\n    unitPrice: number;\n    totalCharge: number;\n  }[];\n  totalOverageAmount: number;\n}\n\n// Discounts & Promotions\nexport interface Discount {\n  id: string;\n  code: string;\n  name: string;\n  description?: string;\n  type: 'percentage' | 'fixed' | 'trial_extension';\n  value: number; // percentage (0-100) or fixed amount in cents\n  currency?: string;\n  applicablePlans: string[]; // plan IDs\n  minAmount?: number; // minimum purchase amount in cents\n  maxUses?: number;\n  currentUses: number;\n  maxUsesPerCustomer?: number;\n  validFrom: Date;\n  validUntil?: Date;\n  firstTimeBuyers: boolean;\n  stackable: boolean;\n  isActive: boolean;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface UserDiscount {\n  id: string;\n  userId: string;\n  discountId: string;\n  discount: Discount;\n  usedCount: number;\n  firstUsedAt?: Date;\n  lastUsedAt?: Date;\n  createdAt: Date;\n}\n\n// Trials & Free Credits\nexport interface Trial {\n  id: string;\n  userId: string;\n  planId: string;\n  startDate: Date;\n  endDate: Date;\n  status: 'active' | 'expired' | 'converted' | 'canceled';\n  convertedToSubscriptionId?: string;\n  remindersSent: number;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface FreeCredit {\n  id: string;\n  userId: string;\n  amount: number; // in cents\n  currency: string;\n  source: 'referral' | 'promotion' | 'refund' | 'bonus' | 'compensation';\n  description: string;\n  remainingAmount: number;\n  expiresAt?: Date;\n  usedAt?: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Referrals & Affiliate System\nexport interface ReferralProgram {\n  id: string;\n  name: string;\n  description: string;\n  referrerReward: {\n    type: 'credit' | 'discount' | 'free_months';\n    value: number;\n    currency?: string;\n  };\n  refereeReward: {\n    type: 'credit' | 'discount' | 'free_months' | 'trial_extension';\n    value: number;\n    currency?: string;\n  };\n  conditions: {\n    validForDays: number;\n    requiresPayment: boolean;\n  };\n  isActive: boolean;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface Referral {\n  id: string;\n  referrerId: string;\n  refereeId: string;\n  refereeEmail: string;\n  code: string;\n  status: 'pending' | 'signed_up' | 'converted' | 'rewarded' | 'expired';\n  signedUpAt?: Date;\n  convertedAt?: Date;\n  rewardedAt?: Date;\n  referrerReward?: string; // reward ID or amount\n  refereeReward?: string; // reward ID or amount\n  expiresAt: Date;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\n// Subscription Management\nexport interface SubscriptionChange {\n  id: string;\n  subscriptionId: string;\n  userId: string;\n  changeType:\n    | \"upgrade\"\n    | \"downgrade\"\n    | \"cancel\"\n    | \"reactivate\"\n    | \"pause\"\n    | \"resume\";\n  fromPlanId: string;\n  toPlanId: string;\n  prorationAmount?: number; // in cents\n  effectiveDate: Date;\n  reason?: string;\n  appliedBy: 'user' | 'admin' | 'system';\n  createdAt: Date;\n}\n\nexport interface CancellationSurvey {\n  id: string;\n  userId: string;\n  subscriptionId: string;\n  primaryReason: 'too_expensive' | 'not_using' | 'missing_features' | 'technical_issues' | 'competitor' | 'other';\n  secondaryReasons: string[];\n  feedback: string;\n  improvementSuggestions: string;\n  likelyToReturn: number; // 1-10 scale\n  wouldRecommend: number; // 1-10 scale\n  retentionOfferShown: boolean;\n  retentionOfferAccepted: boolean;\n  createdAt: Date;\n}\n\n// Feature Gating & Access Control\nexport interface FeatureAccess {\n  userId: string;\n  features: {\n    [featureId: string]: {\n      hasAccess: boolean;\n      usageLimit?: number;\n      usageCount?: number;\n      resetDate?: Date;\n    };\n  };\n  lastUpdated: Date;\n}\n\nexport interface FeatureGate {\n  featureId: string;\n  gracePeriodDays?: number; // Allow usage after downgrade for X days\n  softLimit?: boolean; // Show warnings but allow usage\n  redirectToUpgrade?: string; // URL to redirect for upgrade\n  customMessage?: string;\n}\n\n// Cohort Data Definition\nexport interface CohortData {\n  cohort: string; // YYYY-MM\n  customersCount: number;\n  periods: {\n    period: number; // months since signup\n    retainedCustomers: number;\n    retentionRate: number;\n    revenue: number;\n  }[];\n}\n\n// Revenue Analytics\nexport interface RevenueMetrics {\n  period: {\n    start: Date;\n    end: Date;\n  };\n  metrics: {\n    totalRevenue: number;\n    recurringRevenue: number; // MRR or ARR\n    newRevenue: number;\n    churnRevenue: number;\n    expansionRevenue: number; // from upgrades\n    contractionRevenue: number; // from downgrades\n    totalCustomers: number;\n    newCustomers: number;\n    churnedCustomers: number;\n    averageRevenuePerUser: number;\n    lifetimeValue: number;\n    churnRate: number;\n    growthRate: number;\n  };\n  byTier: Record<SubscriptionTier, {\n      customers: number;\n      revenue: number;\n      churnRate: number;\n      avgRevenue: number;\n    }>;\n  cohortAnalysis: CohortData[];\n}\n\n// Error Handling\nexport interface SubscriptionError {\n  code: string;\n  message: string;\n  details?: Record<string, any>;\n  retryable: boolean;\n  userFriendlyMessage: string;\n}\n\n// API Request/Response Types\nexport interface CreateSubscriptionRequest {\n  planId: string;\n  paymentMethodId?: string;\n  discountCode?: string;\n  billingInterval: BillingInterval;\n  trialDays?: number;\n}\n\nexport interface CreateSubscriptionResponse {\n  subscription: Subscription;\n  clientSecret?: string; // for SCA authentication\n  requiresAction: boolean;\n  error?: SubscriptionError;\n}\n\nexport interface UpdateSubscriptionRequest {\n  planId?: string;\n  billingInterval?: BillingInterval;\n  cancelAtPeriodEnd?: boolean;\n  prorationBehavior?: 'always_invoice' | 'create_prorations' | 'none';\n}\n\nexport interface UpdateSubscriptionResponse {\n  subscription: Subscription;\n  prorationAmount?: number;\n  effectiveDate: Date;\n  error?: SubscriptionError;\n}\n\nexport interface CancelSubscriptionRequest {\n  reason?: string;\n  feedback?: string;\n  cancelImmediately?: boolean;\n  surveyData?: Partial<CancellationSurvey>;\n}\n\nexport interface CancelSubscriptionResponse {\n  subscription: Subscription;\n  refundAmount?: number;\n  effectiveDate: Date;\n  retentionOffer?: {\n    discountPercentage: number;\n    durationMonths: number;\n    description: string;\n  };\n  error?: SubscriptionError;\n}\n\n// Webhook Event Types\nexport interface StripeWebhookEvent {\n  id: string;\n  type: string;\n  data: {\n    object: any;\n    previous_attributes?: any;\n  };\n  created: number;\n  livemode: boolean;\n  pending_webhooks: number;\n  request?: {\n    id: string;\n    idempotency_key?: string;\n  };\n}\n\nexport interface WebhookProcessingResult {\n  processed: boolean;\n  error?: string;\n  actions: string[];\n  subscriptionId?: string;\n  userId?: string;\n  timestamp: Date;\n}\n\n// UI State Types\nexport interface PremiumUIState {\n  selectedPlan?: SubscriptionPlan;\n  isLoading: boolean;\n  isProcessingPayment: boolean;\n  showPaymentModal: boolean;\n  showCancelModal: boolean;\n  showUpgradeModal: boolean;\n  errors: Record<string, string>;\n  currentStep: 'plan_selection' | 'payment_method' | 'confirmation' | 'processing' | 'complete';\n  paymentIntent?: {\n    clientSecret: string;\n    status: string;\n  };\n}\n\nexport interface SubscriptionDashboardData {\n  subscription: Subscription | null;\n  currentPlan: SubscriptionPlan | null;\n  usage: BillingUsage | null;\n  upcomingInvoice: Invoice | null;\n  paymentMethods: PaymentMethod[];\n  invoiceHistory: Invoice[];\n  availablePlans: SubscriptionPlan[];\n  discountCodes: UserDiscount[];\n  referralStats: {\n    code: string;\n    referrals: number;\n    rewards: number;\n    pendingRewards: number;\n  };\n}\n\n// Integration Types\nexport interface StripeConfig {\n  publishableKey: string;\n  secretKey: string;\n  webhookSecret: string;\n  apiVersion: string;\n  appInfo: {\n    name: string;\n    version: string;\n    url: string;\n  };\n}\n\nexport interface PayPalConfig {\n  clientId: string;\n  clientSecret: string;\n  environment: 'sandbox' | 'production';\n}\n\nexport interface ApplePayConfig {\n  merchantId: string;\n  merchantName: string;\n  supportedNetworks: string[];\n}\n\n// Export all types as a namespace for easy importing\nexport namespace Premium {\n  export type Status = SubscriptionStatus;\n  export type Billing = BillingInterval;\n  export type Payment = PaymentStatus;\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/types/subscription.d.ts",
    "messages": [
      {
        "ruleId": null,
        "nodeType": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Interface declaration can only extend an identifier/qualified name with optional type arguments.",
        "line": 179,
        "column": 46
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Subscription-specific Type Definitions\n// Additional types for subscription service to complement premium.ts\n\n// Database row types for mapping functions\nexport interface SubscriptionPlanDbRow {\n  id: string;\n  tier: string;\n  name: string;\n  display_name: string;\n  description: string;\n  tagline?: string;\n  features: any[] | null;\n  limits: Record<string, any> | null;\n  pricing: Record<string, any> | null;\n  stripe_price_id_monthly?: string;\n  stripe_product_id?: string;\n  is_popular?: boolean;\n  is_recommended?: boolean;\n  sort_order?: number;\n  is_active?: boolean;\n  trial_days?: number;\n  setup_fee?: number;\n  discount_eligible?: boolean;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface TrialDbRow {\n  id: string;\n  user_id: string;\n  plan_id: string;\n  tier: string;\n  start_date: string;\n  end_date: string;\n  status: string;\n  converted_to_subscription_id?: string;\n  reminders_sent?: number;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface DiscountDbRow {\n  id: string;\n  code: string;\n  name: string;\n  description?: string;\n  type: string;\n  value: number;\n  currency?: string;\n  applicable_tiers?: string[];\n  applicable_plans?: string[];\n  min_amount?: number;\n  max_uses?: number;\n  current_uses?: number;\n  max_uses_per_customer?: number;\n  valid_from: string;\n  valid_until?: string;\n  first_time_buyers?: boolean;\n  stackable?: boolean;\n  is_active?: boolean;\n  created_at: string;\n  updated_at: string;\n}\n\n// Retention offer type to replace 'any'\nexport interface RetentionOffer {\n  id: string;\n  type: 'discount' | 'free_months' | 'upgrade' | 'feature_unlock';\n  title: string;\n  description: string;\n  discountPercentage?: number;\n  freeMonths?: number;\n  features?: string[];\n  validUntil: Date;\n  acceptUrl: string;\n  declineUrl: string;\n  metadata?: Record<string, any>;\n}\n\n// Enhanced response types with proper typing\nexport interface CreateSubscriptionResult {\n  success: boolean;\n  subscription?: import('./premium').Subscription;\n  error?: import('./premium').SubscriptionError;\n  clientSecret?: string;\n}\n\nexport interface UpdateSubscriptionResult {\n  success: boolean;\n  subscription?: import('./premium').Subscription;\n  error?: import('./premium').SubscriptionError;\n}\n\nexport interface CancelSubscriptionResult {\n  success: boolean;\n  subscription?: import('./premium').Subscription;\n  error?: import('./premium').SubscriptionError;\n  retentionOffer?: RetentionOffer;\n}\n\n// Validation result types\nexport interface DiscountValidationResult {\n  valid: boolean;\n  discount?: import('./premium').Discount;\n  error?: string;\n}\n\nexport interface TrialStartResult {\n  success: boolean;\n  trial?: import('./premium').Trial;\n  error?: string;\n}\n\n// Feature usage tracking types\nexport interface FeatureUsageParams {\n  p_user_id: string;\n  p_feature: string;\n  p_usage_amount: number;\n  p_reset_date: string;\n}\n\nexport interface DiscountUsageParams {\n  p_user_id: string;\n  p_discount_code: string;\n}\n\n// Database query result types\nexport interface FeatureUsageDbRow {\n  id: string;\n  user_id: string;\n  feature: string;\n  usage_count: number;\n  limit_count?: number;\n  reset_date: string;\n  created_at: string;\n  updated_at: string;\n}\n\nexport interface UserDiscountDbRow {\n  id: string;\n  user_id: string;\n  discount_id: string;\n  used_count: number;\n  first_used_at?: string;\n  last_used_at?: string;\n  created_at: string;\n  discounts: DiscountDbRow; // For joined queries\n}\n\nexport interface ReferralDbRow {\n  id: string;\n  referrer_id: string;\n  referee_id?: string;\n  status: 'pending' | 'converted' | 'rewarded';\n  created_at: string;\n  updated_at: string;\n}\n\n// Service configuration types\nexport interface FreeTierLimits {\n  maxAlarms: number;\n  maxBattles: number;\n  maxCustomSounds: number;\n  maxVoiceProfiles: number;\n  maxThemes: number;\n  supportTier: 'community' | 'email' | 'priority' | 'dedicated';\n  advancedAnalytics: boolean;\n}\n\n// Referral statistics type\nexport interface ReferralStats {\n  code: string;\n  referrals: number;\n  rewards: number;\n  pendingRewards: number;\n}\n\n// Extended interfaces for better type safety\nexport interface EnhancedBillingUsage extends import('./premium').BillingUsage {\n  usage: {\n    [feature: string]: {\n      used: number;\n      limit: number;\n      percentage: number;\n      resetDate?: Date;\n    };\n  };\n}\n\n// Type guards for runtime type checking\nexport function isValidSubscriptionTier(tier: string): tier is import('./premium').SubscriptionTier {\n  const validTiers = ['free', 'basic', 'student', 'premium', 'pro', 'ultimate', 'lifetime'];\n  return validTiers.includes(tier);\n}\n\nexport function isValidSubscriptionStatus(status: string): status is import('./premium').SubscriptionStatus {\n  const validStatuses = ['active', 'canceled', 'past_due', 'unpaid', 'trialing', 'incomplete', 'incomplete_expired'];\n  return validStatuses.includes(status);\n}",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/utils/accessibility.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'NodeListOf' is not defined.",
        "line": 221,
        "column": 10,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 221,
        "endColumn": 20
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference lib=\"dom\" />\n// Accessibility utilities for Smart Alarm App\n// Provides color contrast checking and accessibility helpers\n\nexport interface ColorContrastResult {\n  ratio: number;\n  level: 'AAA' | 'AA' | 'A' | 'FAIL';\n  isAccessible: boolean;\n  recommendations?: string[];\n}\n\n/**\n * Convert hex color to RGB values\n */\nexport const hexToRgb = (hex: string): { r: number; g: number; b: number } | null => {\n  const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16)\n  } : null;\n};\n\n/**\n * Calculate relative luminance of a color\n */\nexport const getRelativeLuminance = (r: number, g: number, b: number): number => {\n  const [rs, gs, bs] = [r, g, b].map(c => {\n    c = c / 255;\n    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);\n  });\n\n  return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;\n};\n\n/**\n * Calculate color contrast ratio between two colors\n */\nexport const getContrastRatio = (color1: string, color2: string): number => {\n  const rgb1 = hexToRgb(color1);\n  const rgb2 = hexToRgb(color2);\n\n  if (!rgb1 || !rgb2) {\n    return 0;\n  }\n\n  const lum1 = getRelativeLuminance(rgb1.r, rgb1.g, rgb1.b);\n  const lum2 = getRelativeLuminance(rgb2.r, rgb2.g, rgb2.b);\n\n  const brightest = Math.max(lum1, lum2);\n  const darkest = Math.min(lum1, lum2);\n\n  return (brightest + 0.05) / (darkest + 0.05);\n};\n\n/**\n * Check if color combination meets WCAG contrast requirements\n */\nexport const checkContrastAccessibility = (\n  foreground: string,\n  background: string,\n  fontSize: 'normal' | 'large' = 'normal'\n): ColorContrastResult => {\n  const ratio = getContrastRatio(foreground, background);\n\n  // WCAG contrast requirements\n  const normalAA = 4.5;\n  const normalAAA = 7.0;\n  const largeAA = 3.0;\n  const largeAAA = 4.5;\n\n  const requiredAA = fontSize === 'large' ? largeAA : normalAA;\n  const requiredAAA = fontSize === 'large' ? largeAAA : normalAAA;\n\n  let level: ColorContrastResult['level'] = 'FAIL';\n  const recommendations: string[] = [];\n\n  if (ratio >= requiredAAA) {\n    level = 'AAA';\n  } else if (ratio >= requiredAA) {\n    level = 'AA';\n  } else if (ratio >= 3.0) {\n    level = 'A';\n    recommendations.push('Consider using a darker foreground or lighter background');\n    recommendations.push('Current contrast meets minimum requirements but not recommended standards');\n  } else {\n    level = 'FAIL';\n    recommendations.push('Insufficient contrast - text may be difficult to read');\n    recommendations.push('Use a darker foreground or lighter background color');\n    recommendations.push(`Current ratio: ${ratio.toFixed(2)}, Required: ${requiredAA.toFixed(1)}`);\n  }\n\n  return {\n    ratio: parseFloat(ratio.toFixed(2)),\n    level,\n    isAccessible: ratio >= requiredAA,\n    recommendations: recommendations.length > 0 ? recommendations : undefined\n  };\n};\n\n/**\n * Get improved color suggestions for better contrast\n */\nexport const getContrastImprovedColors = (\n  foreground: string,\n  background: string,\n  targetRatio = 4.5\n): { foreground?: string; background?: string } => {\n  const fgRgb = hexToRgb(foreground);\n  const bgRgb = hexToRgb(background);\n\n  if (!fgRgb || !bgRgb) {\n    return {};\n  }\n\n  const suggestions: { foreground?: string; background?: string } = {};\n\n  // Suggest darker foreground\n  const darkerForeground = {\n    r: Math.max(0, fgRgb.r - 50),\n    g: Math.max(0, fgRgb.g - 50),\n    b: Math.max(0, fgRgb.b - 50)\n  };\n\n  const fgHex = `#${darkerForeground.r.toString(16).padStart(2, '0')}${darkerForeground.g.toString(16).padStart(2, '0')}${darkerForeground.b.toString(16).padStart(2, '0')}`;\n\n  if (getContrastRatio(fgHex, background) >= targetRatio) {\n    suggestions.foreground = fgHex;\n  }\n\n  // Suggest lighter background\n  const lighterBackground = {\n    r: Math.min(255, bgRgb.r + 50),\n    g: Math.min(255, bgRgb.g + 50),\n    b: Math.min(255, bgRgb.b + 50)\n  };\n\n  const bgHex = `#${lighterBackground.r.toString(16).padStart(2, '0')}${lighterBackground.g.toString(16).padStart(2, '0')}${lighterBackground.b.toString(16).padStart(2, '0')}`;\n\n  if (getContrastRatio(foreground, bgHex) >= targetRatio) {\n    suggestions.background = bgHex;\n  }\n\n  return suggestions;\n};\n\n/**\n * Generate ARIA announcements for dynamic content changes\n */\nexport const createAriaAnnouncement = (\n  message: string,\n  priority: 'polite' | 'assertive' = 'polite'\n): void => {\n  // Create or get existing live region\n  let liveRegion = document.getElementById('aria-live-region');\n\n  if (!liveRegion) {\n    liveRegion = document.createElement('div');\n    liveRegion.id = 'aria-live-region';\n    liveRegion.setAttribute('aria-live', priority);\n    liveRegion.setAttribute('aria-atomic', 'true');\n    liveRegion.className = 'sr-only';\n    document.body.appendChild(liveRegion);\n  } else {\n    liveRegion.setAttribute('aria-live', priority);\n  }\n\n  // Clear and set new message\n  liveRegion.textContent = '';\n  setTimeout(() => {\n    liveRegion!.textContent = message;\n  }, 100);\n\n  // Clear after announcement\n  setTimeout(() => {\n    liveRegion!.textContent = '';\n  }, 3000);\n};\n\n/**\n * Focus management utilities\n */\nexport class FocusManager {\n  private static focusStack: HTMLElement[] = [];\n\n  /**\n   * Push current focus to stack and move to new element\n   */\n  static pushFocus(element: HTMLElement): void {\n    const currentFocus = document.activeElement as HTMLElement;\n    if (currentFocus && currentFocus !== document.body) {\n      this.focusStack.push(currentFocus);\n    }\n\n    element.focus();\n  }\n\n  /**\n   * Return focus to previous element in stack\n   */\n  static popFocus(): void {\n    const previousFocus = this.focusStack.pop();\n    if (previousFocus && document.contains(previousFocus)) {\n      previousFocus.focus();\n    }\n  }\n\n  /**\n   * Clear focus stack\n   */\n  static clearFocusStack(): void {\n    this.focusStack = [];\n  }\n\n  /**\n   * Trap focus within a container\n   */\n  static trapFocus(container: HTMLElement): () => void {\n    const focusableElements = container.querySelectorAll(\n      'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n    ) as NodeListOf<HTMLElement>;\n\n    const firstElement = focusableElements[0];\n    const lastElement = focusableElements[focusableElements.length - 1];\n\n    const handleTabKey = (e: KeyboardEvent) => {\n      if (e.key !== 'Tab') return;\n\n      if (e.shiftKey) {\n        if (document.activeElement === firstElement) {\n          e.preventDefault();\n          lastElement.focus();\n        }\n      } else {\n        if (document.activeElement === lastElement) {\n          e.preventDefault();\n          firstElement.focus();\n        }\n      }\n    };\n\n    container.addEventListener('keydown', handleTabKey);\n\n    // Focus first element\n    if (firstElement) {\n      firstElement.focus();\n    }\n\n    // Return cleanup function\n    return () => {\n      container.removeEventListener('keydown', handleTabKey);\n    };\n  }\n}\n\n/**\n * Check if an element is visible on screen (for skip links, etc.)\n */\nexport const isElementVisible = (element: HTMLElement): boolean => {\n  const rect = element.getBoundingClientRect();\n  return (\n    rect.width > 0 &&\n    rect.height > 0 &&\n    rect.top >= 0 &&\n    rect.left >= 0 &&\n    rect.bottom <= window.innerHeight &&\n    rect.right <= window.innerWidth\n  );\n};\n\n/**\n * Announce page changes for single-page applications\n */\nexport const announcePageChange = (pageName: string): void => {\n  createAriaAnnouncement(`Navigated to ${pageName}`, 'polite');\n\n  // Update page title\n  document.title = `${pageName} - Smart Alarm`;\n};\n\n/**\n * High contrast mode detection\n */\nexport const isHighContrastMode = (): boolean => {\n  // Check for Windows high contrast mode\n  if (window.matchMedia('(prefers-contrast: high)').matches) {\n    return true;\n  }\n\n  // Check for forced colors (Windows high contrast)\n  if (window.matchMedia('(forced-colors: active)').matches) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Reduced motion preference detection\n */\nexport const prefersReducedMotion = (): boolean => {\n  return window.matchMedia('(prefers-reduced-motion: reduce)').matches;\n};\n\n/**\n * Add accessible tooltips\n */\nexport const addAccessibleTooltip = (\n  trigger: HTMLElement,\n  content: string,\n  options: {\n    position?: 'top' | 'bottom' | 'left' | 'right';\n    delay?: number;\n  } = {}\n): () => void => {\n  const { position = 'top', delay = 300 } = options;\n  let tooltip: HTMLElement | null = null;\n  let timeoutId: number | null = null;\n\n  const showTooltip = () => {\n    tooltip = document.createElement('div');\n    tooltip.className = `\n      absolute z-50 px-2 py-1 text-xs font-medium text-white bg-gray-900\n      rounded-md shadow-lg pointer-events-none max-w-xs\n    `;\n    tooltip.textContent = content;\n    tooltip.role = 'tooltip';\n\n    document.body.appendChild(tooltip);\n\n    const triggerRect = trigger.getBoundingClientRect();\n    const tooltipRect = tooltip.getBoundingClientRect();\n\n    let top = 0;\n    let left = 0;\n\n    switch (position) {\n      case 'top':\n        top = triggerRect.top - tooltipRect.height - 5;\n        left = triggerRect.left + (triggerRect.width - tooltipRect.width) / 2;\n        break;\n      case 'bottom':\n        top = triggerRect.bottom + 5;\n        left = triggerRect.left + (triggerRect.width - tooltipRect.width) / 2;\n        break;\n      case 'left':\n        top = triggerRect.top + (triggerRect.height - tooltipRect.height) / 2;\n        left = triggerRect.left - tooltipRect.width - 5;\n        break;\n      case 'right':\n        top = triggerRect.top + (triggerRect.height - tooltipRect.height) / 2;\n        left = triggerRect.right + 5;\n        break;\n    }\n\n    tooltip.style.top = `${top}px`;\n    tooltip.style.left = `${left}px`;\n\n    // Generate unique ID\n    const tooltipId = `tooltip-${Date.now()}`;\n    tooltip.id = tooltipId;\n    trigger.setAttribute('aria-describedby', tooltipId);\n  };\n\n  const hideTooltip = () => {\n    if (tooltip) {\n      document.body.removeChild(tooltip);\n      tooltip = null;\n    }\n    trigger.removeAttribute('aria-describedby');\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n  };\n\n  const handleMouseEnter = () => {\n    timeoutId = window.setTimeout(showTooltip, delay);\n  };\n\n  const handleMouseLeave = () => {\n    hideTooltip();\n  };\n\n  const handleFocus = () => {\n    showTooltip();\n  };\n\n  const handleBlur = () => {\n    hideTooltip();\n  };\n\n  trigger.addEventListener('mouseenter', handleMouseEnter);\n  trigger.addEventListener('mouseleave', handleMouseLeave);\n  trigger.addEventListener('focus', handleFocus);\n  trigger.addEventListener('blur', handleBlur);\n\n  // Return cleanup function\n  return () => {\n    hideTooltip();\n    trigger.removeEventListener('mouseenter', handleMouseEnter);\n    trigger.removeEventListener('mouseleave', handleMouseLeave);\n    trigger.removeEventListener('focus', handleFocus);\n    trigger.removeEventListener('blur', handleBlur);\n  };\n};\n\nexport default {\n  checkContrastAccessibility,\n  getContrastImprovedColors,\n  createAriaAnnouncement,\n  FocusManager,\n  announcePageChange,\n  isHighContrastMode,\n  prefersReducedMotion,\n  addAccessibleTooltip\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/utils/advancedTranslationValidator.ts",
    "messages": [
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\-.",
        "line": 66,
        "column": 13,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 66,
        "endColumn": 14,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [2017, 2018], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [2017, 2017], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      },
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\-.",
        "line": 66,
        "column": 22,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 66,
        "endColumn": 23,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [2026, 2027], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [2026, 2026], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      },
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\-.",
        "line": 66,
        "column": 34,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 66,
        "endColumn": 35,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [2038, 2039], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [2038, 2038], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Advanced Translation Validation System\n *\n * Enhanced validation tools with quality scoring, cultural sensitivity detection,\n * consistency analysis, and performance metrics for the Relife translation system.\n */\n\nimport { SupportedLanguage, SUPPORTED_LANGUAGES } from '../config/i18n';\n\n// Enhanced validation result interfaces\nexport interface QualityScore {\n  overall: number; // 0-100\n  completeness: number;\n  consistency: number;\n  culturalAdaptation: number;\n  technicalAccuracy: number;\n  readability: number;\n}\n\nexport interface CulturalIssue {\n  type: 'inappropriate_reference' | 'cultural_assumption' | 'religious_sensitivity' | 'formality_mismatch' | 'time_format' | 'currency_assumption';\n  key: string;\n  message: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  suggestion?: string;\n  culturalContext: string;\n}\n\nexport interface ConsistencyIssue {\n  type: 'terminology_variation' | 'tone_inconsistency' | 'formatting_difference' | 'style_mismatch';\n  keys: string[];\n  message: string;\n  examples: { key: string; value: string }[];\n  suggestedFix: string;\n}\n\nexport interface AdvancedValidationResult {\n  language: SupportedLanguage;\n  qualityScore: QualityScore;\n  culturalIssues: CulturalIssue[];\n  consistencyIssues: ConsistencyIssue[];\n  performanceMetrics: PerformanceMetrics;\n  recommendations: string[];\n  lastValidated: Date;\n}\n\nexport interface PerformanceMetrics {\n  averageTranslationLength: number;\n  readabilityScore: number; // Flesch-Kincaid equivalent\n  complexityRating: 'simple' | 'moderate' | 'complex';\n  estimatedReadingTime: number; // seconds\n  mobileOptimization: number; // 0-100 score\n}\n\n// Cultural patterns and rules\nconst CULTURAL_PATTERNS = {\n  // Religious and cultural sensitivity patterns\n  religious_references: [\n    /\\b(christmas|easter|halloween|thanksgiving)\\b/i,\n    /\\b(pray|prayer|blessing|holy|sacred)\\b/i,\n    /\\b(church|mosque|temple|synagogue)\\b/i\n  ],\n\n  // Cultural assumptions (Western-centric)\n  cultural_assumptions: [\n    /\\b(9[\\s\\-]?to[\\s\\-]?5|9am[\\s\\-]?5pm)\\b/i, // Work hours\n    /\\b(weekend|saturday|sunday)\\b/i, // Weekend assumptions\n    /\\b(family dinner|nuclear family)\\b/i, // Family structure\n    /\\b(first world|third world)\\b/i // Outdated terminology\n  ],\n\n  // Inappropriate references\n  inappropriate_content: [\n    /\\b(drinking|alcohol|wine|beer|cocktail)\\b/i,\n    /\\b(dating|romantic|relationship)\\b/i, // May not be appropriate in all cultures\n    /\\b(pork|beef|meat)\\b/i // Dietary restrictions\n  ],\n\n  // Formality mismatches (detect overly casual language)\n  formality_issues: [\n    /\\b(hey|hi there|what's up|cool|awesome|dude)\\b/i,\n    /\\b(gonna|wanna|gotta)\\b/i,\n    /[!]{2,}/, // Multiple exclamation marks\n  ]\n};\n\n// Language-specific patterns\nconst LANGUAGE_SPECIFIC_RULES = {\n  // RTL languages\n  rtl: ['ar'],\n\n  // Formal languages (require more formal tone)\n  formal: ['de', 'ja', 'ko', 'hi'],\n\n  // Languages with complex pluralization\n  complex_plurals: ['ru', 'ar', 'hi', 'bn'],\n\n  // Languages sensitive to religious content\n  religious_sensitive: ['ar', 'hi', 'bn', 'id'],\n\n  // Languages with strict formality rules\n  strict_formality: ['ja', 'ko', 'de']\n};\n\n// Terminology consistency patterns\nconst TERMINOLOGY_PATTERNS = {\n  // Core app terms that should be consistent\n  core_terms: [\n    'alarm', 'notification', 'reminder', 'snooze', 'challenge',\n    'profile', 'settings', 'theme', 'sound', 'vibration',\n    'morning', 'routine', 'goal', 'achievement', 'streak'\n  ],\n\n  // UI elements that should be consistent\n  ui_elements: [\n    'button', 'menu', 'tab', 'screen', 'page', 'dialog',\n    'save', 'cancel', 'ok', 'yes', 'no', 'confirm'\n  ],\n\n  // Time-related terms\n  time_terms: [\n    'morning', 'afternoon', 'evening', 'night',\n    'hour', 'minute', 'second', 'day', 'week', 'month'\n  ]\n};\n\nexport class AdvancedTranslationValidator {\n  private referenceLanguage: SupportedLanguage = 'en';\n  private validationCache: Map<string, AdvancedValidationResult> = new Map();\n  private terminologyMap: Map<SupportedLanguage, Map<string, string[]>> = new Map();\n\n  constructor(referenceLanguage: SupportedLanguage = 'en') {\n    this.referenceLanguage = referenceLanguage;\n    this.buildTerminologyMaps();\n  }\n\n  /**\n   * Perform comprehensive validation with quality scoring\n   */\n  public async validateAdvanced(\n    language: SupportedLanguage,\n    translations: Record<string, any>,\n    referenceTranslations: Record<string, any>\n  ): Promise<AdvancedValidationResult> {\n\n    console.log(`üîç Running advanced validation for ${language}...`);\n\n    const result: AdvancedValidationResult = {\n      language,\n      qualityScore: this.calculateQualityScore(translations, referenceTranslations, language),\n      culturalIssues: this.detectCulturalIssues(translations, language),\n      consistencyIssues: this.analyzeConsistency(translations, language),\n      performanceMetrics: this.calculatePerformanceMetrics(translations, language),\n      recommendations: [],\n      lastValidated: new Date()\n    };\n\n    // Generate recommendations based on findings\n    result.recommendations = this.generateRecommendations(result);\n\n    // Cache result\n    this.validationCache.set(language, result);\n\n    return result;\n  }\n\n  /**\n   * Calculate comprehensive quality score (0-100)\n   */\n  private calculateQualityScore(\n    translations: Record<string, any>,\n    reference: Record<string, any>,\n    language: SupportedLanguage\n  ): QualityScore {\n\n    const completeness = this.calculateCompleteness(translations, reference);\n    const consistency = this.calculateConsistency(translations, language);\n    const culturalAdaptation = this.calculateCulturalAdaptation(translations, language);\n    const technicalAccuracy = this.calculateTechnicalAccuracy(translations, reference);\n    const readability = this.calculateReadability(translations, language);\n\n    const overall = Math.round(\n      (completeness * 0.25) +\n      (consistency * 0.20) +\n      (culturalAdaptation * 0.20) +\n      (technicalAccuracy * 0.20) +\n      (readability * 0.15)\n    );\n\n    return {\n      overall,\n      completeness,\n      consistency,\n      culturalAdaptation,\n      technicalAccuracy,\n      readability\n    };\n  }\n\n  /**\n   * Detect cultural sensitivity issues\n   */\n  private detectCulturalIssues(\n    translations: Record<string, any>,\n    language: SupportedLanguage\n  ): CulturalIssue[] {\n\n    const issues: CulturalIssue[] = [];\n    const langInfo = SUPPORTED_LANGUAGES[language];\n\n    this.traverseTranslations(translations, (key, value) => {\n      if (typeof value !== 'string') return;\n\n      // Check religious sensitivity\n      if (LANGUAGE_SPECIFIC_RULES.religious_sensitive.includes(language)) {\n        CULTURAL_PATTERNS.religious_references.forEach(pattern => {\n          if (pattern.test(value)) {\n            issues.push({\n              type: 'religious_sensitivity',\n              key,\n              message: 'Contains religious references that may not be appropriate',\n              severity: 'medium',\n              suggestion: 'Consider using more neutral language or cultural alternatives',\n              culturalContext: `${langInfo.nativeName} culture may have different religious practices`\n            });\n          }\n        });\n      }\n\n      // Check cultural assumptions\n      CULTURAL_PATTERNS.cultural_assumptions.forEach(pattern => {\n        if (pattern.test(value)) {\n          issues.push({\n            type: 'cultural_assumption',\n            key,\n            message: 'Contains Western-centric cultural assumptions',\n            severity: 'medium',\n            suggestion: 'Adapt to local cultural norms and practices',\n            culturalContext: `Consider ${langInfo.region} cultural context`\n          });\n        }\n      });\n\n      // Check formality for strict formality languages\n      if (LANGUAGE_SPECIFIC_RULES.strict_formality.includes(language)) {\n        CULTURAL_PATTERNS.formality_issues.forEach(pattern => {\n          if (pattern.test(value)) {\n            issues.push({\n              type: 'formality_mismatch',\n              key,\n              message: 'Language may be too casual for this cultural context',\n              severity: 'high',\n              suggestion: 'Use more formal language appropriate for business applications',\n              culturalContext: `${langInfo.nativeName} culture typically uses formal language in apps`\n            });\n          }\n        });\n      }\n\n      // Check time format assumptions\n      if (value.includes('AM') || value.includes('PM')) {\n        if (langInfo.timeFormat === '24h') {\n          issues.push({\n            type: 'time_format',\n            key,\n            message: 'Uses 12-hour time format in 24-hour time culture',\n            severity: 'low',\n            suggestion: 'Consider using 24-hour format or make format dynamic',\n            culturalContext: `${langInfo.region} typically uses 24-hour time format`\n          });\n        }\n      }\n    });\n\n    return issues;\n  }\n\n  /**\n   * Analyze terminology and style consistency\n   */\n  private analyzeConsistency(\n    translations: Record<string, any>,\n    language: SupportedLanguage\n  ): ConsistencyIssue[] {\n\n    const issues: ConsistencyIssue[] = [];\n    const termUsage = new Map<string, { key: string; value: string }[]>();\n\n    // Build terminology usage map\n    this.traverseTranslations(translations, (key, value) => {\n      if (typeof value !== 'string') return;\n\n      TERMINOLOGY_PATTERNS.core_terms.forEach(term => {\n        const regex = new RegExp(`\\\\b${term}\\\\b`, 'gi');\n        const matches = value.match(regex);\n        if (matches) {\n          matches.forEach(match => {\n            if (!termUsage.has(match.toLowerCase())) {\n              termUsage.set(match.toLowerCase(), []);\n            }\n            termUsage.get(match.toLowerCase())!.push({ key, value });\n          });\n        }\n      });\n    });\n\n    // Check for terminology variations\n    termUsage.forEach((usages, term) => {\n      const variations = new Set(usages.map(u => this.extractTermVariation(u.value, term)));\n      if (variations.size > 1) {\n        issues.push({\n          type: 'terminology_variation',\n          keys: usages.map(u => u.key),\n          message: `Inconsistent translation of \"${term}\" found`,\n          examples: Array.from(variations).map(variation => ({\n            key: usages.find(u => this.extractTermVariation(u.value, term) === variation)!.key,\n            value: variation\n          })),\n          suggestedFix: `Standardize translation of \"${term}\" throughout all files`\n        });\n      }\n    });\n\n    return issues;\n  }\n\n  /**\n   * Calculate performance metrics\n   */\n  private calculatePerformanceMetrics(\n    translations: Record<string, any>,\n    language: SupportedLanguage\n  ): PerformanceMetrics {\n\n    const allTexts: string[] = [];\n    this.traverseTranslations(translations, (key, value) => {\n      if (typeof value === 'string') allTexts.push(value);\n    });\n\n    const totalLength = allTexts.reduce((sum, text) => sum + text.length, 0);\n    const averageLength = totalLength / allTexts.length;\n\n    const readabilityScore = this.calculateReadabilityScore(allTexts, language);\n    const complexityRating = this.determineComplexityRating(allTexts);\n    const estimatedReadingTime = this.calculateReadingTime(allTexts, language);\n    const mobileOptimization = this.calculateMobileOptimization(allTexts);\n\n    return {\n      averageTranslationLength: Math.round(averageLength),\n      readabilityScore,\n      complexityRating,\n      estimatedReadingTime,\n      mobileOptimization\n    };\n  }\n\n  /**\n   * Generate actionable recommendations\n   */\n  private generateRecommendations(result: AdvancedValidationResult): string[] {\n    const recommendations: string[] = [];\n\n    // Quality score recommendations\n    if (result.qualityScore.overall < 80) {\n      recommendations.push(`üéØ Overall quality score (${result.qualityScore.overall}%) needs improvement`);\n    }\n\n    if (result.qualityScore.completeness < 100) {\n      recommendations.push(`üìù Complete missing translations (${100 - result.qualityScore.completeness}% remaining)`);\n    }\n\n    if (result.qualityScore.consistency < 80) {\n      recommendations.push(`üîÑ Improve terminology consistency across files`);\n    }\n\n    if (result.qualityScore.culturalAdaptation < 70) {\n      recommendations.push(`üåç Enhance cultural localization beyond literal translation`);\n    }\n\n    // Cultural issues recommendations\n    const criticalCultural = result.culturalIssues.filter(i => i.severity === 'critical').length;\n    const highCultural = result.culturalIssues.filter(i => i.severity === 'high').length;\n\n    if (criticalCultural > 0) {\n      recommendations.push(`üö® Fix ${criticalCultural} critical cultural sensitivity issues`);\n    }\n    if (highCultural > 0) {\n      recommendations.push(`‚ö†Ô∏è Address ${highCultural} high-priority cultural issues`);\n    }\n\n    // Consistency recommendations\n    if (result.consistencyIssues.length > 0) {\n      recommendations.push(`üìã Standardize ${result.consistencyIssues.length} terminology inconsistencies`);\n    }\n\n    // Performance recommendations\n    if (result.performanceMetrics.mobileOptimization < 70) {\n      recommendations.push(`üì± Optimize translations for mobile display (current: ${result.performanceMetrics.mobileOptimization}%)`);\n    }\n\n    if (result.performanceMetrics.complexityRating === 'complex') {\n      recommendations.push(`‚úÇÔ∏è Simplify complex language for better user comprehension`);\n    }\n\n    return recommendations;\n  }\n\n  // Helper methods for calculations\n  private calculateCompleteness(translations: any, reference: any): number {\n    const refKeys = this.getAllKeys(reference);\n    const transKeys = this.getAllKeys(translations);\n    return Math.round((transKeys.length / refKeys.length) * 100);\n  }\n\n  private calculateConsistency(translations: any, language: SupportedLanguage): number {\n    // Simplified consistency calculation based on terminology usage\n    const termMap = this.terminologyMap.get(language) || new Map();\n    let consistencyScore = 100;\n\n    // Deduct points for each inconsistent term usage\n    termMap.forEach(variations => {\n      if (variations.length > 1) {\n        consistencyScore -= 5; // Deduct 5 points per inconsistent term\n      }\n    });\n\n    return Math.max(0, consistencyScore);\n  }\n\n  private calculateCulturalAdaptation(translations: any, language: SupportedLanguage): number {\n    const issues = this.detectCulturalIssues(translations, language);\n    let score = 100;\n\n    issues.forEach(issue => {\n      switch (issue.severity) {\n        case 'critical': score -= 20; break;\n        case 'high': score -= 10; break;\n        case 'medium': score -= 5; break;\n        case 'low': score -= 2; break;\n      }\n    });\n\n    return Math.max(0, score);\n  }\n\n  private calculateTechnicalAccuracy(translations: any, reference: any): number {\n    // Check for interpolation variable preservation\n    const score = 100;\n    let errors = 0;\n\n    this.traverseTranslations(reference, (key, refValue) => {\n      if (typeof refValue !== 'string') return;\n\n      const transValue = this.getValue(translations, key);\n      if (typeof transValue !== 'string') return;\n\n      // Check interpolation variables\n      const refVars = (refValue.match(/\\{\\{[^}]+\\}\\}/g) || []).sort();\n      const transVars = (transValue.match(/\\{\\{[^}]+\\}\\}/g) || []).sort();\n\n      if (JSON.stringify(refVars) !== JSON.stringify(transVars)) {\n        errors++;\n      }\n    });\n\n    return Math.max(0, score - (errors * 5));\n  }\n\n  private calculateReadability(translations: any, language: SupportedLanguage): number {\n    const texts: string[] = [];\n    this.traverseTranslations(translations, (key, value) => {\n      if (typeof value === 'string') texts.push(value);\n    });\n\n    return this.calculateReadabilityScore(texts, language);\n  }\n\n  private calculateReadabilityScore(texts: string[], language: SupportedLanguage): number {\n    // Simplified readability score based on sentence length and complexity\n    let totalScore = 0;\n\n    texts.forEach(text => {\n      const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);\n      const avgSentenceLength = text.split(/\\s+/).length / Math.max(sentences.length, 1);\n\n      // Score based on sentence length (shorter is better for mobile)\n      let score = 100;\n      if (avgSentenceLength > 20) score -= 20;\n      if (avgSentenceLength > 15) score -= 10;\n      if (avgSentenceLength > 10) score -= 5;\n\n      totalScore += Math.max(0, score);\n    });\n\n    return Math.round(totalScore / texts.length);\n  }\n\n  private determineComplexityRating(texts: string[]): 'simple' | 'moderate' | 'complex' {\n    let totalComplexity = 0;\n\n    texts.forEach(text => {\n      const words = text.split(/\\s+/);\n      const avgWordLength = words.reduce((sum, word) => sum + word.length, 0) / words.length;\n      const sentenceLength = text.split(/[.!?]+/).length;\n\n      let complexity = 0;\n      if (avgWordLength > 8) complexity += 2;\n      if (avgWordLength > 6) complexity += 1;\n      if (sentenceLength > 3) complexity += 1;\n\n      totalComplexity += complexity;\n    });\n\n    const avgComplexity = totalComplexity / texts.length;\n\n    if (avgComplexity < 1.5) return 'simple';\n    if (avgComplexity < 3) return 'moderate';\n    return 'complex';\n  }\n\n  private calculateReadingTime(texts: string[], language: SupportedLanguage): number {\n    const totalWords = texts.reduce((sum, text) =>\n      sum + text.split(/\\s+/).filter(word => word.length > 0).length, 0\n    );\n\n    // Reading speeds vary by language and script complexity\n    const wordsPerMinute = this.getReadingSpeedForLanguage(language);\n\n    return Math.round((totalWords / wordsPerMinute) * 60); // Convert to seconds\n  }\n\n  private calculateMobileOptimization(texts: string[]): number {\n    let score = 100;\n\n    texts.forEach(text => {\n      // Penalize very long strings (bad for mobile)\n      if (text.length > 100) score -= 5;\n      if (text.length > 150) score -= 10;\n      if (text.length > 200) score -= 15;\n\n      // Penalize strings without spaces (can't wrap)\n      if (text.length > 30 && !text.includes(' ')) score -= 10;\n    });\n\n    return Math.max(0, Math.round(score / texts.length));\n  }\n\n  private getReadingSpeedForLanguage(language: SupportedLanguage): number {\n    // Average reading speeds (words per minute) by language/script\n    const speeds: Record<string, number> = {\n      'en': 200, 'es': 180, 'fr': 190, 'de': 170, 'it': 175, 'pt': 185, 'ru': 160,\n      'ja': 120, 'zh': 130, 'zh-TW': 125, 'ko': 140,\n      'ar': 120, 'hi': 140, 'bn': 135, 'th': 130, 'vi': 150, 'id': 160\n    };\n\n    return speeds[language] || 150; // Default fallback\n  }\n\n  private buildTerminologyMaps(): void {\n    // This would be built from actual translation analysis\n    // For now, initialize empty maps\n    Object.keys(SUPPORTED_LANGUAGES).forEach(lang => {\n      this.terminologyMap.set(lang as SupportedLanguage, new Map());\n    });\n  }\n\n  private extractTermVariation(text: string, term: string): string {\n    const regex = new RegExp(`\\\\b([\\\\w]*${term}[\\\\w]*)\\\\b`, 'gi');\n    const match = text.match(regex);\n    return match ? match[0].toLowerCase() : term;\n  }\n\n  private traverseTranslations(\n    obj: any,\n    callback: (key: string, value: any, fullKey?: string) => void,\n    prefix = ''\n  ): void {\n    Object.keys(obj).forEach(key => {\n      const fullKey = prefix ? `${prefix}.${key}` : key;\n      const value = obj[key];\n\n      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n        this.traverseTranslations(value, callback, fullKey);\n      } else {\n        callback(fullKey, value, fullKey);\n      }\n    });\n  }\n\n  private getAllKeys(obj: any, prefix = ''): string[] {\n    const keys: string[] = [];\n\n    Object.keys(obj).forEach(key => {\n      const fullKey = prefix ? `${prefix}.${key}` : key;\n      const value = obj[key];\n\n      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n        keys.push(...this.getAllKeys(value, fullKey));\n      } else {\n        keys.push(fullKey);\n      }\n    });\n\n    return keys;\n  }\n\n  private getValue(obj: any, path: string): any {\n    return path.split('.').reduce((current, key) => current && current[key], obj);\n  }\n\n  /**\n   * Export validation results for dashboard\n   */\n  public exportResults(): Record<SupportedLanguage, AdvancedValidationResult> {\n    const results: Record<string, AdvancedValidationResult> = {};\n\n    this.validationCache.forEach((result, language) => {\n      results[language] = result;\n    });\n\n    return results as Record<SupportedLanguage, AdvancedValidationResult>;\n  }\n\n  /**\n   * Get summary statistics across all languages\n   */\n  public getSummaryStats(): {\n    totalLanguages: number;\n    averageQualityScore: number;\n    totalCulturalIssues: number;\n    totalConsistencyIssues: number;\n    languagesNeedingAttention: SupportedLanguage[];\n  } {\n    const results = Array.from(this.validationCache.values());\n\n    const totalLanguages = results.length;\n    const averageQualityScore = results.reduce((sum, r) => sum + r.qualityScore.overall, 0) / totalLanguages;\n    const totalCulturalIssues = results.reduce((sum, r) => sum + r.culturalIssues.length, 0);\n    const totalConsistencyIssues = results.reduce((sum, r) => sum + r.consistencyIssues.length, 0);\n    const languagesNeedingAttention = results\n      .filter(r => r.qualityScore.overall < 80 || r.culturalIssues.some(i => i.severity === 'critical'))\n      .map(r => r.language);\n\n    return {\n      totalLanguages,\n      averageQualityScore: Math.round(averageQualityScore),\n      totalCulturalIssues,\n      totalConsistencyIssues,\n      languagesNeedingAttention\n    };\n  }\n}\n\nexport default AdvancedTranslationValidator;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/utils/keyboard-navigation.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'ScrollBehavior' is not defined.",
        "line": 665,
        "column": 70,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 665,
        "endColumn": 84
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference lib=\"dom\" />\n// Enhanced Keyboard Navigation for Smart Alarm App\n// Provides comprehensive keyboard shortcuts and navigation patterns\n// Integrated with accessibility preferences system\n\nimport ScreenReaderService from './screen-reader';\nimport AccessibilityPreferencesService, { AccessibilityPreferences } from '../services/accessibility-preferences';\n\nexport interface KeyboardShortcut {\n  key: string;\n  modifiers: ('ctrl' | 'alt' | 'shift' | 'meta')[];\n  action: () => void;\n  description: string;\n  category: 'navigation' | 'alarm' | 'accessibility' | 'general';\n  enabled: boolean;\n}\n\nexport interface NavigationState {\n  currentSection: string;\n  focusedElement?: HTMLElement;\n  focusHistory: HTMLElement[];\n  skipLinksEnabled: boolean;\n  rolandEnabled: boolean; // Roving focus enabled\n}\n\n/**\n * Advanced Keyboard Navigation Manager\n * Now integrated with accessibility preferences\n */\nexport class KeyboardNavigationService {\n  private static instance: KeyboardNavigationService;\n  private shortcuts: Map<string, KeyboardShortcut> = new Map();\n  private state: NavigationState;\n  private screenReader: ScreenReaderService;\n  private focusTrapStack: HTMLElement[] = [];\n  private skipLinks: HTMLElement[] = [];\n  private accessibilityService: AccessibilityPreferencesService;\n  private preferencesUnsubscribe?: () => void;\n\n  private constructor() {\n    this.state = {\n      currentSection: 'main',\n      focusHistory: [],\n      skipLinksEnabled: true,\n      rolandEnabled: true\n    };\n\n    this.screenReader = ScreenReaderService.getInstance();\n    this.accessibilityService = AccessibilityPreferencesService.getInstance();\n\n    this.initializeShortcuts();\n    this.setupAccessibilityIntegration();\n    this.createSkipLinks();\n    this.setupEventListeners();\n  }\n\n  static getInstance(): KeyboardNavigationService {\n    if (!KeyboardNavigationService.instance) {\n      KeyboardNavigationService.instance = new KeyboardNavigationService();\n    }\n    return KeyboardNavigationService.instance;\n  }\n\n  /**\n   * Initialize the keyboard navigation service (called from App.tsx)\n   */\n  public initialize(): void {\n    // Service is already initialized in constructor\n    // This method provides the expected interface for App.tsx\n    console.log('KeyboardNavigationService initialized');\n  }\n\n  /**\n   * Get the current enabled state\n   */\n  public get isEnabled(): boolean {\n    return true; // Always enabled for keyboard navigation\n  }\n\n  /**\n   * Initialize default keyboard shortcuts\n   */\n  private initializeShortcuts(): void {\n    const shortcuts: Omit<KeyboardShortcut, 'enabled'>[] = [\n      // Navigation shortcuts\n      {\n        key: 'd',\n        modifiers: ['alt'],\n        action: () => this.navigateToSection('dashboard'),\n        description: 'Go to Dashboard',\n        category: 'navigation'\n      },\n      {\n        key: 'a',\n        modifiers: ['alt'],\n        action: () => this.navigateToSection('alarms'),\n        description: 'Go to Alarms',\n        category: 'navigation'\n      },\n      {\n        key: 's',\n        modifiers: ['alt'],\n        action: () => this.navigateToSection('settings'),\n        description: 'Go to Settings',\n        category: 'navigation'\n      },\n      {\n        key: 'p',\n        modifiers: ['alt'],\n        action: () => this.navigateToSection('performance'),\n        description: 'Go to Performance',\n        category: 'navigation'\n      },\n\n      // Alarm management shortcuts\n      {\n        key: 'n',\n        modifiers: ['ctrl'],\n        action: () => this.createNewAlarm(),\n        description: 'Create New Alarm',\n        category: 'alarm'\n      },\n      {\n        key: ' ',\n        modifiers: [],\n        action: () => this.toggleSelectedAlarm(),\n        description: 'Toggle Selected Alarm',\n        category: 'alarm'\n      },\n      {\n        key: 'Delete',\n        modifiers: [],\n        action: () => this.deleteSelectedAlarm(),\n        description: 'Delete Selected Alarm',\n        category: 'alarm'\n      },\n      {\n        key: 'Enter',\n        modifiers: [],\n        action: () => this.editSelectedAlarm(),\n        description: 'Edit Selected Alarm',\n        category: 'alarm'\n      },\n\n      // Accessibility shortcuts\n      {\n        key: 'h',\n        modifiers: ['alt'],\n        action: () => this.showKeyboardShortcuts(),\n        description: 'Show Keyboard Shortcuts',\n        category: 'accessibility'\n      },\n      {\n        key: 'r',\n        modifiers: ['alt'],\n        action: () => this.toggleScreenReaderMode(),\n        description: 'Toggle Screen Reader Enhanced Mode',\n        category: 'accessibility'\n      },\n      {\n        key: 'f',\n        modifiers: ['alt'],\n        action: () => this.focusFirstElement(),\n        description: 'Focus First Interactive Element',\n        category: 'accessibility'\n      },\n      {\n        key: 'l',\n        modifiers: ['alt'],\n        action: () => this.focusLastElement(),\n        description: 'Focus Last Interactive Element',\n        category: 'accessibility'\n      },\n\n      // General shortcuts\n      {\n        key: 'Escape',\n        modifiers: [],\n        action: () => this.handleEscape(),\n        description: 'Close Dialog/Go Back',\n        category: 'general'\n      },\n      {\n        key: 'F1',\n        modifiers: [],\n        action: () => this.showHelp(),\n        description: 'Show Help',\n        category: 'general'\n      }\n    ];\n\n    shortcuts.forEach((shortcut, index) => {\n      this.addShortcut(`shortcut-${index}`, {\n        ...shortcut,\n        enabled: true\n      });\n    });\n  }\n\n  /**\n   * Add a new keyboard shortcut\n   */\n  addShortcut(id: string, shortcut: KeyboardShortcut): void {\n    const key = this.createShortcutKey(shortcut.key, shortcut.modifiers);\n    this.shortcuts.set(key, { ...shortcut });\n  }\n\n  /**\n   * Remove a keyboard shortcut\n   */\n  removeShortcut(key: string, modifiers: string[]): void {\n    const shortcutKey = this.createShortcutKey(key, modifiers);\n    this.shortcuts.delete(shortcutKey);\n  }\n\n  /**\n   * Create shortcut key string\n   */\n  private createShortcutKey(key: string, modifiers: string[]): string {\n    const sortedModifiers = [...modifiers].sort();\n    return `${sortedModifiers.join('+')}-${key.toLowerCase()}`;\n  }\n\n  /**\n   * Setup global keyboard event listeners\n   */\n  private setupEventListeners(): void {\n    document.addEventListener('keydown', this.handleKeyDown.bind(this));\n    document.addEventListener('focusin', this.handleFocusIn.bind(this));\n    document.addEventListener('focusout', this.handleFocusOut.bind(this));\n\n    // Handle roving focus for arrow keys\n    document.addEventListener('keydown', this.handleRovingFocus.bind(this));\n  }\n\n  /**\n   * Setup accessibility preferences integration\n   */\n  private setupAccessibilityIntegration(): void {\n    // Subscribe to accessibility preference changes\n    this.preferencesUnsubscribe = this.accessibilityService.subscribe((preferences) => {\n      this.updateFromPreferences(preferences);\n    });\n\n    // Apply initial preferences\n    this.updateFromPreferences(this.accessibilityService.getPreferences());\n  }\n\n  /**\n   * Update keyboard navigation based on accessibility preferences\n   */\n  private updateFromPreferences(preferences: AccessibilityPreferences): void {\n    // Update keyboard navigation state\n    this.state.skipLinksEnabled = preferences.skipLinksVisible;\n    this.state.rolandEnabled = preferences.keyboardNavigation;\n\n    // Enable/disable all shortcuts based on keyboard navigation preference\n    this.shortcuts.forEach(shortcut => {\n      if (shortcut.category !== 'general') {\n        shortcut.enabled = preferences.keyboardNavigation;\n      }\n    });\n\n    // Update skip links visibility\n    this.updateSkipLinksVisibility(preferences.skipLinksVisible);\n\n    // Update focus ring styles\n    this.updateFocusRingStyles(preferences);\n  }\n\n  /**\n   * Update skip links visibility\n   */\n  private updateSkipLinksVisibility(visible: boolean): void {\n    const skipContainer = document.getElementById('skip-links');\n    if (skipContainer) {\n      if (visible) {\n        skipContainer.style.display = 'block';\n        // Make skip links always visible\n        this.skipLinks.forEach(link => {\n          link.classList.remove('-top-96');\n          link.classList.add('top-2');\n        });\n      } else {\n        // Hide skip links until focused\n        this.skipLinks.forEach(link => {\n          link.classList.add('-top-96');\n          link.classList.remove('top-2');\n          link.classList.add('focus:top-2');\n        });\n      }\n    }\n  }\n\n  /**\n   * Update focus ring styles based on preferences\n   */\n  private updateFocusRingStyles(preferences: AccessibilityPreferences): void {\n    // Update CSS custom properties for focus styling\n    document.documentElement.style.setProperty(\n      '--a11y-focus-ring-color',\n      preferences.focusRingColor\n    );\n\n    // Update enhanced focus ring state\n    document.body.classList.toggle(\n      'a11y-enhanced-focus',\n      preferences.enhancedFocusRings\n    );\n  }\n\n  /**\n   * Handle global keydown events\n   */\n  private handleKeyDown(event: KeyboardEvent): void {\n    // Check if keyboard navigation is enabled\n    const preferences = this.accessibilityService.getPreferences();\n    if (!preferences.keyboardNavigation && !this.isGlobalShortcut(event)) {\n      return;\n    }\n\n    // Skip if typing in input fields (unless it's a global shortcut)\n    if (this.isTypingInInput(event.target as HTMLElement) &&\n        !this.isGlobalShortcut(event)) {\n      return;\n    }\n\n    const modifiers: string[] = [];\n    if (event.ctrlKey) modifiers.push('ctrl');\n    if (event.altKey) modifiers.push('alt');\n    if (event.shiftKey) modifiers.push('shift');\n    if (event.metaKey) modifiers.push('meta');\n\n    const shortcutKey = this.createShortcutKey(event.key, modifiers);\n    const shortcut = this.shortcuts.get(shortcutKey);\n\n    if (shortcut && shortcut.enabled) {\n      event.preventDefault();\n      shortcut.action();\n\n      // Announce only if screen reader optimization is enabled\n      if (preferences.screenReaderOptimized && preferences.announceSuccess) {\n        this.screenReader.announce(`Executed: ${shortcut.description}`);\n      }\n    }\n  }\n\n  /**\n   * Handle focus in events\n   */\n  private handleFocusIn(event: FocusEvent): void {\n    const element = event.target as HTMLElement;\n    if (element && this.isFocusableElement(element)) {\n      this.state.focusedElement = element;\n      this.state.focusHistory.push(element);\n\n      // Limit focus history to last 10 elements\n      if (this.state.focusHistory.length > 10) {\n        this.state.focusHistory.shift();\n      }\n\n      // Announce focus change for screen readers\n      this.announceFocusChange(element);\n    }\n  }\n\n  /**\n   * Handle focus out events\n   */\n  private handleFocusOut(event: FocusEvent): void {\n    // Implementation for focus out handling\n  }\n\n  /**\n   * Handle roving focus with arrow keys\n   */\n  private handleRovingFocus(event: KeyboardEvent): void {\n    const preferences = this.accessibilityService.getPreferences();\n\n    // Check if keyboard navigation and roving focus are enabled\n    if (!preferences.keyboardNavigation || !this.state.rolandEnabled) return;\n\n    const currentElement = document.activeElement as HTMLElement;\n    if (!currentElement) return;\n\n    const container = this.findRovingContainer(currentElement);\n    if (!container) return;\n\n    const focusableElements = this.getFocusableElements(container);\n    const currentIndex = focusableElements.indexOf(currentElement);\n\n    if (currentIndex === -1) return;\n\n    let nextIndex = currentIndex;\n\n    switch (event.key) {\n      case 'ArrowRight':\n      case 'ArrowDown':\n        event.preventDefault();\n        nextIndex = (currentIndex + 1) % focusableElements.length;\n        break;\n      case 'ArrowLeft':\n      case 'ArrowUp':\n        event.preventDefault();\n        nextIndex = (currentIndex - 1 + focusableElements.length) % focusableElements.length;\n        break;\n      case 'Home':\n        event.preventDefault();\n        nextIndex = 0;\n        break;\n      case 'End':\n        event.preventDefault();\n        nextIndex = focusableElements.length - 1;\n        break;\n      default:\n        return;\n    }\n\n    if (nextIndex !== currentIndex) {\n      focusableElements[nextIndex].focus();\n\n      // Announce focus change if screen reader is optimized\n      if (preferences.screenReaderOptimized && preferences.announceTransitions) {\n        const element = focusableElements[nextIndex];\n        const label = this.getElementLabel(element);\n        this.screenReader.announce(`Focused: ${label}`);\n      }\n    }\n  }\n\n  /**\n   * Find the roving focus container for an element\n   */\n  private findRovingContainer(element: HTMLElement): HTMLElement | null {\n    // Look for container with data-roving-focus attribute\n    let current = element.parentElement;\n    while (current) {\n      if (current.hasAttribute('data-roving-focus') ||\n          current.getAttribute('role') === 'toolbar' ||\n          current.getAttribute('role') === 'menubar' ||\n          current.getAttribute('role') === 'tablist') {\n        return current;\n      }\n      current = current.parentElement;\n    }\n    return null;\n  }\n\n  /**\n   * Get focusable elements within a container\n   */\n  private getFocusableElements(container: HTMLElement): HTMLElement[] {\n    const selector = `\n      button:not([disabled]),\n      [href]:not([disabled]),\n      input:not([disabled]),\n      select:not([disabled]),\n      textarea:not([disabled]),\n      [tabindex]:not([tabindex=\"-1\"]):not([disabled]),\n      [role=\"button\"]:not([disabled]),\n      [role=\"tab\"]:not([disabled])\n    `;\n\n    return Array.from(container.querySelectorAll(selector))\n      .filter(el => this.isVisible(el as HTMLElement)) as HTMLElement[];\n  }\n\n  /**\n   * Check if element is visible\n   */\n  private isVisible(element: HTMLElement): boolean {\n    const rect = element.getBoundingClientRect();\n    return rect.width > 0 && rect.height > 0;\n  }\n\n  /**\n   * Check if currently typing in an input field\n   */\n  private isTypingInInput(element: HTMLElement): boolean {\n    if (!element) return false;\n\n    const tagName = element.tagName.toLowerCase();\n    const type = (element as HTMLInputElement).type?.toLowerCase();\n\n    return (\n      tagName === 'input' &&\n      !['checkbox', 'radio', 'button', 'submit', 'reset'].includes(type || '')\n    ) ||\n    tagName === 'textarea' ||\n    element.contentEditable === 'true';\n  }\n\n  /**\n   * Check if shortcut should work globally (even in input fields)\n   */\n  private isGlobalShortcut(event: KeyboardEvent): boolean {\n    const globalKeys = ['F1', 'Escape'];\n    const globalWithModifiers = ['alt+h', 'alt+r', 'alt+d', 'alt+a', 'alt+s', 'alt+p'];\n\n    if (globalKeys.includes(event.key)) return true;\n\n    const modifiers: string[] = [];\n    if (event.ctrlKey) modifiers.push('ctrl');\n    if (event.altKey) modifiers.push('alt');\n    if (event.shiftKey) modifiers.push('shift');\n    if (event.metaKey) modifiers.push('meta');\n\n    const shortcutString = `${modifiers.join('+')}${modifiers.length ? '+' : ''}${event.key.toLowerCase()}`;\n    return globalWithModifiers.includes(shortcutString);\n  }\n\n  /**\n   * Check if element is focusable\n   */\n  private isFocusableElement(element: HTMLElement): boolean {\n    const focusableElements = [\n      'button', 'input', 'select', 'textarea', 'a'\n    ];\n\n    if (focusableElements.includes(element.tagName.toLowerCase())) {\n      return true;\n    }\n\n    return element.tabIndex >= 0 ||\n           element.getAttribute('role') === 'button' ||\n           element.getAttribute('role') === 'tab';\n  }\n\n  /**\n   * Announce focus change to screen reader\n   */\n  private announceFocusChange(element: HTMLElement): void {\n    const preferences = this.accessibilityService.getPreferences();\n\n    // Only announce if screen reader optimization is enabled\n    if (!preferences.screenReaderOptimized || !preferences.announceTransitions) {\n      return;\n    }\n\n    const elementType = this.getElementType(element);\n    const label = this.getElementLabel(element);\n    const context = this.getElementContext(element);\n\n    this.screenReader.announceFocusChange(elementType, label, context);\n  }\n\n  /**\n   * Get element type for screen reader announcement\n   */\n  private getElementType(element: HTMLElement): string {\n    const role = element.getAttribute('role');\n    if (role) return role;\n\n    const tagName = element.tagName.toLowerCase();\n    const type = (element as HTMLInputElement).type?.toLowerCase();\n\n    if (tagName === 'input') {\n      return type || 'input';\n    }\n\n    return tagName;\n  }\n\n  /**\n   * Get element label for screen reader announcement\n   */\n  private getElementLabel(element: HTMLElement): string {\n    // Try aria-label first\n    const ariaLabel = element.getAttribute('aria-label');\n    if (ariaLabel) return ariaLabel;\n\n    // Try aria-labelledby\n    const labelledBy = element.getAttribute('aria-labelledby');\n    if (labelledBy) {\n      const labelElement = document.getElementById(labelledBy);\n      if (labelElement) return labelElement.textContent || '';\n    }\n\n    // Try associated label element\n    if (element.id) {\n      const label = document.querySelector(`label[for=\"${element.id}\"]`);\n      if (label) return label.textContent || '';\n    }\n\n    // Use text content or placeholder\n    return element.textContent ||\n           (element as HTMLInputElement).placeholder ||\n           element.getAttribute('title') ||\n           'Unlabeled element';\n  }\n\n  /**\n   * Get additional context for element\n   */\n  private getElementContext(element: HTMLElement): string | undefined {\n    const description = element.getAttribute('aria-describedby');\n    if (description) {\n      const descElement = document.getElementById(description);\n      if (descElement) return descElement.textContent || undefined;\n    }\n\n    // Additional context based on element state\n    const contexts: string[] = [];\n\n    if (element.getAttribute('aria-expanded')) {\n      const expanded = element.getAttribute('aria-expanded') === 'true';\n      contexts.push(expanded ? 'Expanded' : 'Collapsed');\n    }\n\n    if (element.getAttribute('aria-selected')) {\n      const selected = element.getAttribute('aria-selected') === 'true';\n      if (selected) contexts.push('Selected');\n    }\n\n    if (element.getAttribute('aria-checked')) {\n      const checked = element.getAttribute('aria-checked');\n      if (checked === 'true') contexts.push('Checked');\n      else if (checked === 'false') contexts.push('Unchecked');\n      else if (checked === 'mixed') contexts.push('Partially checked');\n    }\n\n    return contexts.length > 0 ? contexts.join(', ') : undefined;\n  }\n\n  /**\n   * Create skip navigation links\n   */\n  private createSkipLinks(): void {\n    const preferences = this.accessibilityService.getPreferences();\n    if (!preferences.keyboardNavigation) return;\n\n    const skipContainer = document.createElement('div');\n    skipContainer.id = 'skip-links';\n    skipContainer.className = 'skip-links fixed top-0 left-0 z-50';\n\n    const skipLinks = [\n      { text: 'Skip to main content', target: '#main-content' },\n      { text: 'Skip to navigation', target: '#main-navigation' },\n      { text: 'Skip to alarm list', target: '#alarm-list' },\n      { text: 'Skip to settings', target: '#settings-panel' }\n    ];\n\n    skipLinks.forEach(({ text, target }) => {\n      const link = document.createElement('a');\n      link.href = target;\n      link.textContent = text;\n\n      // Apply initial visibility based on preferences\n      const baseClasses = 'skip-link absolute left-2 px-3 py-2 rounded-md text-sm font-medium transition-all duration-200';\n      const focusRingColor = preferences.focusRingColor || '#007AFF';\n      const visibilityClasses = preferences.skipLinksVisible ? 'top-2 z-50' : '-top-96 focus:top-2 focus:z-50';\n\n      link.className = `${baseClasses} ${visibilityClasses}`;\n      link.style.backgroundColor = focusRingColor;\n      link.style.color = 'white';\n\n      link.addEventListener('click', (e) => {\n        e.preventDefault();\n        const targetElement = document.querySelector(target) as HTMLElement;\n        if (targetElement) {\n          targetElement.focus();\n\n          // Use reduced motion settings for scroll behavior\n          const scrollBehavior = preferences.reducedMotion ? 'auto' : 'smooth';\n          targetElement.scrollIntoView({ behavior: scrollBehavior as ScrollBehavior, block: 'start' });\n\n          // Announce skip action if enabled\n          if (preferences.screenReaderOptimized && preferences.announceTransitions) {\n            this.screenReader.announce(`Skipped to ${text.toLowerCase()}`);\n          }\n        }\n      });\n\n      skipContainer.appendChild(link);\n      this.skipLinks.push(link);\n    });\n\n    document.body.insertBefore(skipContainer, document.body.firstChild);\n  }\n\n  /**\n   * Navigation shortcut handlers\n   */\n  private navigateToSection(section: string): void {\n    // Dispatch custom navigation event\n    const event = new CustomEvent('keyboard-navigate', {\n      detail: { section, source: 'keyboard' }\n    });\n    document.dispatchEvent(event);\n\n    this.state.currentSection = section;\n\n    // Announce navigation if enabled\n    const preferences = this.accessibilityService.getPreferences();\n    if (preferences.screenReaderOptimized && preferences.announceTransitions) {\n      this.screenReader.announceNavigation(section, `Navigated via keyboard shortcut`);\n    }\n  }\n\n  private createNewAlarm(): void {\n    const event = new CustomEvent('alarm-action', {\n      detail: { action: 'create', source: 'keyboard' }\n    });\n    document.dispatchEvent(event);\n  }\n\n  private toggleSelectedAlarm(): void {\n    const selectedAlarm = document.querySelector('[data-selected=\"true\"]') as HTMLElement;\n    if (selectedAlarm) {\n      const event = new CustomEvent('alarm-action', {\n        detail: { action: 'toggle', target: selectedAlarm, source: 'keyboard' }\n      });\n      document.dispatchEvent(event);\n    }\n  }\n\n  private deleteSelectedAlarm(): void {\n    const selectedAlarm = document.querySelector('[data-selected=\"true\"]') as HTMLElement;\n    if (selectedAlarm) {\n      const event = new CustomEvent('alarm-action', {\n        detail: { action: 'delete', target: selectedAlarm, source: 'keyboard' }\n      });\n      document.dispatchEvent(event);\n    }\n  }\n\n  private editSelectedAlarm(): void {\n    const selectedAlarm = document.querySelector('[data-selected=\"true\"]') as HTMLElement;\n    if (selectedAlarm) {\n      const event = new CustomEvent('alarm-action', {\n        detail: { action: 'edit', target: selectedAlarm, source: 'keyboard' }\n      });\n      document.dispatchEvent(event);\n    }\n  }\n\n  private handleEscape(): void {\n    // Close any open modals or dialogs\n    const modals = document.querySelectorAll('[role=\"dialog\"][aria-hidden=\"false\"]');\n    if (modals.length > 0) {\n      const modal = modals[modals.length - 1] as HTMLElement;\n      const closeButton = modal.querySelector('[data-dismiss]') as HTMLElement;\n      if (closeButton) {\n        closeButton.click();\n      }\n      return;\n    }\n\n    // Return focus to previous element\n    if (this.state.focusHistory.length > 1) {\n      const previousElement = this.state.focusHistory[this.state.focusHistory.length - 2];\n      if (previousElement && document.contains(previousElement)) {\n        previousElement.focus();\n      }\n    }\n  }\n\n  private showKeyboardShortcuts(): void {\n    const preferences = this.accessibilityService.getPreferences();\n    const shortcuts = Array.from(this.shortcuts.values())\n      .filter(s => s.enabled)\n      .sort((a, b) => a.category.localeCompare(b.category));\n\n    // Announce shortcuts if screen reader is enabled\n    if (preferences.screenReaderOptimized) {\n      const shortcutText = shortcuts\n        .map(s => `${s.description}: ${s.modifiers.join('+')}${s.modifiers.length ? '+' : ''}${s.key}`)\n        .join(', ');\n\n      this.screenReader.announce(`Available keyboard shortcuts: ${shortcutText}`, 'polite');\n    }\n\n    // Also dispatch event to show visual shortcut help\n    const event = new CustomEvent('show-shortcuts', {\n      detail: { shortcuts }\n    });\n    document.dispatchEvent(event);\n  }\n\n  private toggleScreenReaderMode(): void {\n    const currentState = this.screenReader.getState();\n    this.screenReader.updateSettings({\n      isEnabled: !currentState.isEnabled\n    });\n  }\n\n  private focusFirstElement(): void {\n    const firstFocusable = this.getFocusableElements(document.body)[0];\n    if (firstFocusable) {\n      firstFocusable.focus();\n    }\n  }\n\n  private focusLastElement(): void {\n    const focusableElements = this.getFocusableElements(document.body);\n    const lastFocusable = focusableElements[focusableElements.length - 1];\n    if (lastFocusable) {\n      lastFocusable.focus();\n    }\n  }\n\n  private showHelp(): void {\n    const event = new CustomEvent('show-help');\n    document.dispatchEvent(event);\n    this.screenReader.announce('Help opened', 'polite');\n  }\n\n  /**\n   * Get current navigation state\n   */\n  getState(): NavigationState {\n    return { ...this.state };\n  }\n\n  /**\n   * Get all enabled shortcuts\n   */\n  getShortcuts(): KeyboardShortcut[] {\n    return Array.from(this.shortcuts.values())\n      .filter(shortcut => shortcut.enabled);\n  }\n\n  /**\n   * Enable or disable roving focus\n   */\n  setRovingFocus(enabled: boolean): void {\n    this.state.rolandEnabled = enabled;\n  }\n\n  /**\n   * Enable or disable skip links\n   */\n  setSkipLinks(enabled: boolean): void {\n    this.state.skipLinksEnabled = enabled;\n    if (enabled && this.skipLinks.length === 0) {\n      this.createSkipLinks();\n    } else if (!enabled) {\n      this.skipLinks.forEach(link => {\n        if (link.parentNode) {\n          link.parentNode.removeChild(link);\n        }\n      });\n      this.skipLinks = [];\n    }\n  }\n\n  /**\n   * Get accessibility preferences integration status\n   */\n  getAccessibilityStatus(): {\n    keyboardNavigationEnabled: boolean;\n    skipLinksVisible: boolean;\n    enhancedFocusRings: boolean;\n    focusRingColor: string;\n    screenReaderOptimized: boolean;\n  } {\n    const preferences = this.accessibilityService.getPreferences();\n    return {\n      keyboardNavigationEnabled: preferences.keyboardNavigation,\n      skipLinksVisible: preferences.skipLinksVisible,\n      enhancedFocusRings: preferences.enhancedFocusRings,\n      focusRingColor: preferences.focusRingColor,\n      screenReaderOptimized: preferences.screenReaderOptimized,\n    };\n  }\n\n  /**\n   * Force refresh of accessibility integration\n   */\n  refreshAccessibilityIntegration(): void {\n    const preferences = this.accessibilityService.getPreferences();\n    this.updateFromPreferences(preferences);\n  }\n\n  /**\n   * Cleanup method\n   */\n  cleanup(): void {\n    document.removeEventListener('keydown', this.handleKeyDown.bind(this));\n    document.removeEventListener('focusin', this.handleFocusIn.bind(this));\n    document.removeEventListener('focusout', this.handleFocusOut.bind(this));\n\n    // Unsubscribe from accessibility preferences\n    if (this.preferencesUnsubscribe) {\n      this.preferencesUnsubscribe();\n    }\n\n    // Remove skip links\n    const skipContainer = document.getElementById('skip-links');\n    if (skipContainer) {\n      skipContainer.remove();\n    }\n  }\n}\n\nexport default KeyboardNavigationService;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/utils/performance-alerts.tsx",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'Console' is not defined.",
        "line": 409,
        "column": 43,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 409,
        "endColumn": 50
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Enhanced Performance Monitoring with Real-Time Alerts\n * Provides intelligent alerting, performance degradation detection, and automated optimization\n */\n\nimport React from 'react';\n\nexport interface PerformanceAlert {\n  id: string;\n  type: 'warning' | 'error' | 'critical' | 'info';\n  metric: string;\n  value: number;\n  threshold: number;\n  message: string;\n  timestamp: number;\n  category: 'webvitals' | 'memory' | 'network' | 'error' | 'custom';\n  severity: 1 | 2 | 3 | 4 | 5; // 1 = low, 5 = critical\n  resolved?: boolean;\n  autoResolve?: boolean;\n  metadata?: Record<string, any>;\n}\n\nexport interface AlertRule {\n  id: string;\n  name: string;\n  metric: string;\n  condition: 'gt' | 'lt' | 'eq' | 'gte' | 'lte';\n  threshold: number;\n  enabled: boolean;\n  category: PerformanceAlert['category'];\n  severity: PerformanceAlert['severity'];\n  cooldownPeriod: number; // Minutes before same alert can fire again\n  autoResolve: boolean;\n  actions: AlertAction[];\n}\n\nexport interface AlertAction {\n  type: 'notification' | 'console' | 'storage' | 'callback' | 'optimization';\n  config: Record<string, any>;\n}\n\nexport interface PerformanceTrend {\n  metric: string;\n  values: number[];\n  timestamps: number[];\n  trend: 'improving' | 'degrading' | 'stable';\n  changePercent: number;\n}\n\nexport interface OptimizationSuggestion {\n  id: string;\n  category: string;\n  priority: 'low' | 'medium' | 'high' | 'critical';\n  title: string;\n  description: string;\n  impact: string;\n  implementation: string;\n  estimatedGain: string;\n}\n\nclass PerformanceAlertManager {\n  private alerts: Map<string, PerformanceAlert> = new Map();\n  private alertRules: Map<string, AlertRule> = new Map();\n  private alertCooldowns: Map<string, number> = new Map();\n  private metricHistory: Map<string, Array<{ value: number; timestamp: number }>> = new Map();\n  private observers: Array<(alert: PerformanceAlert) => void> = [];\n  private isMonitoring = false;\n  private monitoringInterval?: number;\n\n  constructor() {\n    this.initializeDefaultRules();\n    this.startMonitoring();\n    this.setupNotificationPermission();\n  }\n\n  /**\n   * Initialize default alert rules\n   */\n  private initializeDefaultRules() {\n    const defaultRules: AlertRule[] = [\n      {\n        id: 'lcp_threshold',\n        name: 'Largest Contentful Paint',\n        metric: 'LCP',\n        condition: 'gt',\n        threshold: 2500,\n        enabled: true,\n        category: 'webvitals',\n        severity: 3,\n        cooldownPeriod: 5,\n        autoResolve: true,\n        actions: [\n          { type: 'notification', config: { title: 'LCP Performance Issue', persistent: false } },\n          { type: 'console', config: { level: 'warn' } }\n        ]\n      },\n      {\n        id: 'fid_threshold',\n        name: 'First Input Delay',\n        metric: 'FID',\n        condition: 'gt',\n        threshold: 100,\n        enabled: true,\n        category: 'webvitals',\n        severity: 3,\n        cooldownPeriod: 3,\n        autoResolve: true,\n        actions: [\n          { type: 'notification', config: { title: 'Input Responsiveness Issue' } },\n          { type: 'console', config: { level: 'warn' } }\n        ]\n      },\n      {\n        id: 'cls_threshold',\n        name: 'Cumulative Layout Shift',\n        metric: 'CLS',\n        condition: 'gt',\n        threshold: 0.1,\n        enabled: true,\n        category: 'webvitals',\n        severity: 2,\n        cooldownPeriod: 5,\n        autoResolve: false,\n        actions: [\n          { type: 'notification', config: { title: 'Layout Stability Issue' } }\n        ]\n      },\n      {\n        id: 'memory_usage',\n        name: 'Memory Usage',\n        metric: 'memory_used',\n        condition: 'gt',\n        threshold: 50 * 1024 * 1024, // 50MB\n        enabled: true,\n        category: 'memory',\n        severity: 4,\n        cooldownPeriod: 10,\n        autoResolve: true,\n        actions: [\n          { type: 'notification', config: { title: 'High Memory Usage' } },\n          { type: 'optimization', config: { type: 'memory_cleanup' } }\n        ]\n      },\n      {\n        id: 'network_error_rate',\n        name: 'Network Error Rate',\n        metric: 'network_error_rate',\n        condition: 'gt',\n        threshold: 0.1, // 10% error rate\n        enabled: true,\n        category: 'network',\n        severity: 4,\n        cooldownPeriod: 5,\n        autoResolve: false,\n        actions: [\n          { type: 'notification', config: { title: 'Network Issues Detected' } }\n        ]\n      },\n      {\n        id: 'js_error_frequency',\n        name: 'JavaScript Error Frequency',\n        metric: 'js_error',\n        condition: 'gt',\n        threshold: 5, // More than 5 errors in monitoring period\n        enabled: true,\n        category: 'error',\n        severity: 5,\n        cooldownPeriod: 2,\n        autoResolve: false,\n        actions: [\n          { type: 'notification', config: { title: 'Critical Error Frequency' } },\n          { type: 'storage', config: { key: 'critical_errors' } }\n        ]\n      }\n    ];\n\n    defaultRules.forEach(rule => this.alertRules.set(rule.id, rule));\n  }\n\n  /**\n   * Setup notification permission\n   */\n  private async setupNotificationPermission() {\n    if ('Notification' in window && Notification.permission === 'default') {\n      try {\n        await Notification.requestPermission();\n      } catch (error) {\n        console.warn('[PerformanceAlerts] Could not request notification permission:', error);\n      }\n    }\n  }\n\n  /**\n   * Start monitoring performance metrics\n   */\n  private startMonitoring() {\n    if (this.isMonitoring) return;\n\n    this.isMonitoring = true;\n    this.monitoringInterval = window.setInterval(() => {\n      this.checkAllMetrics();\n      this.analyzePerformanceTrends();\n      this.cleanupResolvedAlerts();\n    }, 30000); // Check every 30 seconds\n  }\n\n  /**\n   * Stop monitoring\n   */\n  stopMonitoring() {\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = undefined;\n    }\n    this.isMonitoring = false;\n  }\n\n  /**\n   * Record performance metric and check for alerts\n   */\n  recordMetric(name: string, value: number, metadata?: Record<string, any>) {\n    // Store metric history\n    if (!this.metricHistory.has(name)) {\n      this.metricHistory.set(name, []);\n    }\n\n    const history = this.metricHistory.get(name)!;\n    history.push({ value, timestamp: Date.now() });\n\n    // Keep only last 100 data points\n    if (history.length > 100) {\n      history.shift();\n    }\n\n    // Check alert rules for this metric\n    this.checkMetricAlerts(name, value, metadata);\n  }\n\n  /**\n   * Check metric against alert rules\n   */\n  private checkMetricAlerts(metric: string, value: number, metadata?: Record<string, any>) {\n    this.alertRules.forEach(rule => {\n      if (rule.metric !== metric || !rule.enabled) return;\n\n      // Check cooldown period\n      const lastAlertTime = this.alertCooldowns.get(rule.id);\n      if (lastAlertTime && Date.now() - lastAlertTime < rule.cooldownPeriod * 60 * 1000) {\n        return;\n      }\n\n      // Evaluate condition\n      const shouldAlert = this.evaluateCondition(value, rule.condition, rule.threshold);\n\n      if (shouldAlert) {\n        this.createAlert(rule, value, metadata);\n      }\n    });\n  }\n\n  /**\n   * Evaluate alert condition\n   */\n  private evaluateCondition(value: number, condition: AlertRule['condition'], threshold: number): boolean {\n    switch (condition) {\n      case 'gt': return value > threshold;\n      case 'gte': return value >= threshold;\n      case 'lt': return value < threshold;\n      case 'lte': return value <= threshold;\n      case 'eq': return value === threshold;\n      default: return false;\n    }\n  }\n\n  /**\n   * Create and process alert\n   */\n  private createAlert(rule: AlertRule, value: number, metadata?: Record<string, any>) {\n    const alertId = `${rule.id}-${Date.now()}`;\n\n    const alert: PerformanceAlert = {\n      id: alertId,\n      type: this.getAlertType(rule.severity),\n      metric: rule.metric,\n      value,\n      threshold: rule.threshold,\n      message: this.generateAlertMessage(rule, value),\n      timestamp: Date.now(),\n      category: rule.category,\n      severity: rule.severity,\n      resolved: false,\n      autoResolve: rule.autoResolve,\n      metadata\n    };\n\n    this.alerts.set(alertId, alert);\n    this.alertCooldowns.set(rule.id, Date.now());\n\n    // Execute alert actions\n    this.executeAlertActions(rule, alert);\n\n    // Notify observers\n    this.notifyObservers(alert);\n\n    console.warn(`[PerformanceAlert] ${alert.message}`, { alert, metadata });\n  }\n\n  /**\n   * Get alert type from severity\n   */\n  private getAlertType(severity: number): PerformanceAlert['type'] {\n    switch (severity) {\n      case 1: return 'info';\n      case 2: return 'info';\n      case 3: return 'warning';\n      case 4: return 'error';\n      case 5: return 'critical';\n      default: return 'warning';\n    }\n  }\n\n  /**\n   * Generate alert message\n   */\n  private generateAlertMessage(rule: AlertRule, value: number): string {\n    const formatted = this.formatValue(rule.metric, value);\n    const thresholdFormatted = this.formatValue(rule.metric, rule.threshold);\n\n    return `${rule.name} exceeded threshold: ${formatted} > ${thresholdFormatted}`;\n  }\n\n  /**\n   * Format value based on metric type\n   */\n  private formatValue(metric: string, value: number): string {\n    if (metric.includes('time') || metric.includes('delay') || metric === 'LCP' || metric === 'FID') {\n      return `${Math.round(value)}ms`;\n    }\n\n    if (metric.includes('memory')) {\n      return `${Math.round(value / 1024 / 1024)}MB`;\n    }\n\n    if (metric.includes('rate') || metric === 'CLS') {\n      return (value * 100).toFixed(1) + '%';\n    }\n\n    return value.toString();\n  }\n\n  /**\n   * Execute alert actions\n   */\n  private executeAlertActions(rule: AlertRule, alert: PerformanceAlert) {\n    rule.actions.forEach(action => {\n      try {\n        switch (action.type) {\n          case 'notification':\n            this.showNotification(alert, action.config);\n            break;\n          case 'console':\n            this.logToConsole(alert, action.config);\n            break;\n          case 'storage':\n            this.storeAlert(alert, action.config);\n            break;\n          case 'optimization':\n            this.triggerOptimization(alert, action.config);\n            break;\n        }\n      } catch (error) {\n        console.error(`[PerformanceAlert] Action ${action.type} failed:`, error);\n      }\n    });\n  }\n\n  /**\n   * Show browser notification\n   */\n  private showNotification(alert: PerformanceAlert, config: Record<string, any>) {\n    if ('Notification' in window && Notification.permission === 'granted') {\n      const notification = new Notification(config.title || 'Performance Alert', {\n        body: alert.message,\n        icon: '/icon-192x192.png',\n        badge: '/icon-72x72.png',\n        tag: `perf-alert-${alert.category}`,\n        requireInteraction: config.persistent || alert.severity >= 4,\n        data: { alertId: alert.id }\n      });\n\n      // Auto-close after 10 seconds unless persistent\n      if (!config.persistent && alert.severity < 4) {\n        setTimeout(() => notification.close(), 10000);\n      }\n\n      notification.onclick = () => {\n        window.focus();\n        this.resolveAlert(alert.id);\n        notification.close();\n      };\n    }\n  }\n\n  /**\n   * Log alert to console\n   */\n  private logToConsole(alert: PerformanceAlert, config: Record<string, any>) {\n    const level = config.level || 'warn';\n    const method = console[level as keyof Console] as Function;\n\n    if (typeof method === 'function') {\n      method(`[PerformanceAlert] ${alert.message}`, alert);\n    }\n  }\n\n  /**\n   * Store alert for persistence\n   */\n  private storeAlert(alert: PerformanceAlert, config: Record<string, any>) {\n    try {\n      const key = config.key || 'performance-alerts';\n      const stored = JSON.parse(localStorage.getItem(key) || '[]');\n      stored.push(alert);\n\n      // Keep only last 50 alerts\n      const recent = stored.slice(-50);\n      localStorage.setItem(key, JSON.stringify(recent));\n    } catch (error) {\n      console.error('[PerformanceAlert] Failed to store alert:', error);\n    }\n  }\n\n  /**\n   * Trigger optimization based on alert\n   */\n  private triggerOptimization(alert: PerformanceAlert, config: Record<string, any>) {\n    switch (config.type) {\n      case 'memory_cleanup':\n        this.triggerMemoryCleanup();\n        break;\n      case 'cache_clear':\n        this.clearPerformanceCache();\n        break;\n      case 'gc_force':\n        this.forceGarbageCollection();\n        break;\n    }\n  }\n\n  /**\n   * Trigger memory cleanup\n   */\n  private triggerMemoryCleanup() {\n    // Trigger memory pressure event\n    window.dispatchEvent(new CustomEvent('memory-pressure', {\n      detail: { source: 'performance-alert', timestamp: Date.now() }\n    }));\n  }\n\n  /**\n   * Clear performance caches\n   */\n  private clearPerformanceCache() {\n    if ('caches' in window) {\n      caches.keys().then(cacheNames => {\n        cacheNames.forEach(cacheName => {\n          if (cacheName.includes('perf') || cacheName.includes('temp')) {\n            caches.delete(cacheName);\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * Force garbage collection\n   */\n  private forceGarbageCollection() {\n    if (typeof window !== 'undefined' && 'gc' in window) {\n      (window as any).gc();\n    }\n  }\n\n  /**\n   * Check all metrics against thresholds\n   */\n  private checkAllMetrics() {\n    // Get current performance data\n    if (typeof performance !== 'undefined' && 'memory' in performance) {\n      const memory = (performance as any).memory;\n      this.recordMetric('memory_used', memory.usedJSHeapSize);\n    }\n\n    // Check network error rate\n    const networkErrors = this.getRecentMetricCount('network_error', 5 * 60 * 1000); // 5 minutes\n    const networkRequests = this.getRecentMetricCount('network_request', 5 * 60 * 1000);\n    if (networkRequests > 0) {\n      this.recordMetric('network_error_rate', networkErrors / networkRequests);\n    }\n\n    // Check JavaScript error frequency\n    const jsErrors = this.getRecentMetricCount('js_error', 5 * 60 * 1000);\n    this.recordMetric('js_error_frequency', jsErrors);\n  }\n\n  /**\n   * Get recent metric count\n   */\n  private getRecentMetricCount(metric: string, timeWindow: number): number {\n    const history = this.metricHistory.get(metric);\n    if (!history) return 0;\n\n    const cutoff = Date.now() - timeWindow;\n    return history.filter(entry => entry.timestamp > cutoff).length;\n  }\n\n  /**\n   * Analyze performance trends\n   */\n  private analyzePerformanceTrends() {\n    this.metricHistory.forEach((history, metric) => {\n      const trend = this.calculateTrend(history);\n\n      if (trend.trend === 'degrading' && Math.abs(trend.changePercent) > 20) {\n        this.createTrendAlert(metric, trend);\n      }\n    });\n  }\n\n  /**\n   * Calculate performance trend\n   */\n  private calculateTrend(history: Array<{ value: number; timestamp: number }>): PerformanceTrend {\n    if (history.length < 10) {\n      return {\n        metric: '',\n        values: [],\n        timestamps: [],\n        trend: 'stable',\n        changePercent: 0\n      };\n    }\n\n    const values = history.map(h => h.value);\n    const timestamps = history.map(h => h.timestamp);\n\n    // Simple linear regression to detect trend\n    const n = values.length;\n    const sumX = timestamps.reduce((a, b) => a + b, 0);\n    const sumY = values.reduce((a, b) => a + b, 0);\n    const sumXY = timestamps.reduce((sum, x, i) => sum + x * values[i], 0);\n    const sumXX = timestamps.reduce((sum, x) => sum + x * x, 0);\n\n    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\n\n    // Calculate percent change\n    const first = values.slice(0, Math.floor(n / 3)).reduce((a, b) => a + b) / Math.floor(n / 3);\n    const last = values.slice(-Math.floor(n / 3)).reduce((a, b) => a + b) / Math.floor(n / 3);\n    const changePercent = ((last - first) / first) * 100;\n\n    let trend: PerformanceTrend['trend'];\n    if (Math.abs(changePercent) < 5) {\n      trend = 'stable';\n    } else if (changePercent > 0) {\n      trend = 'degrading';\n    } else {\n      trend = 'improving';\n    }\n\n    return {\n      metric: '',\n      values,\n      timestamps,\n      trend,\n      changePercent\n    };\n  }\n\n  /**\n   * Create trend alert\n   */\n  private createTrendAlert(metric: string, trend: PerformanceTrend) {\n    const alert: PerformanceAlert = {\n      id: `trend-${metric}-${Date.now()}`,\n      type: 'warning',\n      metric,\n      value: trend.changePercent,\n      threshold: 20,\n      message: `Performance degrading: ${metric} has degraded by ${Math.abs(trend.changePercent).toFixed(1)}%`,\n      timestamp: Date.now(),\n      category: 'custom',\n      severity: 3,\n      resolved: false,\n      autoResolve: true,\n      metadata: { trend }\n    };\n\n    this.alerts.set(alert.id, alert);\n    this.notifyObservers(alert);\n  }\n\n  /**\n   * Resolve alert\n   */\n  resolveAlert(alertId: string) {\n    const alert = this.alerts.get(alertId);\n    if (alert && !alert.resolved) {\n      alert.resolved = true;\n      alert.resolvedAt = Date.now();\n      this.notifyObservers(alert);\n    }\n  }\n\n  /**\n   * Clean up resolved alerts\n   */\n  private cleanupResolvedAlerts() {\n    const cutoff = Date.now() - (24 * 60 * 60 * 1000); // 24 hours\n\n    for (const [id, alert] of this.alerts) {\n      if (alert.resolved && alert.timestamp < cutoff) {\n        this.alerts.delete(id);\n      }\n    }\n  }\n\n  /**\n   * Get active alerts\n   */\n  getActiveAlerts(): PerformanceAlert[] {\n    return Array.from(this.alerts.values()).filter(alert => !alert.resolved);\n  }\n\n  /**\n   * Get all alerts\n   */\n  getAllAlerts(): PerformanceAlert[] {\n    return Array.from(this.alerts.values());\n  }\n\n  /**\n   * Get optimization suggestions\n   */\n  getOptimizationSuggestions(): OptimizationSuggestion[] {\n    const suggestions: OptimizationSuggestion[] = [];\n    const activeAlerts = this.getActiveAlerts();\n\n    activeAlerts.forEach(alert => {\n      switch (alert.category) {\n        case 'webvitals':\n          suggestions.push(...this.getWebVitalsOptimizations(alert));\n          break;\n        case 'memory':\n          suggestions.push(...this.getMemoryOptimizations(alert));\n          break;\n        case 'network':\n          suggestions.push(...this.getNetworkOptimizations(alert));\n          break;\n        case 'error':\n          suggestions.push(...this.getErrorOptimizations(alert));\n          break;\n      }\n    });\n\n    // Remove duplicates and sort by priority\n    const unique = suggestions.filter((suggestion, index, arr) =>\n      arr.findIndex(s => s.id === suggestion.id) === index\n    );\n\n    return unique.sort((a, b) => {\n      const priorityOrder = { critical: 4, high: 3, medium: 2, low: 1 };\n      return priorityOrder[b.priority] - priorityOrder[a.priority];\n    });\n  }\n\n  /**\n   * Get Web Vitals optimizations\n   */\n  private getWebVitalsOptimizations(alert: PerformanceAlert): OptimizationSuggestion[] {\n    const suggestions: OptimizationSuggestion[] = [];\n\n    if (alert.metric === 'LCP') {\n      suggestions.push({\n        id: 'optimize-lcp',\n        category: 'Web Vitals',\n        priority: 'high',\n        title: 'Optimize Largest Contentful Paint',\n        description: 'Your largest contentful paint is too slow, affecting user experience',\n        impact: 'Improves perceived loading performance',\n        implementation: 'Optimize images, use CDN, implement preloading for critical resources',\n        estimatedGain: '30-50% improvement in LCP'\n      });\n    }\n\n    if (alert.metric === 'FID') {\n      suggestions.push({\n        id: 'reduce-fid',\n        category: 'Web Vitals',\n        priority: 'high',\n        title: 'Reduce First Input Delay',\n        description: 'Users are experiencing delays when interacting with your app',\n        impact: 'Improves interactivity and user satisfaction',\n        implementation: 'Use web workers, defer non-critical JavaScript, optimize event handlers',\n        estimatedGain: '60-80% improvement in responsiveness'\n      });\n    }\n\n    return suggestions;\n  }\n\n  /**\n   * Get memory optimizations\n   */\n  private getMemoryOptimizations(alert: PerformanceAlert): OptimizationSuggestion[] {\n    return [{\n      id: 'memory-cleanup',\n      category: 'Memory',\n      priority: 'medium',\n      title: 'Implement Memory Cleanup',\n      description: 'High memory usage detected, potential memory leaks',\n      impact: 'Prevents crashes and improves stability',\n      implementation: 'Review event listeners, clear caches, implement proper cleanup',\n      estimatedGain: '20-40% reduction in memory usage'\n    }];\n  }\n\n  /**\n   * Get network optimizations\n   */\n  private getNetworkOptimizations(alert: PerformanceAlert): OptimizationSuggestion[] {\n    return [{\n      id: 'network-optimization',\n      category: 'Network',\n      priority: 'medium',\n      title: 'Optimize Network Requests',\n      description: 'High network error rate affecting user experience',\n      impact: 'Improves reliability and reduces errors',\n      implementation: 'Implement retry logic, request batching, and caching',\n      estimatedGain: '50-70% reduction in network errors'\n    }];\n  }\n\n  /**\n   * Get error optimizations\n   */\n  private getErrorOptimizations(alert: PerformanceAlert): OptimizationSuggestion[] {\n    return [{\n      id: 'error-handling',\n      category: 'Error Handling',\n      priority: 'critical',\n      title: 'Improve Error Handling',\n      description: 'High frequency of JavaScript errors detected',\n      impact: 'Prevents crashes and improves user experience',\n      implementation: 'Add error boundaries, improve validation, fix critical bugs',\n      estimatedGain: '80-90% reduction in error frequency'\n    }];\n  }\n\n  /**\n   * Add alert observer\n   */\n  addObserver(observer: (alert: PerformanceAlert) => void) {\n    this.observers.push(observer);\n  }\n\n  /**\n   * Remove alert observer\n   */\n  removeObserver(observer: (alert: PerformanceAlert) => void) {\n    const index = this.observers.indexOf(observer);\n    if (index >= 0) {\n      this.observers.splice(index, 1);\n    }\n  }\n\n  /**\n   * Notify observers\n   */\n  private notifyObservers(alert: PerformanceAlert) {\n    this.observers.forEach(observer => observer(alert));\n  }\n\n  /**\n   * Cleanup\n   */\n  cleanup() {\n    this.stopMonitoring();\n    this.alerts.clear();\n    this.alertCooldowns.clear();\n    this.metricHistory.clear();\n    this.observers.length = 0;\n  }\n}\n\n// Create singleton instance\nexport const performanceAlertManager = new PerformanceAlertManager();\n\n/**\n * React hook for performance alerts\n */\nexport function usePerformanceAlerts() {\n  const [alerts, setAlerts] = React.useState<PerformanceAlert[]>([]);\n  const [suggestions, setSuggestions] = React.useState<OptimizationSuggestion[]>([]);\n\n  React.useEffect(() => {\n    const updateAlerts = (alert: PerformanceAlert) => {\n      setAlerts(performanceAlertManager.getActiveAlerts());\n      setSuggestions(performanceAlertManager.getOptimizationSuggestions());\n    };\n\n    performanceAlertManager.addObserver(updateAlerts);\n    setAlerts(performanceAlertManager.getActiveAlerts());\n    setSuggestions(performanceAlertManager.getOptimizationSuggestions());\n\n    return () => {\n      performanceAlertManager.removeObserver(updateAlerts);\n    };\n  }, []);\n\n  const recordMetric = React.useCallback((name: string, value: number, metadata?: Record<string, any>) => {\n    performanceAlertManager.recordMetric(name, value, metadata);\n  }, []);\n\n  const resolveAlert = React.useCallback((alertId: string) => {\n    performanceAlertManager.resolveAlert(alertId);\n  }, []);\n\n  return {\n    alerts,\n    suggestions,\n    recordMetric,\n    resolveAlert,\n  };\n}\n\n/**\n * Performance Alert Display Component\n */\nexport interface PerformanceAlertDisplayProps {\n  maxAlerts?: number;\n  showSuggestions?: boolean;\n  className?: string;\n}\n\nexport const PerformanceAlertDisplay: React.FC<PerformanceAlertDisplayProps> = ({\n  maxAlerts = 5,\n  showSuggestions = true,\n  className = '',\n}) => {\n  const { alerts, suggestions, resolveAlert } = usePerformanceAlerts();\n\n  const displayAlerts = alerts.slice(0, maxAlerts);\n  const criticalAlerts = alerts.filter(alert => alert.severity >= 4);\n\n  if (displayAlerts.length === 0 && (!showSuggestions || suggestions.length === 0)) {\n    return null;\n  }\n\n  return (\n    <div className={`performance-alerts ${className}`}>\n      {/* Critical alerts banner */}\n      {criticalAlerts.length > 0 && (\n        <div className=\"critical-alert-banner bg-red-600 text-white p-2 rounded mb-4\">\n          <strong>‚ö†Ô∏è Critical Performance Issues ({criticalAlerts.length})</strong>\n          <p className=\"text-sm\">Immediate attention required</p>\n        </div>\n      )}\n\n      {/* Active alerts */}\n      {displayAlerts.length > 0 && (\n        <div className=\"active-alerts mb-4\">\n          <h4 className=\"font-semibold text-gray-800 mb-2\">Performance Alerts</h4>\n          <div className=\"space-y-2\">\n            {displayAlerts.map(alert => (\n              <div\n                key={alert.id}\n                className={`alert-item p-3 rounded border-l-4 ${\n                  alert.type === 'critical' ? 'bg-red-50 border-red-500' :\n                  alert.type === 'error' ? 'bg-orange-50 border-orange-500' :\n                  alert.type === 'warning' ? 'bg-yellow-50 border-yellow-500' :\n                  'bg-blue-50 border-blue-500'\n                }`}\n              >\n                <div className=\"flex justify-between items-start\">\n                  <div className=\"flex-1\">\n                    <p className=\"font-medium text-sm\">{alert.message}</p>\n                    <p className=\"text-xs text-gray-600 mt-1\">\n                      {alert.category} ‚Ä¢ {new Date(alert.timestamp).toLocaleTimeString()}\n                    </p>\n                  </div>\n                  <button\n                    onClick={() => resolveAlert(alert.id)}\n                    className=\"ml-2 text-gray-400 hover:text-gray-600 text-sm\"\n                  >\n                    ‚úï\n                  </button>\n                </div>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n\n      {/* Optimization suggestions */}\n      {showSuggestions && suggestions.length > 0 && (\n        <div className=\"optimization-suggestions\">\n          <h4 className=\"font-semibold text-gray-800 mb-2\">Optimization Suggestions</h4>\n          <div className=\"space-y-2\">\n            {suggestions.slice(0, 3).map(suggestion => (\n              <div\n                key={suggestion.id}\n                className={`suggestion-item p-3 rounded border ${\n                  suggestion.priority === 'critical' ? 'border-red-300 bg-red-50' :\n                  suggestion.priority === 'high' ? 'border-orange-300 bg-orange-50' :\n                  suggestion.priority === 'medium' ? 'border-yellow-300 bg-yellow-50' :\n                  'border-gray-300 bg-gray-50'\n                }`}\n              >\n                <div className=\"flex items-center justify-between mb-2\">\n                  <h5 className=\"font-medium text-sm\">{suggestion.title}</h5>\n                  <span className={`px-2 py-1 rounded text-xs ${\n                    suggestion.priority === 'critical' ? 'bg-red-200 text-red-800' :\n                    suggestion.priority === 'high' ? 'bg-orange-200 text-orange-800' :\n                    suggestion.priority === 'medium' ? 'bg-yellow-200 text-yellow-800' :\n                    'bg-gray-200 text-gray-800'\n                  }`}>\n                    {suggestion.priority}\n                  </span>\n                </div>\n                <p className=\"text-xs text-gray-600 mb-2\">{suggestion.description}</p>\n                <p className=\"text-xs text-green-600 font-medium\">{suggestion.estimatedGain}</p>\n              </div>\n            ))}\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default performanceAlertManager;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/utils/performance-profiler.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-empty-object-type",
        "severity": 2,
        "message": "The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.",
        "line": 310,
        "column": 51,
        "nodeType": "TSTypeLiteral",
        "messageId": "noEmptyObject",
        "endLine": 310,
        "endColumn": 53,
        "suggestions": [
          {
            "messageId": "replaceEmptyObjectType",
            "data": { "replacement": "object" },
            "fix": { "range": [9143, 9145], "text": "object" },
            "desc": "Replace `{}` with `object`."
          },
          {
            "messageId": "replaceEmptyObjectType",
            "data": { "replacement": "unknown" },
            "fix": { "range": [9143, 9145], "text": "unknown" },
            "desc": "Replace `{}` with `unknown`."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * React Performance Profiler Utility\n * \n * Provides development-mode performance monitoring for React components,\n * including render time tracking, re-render analysis, and bottleneck detection.\n */\n\nimport * as React from 'react';\nimport { Profiler, ProfilerOnRenderCallback } from 'react';\n\n// Performance data storage\ninterface PerformanceEntry {\n  id: string;\n  phase: 'mount' | 'update' | 'nested-update';\n  actualDuration: number;\n  baseDuration: number;\n  startTime: number;\n  commitTime: number;\n  interactions: Set<any>;\n  renderCount: number;\n  totalTime: number;\n  averageTime: number;\n  maxTime: number;\n  minTime: number;\n  lastRender: number;\n}\n\nclass PerformanceProfiler {\n  private data: Map<string, PerformanceEntry> = new Map();\n  private enabled: boolean = false;\n  private logLevel: 'none' | 'summary' | 'detailed' | 'verbose' = 'none';\n  private slowThreshold: number = 16; // 16ms for 60fps\n  private reportingEnabled: boolean = false;\n\n  constructor() {\n    this.enabled = process.env.NODE_ENV === 'development' && \n                   process.env.REACT_APP_PERFORMANCE_PROFILING === 'true';\n    \n    this.logLevel = (process.env.REACT_APP_PROFILING_LOG_LEVEL as any) || 'summary';\n    this.slowThreshold = parseInt(process.env.REACT_APP_SLOW_RENDER_THRESHOLD || '16');\n    this.reportingEnabled = process.env.REACT_APP_PERF_REPORTING === 'true';\n\n    if (this.enabled) {\n      console.log('üî¨ React Performance Profiler enabled');\n      this.setupPerformanceObserver();\n      this.startPeriodicReporting();\n    }\n  }\n\n  /**\n   * Profiler callback for React Profiler component\n   */\n  onRender = (\n    id: string,\n    phase: 'mount' | 'update' | 'nested-update',\n    actualDuration: number,\n    baseDuration: number,\n    startTime: number,\n    commitTime: number\n  ) => {\n    if (!this.enabled) return;\n\n    const existing = this.data.get(id);\n    const renderCount = existing ? existing.renderCount + 1 : 1;\n    \n    const entry: PerformanceEntry = {\n      id,\n      phase,\n      actualDuration,\n      baseDuration,\n      startTime,\n      commitTime,\n      interactions: new Set(), // Placeholder as interactions parameter was removed in newer React\n      renderCount,\n      totalTime: existing ? existing.totalTime + actualDuration : actualDuration,\n      averageTime: existing \n        ? (existing.totalTime + actualDuration) / renderCount\n        : actualDuration,\n      maxTime: existing \n        ? Math.max(existing.maxTime, actualDuration)\n        : actualDuration,\n      minTime: existing \n        ? Math.min(existing.minTime, actualDuration)\n        : actualDuration,\n      lastRender: Date.now(),\n    };\n\n    this.data.set(id, entry);\n\n    // Log slow renders immediately\n    if (actualDuration > this.slowThreshold) {\n      this.logSlowRender(entry);\n    }\n\n    // Detailed logging in verbose mode\n    if (this.logLevel === 'verbose') {\n      console.log(`üî¨ Render: ${id} (${phase})`, {\n        actualDuration: `${actualDuration.toFixed(2)}ms`,\n        baseDuration: `${baseDuration.toFixed(2)}ms`,\n        renderCount,\n        averageTime: `${entry.averageTime.toFixed(2)}ms`,\n      });\n    }\n  };\n\n  /**\n   * Log slow renders with detailed information\n   */\n  private logSlowRender(entry: PerformanceEntry) {\n    console.warn(\n      `üêå Slow render detected: ${entry.id}`,\n      {\n        duration: `${entry.actualDuration.toFixed(2)}ms`,\n        phase: entry.phase,\n        renderCount: entry.renderCount,\n        average: `${entry.averageTime.toFixed(2)}ms`,\n        threshold: `${this.slowThreshold}ms`,\n      }\n    );\n\n    // Send to analytics if reporting is enabled\n    if (this.reportingEnabled) {\n      this.reportSlowRender(entry);\n    }\n  }\n\n  /**\n   * Generate performance summary\n   */\n  getSummary(): {\n    totalComponents: number;\n    slowComponents: PerformanceEntry[];\n    frequentComponents: PerformanceEntry[];\n    averageRenderTime: number;\n    totalRenderTime: number;\n  } {\n    const entries = Array.from(this.data.values());\n    const slowComponents = entries.filter(e => e.averageTime > this.slowThreshold);\n    const frequentComponents = entries.filter(e => e.renderCount > 10)\n      .sort((a, b) => b.renderCount - a.renderCount);\n\n    const totalRenderTime = entries.reduce((sum, e) => sum + e.totalTime, 0);\n    const averageRenderTime = totalRenderTime / Math.max(entries.length, 1);\n\n    return {\n      totalComponents: entries.length,\n      slowComponents: slowComponents.sort((a, b) => b.averageTime - a.averageTime),\n      frequentComponents,\n      averageRenderTime,\n      totalRenderTime,\n    };\n  }\n\n  /**\n   * Print performance summary to console\n   */\n  logSummary() {\n    if (!this.enabled || this.logLevel === 'none') return;\n\n    const summary = this.getSummary();\n    \n    console.group('üî¨ React Performance Summary');\n    console.log(`üìä Total components tracked: ${summary.totalComponents}`);\n    console.log(`‚ö° Average render time: ${summary.averageRenderTime.toFixed(2)}ms`);\n    console.log(`üïí Total render time: ${summary.totalRenderTime.toFixed(2)}ms`);\n\n    if (summary.slowComponents.length > 0) {\n      console.group(`üêå Slow components (>${this.slowThreshold}ms):`);\n      summary.slowComponents.forEach(comp => {\n        console.log(`  ${comp.id}: avg ${comp.averageTime.toFixed(2)}ms, max ${comp.maxTime.toFixed(2)}ms, renders: ${comp.renderCount}`);\n      });\n      console.groupEnd();\n    }\n\n    if (summary.frequentComponents.length > 0) {\n      console.group('üîÑ Frequently rendering components:');\n      summary.frequentComponents.slice(0, 5).forEach(comp => {\n        console.log(`  ${comp.id}: ${comp.renderCount} renders, avg ${comp.averageTime.toFixed(2)}ms`);\n      });\n      console.groupEnd();\n    }\n\n    console.groupEnd();\n  }\n\n  /**\n   * Setup Performance Observer for additional metrics\n   */\n  private setupPerformanceObserver() {\n    if (typeof PerformanceObserver === 'undefined') return;\n\n    try {\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        entries.forEach(entry => {\n          if (entry.entryType === 'measure' && entry.name.startsWith('‚öõÔ∏è')) {\n            // React DevTools performance markers\n            if (this.logLevel === 'verbose') {\n              console.log(`‚öõÔ∏è React measure: ${entry.name}`, `${entry.duration.toFixed(2)}ms`);\n            }\n          }\n        });\n      });\n\n      observer.observe({ entryTypes: ['measure', 'navigation', 'paint'] });\n    } catch (error) {\n      console.warn('Performance Observer not available:', error);\n    }\n  }\n\n  /**\n   * Start periodic performance reporting\n   */\n  private startPeriodicReporting() {\n    if (!this.reportingEnabled) return;\n\n    // Report summary every 30 seconds in development\n    setInterval(() => {\n      if (this.logLevel !== 'none') {\n        this.logSummary();\n      }\n      \n      if (this.reportingEnabled) {\n        this.sendPerformanceReport();\n      }\n    }, 30000);\n  }\n\n  /**\n   * Send slow render data to analytics\n   */\n  private reportSlowRender(entry: PerformanceEntry) {\n    // This would integrate with your analytics system\n    const reportData = {\n      event: 'slow_render_detected',\n      component: entry.id,\n      duration: entry.actualDuration,\n      phase: entry.phase,\n      renderCount: entry.renderCount,\n      timestamp: entry.lastRender,\n      userAgent: navigator.userAgent,\n      url: window.location.href,\n    };\n\n    // Send to analytics endpoint (mock for now)\n    if (process.env.REACT_APP_ANALYTICS_ENDPOINT) {\n      fetch(`${process.env.REACT_APP_ANALYTICS_ENDPOINT}/performance`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(reportData),\n      }).catch(error => {\n        console.warn('Failed to report performance data:', error);\n      });\n    }\n  }\n\n  /**\n   * Send periodic performance report\n   */\n  private sendPerformanceReport() {\n    const summary = this.getSummary();\n    const reportData = {\n      event: 'performance_summary',\n      summary,\n      timestamp: Date.now(),\n      userAgent: navigator.userAgent,\n      url: window.location.href,\n    };\n\n    // Send to analytics endpoint (mock for now)\n    if (process.env.REACT_APP_ANALYTICS_ENDPOINT) {\n      fetch(`${process.env.REACT_APP_ANALYTICS_ENDPOINT}/performance/summary`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(reportData),\n      }).catch(error => {\n        console.warn('Failed to report performance summary:', error);\n      });\n    }\n  }\n\n  /**\n   * Clear all performance data\n   */\n  clear() {\n    this.data.clear();\n  }\n\n  /**\n   * Get specific component performance data\n   */\n  getComponentData(id: string): PerformanceEntry | undefined {\n    return this.data.get(id);\n  }\n\n  /**\n   * Export performance data for external analysis\n   */\n  exportData(): PerformanceEntry[] {\n    return Array.from(this.data.values());\n  }\n}\n\n// Global profiler instance\nexport const performanceProfiler = new PerformanceProfiler();\n\n/**\n * Higher-order component for easy performance profiling\n */\nexport function withPerformanceProfiler<T extends {}>(\n  WrappedComponent: React.ComponentType<T>,\n  profilerId?: string\n) {\n  const displayName = WrappedComponent.displayName || WrappedComponent.name || 'Component';\n  const id = profilerId || displayName;\n\n  const ProfiledComponent: React.FC<T> = (props) => {\n    return React.createElement(\n      Profiler,\n      { id, onRender: performanceProfiler.onRender },\n      React.createElement(WrappedComponent, props)\n    );\n  };\n\n  ProfiledComponent.displayName = `withPerformanceProfiler(${displayName})`;\n  return ProfiledComponent;\n}\n\n/**\n * Hook for component-level performance monitoring\n */\nexport function usePerformanceMonitor(componentName: string) {\n  const startTime = React.useRef<number | undefined>(undefined);\n  const renderCount = React.useRef<number>(0);\n\n  React.useEffect(() => {\n    renderCount.current += 1;\n    const endTime = performance.now();\n    \n    if (startTime.current) {\n      const duration = endTime - startTime.current;\n      \n      if (duration > performanceProfiler['slowThreshold']) {\n        console.warn(\n          `üêå Slow render in ${componentName}: ${duration.toFixed(2)}ms`,\n          `(render #${renderCount.current})`\n        );\n      }\n    }\n    \n    startTime.current = endTime;\n  });\n\n  return {\n    renderCount: renderCount.current,\n    logRender: (message?: string) => {\n      if (performanceProfiler['logLevel'] === 'verbose') {\n        console.log(`üî¨ ${componentName}${message ? `: ${message}` : ''}`);\n      }\n    },\n  };\n}\n\n// Export the Profiler component for manual use\nexport { Profiler } from 'react';",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/utils/screen-reader.ts",
    "messages": [
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 704,
        "column": 11,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 704,
        "endColumn": 84,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [21424, 21582],
              "text": "{ e.preventDefault();\n          const nextIndex = activeIndex < options.length - 1 ? activeIndex + 1 : 0;\n          setActiveOption(nextIndex);\n          break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      },
      {
        "ruleId": "no-case-declarations",
        "severity": 2,
        "message": "Unexpected lexical declaration in case block.",
        "line": 709,
        "column": 11,
        "nodeType": "VariableDeclaration",
        "messageId": "unexpected",
        "endLine": 709,
        "endColumn": 84,
        "suggestions": [
          {
            "messageId": "addBrackets",
            "fix": {
              "range": [21617, 21775],
              "text": "{ e.preventDefault();\n          const prevIndex = activeIndex > 0 ? activeIndex - 1 : options.length - 1;\n          setActiveOption(prevIndex);\n          break; }"
            },
            "desc": "Add {} brackets around the case block."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference lib=\"dom\" />\n// Advanced Screen Reader Support for Smart Alarm App\n// Provides comprehensive ARIA patterns and screen reader utilities\n\nexport interface ScreenReaderState {\n  isEnabled: boolean;\n  verbosityLevel: 'low' | 'medium' | 'high';\n  speechRate: number;\n  autoAnnounceChanges: boolean;\n  preferredVoice?: string;\n}\n\nexport interface AlarmAnnouncement {\n  id: string;\n  time: string;\n  label: string;\n  isActive: boolean;\n  repeatDays: string[];\n  voiceMood: string;\n}\n\n/**\n * Advanced Screen Reader Service for comprehensive accessibility\n */\nexport class ScreenReaderService {\n  private static instance: ScreenReaderService;\n  private state: ScreenReaderState;\n  private announcementQueue: string[] = [];\n  private isProcessingQueue = false;\n  private liveRegion?: HTMLElement;\n  private statusRegion?: HTMLElement;\n  private navigationHistory: string[] = [];\n\n  private constructor() {\n    this.state = {\n      isEnabled: this.detectScreenReader(),\n      verbosityLevel: 'medium',\n      speechRate: 1.0,\n      autoAnnounceChanges: true,\n      preferredVoice: undefined\n    };\n\n    this.initializeLiveRegions();\n    this.loadUserPreferences();\n  }\n\n  static getInstance(): ScreenReaderService {\n    if (!ScreenReaderService.instance) {\n      ScreenReaderService.instance = new ScreenReaderService();\n    }\n    return ScreenReaderService.instance;\n  }\n\n  /**\n   * Initialize the screen reader service (called from App.tsx)\n   */\n  public initialize(): void {\n    // Service is already initialized in constructor\n    // This method provides the expected interface for App.tsx\n    console.log('ScreenReaderService initialized');\n  }\n\n  /**\n   * Get the current enabled state\n   */\n  public get isEnabled(): boolean {\n    return this.state.isEnabled;\n  }\n\n  /**\n   * Detect if a screen reader is likely being used\n   */\n  private detectScreenReader(): boolean {\n    // Check for screen reader specific APIs\n    if ('speechSynthesis' in window && 'SpeechSynthesisUtterance' in window) {\n      // Check for NVDA, JAWS, or other screen readers\n      const userAgent = navigator.userAgent.toLowerCase();\n      if (userAgent.includes('nvda') || userAgent.includes('jaws') || userAgent.includes('dragon')) {\n        return true;\n      }\n    }\n\n    // Check for accessibility features enabled\n    const hasAccessibilityFeatures =\n      window.matchMedia('(prefers-reduced-motion: reduce)').matches ||\n      window.matchMedia('(prefers-contrast: high)').matches ||\n      window.matchMedia('(forced-colors: active)').matches;\n\n    return hasAccessibilityFeatures;\n  }\n\n  /**\n   * Initialize ARIA live regions for announcements\n   */\n  private initializeLiveRegions(): void {\n    // Remove existing regions if they exist\n    const existingMain = document.getElementById('sr-main-live-region');\n    const existingStatus = document.getElementById('sr-status-region');\n    if (existingMain) existingMain.remove();\n    if (existingStatus) existingStatus.remove();\n\n    // Main live region for general announcements\n    this.liveRegion = document.createElement('div');\n    this.liveRegion.id = 'sr-main-live-region';\n    this.liveRegion.setAttribute('aria-live', 'polite');\n    this.liveRegion.setAttribute('aria-atomic', 'true');\n    this.liveRegion.setAttribute('aria-relevant', 'additions text');\n    this.liveRegion.className = 'sr-only';\n    this.liveRegion.style.cssText = 'position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;';\n\n    // Ensure the region is inserted after page load\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', () => {\n        document.body.appendChild(this.liveRegion!);\n      });\n    } else {\n      document.body.appendChild(this.liveRegion);\n    }\n\n    // Status region for important updates\n    this.statusRegion = document.createElement('div');\n    this.statusRegion.id = 'sr-status-region';\n    this.statusRegion.setAttribute('aria-live', 'assertive');\n    this.statusRegion.setAttribute('aria-atomic', 'true');\n    this.statusRegion.setAttribute('aria-relevant', 'additions text');\n    this.statusRegion.className = 'sr-only';\n    this.statusRegion.style.cssText = 'position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;';\n\n    // Ensure the region is inserted after page load\n    if (document.readyState === 'loading') {\n      document.addEventListener('DOMContentLoaded', () => {\n        document.body.appendChild(this.statusRegion!);\n      });\n    } else {\n      document.body.appendChild(this.statusRegion);\n    }\n\n    // Add CSS for screen reader only class if it doesn't exist\n    this.addScreenReaderOnlyCSS();\n  }\n\n  /**\n   * Load user accessibility preferences\n   */\n  private loadUserPreferences(): void {\n    try {\n      const saved = localStorage.getItem('screen-reader-preferences');\n      if (saved) {\n        const preferences = JSON.parse(saved);\n        this.state = { ...this.state, ...preferences };\n      }\n    } catch (error) {\n      console.warn('Failed to load screen reader preferences:', error);\n    }\n  }\n\n  /**\n   * Save user accessibility preferences\n   */\n  private saveUserPreferences(): void {\n    try {\n      localStorage.setItem('screen-reader-preferences', JSON.stringify(this.state));\n    } catch (error) {\n      console.warn('Failed to save screen reader preferences:', error);\n    }\n  }\n\n  /**\n   * Update screen reader settings\n   */\n  updateSettings(settings: Partial<ScreenReaderState>): void {\n    this.state = { ...this.state, ...settings };\n    this.saveUserPreferences();\n\n    if (settings.isEnabled !== undefined) {\n      this.announce(\n        settings.isEnabled\n          ? 'Screen reader enhancements enabled'\n          : 'Screen reader enhancements disabled'\n      );\n    }\n  }\n\n  /**\n   * Get current screen reader state\n   */\n  getState(): ScreenReaderState {\n    return { ...this.state };\n  }\n\n  /**\n   * Queue announcement for screen readers\n   */\n  announce(\n    message: string,\n    priority: 'polite' | 'assertive' = 'polite',\n    options: {\n      interrupt?: boolean;\n      verbosity?: 'low' | 'medium' | 'high';\n      delay?: number;\n    } = {}\n  ): void {\n    if (!this.state.isEnabled || !message.trim()) return;\n\n    const { interrupt = false, verbosity = this.state.verbosityLevel, delay = 0 } = options;\n\n    // Check verbosity level\n    if (verbosity === 'low' && this.state.verbosityLevel !== 'high') return;\n    if (verbosity === 'medium' && this.state.verbosityLevel === 'low') return;\n\n    const processAnnouncement = () => {\n      if (interrupt) {\n        this.clearQueue();\n      }\n\n      const region = priority === 'assertive' ? this.statusRegion : this.liveRegion;\n      if (region && document.body.contains(region)) {\n        // Use a more reliable method for screen reader announcements\n        this.announceToLiveRegion(region, message);\n      } else {\n        // Reinitialize if regions are missing\n        console.warn('Live regions not found, reinitializing...');\n        this.initializeLiveRegions();\n        // Retry announcement after reinitializing\n        setTimeout(() => {\n          const retryRegion = priority === 'assertive' ? this.statusRegion : this.liveRegion;\n          if (retryRegion) {\n            this.announceToLiveRegion(retryRegion, message);\n          }\n        }, 100);\n      }\n    };\n\n    if (delay > 0) {\n      setTimeout(processAnnouncement, delay);\n    } else {\n      processAnnouncement();\n    }\n  }\n\n  /**\n   * Announce alarm information in a structured way\n   */\n  announceAlarm(alarm: AlarmAnnouncement, action: 'created' | 'updated' | 'deleted' | 'toggled'): void {\n    if (!this.state.isEnabled) return;\n\n    const timeFormatted = this.formatTimeForSpeech(alarm.time);\n    const daysText = this.formatDaysForSpeech(alarm.repeatDays);\n    const statusText = alarm.isActive ? 'active' : 'inactive';\n\n    let message = '';\n\n    switch (action) {\n      case 'created':\n        message = `Alarm created for ${timeFormatted}. ${alarm.label}. ${daysText}. Voice mood: ${alarm.voiceMood}. Status: ${statusText}.`;\n        break;\n      case 'updated':\n        message = `Alarm updated: ${timeFormatted}. ${alarm.label}. ${daysText}. Voice mood: ${alarm.voiceMood}. Status: ${statusText}.`;\n        break;\n      case 'deleted':\n        message = `Alarm deleted: ${timeFormatted}. ${alarm.label}.`;\n        break;\n      case 'toggled':\n        message = `Alarm ${alarm.isActive ? 'activated' : 'deactivated'}: ${timeFormatted}. ${alarm.label}.`;\n        break;\n    }\n\n    this.announce(message, 'polite');\n  }\n\n  /**\n   * Announce page navigation changes\n   */\n  announceNavigation(pageName: string, pageDescription?: string): void {\n    if (!this.state.isEnabled) return;\n\n    this.navigationHistory.push(pageName);\n\n    let message = `Navigated to ${pageName}`;\n    if (pageDescription) {\n      message += `. ${pageDescription}`;\n    }\n\n    // Add navigation context for complex flows\n    if (this.navigationHistory.length > 1) {\n      const previousPage = this.navigationHistory[this.navigationHistory.length - 2];\n      message += `. Previous page: ${previousPage}.`;\n    }\n\n    this.announce(message, 'polite');\n\n    // Update document title for screen readers\n    document.title = `${pageName} - Smart Alarm App`;\n  }\n\n  /**\n   * Announce form validation errors\n   */\n  announceFormError(fieldName: string, errorMessage: string): void {\n    if (!this.state.isEnabled) return;\n\n    const message = `Error in ${fieldName}: ${errorMessage}`;\n    this.announce(message, 'assertive');\n  }\n\n  /**\n   * Announce successful actions\n   */\n  announceSuccess(message: string): void {\n    if (!this.state.isEnabled) return;\n\n    this.announce(`Success: ${message}`, 'polite');\n  }\n\n  /**\n   * Announce loading states\n   */\n  announceLoading(action: string, isLoading: boolean): void {\n    if (!this.state.isEnabled) return;\n\n    const message = isLoading ? `Loading ${action}...` : `${action} completed`;\n    this.announce(message, 'polite');\n  }\n\n  /**\n   * Announce alarm ringing with contextual information\n   */\n  announceAlarmRinging(alarm: AlarmAnnouncement): void {\n    if (!this.state.isEnabled) return;\n\n    const timeFormatted = this.formatTimeForSpeech(alarm.time);\n    const message = `Alarm ringing! ${timeFormatted}. ${alarm.label}. Voice mood: ${alarm.voiceMood}. Say \"stop\" to dismiss or \"snooze\" to snooze for 10 minutes.`;\n\n    this.announce(message, 'assertive', { interrupt: true });\n  }\n\n  /**\n   * Announce state changes with automatic detection\n   */\n  announceStateChange(componentName: string, previousState: any, newState: any, customMessage?: string): void {\n    if (!this.state.isEnabled || !this.state.autoAnnounceChanges) return;\n\n    let message = customMessage;\n    if (!message) {\n      if (typeof newState === 'boolean') {\n        message = `${componentName} ${newState ? 'enabled' : 'disabled'}`;\n      } else if (typeof newState === 'string') {\n        message = `${componentName} changed to ${newState}`;\n      } else if (typeof newState === 'number') {\n        message = `${componentName} set to ${newState}`;\n      } else {\n        message = `${componentName} updated`;\n      }\n    }\n\n    this.announce(message, 'polite');\n  }\n\n  /**\n   * Announce collection changes (add/remove/update items)\n   */\n  announceCollectionChange(collectionName: string, action: 'added' | 'removed' | 'updated', itemCount: number, itemDescription?: string): void {\n    if (!this.state.isEnabled) return;\n\n    const item = itemDescription || 'item';\n    let message = '';\n\n    switch (action) {\n      case 'added':\n        message = itemCount === 1\n          ? `${item} added to ${collectionName}`\n          : `${itemCount} ${item}s added to ${collectionName}`;\n        break;\n      case 'removed':\n        message = itemCount === 1\n          ? `${item} removed from ${collectionName}`\n          : `${itemCount} ${item}s removed from ${collectionName}`;\n        break;\n      case 'updated':\n        message = itemCount === 1\n          ? `${item} updated in ${collectionName}`\n          : `${itemCount} ${item}s updated in ${collectionName}`;\n        break;\n    }\n\n    this.announce(message, 'polite');\n  }\n\n  /**\n   * Provide keyboard shortcuts announcement\n   */\n  announceKeyboardShortcuts(): void {\n    if (!this.state.isEnabled) return;\n\n    const shortcuts = [\n      'Alt plus D for Dashboard',\n      'Alt plus A for Alarms',\n      'Alt plus S for Settings',\n      'Alt plus P for Performance',\n      'Space to toggle alarms',\n      'Enter to edit selected alarm',\n      'Delete to remove selected alarm',\n      'Escape to close dialogs'\n    ];\n\n    const message = `Keyboard shortcuts available: ${shortcuts.join(', ')}.`;\n    this.announce(message, 'polite');\n  }\n\n  /**\n   * Announce element focus changes with context\n   */\n  announceFocusChange(elementType: string, elementLabel: string, additionalContext?: string): void {\n    if (!this.state.isEnabled || this.state.verbosityLevel === 'low') return;\n\n    let message = `${elementType}: ${elementLabel}`;\n    if (additionalContext) {\n      message += `. ${additionalContext}`;\n    }\n\n    // Only announce for medium and high verbosity\n    if (this.state.verbosityLevel !== 'low') {\n      this.announce(message, 'polite', { delay: 100 });\n    }\n  }\n\n  /**\n   * Format time for natural speech\n   */\n  private formatTimeForSpeech(time: string): string {\n    const [hours, minutes] = time.split(':').map(Number);\n    const period = hours >= 12 ? 'PM' : 'AM';\n    const displayHours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;\n\n    if (minutes === 0) {\n      return `${displayHours} ${period}`;\n    } else {\n      return `${displayHours}:${minutes.toString().padStart(2, '0')} ${period}`;\n    }\n  }\n\n  /**\n   * Format repeat days for natural speech\n   */\n  private formatDaysForSpeech(days: string[]): string {\n    if (days.length === 0) return 'One time only';\n    if (days.length === 7) return 'Every day';\n    if (days.length === 5 && !days.includes('Saturday') && !days.includes('Sunday')) {\n      return 'Weekdays only';\n    }\n    if (days.length === 2 && days.includes('Saturday') && days.includes('Sunday')) {\n      return 'Weekends only';\n    }\n\n    return `Repeats on ${days.join(', ')}`;\n  }\n\n  /**\n   * Announce to live region with fallback methods\n   */\n  private announceToLiveRegion(region: HTMLElement, message: string): void {\n    // Method 1: Clear and set text content\n    region.textContent = '';\n\n    // Use RAF to ensure the clear is processed before setting new content\n    requestAnimationFrame(() => {\n      region.textContent = message;\n\n      // Method 2: Retry textContent as a fallback\n      setTimeout(() => {\n        if (region.textContent === message) {\n          region.textContent = '';\n          region.textContent = message;\n        }\n      }, 50);\n\n      // Method 3: Force a reflow by temporarily changing aria-live\n      setTimeout(() => {\n        const currentLive = region.getAttribute('aria-live');\n        region.setAttribute('aria-live', 'off');\n        requestAnimationFrame(() => {\n          region.setAttribute('aria-live', currentLive || 'polite');\n        });\n      }, 100);\n\n      // Clear after 3 seconds to prevent accumulation\n      setTimeout(() => {\n        if (region.textContent === message) {\n          region.textContent = '';\n        }\n      }, 3000);\n    });\n  }\n\n  /**\n   * Add CSS for screen reader only class\n   */\n  private addScreenReaderOnlyCSS(): void {\n    const styleId = 'sr-only-styles';\n    if (document.getElementById(styleId)) return;\n\n    const style = document.createElement('style');\n    style.id = styleId;\n    style.textContent = `\n      .sr-only {\n        position: absolute !important;\n        width: 1px !important;\n        height: 1px !important;\n        padding: 0 !important;\n        margin: -1px !important;\n        overflow: hidden !important;\n        clip: rect(0, 0, 0, 0) !important;\n        white-space: nowrap !important;\n        border: 0 !important;\n      }\n    `;\n    document.head.appendChild(style);\n  }\n\n  /**\n   * Clear announcement queue\n   */\n  private clearQueue(): void {\n    this.announcementQueue = [];\n    if (this.liveRegion) this.liveRegion.textContent = '';\n    if (this.statusRegion) this.statusRegion.textContent = '';\n  }\n\n  /**\n   * Cleanup method for component unmounting\n   */\n  cleanup(): void {\n    if (this.liveRegion && document.body.contains(this.liveRegion)) {\n      document.body.removeChild(this.liveRegion);\n    }\n    if (this.statusRegion && document.body.contains(this.statusRegion)) {\n      document.body.removeChild(this.statusRegion);\n    }\n  }\n}\n\n/**\n * Enhanced ARIA utilities for complex interactions\n */\nexport class ARIAPatterns {\n  /**\n   * Create accessible accordion pattern\n   */\n  static setupAccordion(container: HTMLElement): () => void {\n    const headers = container.querySelectorAll('[role=\"button\"]');\n    const panels = container.querySelectorAll('[role=\"region\"]');\n\n    headers.forEach((header, index) => {\n      const panel = panels[index] as HTMLElement;\n      if (!panel) return;\n\n      const headerId = `accordion-header-${index}`;\n      const panelId = `accordion-panel-${index}`;\n\n      header.id = headerId;\n      panel.id = panelId;\n      header.setAttribute('aria-controls', panelId);\n      header.setAttribute('aria-expanded', 'false');\n      panel.setAttribute('aria-labelledby', headerId);\n      panel.setAttribute('aria-hidden', 'true');\n\n      const handleToggle = () => {\n        const isExpanded = header.getAttribute('aria-expanded') === 'true';\n        header.setAttribute('aria-expanded', (!isExpanded).toString());\n        panel.setAttribute('aria-hidden', isExpanded.toString());\n\n        ScreenReaderService.getInstance().announce(\n          `${isExpanded ? 'Collapsed' : 'Expanded'} ${header.textContent}`,\n          'polite'\n        );\n      };\n\n      header.addEventListener('click', handleToggle);\n      header.addEventListener('keydown', (e) => {\n        if (e.key === 'Enter' || e.key === ' ') {\n          e.preventDefault();\n          handleToggle();\n        }\n      });\n    });\n\n    return () => {\n      headers.forEach(header => {\n        header.removeEventListener('click', () => {});\n        header.removeEventListener('keydown', () => {});\n      });\n    };\n  }\n\n  /**\n   * Create accessible tab pattern\n   */\n  static setupTabs(container: HTMLElement): () => void {\n    const tabList = container.querySelector('[role=\"tablist\"]');\n    const tabs = container.querySelectorAll('[role=\"tab\"]');\n    const panels = container.querySelectorAll('[role=\"tabpanel\"]');\n\n    if (!tabList || tabs.length === 0 || panels.length === 0) return () => {};\n\n    let activeIndex = 0;\n\n    const setActiveTab = (index: number) => {\n      tabs.forEach((tab, i) => {\n        const panel = panels[i] as HTMLElement;\n        if (i === index) {\n          tab.setAttribute('aria-selected', 'true');\n          tab.setAttribute('tabindex', '0');\n          panel.setAttribute('aria-hidden', 'false');\n          (tab as HTMLElement).focus();\n        } else {\n          tab.setAttribute('aria-selected', 'false');\n          tab.setAttribute('tabindex', '-1');\n          panel.setAttribute('aria-hidden', 'true');\n        }\n      });\n\n      activeIndex = index;\n      ScreenReaderService.getInstance().announce(\n        `Selected tab: ${tabs[index].textContent}`,\n        'polite'\n      );\n    };\n\n    const handleKeydown = (e: KeyboardEvent) => {\n      let newIndex = activeIndex;\n\n      switch (e.key) {\n        case 'ArrowRight':\n        case 'ArrowDown':\n          newIndex = (activeIndex + 1) % tabs.length;\n          break;\n        case 'ArrowLeft':\n        case 'ArrowUp':\n          newIndex = (activeIndex - 1 + tabs.length) % tabs.length;\n          break;\n        case 'Home':\n          newIndex = 0;\n          break;\n        case 'End':\n          newIndex = tabs.length - 1;\n          break;\n        default:\n          return;\n      }\n\n      e.preventDefault();\n      setActiveTab(newIndex);\n    };\n\n    tabs.forEach((tab, index) => {\n      tab.addEventListener('click', () => setActiveTab(index));\n    });\n\n    tabList.addEventListener('keydown', handleKeydown);\n\n    // Initialize first tab as active\n    setActiveTab(0);\n\n    return () => {\n      tabs.forEach(tab => {\n        tab.removeEventListener('click', () => {});\n      });\n      tabList.removeEventListener('keydown', handleKeydown);\n    };\n  }\n\n  /**\n   * Create accessible combobox pattern\n   */\n  static setupCombobox(input: HTMLInputElement, listbox: HTMLElement): () => void {\n    const options = listbox.querySelectorAll('[role=\"option\"]');\n    let activeIndex = -1;\n\n    const comboboxId = `combobox-${Date.now()}`;\n    const listboxId = `listbox-${Date.now()}`;\n\n    input.setAttribute('role', 'combobox');\n    input.setAttribute('aria-autocomplete', 'list');\n    input.setAttribute('aria-expanded', 'false');\n    input.setAttribute('aria-owns', listboxId);\n    listbox.id = listboxId;\n\n    const setActiveOption = (index: number) => {\n      options.forEach((option, i) => {\n        if (i === index) {\n          option.setAttribute('aria-selected', 'true');\n          input.setAttribute('aria-activedescendant', option.id || `option-${i}`);\n        } else {\n          option.setAttribute('aria-selected', 'false');\n        }\n      });\n      activeIndex = index;\n    };\n\n    const handleKeydown = (e: KeyboardEvent) => {\n      switch (e.key) {\n        case 'ArrowDown':\n          e.preventDefault();\n          const nextIndex = activeIndex < options.length - 1 ? activeIndex + 1 : 0;\n          setActiveOption(nextIndex);\n          break;\n        case 'ArrowUp':\n          e.preventDefault();\n          const prevIndex = activeIndex > 0 ? activeIndex - 1 : options.length - 1;\n          setActiveOption(prevIndex);\n          break;\n        case 'Enter':\n          if (activeIndex >= 0) {\n            e.preventDefault();\n            (options[activeIndex] as HTMLElement).click();\n          }\n          break;\n        case 'Escape':\n          input.setAttribute('aria-expanded', 'false');\n          input.focus();\n          break;\n      }\n    };\n\n    input.addEventListener('keydown', handleKeydown);\n\n    return () => {\n      input.removeEventListener('keydown', handleKeydown);\n    };\n  }\n}\n\nexport default ScreenReaderService;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/src/utils/voice-accessibility.ts",
    "messages": [
      {
        "ruleId": "no-undef",
        "severity": 2,
        "message": "'SpeechRecognition' is not defined.",
        "line": 32,
        "column": 25,
        "nodeType": "Identifier",
        "messageId": "undef",
        "endLine": 32,
        "endColumn": 42
      },
      {
        "ruleId": "no-cond-assign",
        "severity": 2,
        "message": "Expected a conditional expression and instead saw an assignment.",
        "line": 683,
        "column": 12,
        "nodeType": "AssignmentExpression",
        "messageId": "missing",
        "endLine": 683,
        "endColumn": 36
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "// Voice-Controlled Accessibility for Smart Alarm App\n// Provides comprehensive voice navigation and control for accessibility\n\nimport ScreenReaderService from './screen-reader';\nimport KeyboardNavigationService from './keyboard-navigation';\n\nexport interface VoiceCommand {\n  phrases: string[];\n  action: (params?: any) => void;\n  description: string;\n  category: 'navigation' | 'alarm' | 'accessibility' | 'general';\n  enabled: boolean;\n  confirmation?: boolean; // Requires voice confirmation for destructive actions\n}\n\nexport interface VoiceAccessibilityState {\n  isListening: boolean;\n  isEnabled: boolean;\n  language: string;\n  confidence: number;\n  voiceSpeed: number;\n  enabledCategories: string[];\n  requireConfirmation: boolean;\n  continuous: boolean;\n}\n\n/**\n * Voice-Controlled Accessibility Service\n */\nexport class VoiceAccessibilityService {\n  private static instance: VoiceAccessibilityService;\n  private recognition?: SpeechRecognition;\n  private synthesis: SpeechSynthesis;\n  private commands: Map<string, VoiceCommand> = new Map();\n  private state: VoiceAccessibilityState;\n  private screenReader: ScreenReaderService;\n  private keyboardNav: KeyboardNavigationService;\n  private currentlyListening = false;\n  private confirmationPending?: VoiceCommand;\n  private feedbackTimer?: number;\n\n  private constructor() {\n    this.synthesis = window.speechSynthesis;\n    this.screenReader = ScreenReaderService.getInstance();\n    this.keyboardNav = KeyboardNavigationService.getInstance();\n\n    this.state = {\n      isListening: false,\n      isEnabled: this.checkVoiceSupport(),\n      language: 'en-US',\n      confidence: 0.7,\n      voiceSpeed: 1.0,\n      enabledCategories: ['navigation', 'alarm', 'accessibility', 'general'],\n      requireConfirmation: true,\n      continuous: false\n    };\n\n    this.initializeVoiceCommands();\n    this.setupSpeechRecognition();\n  }\n\n  static getInstance(): VoiceAccessibilityService {\n    if (!VoiceAccessibilityService.instance) {\n      VoiceAccessibilityService.instance = new VoiceAccessibilityService();\n    }\n    return VoiceAccessibilityService.instance;\n  }\n\n  /**\n   * Initialize the voice accessibility service (called from App.tsx)\n   */\n  public async initialize(): Promise<void> {\n    // Service is already initialized in constructor\n    // This method provides the expected interface for App.tsx\n    console.log('VoiceAccessibilityService initialized');\n  }\n\n  /**\n   * Get the current enabled state\n   */\n  public get isEnabled(): boolean {\n    return this.state.isEnabled;\n  }\n\n  /**\n   * Check if voice recognition is supported\n   */\n  private checkVoiceSupport(): boolean {\n    return 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;\n  }\n\n  /**\n   * Initialize comprehensive voice commands\n   */\n  private initializeVoiceCommands(): void {\n    const commands: Omit<VoiceCommand, 'enabled'>[] = [\n      // Navigation Commands\n      {\n        phrases: ['go to dashboard', 'open dashboard', 'show dashboard', 'navigate dashboard'],\n        action: () => this.navigateToSection('dashboard'),\n        description: 'Navigate to Dashboard',\n        category: 'navigation'\n      },\n      {\n        phrases: ['go to alarms', 'open alarms', 'show alarms', 'navigate alarms', 'alarm list'],\n        action: () => this.navigateToSection('alarms'),\n        description: 'Navigate to Alarms',\n        category: 'navigation'\n      },\n      {\n        phrases: ['go to settings', 'open settings', 'show settings', 'navigate settings'],\n        action: () => this.navigateToSection('settings'),\n        description: 'Navigate to Settings',\n        category: 'navigation'\n      },\n      {\n        phrases: ['go to performance', 'open performance', 'show performance analytics'],\n        action: () => this.navigateToSection('performance'),\n        description: 'Navigate to Performance',\n        category: 'navigation'\n      },\n      {\n        phrases: ['go back', 'navigate back', 'previous page', 'back'],\n        action: () => this.goBack(),\n        description: 'Go to previous page',\n        category: 'navigation'\n      },\n\n      // Alarm Management Commands\n      {\n        phrases: ['create alarm', 'new alarm', 'add alarm', 'make alarm'],\n        action: () => this.createAlarm(),\n        description: 'Create a new alarm',\n        category: 'alarm'\n      },\n      {\n        phrases: ['delete alarm', 'remove alarm', 'delete selected alarm'],\n        action: () => this.deleteAlarm(),\n        description: 'Delete the selected alarm',\n        category: 'alarm',\n        confirmation: true\n      },\n      {\n        phrases: ['toggle alarm', 'switch alarm', 'activate alarm', 'deactivate alarm'],\n        action: () => this.toggleAlarm(),\n        description: 'Toggle the selected alarm on/off',\n        category: 'alarm'\n      },\n      {\n        phrases: ['edit alarm', 'modify alarm', 'change alarm'],\n        action: () => this.editAlarm(),\n        description: 'Edit the selected alarm',\n        category: 'alarm'\n      },\n      {\n        phrases: ['list alarms', 'show all alarms', 'read alarms'],\n        action: () => this.listAlarms(),\n        description: 'List all alarms',\n        category: 'alarm'\n      },\n      {\n        phrases: ['select first alarm', 'focus first alarm'],\n        action: () => this.selectAlarm('first'),\n        description: 'Select the first alarm',\n        category: 'alarm'\n      },\n      {\n        phrases: ['select last alarm', 'focus last alarm'],\n        action: () => this.selectAlarm('last'),\n        description: 'Select the last alarm',\n        category: 'alarm'\n      },\n      {\n        phrases: ['next alarm', 'select next alarm'],\n        action: () => this.selectAlarm('next'),\n        description: 'Select the next alarm',\n        category: 'alarm'\n      },\n      {\n        phrases: ['previous alarm', 'select previous alarm'],\n        action: () => this.selectAlarm('previous'),\n        description: 'Select the previous alarm',\n        category: 'alarm'\n      },\n\n      // Accessibility Commands\n      {\n        phrases: ['increase voice speed', 'speak faster', 'speed up voice'],\n        action: () => this.adjustVoiceSpeed(0.2),\n        description: 'Increase voice playback speed',\n        category: 'accessibility'\n      },\n      {\n        phrases: ['decrease voice speed', 'speak slower', 'slow down voice'],\n        action: () => this.adjustVoiceSpeed(-0.2),\n        description: 'Decrease voice playback speed',\n        category: 'accessibility'\n      },\n      {\n        phrases: ['read page', 'read screen', 'read current page'],\n        action: () => this.readCurrentPage(),\n        description: 'Read the current page content',\n        category: 'accessibility'\n      },\n      {\n        phrases: ['keyboard shortcuts', 'show shortcuts', 'list shortcuts'],\n        action: () => this.readKeyboardShortcuts(),\n        description: 'List available keyboard shortcuts',\n        category: 'accessibility'\n      },\n      {\n        phrases: ['voice commands', 'voice help', 'list commands'],\n        action: () => this.readVoiceCommands(),\n        description: 'List available voice commands',\n        category: 'accessibility'\n      },\n      {\n        phrases: ['focus first', 'go to first element'],\n        action: () => this.focusElement('first'),\n        description: 'Focus the first interactive element',\n        category: 'accessibility'\n      },\n      {\n        phrases: ['focus last', 'go to last element'],\n        action: () => this.focusElement('last'),\n        description: 'Focus the last interactive element',\n        category: 'accessibility'\n      },\n      {\n        phrases: ['repeat', 'say again', 'repeat last'],\n        action: () => this.repeatLastAnnouncement(),\n        description: 'Repeat the last announcement',\n        category: 'accessibility'\n      },\n\n      // General Commands\n      {\n        phrases: ['help', 'show help', 'what can you do'],\n        action: () => this.showHelp(),\n        description: 'Show help information',\n        category: 'general'\n      },\n      {\n        phrases: ['stop listening', 'turn off voice', 'disable voice'],\n        action: () => this.stopListening(),\n        description: 'Stop voice recognition',\n        category: 'general'\n      },\n      {\n        phrases: ['start listening', 'turn on voice', 'enable voice'],\n        action: () => this.startListening(),\n        description: 'Start voice recognition',\n        category: 'general'\n      },\n      {\n        phrases: ['what time is it', 'current time', 'time'],\n        action: () => this.announceTime(),\n        description: 'Announce the current time',\n        category: 'general'\n      },\n      {\n        phrases: ['cancel', 'nevermind', 'abort'],\n        action: () => this.cancelAction(),\n        description: 'Cancel the current action',\n        category: 'general'\n      },\n      {\n        phrases: ['yes', 'confirm', 'okay', 'proceed'],\n        action: () => this.confirmAction(),\n        description: 'Confirm the pending action',\n        category: 'general'\n      },\n      {\n        phrases: ['no', 'cancel', 'stop', 'abort'],\n        action: () => this.rejectAction(),\n        description: 'Reject the pending action',\n        category: 'general'\n      }\n    ];\n\n    commands.forEach((command, index) => {\n      this.addCommand(`cmd-${index}`, {\n        ...command,\n        enabled: true\n      });\n    });\n  }\n\n  /**\n   * Setup speech recognition\n   */\n  private setupSpeechRecognition(): void {\n    if (!this.checkVoiceSupport()) return;\n\n    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n    this.recognition = new SpeechRecognition();\n\n    this.recognition.continuous = this.state.continuous;\n    this.recognition.interimResults = false;\n    this.recognition.lang = this.state.language;\n\n    this.recognition.onstart = () => {\n      this.currentlyListening = true;\n      this.state.isListening = true;\n      this.provideFeedback('Voice recognition started. Listening for commands.');\n    };\n\n    this.recognition.onend = () => {\n      this.currentlyListening = false;\n      this.state.isListening = false;\n\n      if (this.state.continuous && this.state.isEnabled) {\n        // Restart if continuous mode is enabled\n        setTimeout(() => this.startListening(), 1000);\n      }\n    };\n\n    this.recognition.onerror = (event) => {\n      console.warn('Speech recognition error:', event.error);\n      this.provideFeedback(`Voice recognition error: ${event.error}`);\n      this.currentlyListening = false;\n      this.state.isListening = false;\n    };\n\n    this.recognition.onresult = event => {\n      const result = event.results[event.results.length - 1];\n      if (result.isFinal && result[0].confidence >= this.state.confidence) {\n        const transcript = result[0].transcript.toLowerCase().trim();\n        this.processVoiceCommand(transcript);\n      }\n    };\n  }\n\n  /**\n   * Process voice command from speech recognition\n   */\n  private processVoiceCommand(transcript: string): void {\n    console.log('Voice command received:', transcript);\n\n    // Check if we're waiting for confirmation\n    if (this.confirmationPending) {\n      this.handleConfirmation(transcript);\n      return;\n    }\n\n    // Find matching command\n    const matchedCommand = this.findMatchingCommand(transcript);\n\n    if (matchedCommand) {\n      if (matchedCommand.confirmation && this.state.requireConfirmation) {\n        this.requestConfirmation(matchedCommand);\n      } else {\n        this.executeCommand(matchedCommand);\n      }\n    } else {\n      this.provideFeedback(`Command not recognized: \"${transcript}\". Say \"voice help\" for available commands.`);\n    }\n  }\n\n  /**\n   * Find matching voice command\n   */\n  private findMatchingCommand(transcript: string): VoiceCommand | undefined {\n    for (const command of this.commands.values()) {\n      if (!command.enabled || !this.state.enabledCategories.includes(command.category)) {\n        continue;\n      }\n\n      for (const phrase of command.phrases) {\n        if (this.matchesPhrase(transcript, phrase)) {\n          return command;\n        }\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Check if transcript matches a command phrase\n   */\n  private matchesPhrase(transcript: string, phrase: string): boolean {\n    // Exact match\n    if (transcript === phrase) return true;\n\n    // Fuzzy matching for natural speech\n    const transcriptWords = transcript.split(' ');\n    const phraseWords = phrase.split(' ');\n\n    // Check if all phrase words are in transcript\n    return phraseWords.every(word =>\n      transcriptWords.some(tWord =>\n        tWord.includes(word) || word.includes(tWord)\n      )\n    );\n  }\n\n  /**\n   * Request confirmation for destructive actions\n   */\n  private requestConfirmation(command: VoiceCommand): void {\n    this.confirmationPending = command;\n    this.provideFeedback(`Are you sure you want to ${command.description.toLowerCase()}? Say \"yes\" to confirm or \"no\" to cancel.`);\n\n    // Auto-cancel confirmation after 10 seconds\n    setTimeout(() => {\n      if (this.confirmationPending === command) {\n        this.confirmationPending = undefined;\n        this.provideFeedback('Confirmation timeout. Action cancelled.');\n      }\n    }, 10000);\n  }\n\n  /**\n   * Handle confirmation response\n   */\n  private handleConfirmation(transcript: string): void {\n    const isConfirmed = ['yes', 'confirm', 'okay', 'proceed', 'do it'].some(word =>\n      transcript.includes(word)\n    );\n\n    const isRejected = ['no', 'cancel', 'stop', 'abort', 'nevermind'].some(word =>\n      transcript.includes(word)\n    );\n\n    if (isConfirmed && this.confirmationPending) {\n      const command = this.confirmationPending;\n      this.confirmationPending = undefined;\n      this.executeCommand(command);\n    } else if (isRejected) {\n      this.confirmationPending = undefined;\n      this.provideFeedback('Action cancelled.');\n    } else {\n      this.provideFeedback('Please say \"yes\" to confirm or \"no\" to cancel.');\n    }\n  }\n\n  /**\n   * Execute a voice command\n   */\n  private executeCommand(command: VoiceCommand): void {\n    try {\n      command.action();\n      this.provideFeedback(`Executed: ${command.description}`);\n    } catch (error) {\n      console.error('Error executing voice command:', error);\n      this.provideFeedback(`Error executing command: ${command.description}`);\n    }\n  }\n\n  /**\n   * Add a new voice command\n   */\n  addCommand(id: string, command: VoiceCommand): void {\n    this.commands.set(id, command);\n  }\n\n  /**\n   * Remove a voice command\n   */\n  removeCommand(id: string): void {\n    this.commands.delete(id);\n  }\n\n  /**\n   * Start voice recognition\n   */\n  startListening(): void {\n    if (!this.state.isEnabled || !this.recognition || this.currentlyListening) {\n      return;\n    }\n\n    try {\n      this.recognition.start();\n    } catch (error) {\n      console.warn('Could not start voice recognition:', error);\n      this.provideFeedback('Could not start voice recognition. Please check microphone permissions.');\n    }\n  }\n\n  /**\n   * Stop voice recognition\n   */\n  stopListening(): void {\n    if (this.recognition && this.currentlyListening) {\n      this.recognition.stop();\n    }\n    this.currentlyListening = false;\n    this.state.isListening = false;\n    this.provideFeedback('Voice recognition stopped.');\n  }\n\n  /**\n   * Provide audio feedback to user\n   */\n  private provideFeedback(message: string, priority: 'low' | 'medium' | 'high' = 'medium'): void {\n    // Clear any existing feedback timer\n    if (this.feedbackTimer) {\n      clearTimeout(this.feedbackTimer);\n    }\n\n    // Use screen reader for announcement\n    this.screenReader.announce(message, priority === 'high' ? 'assertive' : 'polite');\n\n    // Also use speech synthesis for immediate feedback\n    if (this.synthesis && !this.synthesis.speaking) {\n      const utterance = new SpeechSynthesisUtterance(message);\n      utterance.rate = this.state.voiceSpeed;\n      utterance.lang = this.state.language;\n\n      // Set voice if specified\n      if (this.state.preferredVoice) {\n        const voices = this.synthesis.getVoices();\n        const voice = voices.find(v => v.name === this.state.preferredVoice);\n        if (voice) utterance.voice = voice;\n      }\n\n      this.synthesis.speak(utterance);\n    }\n  }\n\n  /**\n   * Command implementation methods\n   */\n  private navigateToSection(section: string): void {\n    const event = new CustomEvent('keyboard-navigate', {\n      detail: { section, source: 'voice' }\n    });\n    document.dispatchEvent(event);\n  }\n\n  private goBack(): void {\n    window.history.back();\n  }\n\n  private createAlarm(): void {\n    const event = new CustomEvent('alarm-action', {\n      detail: { action: 'create', source: 'voice' }\n    });\n    document.dispatchEvent(event);\n  }\n\n  private deleteAlarm(): void {\n    const selectedAlarm = document.querySelector('[data-selected=\"true\"]') as HTMLElement;\n    if (selectedAlarm) {\n      const event = new CustomEvent('alarm-action', {\n        detail: { action: 'delete', target: selectedAlarm, source: 'voice' }\n      });\n      document.dispatchEvent(event);\n    } else {\n      this.provideFeedback('No alarm selected. Please select an alarm first.');\n    }\n  }\n\n  private toggleAlarm(): void {\n    const selectedAlarm = document.querySelector('[data-selected=\"true\"]') as HTMLElement;\n    if (selectedAlarm) {\n      const event = new CustomEvent('alarm-action', {\n        detail: { action: 'toggle', target: selectedAlarm, source: 'voice' }\n      });\n      document.dispatchEvent(event);\n    } else {\n      this.provideFeedback('No alarm selected. Please select an alarm first.');\n    }\n  }\n\n  private editAlarm(): void {\n    const selectedAlarm = document.querySelector('[data-selected=\"true\"]') as HTMLElement;\n    if (selectedAlarm) {\n      const event = new CustomEvent('alarm-action', {\n        detail: { action: 'edit', target: selectedAlarm, source: 'voice' }\n      });\n      document.dispatchEvent(event);\n    } else {\n      this.provideFeedback('No alarm selected. Please select an alarm first.');\n    }\n  }\n\n  private listAlarms(): void {\n    const alarms = document.querySelectorAll('[data-alarm-item]');\n    if (alarms.length === 0) {\n      this.provideFeedback('No alarms found.');\n      return;\n    }\n\n    let alarmsList = `Found ${alarms.length} alarm${alarms.length > 1 ? 's' : ''}: `;\n    alarms.forEach((alarm, index) => {\n      const timeElement = alarm.querySelector('[data-alarm-time]');\n      const labelElement = alarm.querySelector('[data-alarm-label]');\n      const statusElement = alarm.querySelector('[data-alarm-status]');\n\n      const time = timeElement?.textContent || 'Unknown time';\n      const label = labelElement?.textContent || 'No label';\n      const status = statusElement?.getAttribute('data-active') === 'true' ? 'active' : 'inactive';\n\n      alarmsList += `${index + 1}: ${time}, ${label}, ${status}. `;\n    });\n\n    this.provideFeedback(alarmsList);\n  }\n\n  private selectAlarm(direction: 'first' | 'last' | 'next' | 'previous'): void {\n    const alarms = Array.from(document.querySelectorAll('[data-alarm-item]')) as HTMLElement[];\n    if (alarms.length === 0) {\n      this.provideFeedback('No alarms available.');\n      return;\n    }\n\n    const currentSelected = document.querySelector('[data-selected=\"true\"]') as HTMLElement;\n    const currentIndex = currentSelected ? alarms.indexOf(currentSelected) : -1;\n    let newIndex = 0;\n\n    switch (direction) {\n      case 'first':\n        newIndex = 0;\n        break;\n      case 'last':\n        newIndex = alarms.length - 1;\n        break;\n      case 'next':\n        newIndex = currentIndex < alarms.length - 1 ? currentIndex + 1 : 0;\n        break;\n      case 'previous':\n        newIndex = currentIndex > 0 ? currentIndex - 1 : alarms.length - 1;\n        break;\n    }\n\n    // Remove previous selection\n    if (currentSelected) {\n      currentSelected.removeAttribute('data-selected');\n    }\n\n    // Select new alarm\n    const newSelected = alarms[newIndex];\n    newSelected.setAttribute('data-selected', 'true');\n    newSelected.focus();\n\n    const timeElement = newSelected.querySelector('[data-alarm-time]');\n    const labelElement = newSelected.querySelector('[data-alarm-label]');\n    const time = timeElement?.textContent || 'Unknown time';\n    const label = labelElement?.textContent || 'No label';\n\n    this.provideFeedback(`Selected alarm: ${time}, ${label}`);\n  }\n\n  private adjustVoiceSpeed(delta: number): void {\n    this.state.voiceSpeed = Math.max(0.5, Math.min(2.0, this.state.voiceSpeed + delta));\n    this.provideFeedback(`Voice speed set to ${this.state.voiceSpeed.toFixed(1)}x`);\n  }\n\n  private readCurrentPage(): void {\n    const mainContent = document.querySelector('main') || document.body;\n    const textContent = this.extractReadableText(mainContent);\n    this.provideFeedback(textContent);\n  }\n\n  private extractReadableText(element: Element): string {\n    const walker = document.createTreeWalker(\n      element,\n      NodeFilter.SHOW_TEXT,\n      {\n        acceptNode: (node) => {\n          const parent = node.parentElement;\n          if (!parent) return NodeFilter.FILTER_REJECT;\n\n          // Skip hidden elements\n          const style = window.getComputedStyle(parent);\n          if (style.display === 'none' || style.visibility === 'hidden') {\n            return NodeFilter.FILTER_REJECT;\n          }\n\n          // Skip script and style elements\n          if (parent.tagName === 'SCRIPT' || parent.tagName === 'STYLE') {\n            return NodeFilter.FILTER_REJECT;\n          }\n\n          return NodeFilter.FILTER_ACCEPT;\n        }\n      }\n    );\n\n    const textNodes: string[] = [];\n    let node;\n    while (node = walker.nextNode()) {\n      const text = node.textContent?.trim();\n      if (text) {\n        textNodes.push(text);\n      }\n    }\n\n    return textNodes.join(' ').replace(/\\s+/g, ' ').trim();\n  }\n\n  private readKeyboardShortcuts(): void {\n    const shortcuts = this.keyboardNav.getShortcuts();\n    const shortcutText = shortcuts\n      .map(s => `${s.description}: ${s.modifiers.join(' plus ')} ${s.key}`)\n      .join('. ');\n    this.provideFeedback(`Available keyboard shortcuts: ${shortcutText}`);\n  }\n\n  private readVoiceCommands(): void {\n    const commands = Array.from(this.commands.values())\n      .filter(cmd => cmd.enabled && this.state.enabledCategories.includes(cmd.category))\n      .map(cmd => cmd.description)\n      .join(', ');\n    this.provideFeedback(`Available voice commands: ${commands}`);\n  }\n\n  private focusElement(position: 'first' | 'last'): void {\n    const focusableElements = Array.from(document.querySelectorAll(\n      'button:not([disabled]), [href]:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex=\"-1\"]):not([disabled])'\n    )) as HTMLElement[];\n\n    if (focusableElements.length === 0) {\n      this.provideFeedback('No focusable elements found.');\n      return;\n    }\n\n    const targetElement = position === 'first'\n      ? focusableElements[0]\n      : focusableElements[focusableElements.length - 1];\n\n    targetElement.focus();\n    this.provideFeedback(`Focused ${position} element: ${this.getElementDescription(targetElement)}`);\n  }\n\n  private getElementDescription(element: HTMLElement): string {\n    return element.getAttribute('aria-label') ||\n           element.textContent?.trim() ||\n           element.tagName.toLowerCase();\n  }\n\n  private repeatLastAnnouncement(): void {\n    // This would need to store the last announcement\n    this.provideFeedback('Repeat functionality not yet implemented.');\n  }\n\n  private showHelp(): void {\n    const helpText = `\n      Voice Accessibility Help.\n      Available categories: Navigation, Alarm Management, Accessibility, and General commands.\n      Say \"voice commands\" to hear all available commands.\n      Say \"keyboard shortcuts\" to hear keyboard options.\n      Say \"stop listening\" to disable voice recognition.\n    `;\n    this.provideFeedback(helpText);\n  }\n\n  private announceTime(): void {\n    const now = new Date();\n    const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });\n    this.provideFeedback(`Current time is ${timeString}`);\n  }\n\n  private cancelAction(): void {\n    if (this.confirmationPending) {\n      this.confirmationPending = undefined;\n      this.provideFeedback('Action cancelled.');\n    } else {\n      this.provideFeedback('No action to cancel.');\n    }\n  }\n\n  private confirmAction(): void {\n    if (this.confirmationPending) {\n      const command = this.confirmationPending;\n      this.confirmationPending = undefined;\n      this.executeCommand(command);\n    } else {\n      this.provideFeedback('No action to confirm.');\n    }\n  }\n\n  private rejectAction(): void {\n    this.cancelAction();\n  }\n\n  /**\n   * Update voice accessibility settings\n   */\n  updateSettings(settings: Partial<VoiceAccessibilityState>): void {\n    this.state = { ...this.state, ...settings };\n\n    if (this.recognition) {\n      this.recognition.continuous = this.state.continuous;\n      this.recognition.lang = this.state.language;\n    }\n\n    this.provideFeedback('Voice accessibility settings updated.');\n  }\n\n  /**\n   * Get current state\n   */\n  getState(): VoiceAccessibilityState {\n    return { ...this.state };\n  }\n\n  /**\n   * Get available voice commands\n   */\n  getCommands(): VoiceCommand[] {\n    return Array.from(this.commands.values())\n      .filter(cmd => cmd.enabled);\n  }\n\n  /**\n   * Cleanup method\n   */\n  cleanup(): void {\n    if (this.recognition) {\n      this.recognition.stop();\n    }\n    if (this.synthesis) {\n      this.synthesis.cancel();\n    }\n    if (this.feedbackTimer) {\n      clearTimeout(this.feedbackTimer);\n    }\n  }\n}\n\nexport default VoiceAccessibilityService;",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/tests/integration/enhanced-alarm-lifecycle.integration.test.tsx",
    "messages": [
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\+.",
        "line": 479,
        "column": 54,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 479,
        "endColumn": 55,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [15567, 15568], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [15567, 15567], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      },
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\*.",
        "line": 479,
        "column": 58,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 479,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [15571, 15572], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [15571, 15571], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      },
      {
        "ruleId": "no-useless-escape",
        "severity": 2,
        "message": "Unnecessary escape character: \\/.",
        "line": 479,
        "column": 60,
        "nodeType": "Literal",
        "messageId": "unnecessaryEscape",
        "endLine": 479,
        "endColumn": 61,
        "suggestions": [
          {
            "messageId": "removeEscape",
            "fix": { "range": [15573, 15574], "text": "" },
            "desc": "Remove the `\\`. This maintains the current functionality."
          },
          {
            "messageId": "escapeBackslash",
            "fix": { "range": [15573, 15573], "text": "\\" },
            "desc": "Replace the `\\` with `\\\\` to include the actual backslash character."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 3,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Enhanced Alarm Lifecycle Integration Tests\n * \n * Comprehensive integration tests for the complete alarm lifecycle using\n * enhanced test utilities and MSW handlers. Tests all critical paths from\n * the integration test matrix.\n */\n\nimport { describe, it, expect, beforeEach, afterEach, vi, beforeAll, afterAll } from 'vitest';\nimport { render, screen, fireEvent, waitFor, act } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport React from 'react';\nimport { BrowserRouter } from 'react-router-dom';\n\n// Import main components\nimport App from '../../src/App';\n\n// Import types\nimport type { User, Alarm, VoiceMood } from '../../src/types';\n\n// Import enhanced test utilities\nimport {\n  createPremiumUser,\n  createTrialUser,\n  createComplexAlarm,\n  createNuclearAlarm,\n  fillAlarmForm,\n  simulateAlarmTrigger,\n  expectAlarmRingingState,\n  mockSpeechRecognition,\n  setupVoiceRecognitionMock,\n  simulateVoiceCommand,\n  mockPostHog,\n  expectAnalyticsEvent,\n  measureRenderTime,\n  expectRenderTimeUnder,\n  renderWithProviders,\n  waitForLoadingToFinish,\n  expectNoConsoleErrors,\n  expectAccessibleForm\n} from '../utils/enhanced-test-utilities';\n\nimport { createMockUser, createMockAlarm, setupAllMocks } from '../utils/test-mocks';\nimport { testDataHelpers, integrationTestUtils } from '../utils/integration-test-setup';\n\n// Mock external services\nvi.mock('../../src/services/supabase');\nvi.mock('../../src/services/push-notifications');\nvi.mock('@capacitor/local-notifications');\nvi.mock('@capacitor/device');\nvi.mock('@capacitor/preferences');\nvi.mock('posthog-js');\n\ndescribe('Enhanced Alarm Lifecycle Integration Tests', () => {\n  let user: ReturnType<typeof userEvent.setup>;\n  let mockUser: User;\n  let mockPostHogInstance: any;\n  let mockSpeechRecognition: any;\n  let checkConsoleErrors: () => void;\n\n  beforeAll(async () => {\n    // Setup all browser API mocks\n    setupAllMocks();\n    \n    // Setup enhanced mocks\n    mockPostHogInstance = mockPostHog();\n    mockSpeechRecognition = setupVoiceRecognitionMock();\n  });\n\n  beforeEach(async () => {\n    user = userEvent.setup();\n    mockUser = createMockUser();\n    checkConsoleErrors = expectNoConsoleErrors();\n    \n    // Clear all test data before each test\n    testDataHelpers.clearAll();\n    testDataHelpers.addUser(mockUser);\n    \n    // Reset all mocks\n    vi.clearAllMocks();\n    vi.clearAllTimers();\n    vi.useRealTimers();\n  });\n\n  afterEach(() => {\n    checkConsoleErrors();\n    vi.clearAllTimers();\n  });\n\n  afterAll(() => {\n    vi.restoreAllMocks();\n  });\n\n  describe('P0 Critical: Basic Alarm Creation Flow', () => {\n    it('should complete basic alarm creation within performance budget', async () => {\n      // Measure render performance\n      const renderTime = await measureRenderTime(async () => {\n        renderWithProviders(<App />, { user: mockUser });\n        await waitForLoadingToFinish();\n      });\n      expectRenderTimeUnder(renderTime, 3000); // 3 second budget\n\n      // Verify dashboard loads\n      await waitFor(() => {\n        expect(screen.getByText(/dashboard/i)).toBeInTheDocument();\n      });\n\n      // Measure alarm creation performance\n      const creationTime = await measureRenderTime(async () => {\n        // Open alarm form\n        const addAlarmButton = screen.getByRole('button', { name: /add.*alarm/i });\n        await user.click(addAlarmButton);\n\n        // Wait for form to appear\n        await waitFor(() => {\n          expect(screen.getByRole('dialog')).toBeInTheDocument();\n        });\n\n        // Verify form accessibility\n        await expectAccessibleForm(screen);\n\n        // Fill alarm form\n        await fillAlarmForm(user, {\n          time: '07:00',\n          label: 'Morning Workout',\n          days: [1, 2, 3, 4, 5], // Weekdays\n          voiceMood: 'motivational',\n          snoozeEnabled: true\n        });\n\n        // Save alarm\n        const saveButton = screen.getByRole('button', { name: /save|create/i });\n        await user.click(saveButton);\n\n        // Wait for success\n        await waitFor(() => {\n          expect(screen.getByText('Morning Workout')).toBeInTheDocument();\n        });\n      });\n      expectRenderTimeUnder(creationTime, 2000); // 2 second budget\n\n      // Verify alarm appears in list with correct details\n      const alarmElement = screen.getByText('Morning Workout');\n      expect(alarmElement).toBeInTheDocument();\n      \n      // Verify time is displayed\n      expect(screen.getByText('7:00')).toBeInTheDocument();\n\n      // Verify analytics was tracked\n      await integrationTestUtils.waitForAnalyticsEvents(1);\n      expectAnalyticsEvent(mockPostHogInstance, 'alarm_created', {\n        label: 'Morning Workout',\n        time: '07:00',\n        snoozeEnabled: true,\n        voiceMood: 'motivational'\n      });\n\n      // Verify user data was updated\n      const userAlarms = testDataHelpers.getAlarmsForUser(mockUser.id);\n      expect(userAlarms).toHaveLength(1);\n      expect(userAlarms[0].label).toBe('Morning Workout');\n    });\n\n    it('should handle alarm creation validation errors gracefully', async () => {\n      renderWithProviders(<App />, { user: mockUser });\n      await waitForLoadingToFinish();\n\n      // Open alarm form\n      const addAlarmButton = screen.getByRole('button', { name: /add.*alarm/i });\n      await user.click(addAlarmButton);\n\n      await waitFor(() => {\n        expect(screen.getByRole('dialog')).toBeInTheDocument();\n      });\n\n      // Try to save without required fields\n      const saveButton = screen.getByRole('button', { name: /save|create/i });\n      await user.click(saveButton);\n\n      // Should show validation errors\n      await waitFor(() => {\n        const errorElement = screen.queryByText(/time.*required|required.*time/i);\n        expect(errorElement).toBeInTheDocument();\n      });\n\n      // Form should remain open\n      expect(screen.getByRole('dialog')).toBeInTheDocument();\n\n      // Fill required fields\n      const timeInput = screen.getByLabelText(/time/i);\n      await user.type(timeInput, '08:00');\n\n      // Now save should work\n      await user.click(saveButton);\n\n      await waitFor(() => {\n        expect(screen.queryByRole('dialog')).not.toBeInTheDocument();\n      });\n    });\n\n    it('should enforce free user alarm limits', async () => {\n      // Create free user with 5 existing alarms (at limit)\n      const freeUser = createMockUser({ subscriptionTier: 'free' });\n      for (let i = 0; i < 5; i++) {\n        const alarm = createMockAlarm({\n          id: `alarm-${i}`,\n          userId: freeUser.id,\n          label: `Alarm ${i + 1}`,\n          time: `0${6 + i}:00`\n        });\n        testDataHelpers.addAlarm(alarm);\n      }\n      testDataHelpers.addUser(freeUser);\n\n      renderWithProviders(<App />, { user: freeUser });\n      await waitForLoadingToFinish();\n\n      // Should see existing alarms\n      await waitFor(() => {\n        expect(screen.getByText('Alarm 1')).toBeInTheDocument();\n      });\n\n      // Try to create 6th alarm\n      const addAlarmButton = screen.getByRole('button', { name: /add.*alarm/i });\n      await user.click(addAlarmButton);\n\n      await waitFor(() => {\n        expect(screen.getByRole('dialog')).toBeInTheDocument();\n      });\n\n      await fillAlarmForm(user, {\n        time: '12:00',\n        label: '6th Alarm'\n      });\n\n      const saveButton = screen.getByRole('button', { name: /save|create/i });\n      await user.click(saveButton);\n\n      // Should show upgrade prompt\n      await waitFor(() => {\n        const upgradeMessage = screen.queryByText(/upgrade.*premium|limit.*reached|5 alarms/i);\n        expect(upgradeMessage).toBeInTheDocument();\n      });\n\n      // Should not create the alarm\n      const userAlarms = testDataHelpers.getAlarmsForUser(freeUser.id);\n      expect(userAlarms).toHaveLength(5); // Still 5, not 6\n    });\n  });\n\n  describe('P0 Critical: Alarm Triggering and Interaction', () => {\n    it('should handle complete alarm trigger and dismiss cycle', async () => {\n      // Create user with an alarm\n      const alarm = createMockAlarm({\n        userId: mockUser.id,\n        time: '07:30',\n        label: 'Test Trigger Alarm',\n        enabled: true\n      });\n      testDataHelpers.addAlarm(alarm);\n\n      renderWithProviders(<App />, { user: mockUser });\n      await waitForLoadingToFinish();\n\n      // Verify alarm is visible\n      await waitFor(() => {\n        expect(screen.getByText('Test Trigger Alarm')).toBeInTheDocument();\n      });\n\n      // Simulate alarm triggering\n      await simulateAlarmTrigger(alarm);\n\n      // Should show alarm ringing interface\n      await expectAlarmRingingState(screen);\n\n      // Should show dismiss and snooze buttons\n      const dismissButton = screen.getByRole('button', { name: /dismiss|stop/i });\n      const snoozeButton = screen.getByRole('button', { name: /snooze/i });\n      \n      expect(dismissButton).toBeInTheDocument();\n      expect(snoozeButton).toBeInTheDocument();\n\n      // Test dismiss functionality\n      await user.click(dismissButton);\n\n      // Should return to dashboard\n      await waitFor(() => {\n        expect(screen.getByText(/dashboard/i)).toBeInTheDocument();\n      });\n\n      // Should track analytics\n      await integrationTestUtils.waitForAnalyticsEvents(1);\n      expectAnalyticsEvent(mockPostHogInstance, 'alarm_dismissed', {\n        alarmId: alarm.id,\n        method: 'button'\n      });\n    });\n\n    it('should handle snooze functionality with limits', async () => {\n      const alarm = createMockAlarm({\n        userId: mockUser.id,\n        time: '07:00',\n        label: 'Snooze Test Alarm',\n        enabled: true,\n        snoozeEnabled: true,\n        maxSnoozes: 2,\n        snoozeInterval: 5\n      });\n      testDataHelpers.addAlarm(alarm);\n\n      renderWithProviders(<App />, { user: mockUser });\n      await waitForLoadingToFinish();\n\n      // Trigger alarm\n      await simulateAlarmTrigger(alarm);\n      await expectAlarmRingingState(screen);\n\n      // First snooze\n      const snoozeButton = screen.getByRole('button', { name: /snooze/i });\n      await user.click(snoozeButton);\n\n      await waitFor(() => {\n        expect(screen.getByText(/dashboard/i)).toBeInTheDocument();\n      });\n\n      // Trigger alarm again after snooze\n      await simulateAlarmTrigger(alarm, { isSnoozeEnd: true });\n      await expectAlarmRingingState(screen);\n\n      // Second snooze (at limit)\n      const snoozeButton2 = screen.getByRole('button', { name: /snooze/i });\n      await user.click(snoozeButton2);\n\n      // Trigger third time - should not allow snooze\n      await simulateAlarmTrigger(alarm, { isSnoozeEnd: true });\n      await expectAlarmRingingState(screen);\n\n      // Snooze button should be disabled or not present\n      const snoozeButton3 = screen.queryByRole('button', { name: /snooze/i });\n      if (snoozeButton3) {\n        expect(snoozeButton3).toBeDisabled();\n      }\n\n      // Should show snooze limit message\n      const limitMessage = screen.queryByText(/snooze.*limit|no.*more.*snoozes/i);\n      expect(limitMessage).toBeInTheDocument();\n    });\n\n    it('should handle voice command dismissal', async () => {\n      const alarm = createMockAlarm({\n        userId: mockUser.id,\n        time: '08:00',\n        label: 'Voice Test Alarm',\n        enabled: true\n      });\n      testDataHelpers.addAlarm(alarm);\n\n      renderWithProviders(<App />, { user: mockUser });\n      await waitForLoadingToFinish();\n\n      // Trigger alarm\n      await simulateAlarmTrigger(alarm);\n      await expectAlarmRingingState(screen);\n\n      // Should show voice command option\n      const voiceButton = screen.queryByText(/voice|speak/i);\n      if (voiceButton) {\n        await user.click(voiceButton);\n      }\n\n      // Simulate voice command\n      simulateVoiceCommand(mockSpeechRecognition, 'stop alarm', 0.95);\n\n      // Should dismiss alarm\n      await waitFor(() => {\n        expect(screen.getByText(/dashboard/i)).toBeInTheDocument();\n      });\n\n      // Should track voice dismissal\n      await integrationTestUtils.waitForAnalyticsEvents(2); // trigger + dismiss\n      expectAnalyticsEvent(mockPostHogInstance, 'alarm_dismissed', {\n        method: 'voice'\n      });\n    });\n  });\n\n  describe('P1 High: Premium Alarm Features', () => {\n    it('should show premium features for premium users', async () => {\n      const premiumUser = createPremiumUser();\n      testDataHelpers.addUser(premiumUser);\n\n      renderWithProviders(<App />, { user: premiumUser });\n      await waitForLoadingToFinish();\n\n      // Open alarm creation\n      const addAlarmButton = screen.getByRole('button', { name: /add.*alarm/i });\n      await user.click(addAlarmButton);\n\n      await waitFor(() => {\n        expect(screen.getByRole('dialog')).toBeInTheDocument();\n      });\n\n      // Should see premium features\n      const nuclearModeToggle = screen.queryByLabelText(/nuclear.*mode/i);\n      const smartWakeupToggle = screen.queryByLabelText(/smart.*wake.*up/i);\n      const customSoundOption = screen.queryByText(/custom.*sound|upload.*sound/i);\n\n      // At least one premium feature should be visible\n      expect(nuclearModeToggle || smartWakeupToggle || customSoundOption).toBeTruthy();\n\n      // Test enabling premium features\n      if (nuclearModeToggle && !nuclearModeToggle.checked) {\n        await user.click(nuclearModeToggle);\n        expect(nuclearModeToggle).toBeChecked();\n      }\n\n      if (smartWakeupToggle && !smartWakeupToggle.checked) {\n        await user.click(smartWakeupToggle);\n        expect(smartWakeupToggle).toBeChecked();\n      }\n    });\n\n    it('should show upgrade prompts for free users accessing premium features', async () => {\n      const freeUser = createMockUser({ subscriptionTier: 'free' });\n      testDataHelpers.addUser(freeUser);\n\n      renderWithProviders(<App />, { user: freeUser });\n      await waitForLoadingToFinish();\n\n      // Open alarm creation\n      const addAlarmButton = screen.getByRole('button', { name: /add.*alarm/i });\n      await user.click(addAlarmButton);\n\n      await waitFor(() => {\n        expect(screen.getByRole('dialog')).toBeInTheDocument();\n      });\n\n      // Try to access premium features\n      const premiumSection = screen.queryByText(/premium|pro.*features/i);\n      if (premiumSection) {\n        await user.click(premiumSection);\n\n        // Should show upgrade prompt\n        await waitFor(() => {\n          const upgradePrompt = screen.queryByText(/upgrade|premium|subscription/i);\n          expect(upgradePrompt).toBeInTheDocument();\n        });\n      }\n    });\n\n    it('should handle nuclear mode alarm challenges', async () => {\n      const premiumUser = createPremiumUser();\n      const nuclearAlarm = createNuclearAlarm({\n        userId: premiumUser.id,\n        nuclearChallenges: ['math', 'qr_scan']\n      });\n      \n      testDataHelpers.addUser(premiumUser);\n      testDataHelpers.addAlarm(nuclearAlarm);\n\n      renderWithProviders(<App />, { user: premiumUser });\n      await waitForLoadingToFinish();\n\n      // Trigger nuclear alarm\n      await simulateAlarmTrigger(nuclearAlarm);\n      await expectAlarmRingingState(screen);\n\n      // Try to dismiss - should show challenges first\n      const dismissButton = screen.getByRole('button', { name: /dismiss|stop/i });\n      await user.click(dismissButton);\n\n      // Should show challenge interface\n      await waitFor(() => {\n        const challengeText = screen.queryByText(/challenge|solve|complete/i);\n        expect(challengeText).toBeInTheDocument();\n      });\n\n      // Should show math challenge\n      const mathProblem = screen.queryByText(/\\d+\\s*[\\+\\-\\*\\/]\\s*\\d+/);\n      if (mathProblem) {\n        expect(mathProblem).toBeInTheDocument();\n        \n        // Would need to solve the math problem in a real test\n        // For now, we'll simulate successful completion\n        const submitButton = screen.queryByRole('button', { name: /submit|check|solve/i });\n        if (submitButton) {\n          // Simulate correct answer\n          const answerInput = screen.queryByLabelText(/answer|result/i);\n          if (answerInput) {\n            await user.type(answerInput, '42'); // Mock correct answer\n            await user.click(submitButton);\n          }\n        }\n      }\n\n      // After completing challenges, should allow dismissal\n      await waitFor(() => {\n        const finalDismissButton = screen.queryByRole('button', { name: /dismiss|complete/i });\n        expect(finalDismissButton).toBeInTheDocument();\n      }, { timeout: 10000 });\n    });\n  });\n\n  describe('P0 Critical: Error Handling and Resilience', () => {\n    it('should handle network failures during alarm creation', async () => {\n      renderWithProviders(<App />, { user: mockUser });\n      await waitForLoadingToFinish();\n\n      // Simulate network failure\n      integrationTestUtils.simulateNetworkError();\n\n      const addAlarmButton = screen.getByRole('button', { name: /add.*alarm/i });\n      await user.click(addAlarmButton);\n\n      await waitFor(() => {\n        expect(screen.getByRole('dialog')).toBeInTheDocument();\n      });\n\n      await fillAlarmForm(user, {\n        time: '09:00',\n        label: 'Network Test Alarm'\n      });\n\n      const saveButton = screen.getByRole('button', { name: /save|create/i });\n      await user.click(saveButton);\n\n      // Should show error message\n      await waitFor(() => {\n        const errorMessage = screen.queryByText(/error|failed|network|offline/i);\n        expect(errorMessage).toBeInTheDocument();\n      });\n\n      // Should offer offline mode or retry\n      const retryButton = screen.queryByRole('button', { name: /retry|try.*again/i });\n      const offlineButton = screen.queryByText(/offline|save.*locally/i);\n      \n      expect(retryButton || offlineButton).toBeTruthy();\n\n      // Reset network and retry should work\n      integrationTestUtils.resetNetworkSimulation();\n      \n      if (retryButton) {\n        await user.click(retryButton);\n        \n        await waitFor(() => {\n          expect(screen.getByText('Network Test Alarm')).toBeInTheDocument();\n        });\n      }\n    });\n\n    it('should handle service worker failures gracefully', async () => {\n      renderWithProviders(<App />, { user: mockUser });\n      await waitForLoadingToFinish();\n\n      // Create an alarm\n      const addAlarmButton = screen.getByRole('button', { name: /add.*alarm/i });\n      await user.click(addAlarmButton);\n\n      await waitFor(() => {\n        expect(screen.getByRole('dialog')).toBeInTheDocument();\n      });\n\n      await fillAlarmForm(user, {\n        time: '10:00',\n        label: 'Service Worker Test'\n      });\n\n      const saveButton = screen.getByRole('button', { name: /save|create/i });\n      await user.click(saveButton);\n\n      await waitFor(() => {\n        expect(screen.getByText('Service Worker Test')).toBeInTheDocument();\n      });\n\n      // Simulate service worker failure during alarm trigger\n      const alarm = testDataHelpers.getAlarmsForUser(mockUser.id)[0];\n      \n      // Mock service worker error\n      await act(async () => {\n        const errorMessage = {\n          type: 'ALARM_ERROR',\n          data: {\n            alarmId: alarm.id,\n            error: 'Service worker unavailable',\n            fallbackMethod: 'web_notification'\n          }\n        };\n        const messageEvent = new MessageEvent('message', { data: errorMessage });\n        window.dispatchEvent(messageEvent);\n      });\n\n      // Should show fallback notification or error handling\n      await waitFor(() => {\n        const fallbackMessage = screen.queryByText(/service.*worker|fallback|alternative.*method/i);\n        expect(fallbackMessage).toBeInTheDocument();\n      });\n    });\n\n    it('should maintain data consistency during app crashes', async () => {\n      renderWithProviders(<App />, { user: mockUser });\n      await waitForLoadingToFinish();\n\n      // Create multiple alarms rapidly\n      for (let i = 0; i < 3; i++) {\n        const addAlarmButton = screen.getByRole('button', { name: /add.*alarm/i });\n        await user.click(addAlarmButton);\n\n        await waitFor(() => {\n          expect(screen.getByRole('dialog')).toBeInTheDocument();\n        });\n\n        await fillAlarmForm(user, {\n          time: `0${7 + i}:00`,\n          label: `Crash Test Alarm ${i + 1}`\n        });\n\n        const saveButton = screen.getByRole('button', { name: /save|create/i });\n        await user.click(saveButton);\n\n        await waitFor(() => {\n          expect(screen.queryByRole('dialog')).not.toBeInTheDocument();\n        });\n      }\n\n      // Verify all alarms were created\n      const userAlarms = testDataHelpers.getAlarmsForUser(mockUser.id);\n      expect(userAlarms.length).toBeGreaterThanOrEqual(3);\n\n      // Verify each alarm has consistent data\n      userAlarms.forEach((alarm, index) => {\n        expect(alarm.label).toBe(`Crash Test Alarm ${index + 1}`);\n        expect(alarm.time).toBe(`0${7 + index}:00`);\n        expect(alarm.userId).toBe(mockUser.id);\n      });\n    });\n  });\n\n  describe('P2 Medium: Performance and Accessibility', () => {\n    it('should support keyboard navigation throughout alarm lifecycle', async () => {\n      renderWithProviders(<App />, { user: mockUser });\n      await waitForLoadingToFinish();\n\n      // Tab to add alarm button\n      await user.tab();\n      expect(document.activeElement).toHaveAccessibleName(/add.*alarm/i);\n\n      // Open form with Enter\n      await user.keyboard('{Enter}');\n\n      await waitFor(() => {\n        expect(screen.getByRole('dialog')).toBeInTheDocument();\n      });\n\n      // Tab through form fields\n      await user.tab();\n      expect(document.activeElement).toHaveAttribute('type', 'time');\n\n      await user.tab();\n      expect(document.activeElement).toHaveAccessibleName(/label/i);\n\n      // Fill form with keyboard\n      await user.type(document.activeElement!, 'Keyboard Test Alarm');\n\n      // Tab to save button and activate\n      while (document.activeElement?.textContent !== 'Save' && \n             document.activeElement?.textContent !== 'Create') {\n        await user.tab();\n      }\n\n      await user.keyboard('{Enter}');\n\n      // Should create alarm successfully\n      await waitFor(() => {\n        expect(screen.getByText('Keyboard Test Alarm')).toBeInTheDocument();\n      });\n    });\n\n    it('should handle large numbers of alarms efficiently', async () => {\n      const premiumUser = createPremiumUser();\n      \n      // Add 50 alarms for performance testing\n      const alarms = [];\n      for (let i = 0; i < 50; i++) {\n        const alarm = createMockAlarm({\n          id: `perf-alarm-${i}`,\n          userId: premiumUser.id,\n          label: `Performance Test ${i + 1}`,\n          time: `${String(Math.floor(i / 4) + 6).padStart(2, '0')}:${String((i % 4) * 15).padStart(2, '0')}`,\n          enabled: i % 2 === 0 // Half enabled, half disabled\n        });\n        alarms.push(alarm);\n        testDataHelpers.addAlarm(alarm);\n      }\n      testDataHelpers.addUser(premiumUser);\n\n      // Measure render time with many alarms\n      const renderTime = await measureRenderTime(async () => {\n        renderWithProviders(<App />, { user: premiumUser });\n        await waitForLoadingToFinish();\n      });\n\n      expectRenderTimeUnder(renderTime, 5000); // Should load within 5 seconds\n\n      // Should display all alarms\n      await waitFor(() => {\n        expect(screen.getByText('Performance Test 1')).toBeInTheDocument();\n      });\n\n      // Test scrolling performance\n      const alarmList = screen.getByRole('list') || screen.getByTestId('alarm-list');\n      if (alarmList) {\n        fireEvent.scroll(alarmList, { target: { scrollTop: 1000 } });\n        \n        // Should handle scrolling without performance issues\n        await waitFor(() => {\n          expect(screen.getByText('Performance Test 50')).toBeInTheDocument();\n        });\n      }\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/tests/integration/premium-upgrade.integration.test.tsx",
    "messages": [
      {
        "ruleId": "@typescript-eslint/ban-ts-comment",
        "severity": 2,
        "message": "Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.",
        "line": 274,
        "column": 7,
        "nodeType": "Line",
        "messageId": "tsIgnoreInsteadOfExpectError",
        "endLine": 274,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "replaceTsIgnoreWithTsExpectError",
            "fix": { "range": [8133, 8146], "text": "// @ts-expect-error" },
            "desc": "Replace \"@ts-ignore\" with \"@ts-expect-error\"."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/ban-ts-comment",
        "severity": 2,
        "message": "Use \"@ts-expect-error\" instead of \"@ts-ignore\", as \"@ts-ignore\" will do nothing if the following line is error-free.",
        "line": 378,
        "column": 7,
        "nodeType": "Line",
        "messageId": "tsIgnoreInsteadOfExpectError",
        "endLine": 378,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "replaceTsIgnoreWithTsExpectError",
            "fix": { "range": [11419, 11432], "text": "// @ts-expect-error" },
            "desc": "Replace \"@ts-ignore\" with \"@ts-expect-error\"."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 2,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Premium Feature Upgrade Integration Tests\n * \n * Tests the complete premium subscription flow:\n * 1. Free user explores premium features\n * 2. Upgrade flow with payment processing\n * 3. Feature unlocking and access control\n * 4. Subscription management\n * 5. Analytics and user persona tracking\n * 6. Downgrade handling\n * 7. Trial period management\n */\n\nimport { describe, it, expect, beforeEach, afterEach, vi, beforeAll, afterAll } from 'vitest';\nimport { render, screen, fireEvent, waitFor, act } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { BrowserRouter } from 'react-router-dom';\n\n// Import components and services\nimport App from '../../src/App';\nimport { SupabaseService } from '../../src/services/supabase';\nimport { AppAnalyticsService } from '../../src/services/app-analytics';\n\n// Import test utilities\nimport { createMockUser, createMockAlarm, mockNavigatorAPI, mockStripeAPI } from '../utils/test-mocks';\nimport { TestData } from '../e2e/fixtures/test-data';\n\n// Types\nimport type { Alarm, User, PersonaType } from '../../src/types';\n\n// Mock external services\nvi.mock('../../src/services/supabase');\nvi.mock('@stripe/stripe-js');\nvi.mock('posthog-js');\n\ndescribe('Premium Feature Upgrade Integration', () => {\n  let mockUser: User;\n  let container: HTMLElement;\n  let user: ReturnType<typeof userEvent.setup>;\n  \n  // Service instances\n  let analyticsService: AppAnalyticsService;\n\n  beforeAll(() => {\n    mockNavigatorAPI();\n    mockStripeAPI();\n  });\n\n  beforeEach(async () => {\n    user = userEvent.setup();\n    \n    // Create free tier user\n    mockUser = createMockUser({\n      subscriptionTier: 'free',\n      premiumFeatures: [],\n      trialEndsAt: null\n    });\n    \n    // Reset all mocks\n    vi.clearAllMocks();\n    \n    analyticsService = AppAnalyticsService.getInstance();\n    \n    // Mock successful authentication\n    vi.mocked(SupabaseService.getCurrentUser).mockResolvedValue(mockUser);\n    vi.mocked(SupabaseService.loadUserAlarms).mockResolvedValue({ \n      alarms: [], \n      error: null \n    });\n    \n    // Mock analytics\n    vi.mocked(analyticsService.trackFeatureUsage).mockImplementation(() => {});\n    vi.mocked(analyticsService.trackConversion).mockImplementation(() => {});\n  });\n\n  afterEach(() => {\n    if (container) {\n      container.remove();\n    }\n    localStorage.clear();\n    sessionStorage.clear();\n  });\n\n  afterAll(() => {\n    vi.restoreAllMocks();\n  });\n\n  describe('Premium Feature Discovery and Paywall', () => {\n    it('should show premium features with paywall for free users', async () => {\n      let appContainer: HTMLElement;\n      \n      await act(async () => {\n        const result = render(\n          <BrowserRouter>\n            <App />\n          </BrowserRouter>\n        );\n        appContainer = result.container;\n        container = appContainer;\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText(/dashboard/i)).toBeInTheDocument();\n      });\n\n      // Navigate to advanced scheduling (premium feature)\n      const advancedButton = screen.getByRole('button', { name: /advanced|brain/i });\n      await user.click(advancedButton);\n\n      // Should show premium paywall\n      await waitFor(() => {\n        const premiumModal = screen.queryByText(/upgrade.*premium|unlock.*features/i);\n        const premiumBadge = screen.queryByText(/premium|pro/i);\n        \n        // Either paywall modal or premium badge should appear\n        if (premiumModal) {\n          expect(premiumModal).toBeInTheDocument();\n        } else if (premiumBadge) {\n          expect(premiumBadge).toBeInTheDocument();\n        }\n      });\n\n      // Track premium feature discovery\n      expect(analyticsService.trackFeatureUsage).toHaveBeenCalledWith(\n        'premium_feature_discovery',\n        expect.any(String),\n        expect.objectContaining({\n          feature: expect.any(String),\n          userTier: 'free'\n        })\n      );\n    });\n\n    it('should show limited alarm creation for free users', async () => {\n      // Create some existing alarms near the free limit\n      const existingAlarms = Array.from({ length: 3 }, (_, i) => \n        createMockAlarm({\n          id: `free-alarm-${i}`,\n          userId: mockUser.id,\n          time: `0${6 + i}:00`,\n          label: `Free Alarm ${i + 1}`,\n          enabled: true\n        })\n      );\n\n      vi.mocked(SupabaseService.loadUserAlarms).mockResolvedValue({\n        alarms: existingAlarms,\n        error: null\n      });\n\n      let appContainer: HTMLElement;\n      \n      await act(async () => {\n        const result = render(\n          <BrowserRouter>\n            <App />\n          </BrowserRouter>\n        );\n        appContainer = result.container;\n        container = appContainer;\n      });\n\n      // Wait for alarms to load\n      await waitFor(() => {\n        expect(screen.getByText('Free Alarm 1')).toBeInTheDocument();\n      });\n\n      // Try to create one more alarm (should work - within limit)\n      const addAlarmButton = screen.getByRole('button', { name: /add.*alarm/i });\n      await user.click(addAlarmButton);\n\n      await waitFor(() => {\n        expect(screen.getByRole('dialog')).toBeInTheDocument();\n      });\n\n      // Should show free tier limitations\n      const limitWarning = screen.queryByText(/free.*limit|upgrade.*more/i);\n      if (limitWarning) {\n        expect(limitWarning).toBeInTheDocument();\n      }\n\n      // Fill and save alarm\n      const timeInput = screen.getByLabelText(/time/i);\n      await user.clear(timeInput);\n      await user.type(timeInput, '09:00');\n\n      const labelInput = screen.getByLabelText(/label|name/i);\n      await user.clear(labelInput);\n      await user.type(labelInput, 'Limit Test Alarm');\n\n      const mockAlarm = createMockAlarm({\n        id: 'limit-test-alarm',\n        userId: mockUser.id,\n        time: '09:00',\n        label: 'Limit Test Alarm',\n        enabled: true\n      });\n\n      vi.mocked(SupabaseService.saveAlarm).mockResolvedValueOnce({\n        alarm: mockAlarm,\n        error: null\n      });\n\n      await user.click(screen.getByRole('button', { name: /save|create/i }));\n\n      await waitFor(() => {\n        expect(screen.getByText('Limit Test Alarm')).toBeInTheDocument();\n      });\n\n      // Now try to create another alarm (should hit limit)\n      await user.click(addAlarmButton);\n\n      // Should show upgrade prompt\n      await waitFor(() => {\n        const upgradePrompt = screen.getByText(/upgrade.*premium|alarm.*limit/i);\n        expect(upgradePrompt).toBeInTheDocument();\n      });\n    });\n  });\n\n  describe('Subscription Upgrade Flow', () => {\n    it('should complete the premium upgrade process', async () => {\n      let appContainer: HTMLElement;\n      \n      await act(async () => {\n        const result = render(\n          <BrowserRouter>\n            <App />\n          </BrowserRouter>\n        );\n        appContainer = result.container;\n        container = appContainer;\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText(/dashboard/i)).toBeInTheDocument();\n      });\n\n      // Navigate to pricing page\n      const pricingButton = screen.getByRole('button', { name: /premium|crown|pricing/i });\n      await user.click(pricingButton);\n\n      await waitFor(() => {\n        expect(screen.getByText(/plans|pricing|subscription/i)).toBeInTheDocument();\n      });\n\n      // Select premium plan\n      const premiumPlan = screen.getByRole('button', { name: /premium|pro.*plan/i });\n      await user.click(premiumPlan);\n\n      // Should show payment form\n      await waitFor(() => {\n        const paymentForm = screen.getByText(/payment|billing|card/i);\n        expect(paymentForm).toBeInTheDocument();\n      });\n\n      // Mock successful payment\n      const mockStripe = {\n        confirmCardPayment: vi.fn().mockResolvedValue({\n          paymentIntent: {\n            status: 'succeeded',\n            id: 'pi_test_12345'\n          }\n        }),\n        elements: vi.fn().mockReturnValue({\n          create: vi.fn().mockReturnValue({\n            mount: vi.fn(),\n            on: vi.fn(),\n            destroy: vi.fn()\n          })\n        })\n      };\n\n      // @ts-ignore\n      global.Stripe = vi.fn().mockResolvedValue(mockStripe);\n\n      // Fill payment form (mock interaction)\n      const cardNumberInput = screen.queryByLabelText(/card.*number/i);\n      if (cardNumberInput) {\n        await user.type(cardNumberInput, '4242424242424242');\n      }\n\n      const expiryInput = screen.queryByLabelText(/expiry|mm.*yy/i);\n      if (expiryInput) {\n        await user.type(expiryInput, '12/25');\n      }\n\n      const cvcInput = screen.queryByLabelText(/cvc|cvv/i);\n      if (cvcInput) {\n        await user.type(cvcInput, '123');\n      }\n\n      // Mock successful subscription creation\n      const upgradedUser = {\n        ...mockUser,\n        subscriptionTier: 'premium' as const,\n        premiumFeatures: ['advanced_scheduling', 'unlimited_alarms', 'custom_sounds'],\n        subscriptionId: 'sub_test_12345',\n        subscriptionStatus: 'active' as const\n      };\n\n      vi.mocked(SupabaseService.updateUserSubscription).mockResolvedValueOnce({\n        user: upgradedUser,\n        error: null\n      });\n\n      // Complete payment\n      const payButton = screen.getByRole('button', { name: /pay|subscribe|upgrade/i });\n      await user.click(payButton);\n\n      // Wait for successful upgrade\n      await waitFor(() => {\n        const successMessage = screen.getByText(/success|upgraded|welcome.*premium/i);\n        expect(successMessage).toBeInTheDocument();\n      }, { timeout: 10000 });\n\n      // Verify analytics tracking\n      expect(analyticsService.trackConversion).toHaveBeenCalledWith(\n        'subscription_upgrade',\n        expect.objectContaining({\n          planId: 'premium',\n          amount: expect.any(Number),\n          userId: mockUser.id\n        })\n      );\n\n      // Verify user can now access premium features\n      const advancedButton = screen.getByRole('button', { name: /advanced|brain/i });\n      await user.click(advancedButton);\n\n      // Should no longer show paywall\n      await waitFor(() => {\n        const paywallContent = screen.queryByText(/upgrade.*premium|unlock.*features/i);\n        expect(paywallContent).not.toBeInTheDocument();\n      });\n    });\n\n    it('should handle payment failures gracefully', async () => {\n      let appContainer: HTMLElement;\n      \n      await act(async () => {\n        const result = render(\n          <BrowserRouter>\n            <App />\n          </BrowserRouter>\n        );\n        appContainer = result.container;\n        container = appContainer;\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText(/dashboard/i)).toBeInTheDocument();\n      });\n\n      // Navigate to pricing\n      const pricingButton = screen.getByRole('button', { name: /premium|crown|pricing/i });\n      await user.click(pricingButton);\n\n      await waitFor(() => {\n        expect(screen.getByText(/plans|pricing/i)).toBeInTheDocument();\n      });\n\n      // Select premium plan\n      const premiumPlan = screen.getByRole('button', { name: /premium|pro.*plan/i });\n      await user.click(premiumPlan);\n\n      // Mock payment failure\n      const mockStripe = {\n        confirmCardPayment: vi.fn().mockResolvedValue({\n          error: {\n            type: 'card_error',\n            code: 'card_declined',\n            message: 'Your card was declined.'\n          }\n        })\n      };\n\n      // @ts-ignore\n      global.Stripe = vi.fn().mockResolvedValue(mockStripe);\n\n      // Attempt payment\n      const payButton = screen.getByRole('button', { name: /pay|subscribe|upgrade/i });\n      await user.click(payButton);\n\n      // Should show error message\n      await waitFor(() => {\n        const errorMessage = screen.getByText(/declined|failed|error/i);\n        expect(errorMessage).toBeInTheDocument();\n      });\n\n      // User should still be on free tier\n      expect(analyticsService.trackFeatureUsage).toHaveBeenCalledWith(\n        'payment_failure',\n        'card_declined',\n        expect.objectContaining({\n          userId: mockUser.id,\n          planId: 'premium'\n        })\n      );\n    });\n  });\n\n  describe('Premium Feature Access Control', () => {\n    it('should unlock premium features after successful upgrade', async () => {\n      // Start with premium user\n      const premiumUser = createMockUser({\n        subscriptionTier: 'premium',\n        premiumFeatures: ['advanced_scheduling', 'unlimited_alarms', 'custom_sounds'],\n        subscriptionId: 'sub_test_67890',\n        subscriptionStatus: 'active'\n      });\n\n      vi.mocked(SupabaseService.getCurrentUser).mockResolvedValue(premiumUser);\n\n      let appContainer: HTMLElement;\n      \n      await act(async () => {\n        const result = render(\n          <BrowserRouter>\n            <App />\n          </BrowserRouter>\n        );\n        appContainer = result.container;\n        container = appContainer;\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText(/dashboard/i)).toBeInTheDocument();\n      });\n\n      // Test unlimited alarms (create more than free limit)\n      for (let i = 0; i < 6; i++) {\n        const addAlarmButton = screen.getByRole('button', { name: /add.*alarm/i });\n        await user.click(addAlarmButton);\n\n        await waitFor(() => {\n          expect(screen.getByRole('dialog')).toBeInTheDocument();\n        });\n\n        const timeInput = screen.getByLabelText(/time/i);\n        await user.clear(timeInput);\n        await user.type(timeInput, `0${6 + i}:00`);\n\n        const labelInput = screen.getByLabelText(/label|name/i);\n        await user.clear(labelInput);\n        await user.type(labelInput, `Premium Alarm ${i + 1}`);\n\n        const mockAlarm = createMockAlarm({\n          id: `premium-alarm-${i}`,\n          userId: premiumUser.id,\n          time: `0${6 + i}:00`,\n          label: `Premium Alarm ${i + 1}`,\n          enabled: true\n        });\n\n        vi.mocked(SupabaseService.saveAlarm).mockResolvedValueOnce({\n          alarm: mockAlarm,\n          error: null\n        });\n\n        await user.click(screen.getByRole('button', { name: /save|create/i }));\n\n        await waitFor(() => {\n          expect(screen.getByText(`Premium Alarm ${i + 1}`)).toBeInTheDocument();\n        });\n\n        // No limit warning should appear\n        const limitWarning = screen.queryByText(/limit.*reached|upgrade.*more/i);\n        expect(limitWarning).not.toBeInTheDocument();\n      }\n\n      // Test advanced scheduling access\n      const advancedButton = screen.getByRole('button', { name: /advanced|brain/i });\n      await user.click(advancedButton);\n\n      await waitFor(() => {\n        // Should have access to advanced features\n        const aiOptimization = screen.queryByText(/ai.*optimization|smart.*scheduling/i);\n        const customPatterns = screen.queryByText(/custom.*pattern|advanced.*repeat/i);\n        \n        // At least one premium feature should be visible\n        if (aiOptimization) {\n          expect(aiOptimization).toBeInTheDocument();\n        } else if (customPatterns) {\n          expect(customPatterns).toBeInTheDocument();\n        }\n      });\n    });\n\n    it('should handle subscription expiration and feature locking', async () => {\n      // Start with expired premium user\n      const expiredPremiumUser = createMockUser({\n        subscriptionTier: 'free',\n        premiumFeatures: [],\n        subscriptionId: 'sub_test_expired',\n        subscriptionStatus: 'canceled',\n        subscriptionEndsAt: new Date(Date.now() - 24 * 60 * 60 * 1000) // Yesterday\n      });\n\n      vi.mocked(SupabaseService.getCurrentUser).mockResolvedValue(expiredPremiumUser);\n\n      let appContainer: HTMLElement;\n      \n      await act(async () => {\n        const result = render(\n          <BrowserRouter>\n            <App />\n          </BrowserRouter>\n        );\n        appContainer = result.container;\n        container = appContainer;\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText(/dashboard/i)).toBeInTheDocument();\n      });\n\n      // Should show subscription expired notice\n      const expiredNotice = screen.queryByText(/subscription.*expired|reactivate.*plan/i);\n      if (expiredNotice) {\n        expect(expiredNotice).toBeInTheDocument();\n      }\n\n      // Try to access premium feature\n      const advancedButton = screen.getByRole('button', { name: /advanced|brain/i });\n      await user.click(advancedButton);\n\n      // Should show upgrade prompt again\n      await waitFor(() => {\n        const upgradePrompt = screen.getByText(/upgrade.*premium|subscription.*expired/i);\n        expect(upgradePrompt).toBeInTheDocument();\n      });\n\n      // Analytics should track feature access attempt\n      expect(analyticsService.trackFeatureUsage).toHaveBeenCalledWith(\n        'premium_feature_blocked',\n        'advanced_scheduling',\n        expect.objectContaining({\n          reason: 'subscription_expired',\n          userId: expiredPremiumUser.id\n        })\n      );\n    });\n  });\n\n  describe('Trial Period Management', () => {\n    it('should handle free trial correctly', async () => {\n      // Create user with active trial\n      const trialUser = createMockUser({\n        subscriptionTier: 'trial',\n        premiumFeatures: ['advanced_scheduling', 'unlimited_alarms'],\n        trialEndsAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days from now\n        trialStartedAt: new Date()\n      });\n\n      vi.mocked(SupabaseService.getCurrentUser).mockResolvedValue(trialUser);\n\n      let appContainer: HTMLElement;\n      \n      await act(async () => {\n        const result = render(\n          <BrowserRouter>\n            <App />\n          </BrowserRouter>\n        );\n        appContainer = result.container;\n        container = appContainer;\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText(/dashboard/i)).toBeInTheDocument();\n      });\n\n      // Should show trial status\n      const trialIndicator = screen.queryByText(/trial|days.*left|free.*until/i);\n      if (trialIndicator) {\n        expect(trialIndicator).toBeInTheDocument();\n      }\n\n      // Should have access to premium features\n      const advancedButton = screen.getByRole('button', { name: /advanced|brain/i });\n      await user.click(advancedButton);\n\n      await waitFor(() => {\n        // Should access premium features without paywall\n        const paywallContent = screen.queryByText(/upgrade.*premium|unlock.*features/i);\n        expect(paywallContent).not.toBeInTheDocument();\n      });\n\n      // Analytics should track trial usage\n      expect(analyticsService.trackFeatureUsage).toHaveBeenCalledWith(\n        'trial_feature_usage',\n        'advanced_scheduling',\n        expect.objectContaining({\n          trialDaysRemaining: expect.any(Number),\n          userId: trialUser.id\n        })\n      );\n    });\n\n    it('should handle trial expiration', async () => {\n      // Create user with expired trial\n      const expiredTrialUser = createMockUser({\n        subscriptionTier: 'free',\n        premiumFeatures: [],\n        trialEndsAt: new Date(Date.now() - 24 * 60 * 60 * 1000), // Yesterday\n        trialStartedAt: new Date(Date.now() - 14 * 24 * 60 * 60 * 1000) // 14 days ago\n      });\n\n      vi.mocked(SupabaseService.getCurrentUser).mockResolvedValue(expiredTrialUser);\n\n      let appContainer: HTMLElement;\n      \n      await act(async () => {\n        const result = render(\n          <BrowserRouter>\n            <App />\n          </BrowserRouter>\n        );\n        appContainer = result.container;\n        container = appContainer;\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText(/dashboard/i)).toBeInTheDocument();\n      });\n\n      // Should show trial expired message\n      const trialExpiredMessage = screen.queryByText(/trial.*expired|subscribe.*continue/i);\n      if (trialExpiredMessage) {\n        expect(trialExpiredMessage).toBeInTheDocument();\n      }\n\n      // Premium features should be locked\n      const advancedButton = screen.getByRole('button', { name: /advanced|brain/i });\n      await user.click(advancedButton);\n\n      await waitFor(() => {\n        const upgradePrompt = screen.getByText(/upgrade.*premium|trial.*ended/i);\n        expect(upgradePrompt).toBeInTheDocument();\n      });\n\n      // Should offer conversion to paid plan\n      const subscribeButton = screen.queryByRole('button', { name: /subscribe|upgrade.*now/i });\n      if (subscribeButton) {\n        expect(subscribeButton).toBeInTheDocument();\n      }\n    });\n  });\n\n  describe('Persona-Based Upgrade Flows', () => {\n    it('should customize upgrade flow for different user personas', async () => {\n      // Mock persona detection\n      const strugglingSamUser = createMockUser({\n        subscriptionTier: 'free',\n        email: 'sam@example.com',\n        detectedPersona: 'struggling_sam' as PersonaType\n      });\n\n      vi.mocked(SupabaseService.getCurrentUser).mockResolvedValue(strugglingSamUser);\n\n      let appContainer: HTMLElement;\n      \n      await act(async () => {\n        const result = render(\n          <BrowserRouter>\n            <App />\n          </BrowserRouter>\n        );\n        appContainer = result.container;\n        container = appContainer;\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText(/dashboard/i)).toBeInTheDocument();\n      });\n\n      // Navigate to pricing\n      const pricingButton = screen.getByRole('button', { name: /premium|crown|pricing/i });\n      await user.click(pricingButton);\n\n      await waitFor(() => {\n        expect(screen.getByText(/plans|pricing/i)).toBeInTheDocument();\n      });\n\n      // Should show persona-specific messaging\n      const strugglingMessage = screen.queryByText(/struggle|getting.*started|free.*trial/i);\n      if (strugglingMessage) {\n        expect(strugglingMessage).toBeInTheDocument();\n      }\n\n      // Should offer appropriate discount or trial\n      const discountOffer = screen.queryByText(/50%.*off|special.*offer|limited.*time/i);\n      if (discountOffer) {\n        expect(discountOffer).toBeInTheDocument();\n      }\n\n      // Analytics should track persona-specific conversion attempt\n      expect(analyticsService.trackFeatureUsage).toHaveBeenCalledWith(\n        'personalized_upgrade_view',\n        'struggling_sam',\n        expect.objectContaining({\n          userId: strugglingSamUser.id,\n          persona: 'struggling_sam'\n        })\n      );\n    });\n  });\n\n  describe('Subscription Management', () => {\n    it('should allow subscription management for premium users', async () => {\n      const premiumUser = createMockUser({\n        subscriptionTier: 'premium',\n        premiumFeatures: ['advanced_scheduling', 'unlimited_alarms'],\n        subscriptionId: 'sub_test_active',\n        subscriptionStatus: 'active'\n      });\n\n      vi.mocked(SupabaseService.getCurrentUser).mockResolvedValue(premiumUser);\n\n      let appContainer: HTMLElement;\n      \n      await act(async () => {\n        const result = render(\n          <BrowserRouter>\n            <App />\n          </BrowserRouter>\n        );\n        appContainer = result.container;\n        container = appContainer;\n      });\n\n      await waitFor(() => {\n        expect(screen.getByText(/dashboard/i)).toBeInTheDocument();\n      });\n\n      // Navigate to settings\n      const settingsButton = screen.getByRole('button', { name: /settings/i });\n      await user.click(settingsButton);\n\n      await waitFor(() => {\n        expect(screen.getByText(/settings/i)).toBeInTheDocument();\n      });\n\n      // Look for subscription management section\n      const subscriptionSection = screen.queryByText(/subscription|billing|manage.*plan/i);\n      if (subscriptionSection) {\n        expect(subscriptionSection).toBeInTheDocument();\n      }\n\n      // Should show current plan details\n      const currentPlan = screen.queryByText(/premium|current.*plan/i);\n      if (currentPlan) {\n        expect(currentPlan).toBeInTheDocument();\n      }\n\n      // Should offer management options\n      const manageButton = screen.queryByRole('button', { name: /manage|cancel|update.*payment/i });\n      if (manageButton) {\n        expect(manageButton).toBeInTheDocument();\n        await user.click(manageButton);\n\n        // Should track subscription management access\n        expect(analyticsService.trackFeatureUsage).toHaveBeenCalledWith(\n          'subscription_management',\n          'accessed',\n          expect.objectContaining({\n            userId: premiumUser.id,\n            subscriptionTier: 'premium'\n          })\n        );\n      }\n    });\n  });\n});",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/tests/utils/a11y-testing-utils.ts",
    "messages": [
      {
        "ruleId": null,
        "nodeType": null,
        "fatal": true,
        "severity": 2,
        "message": "Parsing error: Unterminated regular expression literal.",
        "line": 45,
        "column": 5
      }
    ],
    "suppressedMessages": [],
    "errorCount": 1,
    "fatalErrorCount": 1,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/* \n * Accessibility Testing Utilities\n * Provides jest-axe integration with component providers\n */\n\nimport React from 'react';\nimport { render, RenderOptions, RenderResult } from '@testing-library/react';\nimport { axe, toHaveNoViolations, AxeResults } from 'jest-axe';\n\n// Extend Jest matchers with axe\nexpect.extend(toHaveNoViolations);\n\n// Re-export axe for direct use\nexport { axe };\n\n/**\n * Enhanced render function that includes accessibility testing\n * Automatically wraps components with necessary providers\n */\nexport async function axeRender(\n  ui: React.ReactElement,\n  options?: RenderOptions & {\n    /**\n     * Axe configuration options\n     */\n    axeOptions?: {\n      rules?: Record<string, any>;\n      tags?: string[];\n      exclude?: string[];\n      include?: string[];\n    };\n    /**\n     * Skip automatic axe test (useful when you want to run axe manually)\n     */\n    skipAxeTest?: boolean;\n  }\n): Promise<RenderResult & { axeResults?: AxeResults }> {\n  // Import providers dynamically to avoid circular dependencies\n  const { TestProviders } = await import('../../src/__tests__/providers/test-providers');\n  \n  // Wrap component with test providers\n  const WrappedComponent = () => (\n    <TestProviders>\n      {ui}\n    </TestProviders>\n  );\n\n  const renderResult = render(<WrappedComponent />, options);\n\n  // Run axe test automatically unless skipped\n  if (!options?.skipAxeTest) {\n    const axeResults = await axe(renderResult.container, options?.axeOptions);\n    expect(axeResults).toHaveNoViolations();\n    \n    return {\n      ...renderResult,\n      axeResults\n    };\n  }\n\n  return renderResult;\n}\n\n/**\n * Run axe tests on an already rendered component\n */\nexport async function runAxeTest(\n  container: Element,\n  axeOptions?: {\n    rules?: Record<string, any>;\n    tags?: string[];\n    exclude?: string[];\n    include?: string[];\n  }\n): Promise<AxeResults> {\n  const results = await axe(container, axeOptions);\n  expect(results).toHaveNoViolations();\n  return results;\n}\n\n/**\n * Predefined axe rule configurations for different testing scenarios\n */\nexport const axeRulesets = {\n  /**\n   * Critical accessibility rules that must never fail\n   */\n  critical: {\n    rules: {\n      'color-contrast': { enabled: true },\n      'keyboard': { enabled: true },\n      'focus-order-semantics': { enabled: true },\n      'label': { enabled: true },\n      'aria-required-attr': { enabled: true },\n      'aria-required-children': { enabled: true },\n      'aria-required-parent': { enabled: true },\n      'button-name': { enabled: true },\n      'form-field-multiple-labels': { enabled: true },\n      'image-alt': { enabled: true },\n      'link-name': { enabled: true },\n    },\n  },\n\n  /**\n   * WCAG 2.1 AA compliance rules\n   */\n  wcag21aa: {\n    tags: ['wcag2a', 'wcag2aa'],\n  },\n\n  /**\n   * Form-specific accessibility rules\n   */\n  forms: {\n    rules: {\n      'label': { enabled: true },\n      'aria-required-attr': { enabled: true },\n      'form-field-multiple-labels': { enabled: true },\n      'duplicate-id-aria': { enabled: true },\n      'aria-describedby': { enabled: true },\n    },\n  },\n\n  /**\n   * Modal/Dialog specific rules\n   */\n  modals: {\n    rules: {\n      'focus-order-semantics': { enabled: true },\n      'aria-dialog-name': { enabled: true },\n      'keyboard': { enabled: true },\n      'aria-required-attr': { enabled: true },\n    },\n  },\n\n  /**\n   * Component library specific rules (for testing individual components)\n   */\n  components: {\n    rules: {\n      'button-name': { enabled: true },\n      'link-name': { enabled: true },\n      'image-alt': { enabled: true },\n      'label': { enabled: true },\n      'color-contrast': { enabled: true },\n      'aria-required-attr': { enabled: true },\n    },\n  },\n};\n\n/**\n * Test helper for checking specific accessibility patterns\n */\nexport const accessibilityPatterns = {\n  /**\n   * Test that an element is properly focusable\n   */\n  async testFocusable(element: HTMLElement): Promise<void> {\n    element.focus();\n    expect(document.activeElement).toBe(element);\n  },\n\n  /**\n   * Test keyboard navigation within a container\n   */\n  async testKeyboardNavigation(\n    container: HTMLElement,\n    expectedFocusOrder: string[] // CSS selectors in expected order\n  ): Promise<void> {\n    const focusableElements = expectedFocusOrder.map(selector => \n      container.querySelector(selector) as HTMLElement\n    );\n\n    // Test forward navigation\n    for (let i = 0; i < focusableElements.length; i++) {\n      if (focusableElements[i]) {\n        focusableElements[i].focus();\n        expect(document.activeElement).toBe(focusableElements[i]);\n      }\n    }\n  },\n\n  /**\n   * Test ARIA labels and descriptions\n   */\n  testAriaLabeling(element: HTMLElement): {\n    hasAccessibleName: boolean;\n    hasDescription: boolean;\n    accessibleName: string;\n    description: string;\n  } {\n    const ariaLabel = element.getAttribute('aria-label');\n    const ariaLabelledBy = element.getAttribute('aria-labelledby');\n    const ariaDescribedBy = element.getAttribute('aria-describedby');\n    \n    let accessibleName = '';\n    let description = '';\n\n    if (ariaLabel) {\n      accessibleName = ariaLabel;\n    } else if (ariaLabelledBy) {\n      const labelElement = document.getElementById(ariaLabelledBy);\n      accessibleName = labelElement?.textContent || '';\n    }\n\n    if (ariaDescribedBy) {\n      const descElement = document.getElementById(ariaDescribedBy);\n      description = descElement?.textContent || '';\n    }\n\n    return {\n      hasAccessibleName: accessibleName.length > 0,\n      hasDescription: description.length > 0,\n      accessibleName,\n      description,\n    };\n  },\n};\n\n/**\n * Accessibility test result reporter\n */\nexport const accessibilityReporter = {\n  /**\n   * Generate a comprehensive accessibility report\n   */\n  generateReport(\n    testName: string,\n    axeResults: AxeResults,\n    additionalInfo?: Record<string, any>\n  ): {\n    testName: string;\n    timestamp: string;\n    passed: boolean;\n    violations: number;\n    incomplete: number;\n    details: any;\n    additionalInfo?: Record<string, any>;\n  } {\n    return {\n      testName,\n      timestamp: new Date().toISOString(),\n      passed: axeResults.violations.length === 0,\n      violations: axeResults.violations.length,\n      incomplete: axeResults.incomplete.length,\n      details: {\n        violations: axeResults.violations,\n        incomplete: axeResults.incomplete,\n        passes: axeResults.passes.length,\n        inapplicable: axeResults.inapplicable.length,\n      },\n      additionalInfo,\n    };\n  },\n\n  /**\n   * Save accessibility report to artifacts\n   */\n  async saveReport(\n    report: any,\n    filename?: string\n  ): Promise<string> {\n    const fs = await import('fs/promises');\n    const path = await import('path');\n    \n    const reportFilename = filename || `a11y-report-${Date.now()}.json`;\n    const reportPath = path.join(process.cwd(), 'artifacts', 'a11y-reports', reportFilename);\n    \n    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));\n    return reportPath;\n  },\n};\n\n/**\n * Common accessibility test patterns\n */\nexport const commonA11yTests = {\n  /**\n   * Standard button accessibility test\n   */\n  async testButton(button: HTMLElement): Promise<AxeResults> {\n    const container = button.parentElement || document.body;\n    return await runAxeTest(container, axeRulesets.components);\n  },\n\n  /**\n   * Standard form field accessibility test\n   */\n  async testFormField(field: HTMLElement): Promise<AxeResults> {\n    const container = field.closest('form') || field.parentElement || document.body;\n    return await runAxeTest(container, axeRulesets.forms);\n  },\n\n  /**\n   * Standard modal/dialog accessibility test\n   */\n  async testModal(modal: HTMLElement): Promise<AxeResults> {\n    return await runAxeTest(modal, axeRulesets.modals);\n  },\n};",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "/project/workspace/Coolhgg/Relife/tests/utils/integration-test-setup.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 27,
        "column": 7,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 27,
        "endColumn": 30
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 392,
        "column": 34,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 392,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 402,
        "column": 34,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 402,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 418,
        "column": 34,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 418,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 430,
        "column": 31,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 430,
        "endColumn": 54
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 461,
        "column": 34,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 461,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 478,
        "column": 34,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 478,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/no-require-imports",
        "severity": 2,
        "message": "A `require()` style import is forbidden.",
        "line": 519,
        "column": 25,
        "nodeType": "CallExpression",
        "messageId": "noRequireImports",
        "endLine": 519,
        "endColumn": 48
      }
    ],
    "suppressedMessages": [],
    "errorCount": 8,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/// <reference lib=\"dom\" />\nimport '@testing-library/jest-dom';\nimport { vi, afterEach, beforeAll, afterAll } from 'vitest';\nimport { cleanup } from '@testing-library/react';\n\n// Import MSW setup for API mocking (Vitest-compatible version)\nimport { setupServer } from 'msw/node';\n\n// Import MSW handlers from the main test setup\nimport { handlers } from '../../src/__tests__/mocks/msw-handlers';\n\n// Import enhanced browser API mocks\nimport {\n  setupEnhancedBrowserAPIMocks,\n  createIntegrationTestHelpers,\n} from './enhanced-browser-api-mocks';\n\n// Import additional mocks for new features (if available)\ntry {\n  const {\n    setupAllMocks,\n    mockWebSocket,\n    mockMediaRecorder,\n    mockFileAPI,\n    mockBiometricAPIs,\n    mockSleepAPIs,\n  } = require('./test-mocks');\n\n  // Setup all additional mocks for new features if available\n  if (setupAllMocks) {\n    setupAllMocks();\n  }\n} catch (error) {\n  // test-mocks not available, continue without enhanced mocks\n}\n// Setup MSW server for integration tests\nconst server = setupServer(...handlers);\n\n// Establish API mocking before all tests\nbeforeAll(() => {\n  server.listen({\n    onUnhandledRequest: 'warn', // Warn about unhandled requests instead of erroring\n  });\n});\n\n// Reset any request handlers that we may add during the tests,\n// so they don't affect other tests\nafterEach(() => {\n  server.resetHandlers();\n  cleanup();\n});\n\n// Clean up after the tests are finished\nafterAll(() => {\n  server.close();\n});\n\n// Setup enhanced browser API mocks globally\nconst integrationTestHelpers = createIntegrationTestHelpers();\n\n// Reset enhanced mocks after each test\nafterEach(() => {\n  integrationTestHelpers.resetAll();\n});\n\n// Setup global mocks for integration tests\nconst createMockStorage = () => ({\n  getItem: vi.fn(),\n  setItem: vi.fn(),\n  removeItem: vi.fn(),\n  clear: vi.fn(),\n  length: 0,\n  key: vi.fn(),\n});\n\n// Only mock storage if it doesn't exist or isn't functional\nif (typeof global !== 'undefined') {\n  // Check if localStorage works, if not mock it\n  try {\n    global.localStorage?.getItem('test');\n  } catch {\n    global.localStorage = createMockStorage();\n  }\n\n  // Check if sessionStorage works, if not mock it\n  try {\n    global.sessionStorage?.getItem('test');\n  } catch {\n    global.sessionStorage = createMockStorage();\n  }\n\n  // Mock window.matchMedia only if it doesn't exist\n  if (!global.matchMedia) {\n    global.matchMedia = vi.fn().mockImplementation(query => ({\n      matches: false,\n      media: query,\n      onchange: null,\n      addListener: vi.fn(),\n      removeListener: vi.fn(),\n      addEventListener: vi.fn(),\n      removeEventListener: vi.fn(),\n      dispatchEvent: vi.fn(),\n    }));\n  }\n}\n\n// Mock Speech API only if it doesn't exist\nif (!global.SpeechSynthesisUtterance) {\n  const MockSpeechSynthesisUtterance = vi.fn().mockImplementation(() => ({\n    text: '',\n    rate: 1,\n    pitch: 1,\n    volume: 1,\n    voice: null,\n    lang: 'en',\n  }));\n  global.SpeechSynthesisUtterance = MockSpeechSynthesisUtterance;\n}\n\nif (!global.speechSynthesis) {\n  const mockSpeechSynthesis = {\n    speak: vi.fn(),\n    cancel: vi.fn(),\n    pause: vi.fn(),\n    resume: vi.fn(),\n    getVoices: vi.fn(() => []),\n    speaking: false,\n    pending: false,\n    paused: false,\n    onvoiceschanged: null,\n  } as any;\n  global.speechSynthesis = mockSpeechSynthesis;\n}\n\n// Mock observers only if they don't exist\nif (!global.ResizeObserver) {\n  global.ResizeObserver = vi.fn().mockImplementation(() => ({\n    observe: vi.fn(),\n    unobserve: vi.fn(),\n    disconnect: vi.fn(),\n  }));\n}\n\nif (!global.IntersectionObserver) {\n  global.IntersectionObserver = vi.fn().mockImplementation(() => ({\n    observe: vi.fn(),\n    unobserve: vi.fn(),\n    disconnect: vi.fn(),\n  }));\n}\n\n// Mock animation frame functions only if they don't exist\nif (!global.requestAnimationFrame) {\n  global.requestAnimationFrame = vi.fn(cb => setTimeout(cb, 0));\n}\nif (!global.cancelAnimationFrame) {\n  global.cancelAnimationFrame = vi.fn(id => clearTimeout(id));\n}\n\n// Mock timer functions\nconst createTimerMock = (originalTimer: any) => {\n  const mockFn = vi.fn(originalTimer) as any;\n  mockFn.__promisify__ = vi.fn();\n  return mockFn;\n};\n\nif (typeof window !== 'undefined') {\n  // Only mock if window timer functions don't exist\n  if (!window.setInterval) {\n    (window as any).setInterval = createTimerMock(() => 1);\n  }\n  if (!window.clearInterval) {\n    (window as any).clearInterval = vi.fn();\n  }\n  if (!window.setTimeout) {\n    (window as any).setTimeout = createTimerMock(() => 1);\n  }\n  if (!window.clearTimeout) {\n    (window as any).clearTimeout = vi.fn();\n  }\n} else {\n  // For global scope\n  if (!(global as any).setInterval) {\n    (global as any).setInterval = createTimerMock(() => 1);\n  }\n  if (!(global as any).clearInterval) {\n    (global as any).clearInterval = vi.fn();\n  }\n  if (!(global as any).setTimeout) {\n    (global as any).setTimeout = createTimerMock(() => 1);\n  }\n  if (!(global as any).clearTimeout) {\n    (global as any).clearTimeout = vi.fn();\n  }\n}\n\n// Ensure DOM is properly set up\nif (typeof document !== 'undefined' && document.body) {\n  // Only add a container if it doesn't exist and we're in a test environment\n  if (!document.getElementById('root')) {\n    const container = document.createElement('div');\n    container.id = 'root';\n    document.body.appendChild(container);\n  }\n}\n\n// Mock HTMLCanvasElement.prototype.getContext for color contrast checking\nif (typeof HTMLCanvasElement !== 'undefined') {\n  HTMLCanvasElement.prototype.getContext = vi.fn().mockImplementation(function (\n    contextType: string\n  ) {\n    if (contextType === '2d') {\n      return {\n        fillText: vi.fn(),\n        strokeText: vi.fn(),\n        measureText: vi.fn(() => ({ width: 100 })),\n        getImageData: vi.fn(() => ({\n          data: new Uint8ClampedArray(4).fill(255),\n          width: 1,\n          height: 1,\n        })),\n        createImageData: vi.fn(() => ({\n          data: new Uint8ClampedArray(4).fill(255),\n          width: 1,\n          height: 1,\n        })),\n        putImageData: vi.fn(),\n        drawImage: vi.fn(),\n        fillRect: vi.fn(),\n        strokeRect: vi.fn(),\n        clearRect: vi.fn(),\n        beginPath: vi.fn(),\n        closePath: vi.fn(),\n        moveTo: vi.fn(),\n        lineTo: vi.fn(),\n        arc: vi.fn(),\n        fill: vi.fn(),\n        stroke: vi.fn(),\n        canvas: this,\n        fillStyle: '#000000',\n        strokeStyle: '#000000',\n        lineWidth: 1,\n        font: '10px sans-serif',\n        textAlign: 'start',\n        textBaseline: 'alphabetic',\n        globalAlpha: 1,\n        globalCompositeOperation: 'source-over',\n      };\n    }\n    return null;\n  });\n}\n\n// Mock window.getComputedStyle for axe-core color contrast checking\nif (typeof window !== 'undefined') {\n  window.getComputedStyle = vi\n    .fn()\n    .mockImplementation((element: Element, pseudoElt?: string) => {\n      const mockStyle = {\n        color: 'rgb(0, 0, 0)',\n        backgroundColor: 'rgb(255, 255, 255)',\n        fontSize: '16px',\n        fontFamily: 'Arial, sans-serif',\n        display: 'block',\n        visibility: 'visible',\n        opacity: '1',\n        width: '100px',\n        height: '100px',\n        padding: '0px',\n        margin: '0px',\n        border: '0px',\n        borderColor: 'rgb(0, 0, 0)',\n        borderStyle: 'none',\n        borderWidth: '0px',\n        getPropertyValue: vi.fn((prop: string) => {\n          switch (prop) {\n            case 'color':\n              return 'rgb(0, 0, 0)';\n            case 'background-color':\n              return 'rgb(255, 255, 255)';\n            case 'font-size':\n              return '16px';\n            case 'font-family':\n              return 'Arial, sans-serif';\n            case 'width':\n              return '100px';\n            case 'height':\n              return '100px';\n            case 'display':\n              return 'block';\n            case 'visibility':\n              return 'visible';\n            case 'opacity':\n              return '1';\n            case 'border-color':\n              return 'rgb(0, 0, 0)';\n            case 'border-style':\n              return 'none';\n            case 'border-width':\n              return '0px';\n            default:\n              return '';\n          }\n        }),\n        position: 'static',\n        top: 'auto',\n        left: 'auto',\n        right: 'auto',\n        bottom: 'auto',\n        zIndex: 'auto',\n        float: 'none',\n        clear: 'none',\n        textAlign: 'start',\n        textDecoration: 'none',\n        textTransform: 'none',\n        lineHeight: 'normal',\n        letterSpacing: 'normal',\n        wordSpacing: 'normal',\n      };\n\n      return mockStyle as CSSStyleDeclaration;\n    });\n}\n\n// Mock i18next for tests that need translation\nconst mockI18n = {\n  t: vi.fn((key: string) => key),\n  changeLanguage: vi.fn(),\n  language: 'en',\n  languages: ['en'],\n  use: vi.fn(() => mockI18n),\n  init: vi.fn(() => Promise.resolve()),\n  on: vi.fn(),\n  off: vi.fn(),\n};\n\n// Provide i18next mock globally\nif (typeof global !== 'undefined') {\n  global.i18n = mockI18n;\n}\n\n// Additional global setup for new features\nif (typeof global !== 'undefined') {\n  // Mock performance.now for timing measurements\n  if (!global.performance) {\n    global.performance = {\n      now: vi.fn(() => Date.now()),\n      mark: vi.fn(),\n      measure: vi.fn(),\n      getEntriesByName: vi.fn(() => []),\n    } as any;\n  }\n\n  // Mock requestIdleCallback for sleep analysis\n  if (!global.requestIdleCallback) {\n    global.requestIdleCallback = vi.fn(cb => {\n      return setTimeout(\n        () =>\n          cb({\n            didTimeout: false,\n            timeRemaining: () => 50,\n          }),\n        0\n      );\n    });\n  }\n\n  if (!global.cancelIdleCallback) {\n    global.cancelIdleCallback = vi.fn(clearTimeout);\n  }\n\n  // Mock TextEncoder/TextDecoder for WebSocket message handling\n  if (!global.TextEncoder) {\n    global.TextEncoder = vi.fn().mockImplementation(() => ({\n      encode: vi.fn(text => new Uint8Array(Buffer.from(text, 'utf-8'))),\n    }));\n  }\n\n  if (!global.TextDecoder) {\n    global.TextDecoder = vi.fn().mockImplementation(() => ({\n      decode: vi.fn(bytes => Buffer.from(bytes).toString('utf-8')),\n    }));\n  }\n}\n\n// Helper functions for integration tests\nexport const mockApiError = (\n  endpoint: string,\n  status: number = 500,\n  message: string = 'Server Error'\n) => {\n  const { http, HttpResponse } = require('msw');\n\n  server.use(\n    http.all(endpoint, () => {\n      return HttpResponse.json({ error: message }, { status });\n    })\n  );\n};\n\nexport const mockApiDelay = (endpoint: string, delay: number = 1000) => {\n  const { http, HttpResponse } = require('msw');\n\n  server.use(\n    http.all(endpoint, async () => {\n      await new Promise(resolve => setTimeout(resolve, delay));\n      return HttpResponse.json({ success: true });\n    })\n  );\n};\n\n// Enhanced delay mock for real-time features\nexport const mockRealtimeDelay = (endpoint: string, delay: number = 100) => {\n  return mockApiDelay(endpoint, delay);\n};\n\nexport const mockApiSuccess = (endpoint: string, data: any) => {\n  const { http, HttpResponse } = require('msw');\n\n  server.use(\n    http.all(endpoint, () => {\n      return HttpResponse.json(data);\n    })\n  );\n};\n\n// New API mock helpers for advanced features (if enhanced mocks available)\nexport const mockWebSocketServer = (url: string, responses: any[] = []) => {\n  try {\n    const { mockWebSocket } = require('./test-mocks');\n    const mockWS = mockWebSocket();\n\n    // Simulate server responses\n    responses.forEach((response, index) => {\n      setTimeout(\n        () => {\n          if (mockWS.onmessage) {\n            mockWS.onmessage({ data: JSON.stringify(response) });\n          }\n        },\n        100 * (index + 1)\n      );\n    });\n\n    return mockWS;\n  } catch (error) {\n    // Return basic WebSocket mock if enhanced version not available\n    return {\n      readyState: 1,\n      send: vi.fn(),\n      close: vi.fn(),\n      onopen: null,\n      onmessage: null,\n      onclose: null,\n      onerror: null,\n    };\n  }\n};\n\nexport const mockTTSService = (audioUrl: string = 'blob:mock-tts-audio') => {\n  const { http, HttpResponse } = require('msw');\n\n  server.use(\n    http.post('*/api/voice/synthesize', () => {\n      return HttpResponse.json({ audioUrl, duration: 5.2 });\n    }),\n    http.post('*/api/voice/clone', () => {\n      return HttpResponse.json({\n        voiceId: 'mock-voice-id',\n        status: 'ready',\n        similarity: 0.95,\n      });\n    })\n  );\n};\n\nexport const mockSleepAnalysisService = (analysisData: any) => {\n  const { http, HttpResponse } = require('msw');\n\n  server.use(\n    http.post('*/api/sleep/analyze', () => {\n      return HttpResponse.json(analysisData);\n    }),\n    http.get('*/api/sleep/recommendations', () => {\n      return HttpResponse.json({\n        optimalBedtime: '22:30',\n        optimalWakeTime: '06:30',\n        sleepCycles: 5,\n        chronotype: 'intermediate',\n        confidence: 0.87,\n      });\n    })\n  );\n};\n\n// Export server and enhanced test helpers for use in specific tests\nexport { server as mswServer };\nexport { integrationTestHelpers };\n\n// Export individual mock helpers for convenience\nexport const {\n  notifications: notificationHelpers,\n  serviceWorker: serviceWorkerHelpers,\n  wakeLock: wakeLockHelpers,\n  speech: speechHelpers,\n  permissions: permissionHelpers,\n  simulateAlarmNotification,\n  simulateVoiceAlarmDismiss,\n  simulateVoiceSnooze,\n  simulatePushSubscription,\n  simulateScreenWakeLock,\n  verifyNotificationShown,\n  verifyServiceWorkerActive,\n  verifyPushSubscriptionActive,\n} = integrationTestHelpers;\n\n// Additional helper exports for new features (if available)\ntry {\n  const enhancedMocks = require('./test-mocks');\n\n  // Export enhanced mocks if available\n  module.exports = {\n    ...module.exports,\n    ...enhancedMocks,\n  };\n} catch (error) {\n  // Enhanced mocks not available, continue with basic functionality\n}\n",
    "usedDeprecatedRules": []
  }
]
